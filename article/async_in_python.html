<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人一切的痛苦，本质是都是对自已的无能的愤怒"><title>python中的异步实践与tornado应用 | 杨彦星</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'e9662659e0be3b869d4966455356c0ed';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">python中的异步实践与tornado应用</h1><a id="logo" href="/.">杨彦星</a><p class="description">序语程言</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="http://yangyanxing.lofter.com"><i class="fa fa-folder"> 时光</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">python中的异步实践与tornado应用</h1><div class="post-meta">Jan 11, 2019<span> | </span><span class="category"><a href="/categories/Python/">Python</a></span></div><div class="post-content"><p>最近项目中由于在python3中使用tornado,之前也有用过，是在python2中，由于对于协程理解不是很透彻，只是套用官方文档中的写法，最近比较细致的看了下协程的用法，也将tornado在python3中异步的实践了一下。</p>
<a id="more"></a>
<h1 id="异步基础"><a href="#异步基础" class="headerlink" title="异步基础"></a>异步基础</h1><p>要理解协程，先要理解异步，要理解异步，先要理解同步，与同步相关的概念又有阻塞与非阻塞，下面一一做简单介绍。</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><blockquote>
<p>阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。<br>常见的阻塞形式有：网络 I/O 阻塞、磁盘 I/O 阻塞、用户输入阻塞等。阻塞是无处不在的，包括 CPU 切换上下文时，所有的进程都无法真正干事情，它们也会被阻塞。如果是多核 CPU 则正在执行上下文切换操作的核不可被利用。</p>
</blockquote>
<h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><blockquote>
<p>程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情，则称该程序在该操作上是非阻塞的。<br>非阻塞并不是在任何程序级别、任何情况下都可以存在的。<br>仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。<br>非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。</p>
</blockquote>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><blockquote>
<p>不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，称这些程序单元是同步执行的。<br>例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。<br>简言之，同步意味着有序。</p>
</blockquote>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><blockquote>
<p>为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式，不相关的程序单元之间可以是异步的。<br>例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。<br>简言之，异步意味着无序。</p>
</blockquote>
<p>这个概念让我想起了上学时学过的一篇文章，讲统筹安排的，比如你现在要烧水，做饭，洗衣服三件事，如果同步的进行，先烧水，在水烧开的过程中你什么都不做就等着它烧开，然后水烧开以后你再接着做饭，饭做熟的过程中你也是什么都不干，就干等着，饭做熟后再去将洗衣服放入洗衣机中去洗，之后又是干等着。如果单做一件事的时间是烧水10分别，做饭30分钟，洗衣服20分钟，那么完成这三件事总共需要60分钟。<br>如果将这三件事异步的去进行，我先将水烧上，然后再将衣服放到洗衣机里，然后去做饭，这三件事同时进行，当水烧开的时候给我一个信号，这里就是水壶会响，我听到响声以后我会中止做饭这件事情去处理烧开的水，比如把它倒到保温瓶中，衣服洗完以后洗衣机也会给我一个信号，那么我就会将衣服拿出来晾晒。这样处理完三件事总共的时间就由三件事情中最长的时间决定，这里就是30分钟，其实异步的处理就是最大程度的发挥cup的处理能力，让其在同一时间内做更多的事情。</p>
<p>上面的过程用代码来实现大概是这个样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:gbk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading,multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">water</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"开始烧水了"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"水开了"</span>, end - start)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wash</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"开始洗衣服了"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"衣服洗完了"</span>, end - start)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"开始做饭了"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"饭熟了"</span>,end - start)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alarm</span><span class="params">(info)</span>:</span></span><br><span class="line">    print(<span class="string">"%s 一共用了%s 时间"</span>%(info[<span class="number">0</span>],info[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoWork</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, callback,*params, **paramMap)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.func = func</span><br><span class="line">        self.params = params</span><br><span class="line">        self.paramMap = paramMap</span><br><span class="line">        self.rst = <span class="keyword">None</span></span><br><span class="line">        self.finished = <span class="keyword">False</span></span><br><span class="line">        self.isDaemon = <span class="keyword">True</span></span><br><span class="line">        self.isDaemon = <span class="keyword">False</span></span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.rst = self.func(*self.params, **self.paramMap)</span><br><span class="line">        self.callback(self.rst)</span><br><span class="line">        self.finished = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    task1 = DoWork(water,alarm)</span><br><span class="line">    task2 = DoWork(wash,alarm)</span><br><span class="line">    task3 = DoWork(cook,alarm)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    task1.start()</span><br><span class="line">    task2.start()</span><br><span class="line">    task3.start()</span><br><span class="line">    task1.join()</span><br><span class="line">    task2.join()</span><br><span class="line">    task3.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"一共用了%s时间"</span>%(end-start))</span><br></pre></td></tr></table></figure>
<p>执行结果如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始烧水了</span><br><span class="line">开始洗衣服了</span><br><span class="line">开始做饭了</span><br><span class="line">水开了 一共用了2.0003998279571533 时间</span><br><span class="line">衣服洗完了 一共用了4.00029993057251 时间</span><br><span class="line">饭熟了 一共用了10.000999689102173 时间</span><br><span class="line">一共用了10.001499891281128时间</span><br></pre></td></tr></table></figure></p>
<h2 id="yield-语法"><a href="#yield-语法" class="headerlink" title="yield 语法"></a><code class="text">yield</code> 语法</h2><p>以上是用了多线程的方式来达到异步的效果，但是并没有用到协程，协程在python2就有，现在来看看在python2中通过<code class="text">yield</code>语法。以下方法是在python2.6中执行.</p>
<p>要了解 <code class="text">yield</code> 语法，先要了解一个概念： <code class="text">Generator</code> 『生成器』，关于generator的概念可以参考廖雪峰的教程，写的很好，<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000" target="_blank" rel="noopener">生成器</a></p>
<p>如果一个函数定义中包含 <code class="text">yield</code> 关键字，那么这个函数就不再是一个普通函数，而是一个 <code class="text">generator</code> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'I am yangyanxing'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = h()</span><br></pre></td></tr></table></figure>
<p>运行该脚本以后程序并没有任何输出，因为它有yield表达式，因此，我们通过next()语句让它执行。next()语句将恢复Generator执行，并直到下一个yield表达式处。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'I am yangyanxing'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">    print(<span class="string">"I am fjy"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = h()</span><br><span class="line">    c.next()</span><br></pre></td></tr></table></figure>
<p>调用 <code class="text">c.nect()</code> 以后，函数开始执行，这时先打印 “I am yangyanxing”, 之后遇到 <code class="text">yield</code> 关键字，此时函数又被中断，脚本执行结束，程序只打印了一行 “I am yangyanxing”,如果想要打印出 <code class="text">I am fjy</code> 呢，以时需要再调用一次 <code class="text">c.next()</code>, 当再次调用 <code class="text">c.next()</code> 时，函数从之前的 <code class="text">yield</code> 处开始执行，由于函数在之后没有 <code class="text">yield</code> 了，所以程序会抛一个 <code class="text">StopIteration</code> 异常。</p>
<p>与 <code class="text">next()</code> 函数相关的还有一个 <code class="text">send()</code> 函数，<code class="text">next</code> 函数传递的是 <code class="text">None</code> ， <code class="text">send</code> 函数可以传递对应的值。其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做<br>c.next() 和 c.send(None) 作用是一样的。看如下的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'I am yangyanxing'</span>)</span><br><span class="line">    m = <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">    print(m)</span><br><span class="line">    print(<span class="string">"I am fjy"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">6</span></span><br><span class="line">    print(<span class="string">"They love too much"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = h()</span><br><span class="line">    c.next()</span><br><span class="line">    c.send(<span class="string">"hahaha"</span>)</span><br></pre></td></tr></table></figure></p>
<p>函数的输出为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am yangyanxing</span><br><span class="line">hahaha</span><br><span class="line">I am fjy</span><br></pre></td></tr></table></figure></p>
<p>这代码解析，首先通过 <code class="text">c = h()</code> 定义了一个 generator ,然后调用 <code class="text">c.next()</code> 启动这个生成器，生成器先打印出 <code class="text">I am yangyanxing</code> 然后遇到 <code class="text">m = yield 5</code> 这行代码，后停止，之后再调用 <code class="text">c.send(&quot;hahaha&quot;)</code> ，这时候 m 的值就是 <code class="text">hahaha</code>, 然后再打印出 m ,之后再打印出 <code class="text">I am fjy</code>,之后又遇到了 <code class="text">yield</code> 关键字，程序又中止了，整个脚本执行结束,需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会出错的，因为没有yield语句来接收这个值。<br>那么 <code class="text">next()</code> 与 <code class="text">send()</code> 函数的返回值是什么呢？ 注意到上面函数中的 <code class="text">yield</code> 之后是一个5了吗？其实这就是调用 netx 或者 send 以后得到的返回值.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'I am yangyanxing'</span>)</span><br><span class="line">    m = <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">    print(m)</span><br><span class="line">    print(<span class="string">"I am fjy"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = h()</span><br><span class="line">    print(c.next())</span><br><span class="line">    print(c.send(<span class="string">"hahaha"</span>))</span><br></pre></td></tr></table></figure></p>
<p>得到的输出为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am yangyanxing</span><br><span class="line"><span class="number">5</span></span><br><span class="line">hahaha</span><br><span class="line">I am fjy</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h1 id="异步使用"><a href="#异步使用" class="headerlink" title="异步使用"></a>异步使用</h1><h2 id="同步的困扰"><a href="#同步的困扰" class="headerlink" title="同步的困扰"></a>同步的困扰</h2><p>首先看以下的代码，以下是在python2中编写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.options</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options</span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        query = self.get_argument(<span class="string">'q'</span>)</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        self.write(<span class="string">"hello %s"</span>%query)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    app = tornado.web.Application(handlers=[(<span class="string">r"/"</span>, IndexHandler)])</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></p>
<p>我分别用浏览器和和用脚本对 <code class="text">http://127.0.0.1:8000/?q=yangyanxing</code> 该 url 进行访问，脚本如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geturl</span><span class="params">(url)</span>:</span></span><br><span class="line">     s = time.time()</span><br><span class="line">     r = requests.get(url)</span><br><span class="line">     e = time.time()</span><br><span class="line">     print(int(e-s))</span><br><span class="line"></span><br><span class="line">getrul(<span class="string">r"http://127.0.0.1:8000/?q=yangyanxing"</span>)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">服务端显示</span><br><span class="line">``` </span><br><span class="line">[I 190114 00:03:46 web:2162] 304 GET /?q=yangyanxing (127.0.0.1) 5000.97ms</span><br><span class="line">[I 190114 00:03:51 web:2162] 200 GET /?q=yangyanxing (127.0.0.1) 5006.78ms</span><br></pre></td></tr></table></figure></p>
<p>脚本打印为 7或者8</p>
<p>在同步应用中，由于同时只能提供一个请求。所以，如果一个路由中有一个比较耗时的操作，如代码中的 <code class="text">time.sleep(5)</code> 那么意味着如果同时有两个请求，那么第二个请求只能等待服务器处理完第一个请求之后才能处理第二个请求，也就中处理两个请求，最短要5秒，最长要10秒,这还只是2个，如果有10个那就是要50秒处理完所有的请求，这个效率是无法接受的，服务端可否同时处理10个请求，就像文章一开始提到的同时做三件事情，在处理一个耗时的操作时，不是干等着这件事情处理完，而是去做别的事情，当那件事情结束以后，再通过调用回调函数来通知调用者。</p>
<h2 id="异步的使用"><a href="#异步的使用" class="headerlink" title="异步的使用"></a>异步的使用</h2><ul>
<li>客户端的实现<br>异步的使用可以分为客户端的调用与服务端的处理，先从简单的来看，客户端的调用，比如你要同时访问 baidu.com 10次，你会怎么做？可以依次的对 baidu 发起10次请求，每次请求结束以后再发起下一次请求，假如每次请求是1秒钟，那么10次请求至少要用10秒钟，排除IO相关耗时，代码可能是这个样子的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geturl</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span>%(end-start))</span><br><span class="line">    <span class="keyword">return</span> r.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        geturl(<span class="string">r"https://www.baidu.com"</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"all done,use %s time"</span>%(end-start))</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用了0.2974998950958252时间</span><br><span class="line">用了0.0494999885559082时间</span><br><span class="line">用了0.0410001277923584时间</span><br><span class="line">用了0.029999971389770508时间</span><br><span class="line">用了0.18199992179870605时间</span><br><span class="line">用了0.02700018882751465时间</span><br><span class="line">用了0.022499799728393555时间</span><br><span class="line">用了0.020000219345092773时间</span><br><span class="line">用了0.020999908447265625时间</span><br><span class="line">用了0.019999980926513672时间</span><br><span class="line">all done,use 0.7105000019073486 time</span><br></pre></td></tr></table></figure></p>
<p>一共用了0.7秒，百度的反应可能太快了，我们准备一个本地的环境来模拟慢返回。这里我先使用tornado的异步协程处理，之后再详细说明该处的用法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.options</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options</span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        query = self.get_argument(<span class="string">'q'</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>)</span><br><span class="line">        self.writeres(<span class="string">"hello %s"</span>%query)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeres</span><span class="params">(self,returnstr)</span>:</span></span><br><span class="line">        self.write(returnstr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    app = tornado.web.Application(handlers=[(<span class="string">r"/"</span>, IndexHandler)])</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></p>
<p>请求代码改为三次，只是为了说明问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geturl</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span>%(end-start))</span><br><span class="line">    <span class="keyword">return</span> r.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        geturl(<span class="string">r"http://127.0.0.1:8000/?q=yangyanxing"</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"all done,use %s time"</span>%(end-start))</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用了5.009501695632935时间</span><br><span class="line">用了5.012002229690552时间</span><br><span class="line">用了5.012502193450928时间</span><br><span class="line">all done,use 15.035006284713745 time</span><br></pre></td></tr></table></figure></p>
<p>可以看到，总是时间是15秒，同步对一个url发请求，在没有做异步处理的时候时间是累积的。</p>
<p>接下来说本篇的重点，<code class="text">协程</code>.</p>
<ul>
<li>定义协程</li>
</ul>
<p>在一个普通的函数前面加上 <code class="text">async</code> 关键字，此时该函数会返回一个coroutine对象，函数里也不会立刻执行.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getUrlByCor</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span> % (end - start))</span><br><span class="line">    <span class="keyword">return</span> r.status_code</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = getUrlByCor(<span class="string">r'http://127.0.0.1:8000/?q=yangyanxing'</span>)</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;coroutine object getUrlByCor at <span class="number">0x00000000034BBF10</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>此处的 s 是一个coroutine对象，那么怎么才能执行函数里面的方法呢？ 将这个协程对象放到事件循环 <code class="text">event_loop</code> 中执行 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getUrlByCor</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span> % (end - start))</span><br><span class="line">    <span class="keyword">return</span> r.status_code</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = getUrlByCor(<span class="string">r"http://127.0.0.1:8000/?q=yangyanxing"</span>)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(s)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>用了5.009500026702881时间</p>
</blockquote>
<p>如果同时发三个请求呢？<br>这里要对协程做一个封装，将其封装成一个 task 对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getUrlByCor</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span> % (end - start))</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(getUrlByCor(<span class="string">r"http://127.0.0.1:8000/?q=yangyanxing"</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    print(len(tasks),tasks)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    e = time.time()</span><br><span class="line">    print(<span class="string">"use %s time"</span>%(e-s))</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        print(<span class="string">'Task Result:'</span>, task.result())</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> [&lt;Task pending coro=&lt;getUrlByCor() running at E:/Github/asyncTorMysql/asynctest.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending coro=&lt;getUrlByCor() running at E:/Github/asyncTorMysql/asynctest.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending coro=&lt;getUrlByCor() running at E:/Github/asyncTorMysql/asynctest.py:<span class="number">69</span>&gt;&gt;]</span><br><span class="line">用了<span class="number">5.008501291275024</span>时间</span><br><span class="line">用了<span class="number">5.012002229690552</span>时间</span><br><span class="line">用了<span class="number">5.012002229690552</span>时间</span><br><span class="line">use <span class="number">15.03450632095337</span> time</span><br><span class="line">Task Result: hello yangyanxing</span><br><span class="line">Task Result: hello yangyanxing</span><br><span class="line">Task Result: hello yangyanxing</span><br></pre></td></tr></table></figure></p>
<p>总的时间还是15秒，并没有实现异步呢，还是同步的依次执行请求。<br>其实，要实现异步处理，我们得先要有挂起的操作，当一个任务需要等待 IO 结果的时候，可以挂起当前任务，转而去执行其他任务，这样我们才能充分利用好资源，上面方法都是一本正经的串行走下来，连个挂起都没有，怎么可能实现异步？</p>
<p>上面的函数存在耗时的操作就是<code class="text">r = requests.get(url)</code> 那么将它写成挂起的呢？<br><code class="text">r = await requests.get(url)</code> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getUrlByCor</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = <span class="keyword">await</span> requests.get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span> % (end - start))</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(getUrlByCor(<span class="string">r"http://127.0.0.1:8000/?q=yangyanxing"</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    print(len(tasks),tasks)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    e = time.time()</span><br><span class="line">    print(<span class="string">"use %s time"</span>%(e-s))</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        print(<span class="string">'Task Result:'</span>, task.result())</span><br></pre></td></tr></table></figure>
<p>不出意外的报错了</p>
<blockquote>
<p>Task exception was never retrieved<br>future: <task finished="" coro="<getUrlByCor()" done,="" defined="" at="" e:="" github="" asynctormysql="" asynctest.py:69=""> exception=TypeError(“object Response can’t be used in ‘await’ expression”,)&gt;<br>Traceback (most recent call last):<br>  File “C:\Python35\lib\asyncio\tasks.py”, line 240, in _step<br>    result = coro.send(None)<br>  File “E:/Github/asyncTorMysql/asynctest.py”, line 71, in getUrlByCor<br>    r = await requests.get(url)<br>TypeError: object Response can’t be used in ‘await’ expression</task></p>
</blockquote>
<p>这个错误的意思是 requests 返回的 Response 对象不能和 await 一起使用,await 后面的对象必须是如下格式之一</p>
<ol>
<li>原生 coroutine 对象</li>
<li>一个由 types.coroutine() 修饰的生成器，这个生成器可以返回 coroutine 对象。</li>
<li>一个包含 __await 方法的对象返回的一个迭代器。</li>
</ol>
<p>reqeusts 返回的 Response 不符合上面任一条件，因此就会报上面的错误了。</p>
<p>既然 <code class="text">await</code> 后面的对象要是 <code class="text">coroutine</code> 对象 ，那么将其包装在<code class="text">async</code> 后面不就可以了吗？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getUrlByCor</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = <span class="keyword">await</span> get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span> % (end - start))</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(getUrlByCor(<span class="string">r"http://127.0.0.1:8000/?q=yangyanxing"</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    print(len(tasks),tasks)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    e = time.time()</span><br><span class="line">    print(<span class="string">"use %s time"</span>%(e-s))</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        print(<span class="string">'Task Result:'</span>, task.result())</span><br></pre></td></tr></table></figure></p>
<p>这次不报错了，但是依然没有异步的执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用了5.0090014934539795时间</span><br><span class="line">用了5.011002063751221时间</span><br><span class="line">用了5.011502027511597时间</span><br><span class="line">use 15.03450632095337 time</span><br><span class="line">Task Result: hello yangyanxing</span><br><span class="line">Task Result: hello yangyanxing</span><br><span class="line">Task Result: hello yangyanxing</span><br></pre></td></tr></table></figure></p>
<p>也就是说我们仅仅将涉及 IO 操作的代码封装到 async 修饰的方法里面是不可行的！我们必须要使用支持异步操作的请求方式才可以实现真正的异步，所以这里就需要 aiohttp 派上用场了</p>
<p>aiohttp 是一个支持异步请求的库，利用它和 asyncio 配合我们可以非常方便地实现异步请求操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    res = <span class="keyword">await</span> session.get(url)</span><br><span class="line">    result = <span class="keyword">await</span> res.text()</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getUrlByCor</span><span class="params">(url)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    r = <span class="keyword">await</span> get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"用了%s时间"</span> % (end - start))</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(getUrlByCor(<span class="string">r"http://127.0.0.1:8000/?q=yangyanxing"</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    print(len(tasks),tasks)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    e = time.time()</span><br><span class="line">    print(<span class="string">"use %s time"</span>%(e-s))</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        print(<span class="string">'Task Result:'</span>, task.result())</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用了5.006500005722046时间</span><br><span class="line">用了5.006499767303467时间</span><br><span class="line">用了5.006500005722046时间</span><br><span class="line">use 5.008500099182129 time</span><br><span class="line">Task Result: hello yangyanxing</span><br><span class="line">Task Result: hello yangyanxing</span><br><span class="line">Task Result: hello yangyanxing</span><br></pre></td></tr></table></figure></p>
<p>这次终于实现了异步请求。</p>
<p>还记得最开始的洗衣做饭的例子吗？可以使用异步协程来实现，代码大概是这个样子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading,multiprocessing</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">water</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"开始烧水了"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 这里使用asyncio.sleep 异步休眠</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"水开了"</span>, end - start)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">wash</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"开始洗衣服了"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"衣服洗完了"</span>, end - start)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"开始做饭了"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">10</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"饭熟了"</span>,end - start)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alarm</span><span class="params">(task)</span>:</span></span><br><span class="line">    print(<span class="string">"%s 一共用了%s 时间"</span>%(task.result()[<span class="number">0</span>],task.result()[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="comment"># 初始化task</span></span><br><span class="line">    task_water = asyncio.ensure_future(water())</span><br><span class="line">    task_wash = asyncio.ensure_future(wash())</span><br><span class="line">    task_cook = asyncio.ensure_future(cook())</span><br><span class="line">    tasks.extend([task_water,task_wash,task_cook])</span><br><span class="line">    <span class="comment"># 将这三个task 绑定回调函数</span></span><br><span class="line">    task_water.add_done_callback(alarm)</span><br><span class="line">    task_wash.add_done_callback(alarm)</span><br><span class="line">    task_cook.add_done_callback(alarm)</span><br><span class="line">    <span class="comment"># 将task放入事件循环中</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<blockquote>
<p>开始烧水了<br>开始洗衣服了<br>开始做饭了<br>水开了 一共用了2.0 时间<br>衣服洗完了 一共用了4.003999948501587 时间<br>饭熟了 一共用了9.994499921798706 时间</p>
</blockquote>
<h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><ul>
<li>先看下tornado在python2中的解决方案.</li>
</ul>
<p>我们再来翻过头来看之前用tornado写的服务端同步代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.options</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options</span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        query = self.get_argument(<span class="string">'q'</span>)</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        self.write(<span class="string">"hello %s"</span>%query)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    app = tornado.web.Application(handlers=[(<span class="string">r"/"</span>, IndexHandler)])</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>
<p>在 <code class="text">IndexHandler</code> 中的 get 方法，由于当中存在了一个比较耗时的操作，<code class="text">time.sleep(5)</code> 处理完这个请求需要卡5秒，在卡住的这段时间，tornado无法再完成别的请求，如果此时再发来一个 <code class="text">/</code> 的请求，那么只能等待这前的请求操作结束之后再对处理新发过来的请求，如果同时有1万个请求发过来，可想而知，最后一个请求就等到猴年马月才能处理完呢……  </p>
<p>解决方法是使用<code class="text">@tornado.web.asynchronous</code> 和<code class="text">@tornado.gen.coroutine</code> 装饰器，将耗时的操作放到线程中去执行，这里的耗时操作 <code class="text">time.sleep(5)</code> 是阻塞的，所以将阻塞函数放加上 <code class="text">@run_on_executor</code> 装饰器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.options</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="keyword">import</span> tornado.autoreload</span><br><span class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> run_on_executor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options</span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">100</span>)</span><br><span class="line"><span class="meta">    @tornado.web.asynchronous</span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        query = self.get_argument(<span class="string">'q'</span>)</span><br><span class="line">        res = <span class="keyword">yield</span> self.sleepBlock(<span class="number">2</span>,query)</span><br><span class="line">        self.write(<span class="string">"hello %s"</span>%res)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_on_executor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleepBlock</span><span class="params">(self,sleeptime,query)</span>:</span></span><br><span class="line">        time.sleep(sleeptime)</span><br><span class="line">        <span class="keyword">return</span> query</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    app = tornado.web.Application(handlers=[(<span class="string">r"/"</span>, IndexHandler)],settings=&#123;<span class="string">"debug"</span>:<span class="keyword">True</span>&#125;)</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></p>
<p>注意到在 <code class="text">IndexHandler</code> 中有一行初始化 executor 的代码  <code class="text">executor = ThreadPoolExecutor(100)</code> 这里的参数100是最大的线程数，我这里传的是100，也就意味着同时能处理100个请求，当有101个请求的时候，前100个请求可以同时在2秒内执行，最后的那一个请求就要等之前有结束的线程以后再去执行了。</p>
<ul>
<li>再看下tornado在python3.5 中的解决方案</li>
</ul>
<p>由于在python3.5以后引入了 <code class="text">asyncio</code>这个标准库，很多异步的操作可以用这个库来操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.options</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="keyword">import</span> tornado.autoreload</span><br><span class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> run_on_executor</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options</span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">100</span>)</span><br><span class="line"><span class="meta">    @tornado.web.asynchronous</span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        query = self.get_argument(<span class="string">'q'</span>)</span><br><span class="line">        res = <span class="keyword">yield</span> self.sleepBlock(<span class="number">2</span>,query)</span><br><span class="line">        self.write(<span class="string">"hello %s"</span>%res)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_on_executor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleepBlock</span><span class="params">(self,sleeptime,query)</span>:</span></span><br><span class="line">        time.sleep(sleeptime)</span><br><span class="line">        <span class="keyword">return</span> query</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">asyncIndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        query = self.get_argument(<span class="string">'q'</span>)</span><br><span class="line">        res = <span class="keyword">await</span> self.sleepBlock(<span class="number">2</span>,query)</span><br><span class="line">        self.write(<span class="string">"hello %s"</span>%res)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">sleepBlock</span><span class="params">(self,sleeptime,query)</span>:</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(sleeptime) <span class="comment"># 使用异步的sleep方法</span></span><br><span class="line">        <span class="keyword">return</span> query</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    app = tornado.web.Application(handlers=[</span><br><span class="line">        (<span class="string">r"/"</span>, IndexHandler),</span><br><span class="line">        (<span class="string">r"/async"</span>,asyncIndexHandler)</span><br><span class="line">    ],settings=&#123;<span class="string">"debug"</span>:<span class="keyword">True</span>&#125;)</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></p>
<p><code class="text">IndexHandler</code> 中的 get 方法使用了<code class="text">async</code> 与<code class="text">await</code> 关键字来达到异步的处理请求，这里的<code class="text">asyncio.sleep(5)</code> 是异步的暂停5秒，如果此处的方法涉及到无法使用异步请求的库该怎么处理，比如说我就想使用<code class="text">time.sleep(5)</code> 则需要在线程池中运行，就像上面的<code class="text">/</code> 路由里使用 <code class="text">@run_on_executor</code> 中执行。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>异步操作涉及的知识点比较多，不同版本的 python 对于异步的处理也不一样，有些东西如 <code class="text">yield</code> 理解起来比较费劲，需要多在项目中实践，<code class="text">tornado</code> 这个框架的设计初衷也是异步网络库，过使用非阻塞网络I/O, Tornado 可以支持上万级的连接，所以要使用过程中要多多考虑异步非阻塞的编码。 </p>
<p>参考文章</p>
<p><a href="https://cuiqingcai.com/6160.html" target="_blank" rel="noopener">爬虫速度太慢？来试试用异步协程提速吧！</a></p>
<p><a href="https://www.jianshu.com/p/7690edfe9ba5" target="_blank" rel="noopener">Python3 异步协程函数async具体用法</a></p>
<p><a href="http://www.cnblogs.com/coderzh/articles/1202040.html" target="_blank" rel="noopener">Python天天美味(25) - 深入理解yield</a></p>
<p><a href="https://blog.csdn.net/soonfly/article/details/78361819" target="_blank" rel="noopener">理解Python协程:从yield/send到yield from再到async/await</a></p>
<p><a href="http://www.dongwm.com/archives/shi-yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-sai/" target="_blank" rel="noopener">使用tornado让你的请求异步非阻塞</a></p>
</div><div class="article-footer-copyright"><p>本文由 杨彦星 发表于 杨彦星的个人博客 ,采用<a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" >「署名 4.0 国际」</a>创作共享协议。<br>
非商业转载请注明作者及出处。商业转载请联系作者本人。<br>
本文标题为: python中的异步实践与tornado应用 <br></p><p>本文链接为：<a href="https://www.yangyanxing.com/article/async_in_python.html">https://www.yangyanxing.com/article/async_in_python.html</a> <br></p></div><div class="tags"><a href="/tags/python/">python</a></div><div class="post-nav"><a class="next" href="/article/specialUse-in-pymongo.html">pymongo中的特殊查询</a></div><div class="article-end-text-wrap"><div class="article-end-text"> <p text-align="center">欢迎关注我的公众号--序语程言，里面会分享一些编程的基础与一些问题的解决<div align="center"><img src="/image/qrcode.jpg"></div></p></div></div><div class="reward" id="reward" text-align="center"><p>Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</p></div><iframe src="/donate/?AliPayQR=http://ww1.sinaimg.cn/large/795ab47fly1fu0ekgctg1j205k058jrs.jpg&amp;WeChatQR=http://ww1.sinaimg.cn/large/795ab47fly1fu0eoafd9kj206a077glz.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.yangyanxing.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IT关注/">IT关注</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux相关/">Linux相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/我的大学/">我的大学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活记录/">生活记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机相关/">计算机相关</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/ThinkPHP/" style="font-size: 15px;">ThinkPHP</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/微博/" style="font-size: 15px;">微博</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/自动化测试/" style="font-size: 15px;">自动化测试</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/requests/" style="font-size: 15px;">requests</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/webpy/" style="font-size: 15px;">webpy</a> <a href="/tags/wordpress/" style="font-size: 15px;">wordpress</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/xml/" style="font-size: 15px;">xml</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/async_in_python.html">python中的异步实践与tornado应用</a></li><li class="post-list-item"><a class="post-list-link" href="/article/specialUse-in-pymongo.html">pymongo中的特殊查询</a></li><li class="post-list-item"><a class="post-list-link" href="/article/use-redis-for-mq-in-python.html">使用Redis作为消息队列实现生产消费与发布订阅</a></li><li class="post-list-item"><a class="post-list-link" href="/article/tulple_detail.html">别小看元组</a></li><li class="post-list-item"><a class="post-list-link" href="/article/higher-order-function.html">python中关于map,lambda,高阶函数与装饰器的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/article/python-list-sort.html">python中的list排序问题以及sort,sorted的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/article/python-logging-day-file.html">python中的日志按天保存单独的文件</a></li><li class="post-list-item"><a class="post-list-link" href="/article/use-logging-in-python.html">利用logging模块轻松地进行Python日志记录(转)</a></li><li class="post-list-item"><a class="post-list-link" href="/article/config-local-ssh.html">配置多个ssh密钥对并且永久多ssh管理</a></li><li class="post-list-item"><a class="post-list-link" href="/article/put-html-to-qiniu.html">将hexo生成的静态网站部署到七牛</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.liaoxuefeng.com/" title="廖雪峰" target="_blank">廖雪峰</a><ul></ul><a href="http://blog.csdn.net/itfootball" title="D.Q的专栏" target="_blank">D.Q的专栏</a><ul></ul><a href="http://opentest.360.cn/" title="360开测" target="_blank">360开测</a><ul></ul><a href="https://testerhome.com/" title="TesterHome" target="_blank">TesterHome</a><ul></ul><a href="http://www.androiddevtools.cn/" title="AndroidDev" target="_blank">AndroidDev</a><ul></ul><a href="http://blog.csdn.net/guolin_blog" title="郭霖的专栏" target="_blank">郭霖的专栏</a><ul></ul><a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.ruanyifeng.com/blog/archives.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="http://stormzhang.com/" title="stormzhang博客" target="_blank">stormzhang博客</a><ul></ul><a href="https://imququ.com/" title="Jerry Qu" target="_blank">Jerry Qu</a><ul></ul><a href="https://www.opsdev.cn/" title="360OPS" target="_blank">360OPS</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">杨彦星.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages <br></a><a class="text-muted" href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备18004468号 <script>(function(){
var bp = document.createElement('script');
var curProtocol = window.location.protocol.split(':')[0];        
if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
}
else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
}
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();</script></a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>