{"meta":{"title":"杨彦星","subtitle":"序语程言","description":"python,go,java,php,编程,线程,进程,异步","author":"杨彦星","url":"https://www.yangyanxing.com"},"pages":[{"title":"","date":"2018-12-28T16:02:47.892Z","updated":"2017-12-18T14:40:59.764Z","comments":true,"path":"README.html","permalink":"https://www.yangyanxing.com/README.html","excerpt":"","text":"blogsourcemy blog source There is my blog source dir for sync and there is no use for other"},{"title":"关于我","date":"2015-12-04T06:12:08.000Z","updated":"2019-06-22T11:10:18.253Z","comments":true,"path":"about/index.html","permalink":"https://www.yangyanxing.com/about/index.html","excerpt":"","text":"天行健，君子以自强不息；地势坤，君子以厚德载物 GitHub: https://github.com/kevinkelinWeibo: https://weibo.com/kevinkelinEmail: admin@yangyanxing.comFacebook: https://www.facebook.com/yangyanxingTwitter: https://www.twitter.com/yangyanxing 微信公众号 头条号"},{"title":"categories","date":"2017-12-16T15:06:48.652Z","updated":"2017-12-16T10:11:00.323Z","comments":true,"path":"categories/index.html","permalink":"https://www.yangyanxing.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-16T15:06:49.213Z","updated":"2017-12-16T10:10:43.453Z","comments":true,"path":"tags/index.html","permalink":"https://www.yangyanxing.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"go语言中关于字符串使用的总结","slug":"string_use_in_go","date":"2019-08-26T16:00:00.000Z","updated":"2019-08-27T10:49:24.000Z","comments":true,"path":"article/string_use_in_go.html","link":"","permalink":"https://www.yangyanxing.com/article/string_use_in_go.html","excerpt":"字符串 字符串只能用双引号定义， go里单引号和双引号不通过,可以使用`` 号来定义原始输出，不会进行转义，相当于python 里的三引号","text":"字符串 字符串只能用双引号定义， go里单引号和双引号不通过,可以使用`` 号来定义原始输出，不会进行转义，相当于python 里的三引号 123456789101112package mainimport \"fmt\"func main() &#123; name := \"杨彦星\\n\" s := `杨 adgfgfg \\n\\t ` fmt.Println(name,s)&#125; 输出 1234杨彦星杨 adgfgfg \\n\\t 字符串是不可改变的 我们说字符串是不可变的指的是字符串内部⽤用指针指向 UTF-8 字节数组，所指向的字节数组不能单独改变。并不是指字符串指向一个新的UTF-8数组 1234567891011121314151617package mainimport \"fmt\"func main() &#123; var name string var name1 = []byte(\"yangyanxing汉字\") name = string(name1) fmt.Println(&amp;name,name) name = \"杨彦星\" //这个是可以的 fmt.Println(&amp;name) //name 的地址不会改变 //非法 //name[0] = \"a\"&#125; 如果想要改变字符串中的值需要先将字符串转为字节数组([]byte)或者字符数组([]rune),有中文的情况下使用字符数组 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; var name = \"yangyanxing\" fmt.Println(&amp;name,name) names := []byte(name) //字节数组需要使用单引号,双引号是字符串了 names[0] = 'f' fmt.Println(&amp;name,string(names)) name = \"杨彦星\" //这个是可以的 //如果有汉字的话需要使用字符数组 namer := []rune(name) //需要使用单引号 namer[0] = '饭' //name 的地址不会改变 fmt.Println(&amp;name,string(namer)) &#125; 字符串与字节数组与字符数组的相互转换 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var name = \"yangyanxing\" fmt.Println(&amp;name,name) names := []byte(name) fmt.Printf(\"%T\\n\",names) names[0] = 'f' //字节数组需要使用单引号,双引号是字符串了 name = string(names) fmt.Println(&amp;name,name) name = \"杨彦星\" //如果有汉字的话需要使用字符数组 namer := []rune(name) fmt.Printf(\"%T\\n\",namer) namer[0] = '饭' name = string(namer) fmt.Println(&amp;name,name) //name 的地址不会改变&#125; 字符串的遍历 字符串可以按字节或者字符来遍历 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; var name = \"yang杨彦星\" //按字节遍历 for i:=0;i&lt;len(name);i++&#123; fmt.Printf(\"%v %T:%v\\n\",i,name[i],name[i]) &#125; fmt.Println(\"\") //按字符遍历 for _,r := range name&#123; //%c 为输出数值所表示的 Unicode 字符,不带单引号 如 y //%q 输出数值所表示的 Unicode 字符（带单引号）如 '杨' fmt.Printf(\"%c\",r) &#125;&#125; 结果为 123456789101112131415160 uint8:1211 uint8:972 uint8:1103 uint8:1034 uint8:2305 uint8:1576 uint8:1687 uint8:2298 uint8:1899 uint8:16610 uint8:23011 uint8:15212 uint8:159yang杨彦星Process finished with exit code 0 字符串的拼接 可以直接使用 + 拼接 123456789101112131415161718package mainimport \"fmt\"func main() &#123; //字符串可以使用+进行拼接 var name = \"yang\" + \"yan\" + \"xing\" fmt.Println(name) //使用+=在原字符串后面追加字符串 name += \"杨彦星\" fmt.Println(name) // + 不能在行首，只能写在行尾，就和if else中的else那样 s := \"BeiJing\" + \" TongZhou\" fmt.Println(s)&#125; 在循环中使用 + 号进行拼接并不是高效的方法，可以使用strings.Join方法 123456789101112131415161718package mainimport ( \"fmt\" \"strings\")func main() &#123; var names = []string&#123;\"yang\",\"fan\",\"zhang\",\"li\",\"chen\"&#125; n := strings.Join(names,\" \") fmt.Println(n) s := \"yang&amp;aaa&amp;bbb&amp;ccc\" //以&amp;分割 str := strings.Split(s,\"&amp;\") fmt.Println(str)&#125; yang fan zhang li chen [yang aaa bbb ccc] strings包的常用方法该包提供了字符串操作的常用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"yang&amp; yan&amp;xing\" //HasPrefix 判断字符串 s 是否以 prefix 开头 fmt.Println(strings.HasPrefix(s,\"y\")) //HasSuffix 判断字符串 s 是否以 suffix 结尾 fmt.Println(strings.HasSuffix(s,\"aaa\")) //Contains 判断字符串 s 是否包含 substr fmt.Println(strings.Contains(s,\"yang\")) //Replace替换字符串,最后一个参数为数量，-1为替换全部 fmt.Println(strings.Replace(s,\"y\",\"Y\",-1)) //ToLower 将字符串中的 Unicode 字符全部转换为相应的小写字符 ss := \"AAA杨彦星BbbbB\" fmt.Println(strings.ToLower(ss)) //ToUpper 将字符串中的 Unicode 字符全部转换为相应的大写字符 fmt.Println(strings.ToUpper(ss)) //strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号 //中间的不能删除 sp := \" aaa bbb ccc \" fmt.Println(strings.TrimSpace(sp)) //还可以去除开头或者结尾指定的字符 ssp := \"aaa Hey, how are you George?aaaa\" fmt.Println(strings.TrimLeft(ssp,\"He\")) fmt.Println(strings.TrimRight(ssp,\"ge\")) fmt.Println(strings.Trim(ssp,\"aaa\")) //strings.Fields(s) 将会利用 //strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割 sp2 := \" aa a b bb ccc \" fmt.Println(strings.Fields(sp2)) fmt.Println(strings.Split(sp2,\" \")) //使用空格分割 //Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串 sp3 := []string&#123;\"aa\",\"a\",\"b\",\"bb\",\"ccc\"&#125; fmt.Println(strings.Join(sp3,\"$$$\"))&#125; 结果 12345678910111213truefalsetrueYang&amp; Yan&amp;xingaaa杨彦星bbbbbAAA杨彦星BBBBBaaa bbb cccaaa Hey, how are you George?aaaaaaa Hey, how are you George?aaaaHey, how are you George?[aa a b bb ccc][ aa a b bb ccc ]aa$$$a$$$b$$$bb$$$ccc 字符串与其它类型的转换使用strconv包中的方法可以实现字符串与其它类型的转换 1234567891011121314151617181920package mainimport ( \"fmt\" \"strconv\")func main() &#123; //Itoa 将数字转为字符串 fmt.Println(strconv.Itoa(35)) // Atoi 将字符串转为其它类型并不一定会成功 fmt.Println(strconv.Atoi(\"100\")) fmt.Println(strconv.ParseBool(\"true\")) //可以成功 v,e := strconv.ParseBool(\"trues\")//会有err if e!=nil&#123; fmt.Println(e.Error()) &#125;else&#123; fmt.Println(v) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/tags/go/"}]},{"title":"go语言中关于文件路径的使用总结","slug":"file_path_in_go","date":"2019-08-24T16:00:00.000Z","updated":"2019-08-26T10:58:00.000Z","comments":true,"path":"article/file_path_in_go.html","link":"","permalink":"https://www.yangyanxing.com/article/file_path_in_go.html","excerpt":"在编程中操作文件非常常见，如读取或者写入文件，但是在此之前会先构造出文件路径，在python中有相应的os.path库，对于文件路径的操作很简单，如 os.path.basename 获取文件名 os.path.dirname 获取文件目录名 os.path.join 拼接文件路径 os.path.splitext 拆分文件，获取文件名和扩展名 os.path.adspath 获取文件绝对路径 os.path.exists 判断文件或者文件夹是否存在 以下尝试在go语言中对上面的这些方法进行实现","text":"在编程中操作文件非常常见，如读取或者写入文件，但是在此之前会先构造出文件路径，在python中有相应的os.path库，对于文件路径的操作很简单，如 os.path.basename 获取文件名 os.path.dirname 获取文件目录名 os.path.join 拼接文件路径 os.path.splitext 拆分文件，获取文件名和扩展名 os.path.adspath 获取文件绝对路径 os.path.exists 判断文件或者文件夹是否存在 以下尝试在go语言中对上面的这些方法进行实现 在go语言中操作文件路径主要使用 filepath 这个包，使用也比较简单，已经写在注释里了。1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"fmt\" \"os\" \"path/filepath\")func main() &#123; pwd,_ := os.Getwd() // 获取到当前目录，相当于python里的os.getcwd() fmt.Println(\"当前的操作路径为:\",pwd) //文件路径拼接 f1 := filepath.Join(pwd,\"test\",\"1.txt\") fmt.Println(\"文件的路径为:\",f1) //文件的目录名 fmt.Println(\"文件的目录名:\",filepath.Dir(f1)) //文件的文件名 fmt.Println(\"文件的文件名:\",filepath.Base(f1)) //文件的绝对路径 adspath,_ := filepath.Abs(\"evn/3.txt\") fmt.Println(\"文件的绝对路径为:\",adspath) //拆分路径 dirname,filename := filepath.Split(f1) fmt.Println(\"目录名为:\",dirname,\"文件名为\",filename) //扩展名相关 fmt.Println(\"f1的扩展名为:\",filepath.Ext(f1)) //通过os.Stat()函数返回的文件状态，如果有错误则根据错误状态来判断文件或者文件夹是否存在 fileinfo,err :=os.Stat(f1) if err!=nil&#123; fmt.Println(err.Error()) if os.IsNotExist(err)&#123; fmt.Println(\"file:\",f1,\" not exist！\") &#125; &#125;else&#123; //判断路径是否为文件夹 fmt.Println(fileinfo.IsDir()) fmt.Println(!fileinfo.IsDir()) fmt.Println(fileinfo.Name()) &#125;&#125; 运行的结果为： 1234567当前的操作路径为: F:\\GO\\src\\gobookcode文件的路径为: F:\\GO\\src\\gobookcode\\test\\1.txt文件的目录名: F:\\GO\\src\\gobookcode\\test文件的文件名: 1.txt文件的绝对路径为: F:\\GO\\src\\gobookcode\\evn\\3.txt目录名为: F:\\GO\\src\\gobookcode\\test\\ 文件名为 1.txtf1的扩展名为: .txt","categories":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/tags/go/"}]},{"title":"go语言中函数使用不定参数问题","slug":"func_viriadic_in_go","date":"2019-08-23T16:00:00.000Z","updated":"2019-08-25T01:01:37.454Z","comments":true,"path":"article/func_viriadic_in_go.html","link":"","permalink":"https://www.yangyanxing.com/article/func_viriadic_in_go.html","excerpt":"在go语言中，函数也可以使用不定参数,可变参数函数即其参数数量是可变的 —— 0 个或多个。声明可变参数函数的方式是在其参数类型前带上省略符（三个点）前缀。","text":"在go语言中，函数也可以使用不定参数,可变参数函数即其参数数量是可变的 —— 0 个或多个。声明可变参数函数的方式是在其参数类型前带上省略符（三个点）前缀。 1234567891011121314151617package mainimport ( \"fmt\" \"strings\")func main() &#123; showName(\"yang\",\"yanxing\") showName(\"fan\") showName(\"fan\",\"jie\",\"ying\")&#125;func showName(a ...string) &#123; name := strings.Join(a,\" \") fmt.Println(name)&#125; 输出： yang yanxingfanfan jie ying 使用起来还是比较简单的，但是这里需要注意一些问题 不定参数只能是最后一个参数如果在不定参数后面还要定义参数的话就会报错，can noly use &#39;...&#39; as final argument in list 函数的不定参数在内部是一个定义类型的切片如上面的数，打印a的类型，这是一个[]string 切片的展开在使用不定参数的时候，可以传入该类型切片的展开形式，但是如只传入的是展开形式，则其前后就不能再添加参数了 12345678910111213141516package mainimport ( \"fmt\" \"strings\")func main() &#123; name := []string&#123;\"yang\",\"yan\",\"xing\"&#125; showName(name...)&#125;func showName(a ...string) &#123; fmt.Println(strings.Join(a,\" \"))&#125; 如果尝试使用shwName(name...,&quot;is&quot;,&quot;a&quot;,&quot;good man&quot;) 或者showName(&quot;my name&quot;,&quot;is&quot;,name...) 则报错 如果传入的是切片形式的，如果函数内改变切片的值，则会对影响到原切片 1234567891011121314151617181920package mainimport ( \"fmt\" \"strings\")func main() &#123; name := []string&#123;\"yang\",\"yan\",\"xing\"&#125; fmt.Println(name) showName(name...) fmt.Println(name)&#125;func showName(a ...string) &#123; a[0] = \"fan\" a = append(a,\"is\",\"a\",\"good\",\"man\") fmt.Println(strings.Join(a,\" \"))&#125; 输出 [yang yan xing] fan yan xing is a good man [fan yan xing] 参数文章Go 语言“可变参数函数”终极指南","categories":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/tags/go/"}]},{"title":"go语言中执行命令的几种方式","slug":"exec_command_in_go","date":"2019-08-22T16:00:00.000Z","updated":"2019-08-25T14:52:14.480Z","comments":true,"path":"article/exec_command_in_go.html","link":"","permalink":"https://www.yangyanxing.com/article/exec_command_in_go.html","excerpt":"go语言用来执行一切系统的命令相对python来说还是有点复杂的，执行命令是一个非常常见的需求，如调用一个系统命令，启一个exe等，这里分为几种情况，之后统一总结一下。 只执行命令，不要输出结果 执行命令并且要获取到输出结果 阻塞和异步的执行","text":"go语言用来执行一切系统的命令相对python来说还是有点复杂的，执行命令是一个非常常见的需求，如调用一个系统命令，启一个exe等，这里分为几种情况，之后统一总结一下。 只执行命令，不要输出结果 执行命令并且要获取到输出结果 阻塞和异步的执行 以下以ping www.baidu.com 为例依次执行一下各种命令，主要使用标准库中的os/exec 在执行命令的时候，我们主要使用的是os/exec包主的Cmd结构体方法，Cmd的结构体定义如下Cmd结构体定义 主要的参数有1234567891011121314Path string// Args保管命令的参数，包括命令名作为第一个参数；如果为空切片或者nil，相当于无参数命令。//// 典型用法下，Path和Args都应被Command函数设定。Args []string// Env指定进程的环境，如为nil，则是在当前进程的环境下执行。Stdin io.Reader// Stdout和Stderr指定进程的标准输出和标准错误输出。//// 如果任一个为nil，Run方法会将对应的文件描述符关联到空设备（os.DevNull）//// 如果两个字段相同，同一时间最多有一个线程可以写入。Stdout io.WriterStderr io.Writer 但是我们一般不直接构造Cmd结构体，而是通过exec.Command() 函数返回一个Cmd结构体指针如 exec.Command(“ping”,”www.baidu.com”) ping为命令，”www.baidu.com” 为参数,在得到*Cmd以后再使用结构体方法Run,Start等方法来真正的执行命令。 只执行命令，不要输出结果这里的输出结果只是表明命令执行了，但是它具体的输出我们不关心，在这种其实用的挺多的，我们只是想执行命令,在python里我们可以使用os.system() 函数来执行，当然这个是阻塞的执行123456789101112131415&gt;&gt;&gt; import os&gt;&gt;&gt; r = os.system(\"ping www.baidu.com\")正在 Ping www.a.shifen.com [39.156.66.18] 具有 32 字节的数据:来自 39.156.66.18 的回复: 字节=32 时间=6ms TTL=54来自 39.156.66.18 的回复: 字节=32 时间=28ms TTL=54来自 39.156.66.18 的回复: 字节=32 时间=6ms TTL=54来自 39.156.66.18 的回复: 字节=32 时间=7ms TTL=5439.156.66.18 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 6ms，最长 = 28ms，平均 = 11ms&gt;&gt;&gt; r0 这里的r只是获取了该命令的执行结果，是0表示没有错误，但是执行命令的输出如 正在 Ping www.a.shifen.com….. 我们并不关心 执行命令可以使用Run() 或者Start() 方法，Run是阻塞的执行，Start() 是非阻塞的执行。1234567891011121314package mainimport ( \"fmt\" \"os/exec\")func main() &#123; command := exec.Command(\"ping\",\"www.baidu.com\") err := command.Run() if err != nil&#123; fmt.Println(err.Error()) &#125;&#125; 程序什么也没有输出，但是停顿的一段时间后才退出。如果换成command.Start() 则程序运行起来以后马上就停止了。 如果想要获取到像python那种os.system的执行结果，其实这里的结果应该是ExitError,程序的退出码，应该怎么操作呢？这里exec包里有一个专门的结构体ExitError,使用它的一些方法可以获取到ExitCode，但是想要获取到ExitCode得到得到命令结束，也就是要阻塞的运行,上面使用Run() 方法可以阻塞等待执行结果，使用Start()方法以后，也可以使用Wait()方法来等待执行结束。123456789101112131415161718192021package mainimport ( \"fmt\" \"os/exec\" \"syscall\")func main() &#123; command := exec.Command(\"ping\",\"www.baidu.com\") err := command.Start() if err != nil&#123; fmt.Println(err.Error()) &#125; if err = command.Wait();err!=nil&#123; fmt.Println(err.Error()) &#125;else&#123; fmt.Println(command.ProcessState.Pid()) fmt.Println(command.ProcessState.Sys().(syscall.WaitStatus).ExitCode) &#125;&#125; 通过 1command.ProcessState.Sys().(syscall.WaitStatus).ExitCode 来获取到命令执行的退出码 执行命令并且要获取到输出结果这里的输出结果是命令行的标准输出或者错误输出，也就是stdout或者stderr,通过bytes.Buffer来存储12345678910111213141516171819202122232425package mainimport ( \"bytes\" \"fmt\" \"os/exec\" \"syscall\")func main() &#123; command := exec.Command(\"ping\",\"www.baidu.com\") outinfo := bytes.Buffer&#123;&#125; command.Stdout = &amp;outinfo err := command.Start() if err != nil&#123; fmt.Println(err.Error()) &#125; if err = command.Wait();err!=nil&#123; fmt.Println(err.Error()) &#125;else&#123; fmt.Println(command.ProcessState.Pid()) fmt.Println(command.ProcessState.Sys().(syscall.WaitStatus).ExitCode) fmt.Println(outinfo.String()) &#125;&#125; 这里得到的中文输出有乱码 这个我查了一下一般都是说是设置一下控制台输出chcp或者使用1golang.org/x/text/encoding/simplifiedchinese 这个包进行转换，我不想使用，这个以后找到方法再说吧。 命令行的输入有时候进入命令行会等待用户的交互，如输入nslookup1234567891011121314151617package mainimport ( \"bytes\" \"fmt\" \"os/exec\" \"strings\")func main() &#123; var outInfo bytes.Buffer cmd := exec.Command(\"nslookup\") cmd.Stdin = strings.NewReader(\"set q=mx\\npython.org\\nexit\\n\") cmd.Stdout = &amp;outInfo cmd.Run() fmt.Println(outInfo.String())&#125; 执行不在环境变量里的命令像上面这个ping 命令，由于在windows 或者linux中，这个命令是在环境变量里，但是像windows中的copy 命令，它是不在环境变量里，正常情况下你可以在cmd中使用copy 命令，但是如果在go 语言中如果直接像上面那样使用是不行的。例如使用上面的代码，替换一下copy 命令12345678910111213141516171819package mainimport ( \"bytes\" \"fmt\" \"os/exec\")func main() &#123; cmd := exec.Command(\"copy\",\"1.txt\",\"2.txt\") var output bytes.Buffer cmd.Stdout = &amp;output e :=cmd.Run() if e != nil&#123; fmt.Println(\"run error :\" + e.Error()) &#125;else&#123; fmt.Println(output.String()) &#125;&#125; 得到的输出结果为1run error :exec: &quot;copy&quot;: executable file not found in %PATH% 应该使用cmd&quot;, &quot;/C&quot; copy命令1234567891011func main() &#123; cmd := exec.Command(\"cmd\",\"/C\",\"copy\",\"1.txt\",\"2.txt\") var output bytes.Buffer cmd.Stdout = &amp;output e :=cmd.Run() if e != nil&#123; fmt.Println(\"run error :\" + e.Error()) &#125;else&#123; fmt.Println(output.String()) &#125;&#125; 参考文章 golang exec 命令执行 Windows下，在CMD下执行Go出现中文乱码的解决方法","categories":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/tags/go/"}]},{"title":"go语言中的new与make","slug":"new_make_in_go","date":"2019-08-13T15:53:38.000Z","updated":"2019-08-17T12:28:51.256Z","comments":true,"path":"article/new_make_in_go.html","link":"","permalink":"https://www.yangyanxing.com/article/new_make_in_go.html","excerpt":"初学go语言，对于初始化变量时使用new还是make有些迷惑，这里简单总结一下","text":"初学go语言，对于初始化变量时使用new还是make有些迷惑，这里简单总结一下 new() 和 make() 的区别以下摘录自 https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/07.2.md 二者都在堆上分配内存，但是它们的行为不同，适用于不同的类型。 new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。 make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel 换言之，new 函数分配内存，make 函数初始化；下图给出了区别： 我的理解，new返回一个变量的指针，但是这个指针指向空，你不可以直接对该指针进行操作，否则会报错，除非你将该指针指向一个该类型变量的地址。make返回一个该类型的变量，以切片变量为例，上面提到，make适用于创建切片、map和channel,但new也可以创建 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"func main() &#123; //使用make创建切片，返回的是变量本身 s1 := make([]int,5,10) fmt.Printf(\"use make create slise type %T value %v \\n\",s1,s1) s1[0] = 123 s1[4] = 321 fmt.Printf(\"make s1 type %T value %v \\n\",s1,s1) //# 使用new 创建切片,返回的是切片变量的指针 s2 := new([]int) fmt.Printf(\"use new create slise type %T value %v \\n\",s2,s2) fmt.Printf(\"new s2 type %T value %v \\n\",*s2,*s2) // 想要赋值的话需要使用*解引用 // 这里虽然不报语法错误，但是如果尝试直接使用(*s2)[0] = 123的话会有运行时错误， // panic: runtime error: index out of range s2 = &amp;s1 //需要将变量指针指向一个该类型变量的地址 (*s2)[0] = 123 (*s2)[4] = 3211 fmt.Printf(\"new s2 type %T value %v \\n\",s2,s2) //s2的修改也会影响s1 fmt.Printf(\"s1 type %T value %v \\n\",s1,s1) m1 := make(map[string]string) m1[\"name\"] = \"yangyanxing\" m1[\"age\"] = \"30\" fmt.Printf(\"m1 use make create type:%T value %v \\n\",m1,m1) m2 := new(map[string]string) fmt.Printf(\"m2 use new create type:%T value %v \\n\",m2,m2) //直接赋值会报 panic: assignment to entry in nil map m2 = &amp;m1 (*m2)[\"name\"] = \"fan\" //对m2的修改也会影响到m1 fmt.Printf(\"after m2 change m1 value is %v\",m1)&#125; 输出结果为123456789use make create slise type []int value [0 0 0 0 0] make s1 type []int value [123 0 0 0 321] use new create slise type *[]int value &amp;[] new s2 type []int value [] new s2 type *[]int value &amp;[123 0 0 0 3211] s1 type []int value [123 0 0 0 3211] m1 use make create type:map[string]string value map[name:yangyanxing age:30] m2 use new create type:*map[string]string value &amp;map[] after m2 change m1 value is map[name:fan age:30] map的初始化map有以下两种初始化方法 使用make函数 直接使用map初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport \"fmt\"func main() &#123; //使用make初始化map mp2 := make(map[string]string) mp2[\"name\"] = \"yangyanxing\" mp2[\"age\"] = \"18\" fmt.Println(\"m2 address \",&amp;mp2) // out:m2 address &amp;map[name:yangyanxing age:18] mp3 := map[string]int&#123;&#125; //这里要有&#123;&#125;,花括号里如果没有内容则说明初始化了一个空字典 mp3[\"yang\"] = 18 mp3[\"fan\"] = 20 fmt.Println(mp3) //out:map[yang:18 fan:20] mp4 := map[string]int&#123; \"yang\":20, \"fan\":21, //即使是最后一个也要有逗号 &#125; fmt.Println(mp4) //out:map[yang:20 fan:21] mp5 := map[string]int&#123;\"yang\":30&#125; //写在同一行则不用加逗号 fmt.Println(mp5) //out: map[yang:30] mp6 := make(map[string]int,1) //还可以给map加一个容量 mp6[\"yang\"] = 30 fmt.Println(\"mp6 lens is \",len(mp6),\"address:\",&amp;mp6) //out:mp6 lens is 1 address: &amp;map[yang:30] mp6[\"fan\"] = 31 fmt.Println(\"mp6 lens is \",len(mp6),\"address:\",&amp;mp6) //out:mp6 lens is 2 address: &amp;map[yang:30 fan:31] //也可以使用new,但是不可以直接对其进行赋值,因为此时它返回的是一个空指针 //需要指向一个该类型的变量地址以后才可以进行操作 mp7 := new(map[string]int) fmt.Println(mp7) //out:&amp;map[] //(*mp7)[\"yang\"] = 100 //会报运行时错误 mp7 = &amp;mp6 //mp7[\"fan\"] = 1000 //也不可以直接使用mp7,需要使用* 先解引用 (*mp7)[\"yang\"] = 100 //这时就不会报运行时错误 fmt.Println(mp7) //out:&amp;map[yang:100 fan:31]&#125; slice切片的初始化同样可以通过make和切片本身进行初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport \"fmt\"func main() &#123; //使用make初始化切片,需要传一个len长度,容量cap为可选 //如果不传的话则长度和容量相同 sls1 := make([]int,5,10) sls1[0] = 100 //append 追加到尾部,这里有点意思 sls1 = append(sls1,200) // ... 三个点,go里的语法糖,展开前面的切片 sls1 = append(sls1,[]int&#123;30,40&#125;...) fmt.Println(sls1,len(sls1),cap(sls1)) //out: [100 0 0 0 0 200 30 40] 8 10 sls1 = append(sls1,3,4,6)//超过切片原有容量以后将会发生扩容 fmt.Println(sls1,len(sls1),cap(sls1)) //out: [100 0 0 0 0 200 30 40 3 4 6] 11 20 sls2 := make([]int,3) sls2[1] = 123 fmt.Println(sls2,len(sls2),cap(sls2)) //out: [0 123 0] 3 3 //直接初始化 sls3 := []int&#123;&#125; sls3 = append(sls3,10,20) fmt.Println(sls3,len(sls3),cap(sls3)) //out: [10 20] 2 2 sls4 := []int&#123;1,2,3&#125; sls5 :=[]int&#123; 1, 2, 5,//这里的逗号不能省 &#125; fmt.Println(sls4,sls5) //out: [1 2 3] [1 2 5] //使用new创建切片,和map一样,返回的也是指针,不能直接对其进行操作 //需要先指向一个变量的地址 sls6 := new([]int) fmt.Println(sls6)//out: &amp;[] sls6 = &amp;sls4 fmt.Println(sls6) //out: &amp;[1 2 3]&#125; array数组的初始化数组不能使用make初始化,但是可以使用new初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport \"fmt\"type person struct &#123; name string age int&#125;func main() &#123; fmt.Println(\"数组的初始化\") //声明并初始化一个空数组,里面的元素值为类型的零值 arr1 := [2]int&#123;&#125; fmt.Println(arr1) //out: [0 0] //初始化时将元素值写上 arr2 := [2]int&#123;1,3&#125; fmt.Println(arr2) //out: [1 3] //只写一个,不写的是零值 arr3 := [2]int&#123;1&#125; fmt.Println(arr3) //out: [1 0] //arr4 := make([2]int) //数组不能使用make var arr5 [2]int arr5[0] = 100 fmt.Println(arr5)//[100 0] //不指定数组大小,使用... 三点号让其自动展开计算 arr6 := [...]int&#123;2,4,6,8&#125; fmt.Println(arr6,len(arr6))//out: [2 4 6 8] 4 //使用new创建一个数组,得到的是一个指针 arr7 := new([3]int) fmt.Println(arr7)//out: &amp;[0 0 0] //可以直接对指针进行操作 arr7[0] = 3 //和使用*解引用作用一样 (*arr7)[1] = 4 fmt.Println(arr7) //out: &amp;[3 4 0]&#125; struct结构体的初始化结构体不能使用make,需要使用new和结构体本身 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"type person struct &#123; name string age int&#125;func main() &#123; fmt.Println(\"结构体的初始化\") //使用new,返回结构体指针 stru1 := new(person) fmt.Println(stru1)//out &amp;&#123; 0&#125; ,默认是字段的零值 //可以直接使用这个指针来操作变量 //和使用*解引用效果一样 stru1.name = \"yangyanxing\" (*stru1).age = 18 fmt.Println(stru1,*stru1) //&amp;&#123;yangyanxing 18&#125; &#123;yangyanxing 18&#125; //只指定一个字段,没有指定的默认零值 stru2 := person&#123;name:\"fan\"&#125; fmt.Println(stru2) //&#123;fan 0&#125; //全部指定,字段的顺序可以不按照定义时的顺序 stru3 := person&#123;age:18,name:\"yang\"&#125; fmt.Println(stru3) //&#123;yang 18&#125; //按照结构体顺序初始化,这时元素的值必须都写全了 stru4 := person&#123;\"fan\",17&#125; fmt.Println(stru4) //&#123;fan 17&#125;&#125;","categories":[{"name":"Go","slug":"Go","permalink":"https://www.yangyanxing.com/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/tags/go/"}]},{"title":"go语言中的for range的应用","slug":"forrange_in_go","date":"2019-08-11T15:53:38.000Z","updated":"2019-08-26T11:12:39.000Z","comments":true,"path":"article/forrange_in_go.html","link":"","permalink":"https://www.yangyanxing.com/article/forrange_in_go.html","excerpt":"for range 在go语言中用于遍历一个可迭代的对象，它可以应用于数组，切片，字典等它有以下一些用法","text":"for range 在go语言中用于遍历一个可迭代的对象，它可以应用于数组，切片，字典等它有以下一些用法 遍历数组与切片12345678910package mainimport \"fmt\"func main() &#123; a := [...]string&#123;\"a\", \"b\", \"c\", \"d\"&#125; for i := range a &#123; fmt.Println(\"Array item\", i, \"is\", a[i]) &#125;&#125; 初始化数组时使用[...]string 为初始化一个字符串数组，长度自动计算，如果写成[]string 则为初始化一个切片. for i := range a 这里是通过遍历数组的下标，i 每次循环下标加1，然后通过 array[i] 的方式获取数组的值，也可以在for range 结构中直接获取数组元素1234567891011package mainimport \"fmt\"func main() &#123; a := [...]string&#123;\"a\", \"b\", \"c\", \"d\"&#125; for i,v := range a &#123; fmt.Println(\"Array item\", i, \"is\", v) &#125;&#125; 遍历map遍历字典也有两种方式，一种是遍历key,一种是同时遍历key和value123456789101112131415161718package mainimport \"fmt\"func main() &#123; var fruits = map[string]int &#123; \"apple\": 2, \"banana\": 5, \"orange\": 8, &#125; for f,s := range fruits&#123; fmt.Println(\"fruits:\",f,\"score:\",s) &#125; for f := range fruits&#123; fmt.Println(\"fruits:\",f,\"score:\",fruits[f]) &#125;&#125; 遍历通道可以使用for range 来遍历通道，当通道未关闭时，会阻塞的等待，当通道关闭以后，则跳出循环遍历。123456789101112131415161718package mainimport \"fmt\"func main() &#123; ch := make(chan int,6) go setData(ch) for ele := range ch&#123; fmt.Println(\"get data \" ,ele) &#125;&#125;func setData(ch chan int) &#123; for v:=0;v&lt;8;v++&#123; ch &lt;- v &#125; close(ch)&#125; 如果上面代码中，setData函数中不close(ch) 关闭通道的话，则会发生panic 死锁 上面的for range 遍历通道，如果使用for 循环来写的话是下面这样12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; ch := make(chan int,6) go setData(ch) for&#123; v,ok := &lt;- ch if !ok&#123; break &#125; fmt.Println(\"get data \",v) &#125;&#125;func setData(ch chan int) &#123; for v:=0;v&lt;8;v++&#123; ch &lt;- v &#125; close(ch)&#125;","categories":[{"name":"Go","slug":"Go","permalink":"https://www.yangyanxing.com/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.yangyanxing.com/tags/go/"}]},{"title":"在python中使用注解函数","slug":"function_annotations_in_python","date":"2019-08-04T15:53:38.000Z","updated":"2019-08-04T14:01:43.488Z","comments":true,"path":"article/function_annotations_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/function_annotations_in_python.html","excerpt":"最近在看aiohttp的源码，发现一种没有见过的定义函数写法def __enter__(self) -&gt; None ,函数后面还跟着一个-&gt;，这让一个以前受过C指针伤害过的人来说整个人都不好了，于是查了一下这个带箭头的用法，这里的-&gt;的指针没有半毛钱关系。","text":"最近在看aiohttp的源码，发现一种没有见过的定义函数写法def __enter__(self) -&gt; None ,函数后面还跟着一个-&gt;，这让一个以前受过C指针伤害过的人来说整个人都不好了，于是查了一下这个带箭头的用法，这里的-&gt;的指针没有半毛钱关系。 这里的箭头其实是一种注解的写法，他是为了告诉调用者这个函数返回什么内容，如下面的代码12def test(x,y)-&gt;int: return x+y 这告诉使用者，这个函数会返回一个int类型的值。虽然在函数注解里虽然指定了返回一个int类型的值，但是我们知道在python 的返回值里可以返回任意类型的值，我们依然可以不按照注解来返回一个str类型的值123def test(x,y)-&gt;int: r = x+y return \"yangyanxing\" 这里写虽说不会报语法错误，可是谁看都会骂街，你既然告诉了你的使用者说你要返回一个int类型的值，可是你自己却给人家返回一个str类型的值，这都是不符合规范的。在使用pyCharm编辑器时，就会显示一个警告 Expected type ‘int’, got ‘str’ instead 对于函数的参数也可以使用注解函数的参数也可以使用注解，用来告诉使用者需要传哪种类型的参数，方法是在参数后面加上一个冒号:1234def test(x:int,y:int)-&gt;int: return x+ytest(1,2) 同样还是那个问题，你可以约束，但是我也可以不遵守，你让我传一个int，我偏要传一个str，语法上不会报错，但是会报一个警告 注意上面的注解写法是在python3才有的，如果在python2下运行会报语法错误！","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中多线程与多进程中的数据共享问题","slug":"sharedata_in_python_thread","date":"2019-07-27T15:53:38.000Z","updated":"2019-07-27T17:30:20.810Z","comments":true,"path":"article/sharedata_in_python_thread.html","link":"","permalink":"https://www.yangyanxing.com/article/sharedata_in_python_thread.html","excerpt":"之前在写多线程与多进程的时候，因为一般情况下都是各自完成各自的任务，各个子线程或者各个子进程之前并没有太多的联系，如果需要通信的话我会使用队列或者数据库来完成，但是最近我在写一些多线程与多进程的代码时，发现如果它们需要用到共享变量的话，需要有一些注意的地方","text":"之前在写多线程与多进程的时候，因为一般情况下都是各自完成各自的任务，各个子线程或者各个子进程之前并没有太多的联系，如果需要通信的话我会使用队列或者数据库来完成，但是最近我在写一些多线程与多进程的代码时，发现如果它们需要用到共享变量的话，需要有一些注意的地方 多线程之间的共享数据标准数据类型在线程间共享看以下代码1234567891011121314#coding:utf-8import threadingdef test(name,data): print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data,id(data)))if __name__ == '__main__': d = 5 name = \"杨彦星\" for i in range(5): th = threading.Thread(target=test,args=(name,d)) th.start() 这里我创建一个全局的int变量d,它的值是5，当我在5个线程中调用test函数时，将d作为参数传进去，那么这5个线程所拥有的是同一个d吗？我在test函数中通过id(data) 来打印一下它们的ID，得到了如下的结果 12345678910in thread &lt;Thread(Thread-1, started 6624)&gt; name is 杨彦星data is 5 id(data) is 1763791776in thread &lt;Thread(Thread-2, started 8108)&gt; name is 杨彦星data is 5 id(data) is 1763791776in thread &lt;Thread(Thread-3, started 3356)&gt; name is 杨彦星data is 5 id(data) is 1763791776in thread &lt;Thread(Thread-4, started 13728)&gt; name is 杨彦星data is 5 id(data) is 1763791776in thread &lt;Thread(Thread-5, started 3712)&gt; name is 杨彦星data is 5 id(data) is 1763791776 从结果中可以看到，在5个子线程中，data的id都是1763791776，说明在主线程中创建了变量d，在子线程中是可以共享的，在子线程中对共享元素的改变是会影响到其它线程的，所以如果要对共享变量进行修改时，也就是线程不安全的，需要加锁。 自定义类型对象在线程间共享如果我们要自定义一个类呢，将一个对象作为变量在子线程中传递呢？会是什么效果呢？ 12345678910111213141516171819202122232425#coding:utf-8import threadingclass Data: def __init__(self,data=None): self.data = data def get(self): return self.data def set(self,data): self.data = datadef test(name,data): print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data.get(),id(data)))if __name__ == '__main__': d = Data(10) name = \"杨彦星\" print(\"in main thread id(data) is &#123;&#125;\".format(id(d))) for i in range(5): th = threading.Thread(target=test,args=(name,d)) th.start() 这里我定义一个简单的类，在主线程初始化了一个该类型的对象d,然后将它作为参数传给子线程，主线程和子线程分别打印了这个对象的id，我们来看一下结果1234567891011in main thread id(data) is 2849240813864in thread &lt;Thread(Thread-1, started 11648)&gt; name is 杨彦星data is 10 id(data) is 2849240813864in thread &lt;Thread(Thread-2, started 11016)&gt; name is 杨彦星data is 10 id(data) is 2849240813864in thread &lt;Thread(Thread-3, started 10416)&gt; name is 杨彦星data is 10 id(data) is 2849240813864in thread &lt;Thread(Thread-4, started 8668)&gt; name is 杨彦星data is 10 id(data) is 2849240813864in thread &lt;Thread(Thread-5, started 4420)&gt; name is 杨彦星data is 10 id(data) is 2849240813864 我们看到，在主线程和子线程中，这个对象的id是一样的，说明它们用的是同一个对象。 无论是标准数据类型还是复杂的自定义数据类型，它们在多线程之间是共享同一个的，但是在多进程中是这样的吗？ 多进程之间的共享数据标准数据类型在进程间共享还是上面的代码，我们先来看一下int类型的变量的子进程间的共享12345678910111213141516#coding:utf-8import threadingimport multiprocessingdef test(name,data): print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data,id(data)))if __name__ == '__main__': d = 10 name = \"杨彦星\" print(\"in main thread id(data) is &#123;&#125;\".format(id(d))) for i in range(5): pro = multiprocessing.Process(target=test,args=(name,d)) pro.start() 得到的结果是1234567891011in main thread id(data) is 1763791936in thread &lt;_MainThread(MainThread, started 9364)&gt; name is 杨彦星data is 10 id(data) is 1763791936in thread &lt;_MainThread(MainThread, started 9464)&gt; name is 杨彦星data is 10 id(data) is 1763791936in thread &lt;_MainThread(MainThread, started 3964)&gt; name is 杨彦星data is 10 id(data) is 1763791936in thread &lt;_MainThread(MainThread, started 10480)&gt; name is 杨彦星data is 10 id(data) is 1763791936in thread &lt;_MainThread(MainThread, started 13608)&gt; name is 杨彦星data is 10 id(data) is 1763791936 可以看到它们的id是一样的，说明用的是同一个变量，但是当我尝试把d由int变为了string时，发现它们又不一样了……1234567if __name__ == '__main__': d = 'yangyanxing' name = \"杨彦星\" print(\"in main thread id(data) is &#123;&#125;\".format(id(d))) for i in range(5): pro = multiprocessing.Process(target=test,args=(name,d)) pro.start() 此时得到的结果是1234567891011in main thread id(data) is 2629633397040in thread &lt;_MainThread(MainThread, started 9848)&gt; name is 杨彦星data is yangyanxing id(data) is 1390942032880in thread &lt;_MainThread(MainThread, started 988)&gt; name is 杨彦星data is yangyanxing id(data) is 2198251377648in thread &lt;_MainThread(MainThread, started 3728)&gt; name is 杨彦星data is yangyanxing id(data) is 2708672287728in thread &lt;_MainThread(MainThread, started 5288)&gt; name is 杨彦星data is yangyanxing id(data) is 2376058999792in thread &lt;_MainThread(MainThread, started 12508)&gt; name is 杨彦星data is yangyanxing id(data) is 2261044040688 于是我又尝试了list、Tuple、dict，结果它们都是不一样的，我又回过头来试着在多线程中使用列表元组和字典，结果在多线程中它们的id还是一样的。 这里有一个有趣的问题，如果是int类型，当值小于等于256时，它们在多进程间的id是相同的，如果大于256，则它们的id就会不同了，这个我没有查看原因。 自定义类型对象在进程间共享1234567891011121314151617181920212223242526#coding:utf-8import threadingimport multiprocessingclass Data: def __init__(self,data=None): self.data = data def get(self): return self.data def set(self,data): self.data = datadef test(name,data): print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data.get(),id(data)))if __name__ == '__main__': d = Data(10) name = \"杨彦星\" print(\"in main thread id(data) is &#123;&#125;\".format(id(d))) for i in range(5): pro = multiprocessing.Process(target=test,args=(name,d)) pro.start() 得到的结果是1234567891011in main thread id(data) is 1927286591728in thread &lt;_MainThread(MainThread, started 2408)&gt; name is 杨彦星data is 10 id(data) is 1561177927752in thread &lt;_MainThread(MainThread, started 5728)&gt; name is 杨彦星data is 10 id(data) is 2235260514376in thread &lt;_MainThread(MainThread, started 1476)&gt; name is 杨彦星data is 10 id(data) is 2350586073040in thread &lt;_MainThread(MainThread, started 996)&gt; name is 杨彦星data is 10 id(data) is 2125002248088in thread &lt;_MainThread(MainThread, started 10740)&gt; name is 杨彦星data is 10 id(data) is 1512231669656 可以看到它们的id是不同的，也就是不同的对象。 在多进程间如何共享数据我们看到，数据在多进程间是不共享的(小于256的int类型除外)，但是我们又想在主进程和子进程间共享一个数据对象时该如何操作呢？ 在看这个问题之前，我们先将之前的多线程代码做下修改12345678910111213141516171819202122232425262728293031323334#coding:utf-8import threadingimport multiprocessingclass Data: def __init__(self,data=None): self.data = data def get(self): return self.data def set(self,data): self.data = datadef test(name,data,lock): lock.acquire() print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data,id(data))) data.set(data.get()+1) lock.release()if __name__ == '__main__': d = Data(0) thlist = [] name = \"yang\" lock = threading.Lock() for i in range(5): th = threading.Thread(target=test,args=(name,d,lock)) th.start() thlist.append(th) for i in thlist: i.join() print(d.get()) 我们这个代码的目的是这样，使用自定义的Data类型对象，当经过5个子线程操作以后，每个子线程对其data值进行加1操作，最后在主线程打印对象的data值。该输出结果如下1234567891011in thread &lt;Thread(Thread-1, started 3296)&gt; name is yangdata is &lt;__main__.Data object at 0x000001A451139198&gt; id(data) is 1805246501272in thread &lt;Thread(Thread-2, started 9436)&gt; name is yangdata is &lt;__main__.Data object at 0x000001A451139198&gt; id(data) is 1805246501272in thread &lt;Thread(Thread-3, started 760)&gt; name is yangdata is &lt;__main__.Data object at 0x000001A451139198&gt; id(data) is 1805246501272in thread &lt;Thread(Thread-4, started 1952)&gt; name is yangdata is &lt;__main__.Data object at 0x000001A451139198&gt; id(data) is 1805246501272in thread &lt;Thread(Thread-5, started 5988)&gt; name is yangdata is &lt;__main__.Data object at 0x000001A451139198&gt; id(data) is 18052465012725 可以看到在主线程最后打印出来了5，符合我们的预期，但是如果放到多进程中呢？因为多进程下，每个子进程所持有的对象是不同的，所以每个子进程操作的是各自的Data对象，对于主进程的Data对象应该是没有影响的，我们来看下它的结果12345678910111213141516171819202122232425262728293031323334#coding:utf-8import threadingimport multiprocessingclass Data: def __init__(self,data=None): self.data = data def get(self): return self.data def set(self,data): self.data = datadef test(name,data,lock): lock.acquire() print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data,id(data))) data.set(data.get()+1) lock.release()if __name__ == '__main__': d = Data(0) thlist = [] name = \"yang\" lock = multiprocessing.Lock() for i in range(5): th = multiprocessing.Process(target=test,args=(name,d,lock)) th.start() thlist.append(th) for i in thlist: i.join() print(d.get()) 它的输出结果是:1234567891011in thread &lt;_MainThread(MainThread, started 7604)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000001D110130EB8&gt; id(data) is 1997429477048in thread &lt;_MainThread(MainThread, started 12108)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000002C4E88E0E80&gt; id(data) is 3044738469504in thread &lt;_MainThread(MainThread, started 3848)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x0000027827270EF0&gt; id(data) is 2715076202224in thread &lt;_MainThread(MainThread, started 12368)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000002420EA80E80&gt; id(data) is 2482736991872in thread &lt;_MainThread(MainThread, started 4152)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000001B1577F0E80&gt; id(data) is 18611887837440 最后的输出是0，说明了子进程对于主进程传入的Data对象操作其实对于主进程的对象是不起作用的，我们需要怎样的操作才能实现子进程可以操作主进程的对象呢？我们可以使用multiprocessing.managers 下的 BaseManager 来实现123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8import threadingimport multiprocessingfrom multiprocessing.managers import BaseManagerclass Data: def __init__(self,data=None): self.data = data def get(self): return self.data def set(self,data): self.data = data BaseManager.register(\"mydata\",Data)def test(name,data,lock): lock.acquire() print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data,id(data))) data.set(data.get()+1) lock.release()def getManager(): m = BaseManager() m.start() return mif __name__ == '__main__': manager = getManager() d = manager.mydata(0) thlist = [] name = \"yang\" lock = multiprocessing.Lock() for i in range(5): th = multiprocessing.Process(target=test,args=(name,d,lock)) th.start() thlist.append(th) for i in thlist: i.join() print(d.get()) 使用from multiprocessing.managers import BaseManager 引入 BaseManager以后，在定义完Data类型之后，使用BaseManager.register(&quot;mydata&quot;,Data) 将Data类型注册到BaseManager中，并且给了它一个名字叫mydata，之后就可以使用BaseManager对象的这个名字来初始化对象，我们来看一下输出123456789101112C:\\Python35\\python.exe F:/python/python3Test/multask.pyin thread &lt;_MainThread(MainThread, started 12244)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000001FE1B7D9668&gt; id(data) is 2222932504080in thread &lt;_MainThread(MainThread, started 2860)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000001FE1B7D9668&gt; id(data) is 1897574510096in thread &lt;_MainThread(MainThread, started 2748)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000001FE1B7D9668&gt; id(data) is 2053415775760in thread &lt;_MainThread(MainThread, started 7812)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000001FE1B7D9668&gt; id(data) is 2766155820560in thread &lt;_MainThread(MainThread, started 2384)&gt; name is yangdata is &lt;__mp_main__.Data object at 0x000001FE1B7D9668&gt; id(data) is 25011598904485 我们看到，虽然在每个子进程中使用的是不同的对象，但是它们的值却是可以“共享”的。 标准的数据类型也可以通过multiprocessing库中的Value对象，举一个简单的例子1234567891011121314151617181920212223242526272829303132333435363738#coding:utf-8import threadingimport multiprocessingfrom multiprocessing.managers import BaseManagerclass Data: def __init__(self,data=None): self.data = data def get(self): return self.data def set(self,data): self.data = dataBaseManager.register(\"mydata\",Data)def test(name,data,lock): lock.acquire() print(\"in thread &#123;&#125; name is &#123;&#125;\".format(threading.current_thread(),name)) print(\"data is &#123;&#125; id(data) is &#123;&#125;\".format(data,id(data))) data.value +=1 lock.release()if __name__ == '__main__': d = multiprocessing.Value(\"l\",10) # print(d) thlist = [] name = \"yang\" lock = multiprocessing.Lock() for i in range(5): th = multiprocessing.Process(target=test,args=(name,d,lock)) th.start() thlist.append(th) for i in thlist: i.join() print(d.value) 这里使用d = multiprocessing.Value(&quot;l&quot;,10) 初始化了一个数字类型的对象，这个类型是Synchronized wrapper for c_long ,multiprocessing.Value在初始化时，第一个参数是类型，第二个参数是值,具体支持的类型如下 还可以使用ctypes库里和类初始化字符串1234&gt;&gt;&gt; from ctypes import c_char_p&gt;&gt;&gt; s = multiprocessing.Value(c_char_p, b'\\xd1\\xee\\xd1\\xe5\\xd0\\xc7')&gt;&gt;&gt; print(s.value.decode('gbk'))杨彦星 还可以使用Manager对象初始list,dict等1234567891011121314151617181920212223242526#coding:utf-8import multiprocessingdef func(mydict, mylist): # 子进程改变dict,主进程跟着改变 mydict[\"index1\"] = \"aaaaaa\" # 子进程改变List,主进程跟着改变 mydict[\"index2\"] = \"bbbbbb\" mylist.append(11) mylist.append(22) mylist.append(33)if __name__ == \"__main__\": # 主进程与子进程共享这个字典 mydict = multiprocessing.Manager().dict() # 主进程与子进程共享这个List mylist = multiprocessing.Manager().list(range(5)) p = multiprocessing.Process(target=func, args=(mydict, mylist)) p.start() p.join() print(mylist) print(mydict) 其实我们这里所说的共享只是数据值上的共享，因为在多进程中，各自持有的对象都不相同，所以如果想要同步状态需要曲线救国。不过这种在自己写的小项目中可以简单的使用，如果做一些大一点的项目，还是建议不要使用这种共享数据的方式，这种大大的增加了程序间的耦合性，使用逻辑变得复杂难懂，所以建议还是使用队列或者数据库作为通信的渠道。 参考文章Python 进程之间共享数据(全局变量) Python多进程编程-进程间共享数据","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"使用aiomysql异步操作mysql","slug":"aiomysql_in_python","date":"2019-07-20T15:53:38.000Z","updated":"2019-07-21T12:35:05.783Z","comments":true,"path":"article/aiomysql_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/aiomysql_in_python.html","excerpt":"之前一直在使用mongo与redis，最近在项目中开始使用mysql数据库，由于现在的项目是全程异步的操作，所以在在网上查了下关于在python中异步的操作mysql，找来找去最后发现aiomysql的是实现最好的，现在简单介绍一下它的使用。","text":"之前一直在使用mongo与redis，最近在项目中开始使用mysql数据库，由于现在的项目是全程异步的操作，所以在在网上查了下关于在python中异步的操作mysql，找来找去最后发现aiomysql的是实现最好的，现在简单介绍一下它的使用。 aiomysql的文档地址 https://aiomysql.readthedocs.io/en/latest/ 需要根据项目中使用mysql查询的频率来选择是使用单独的connection还是使用连接池，查询较少的可以选择使用connection，使用一次以后就断开，再次使用再次连接，但是对于mysql，每次连接的开销都很高，所以建议还是使用连接池，由于不同的mysql服务对于interactive_timeout的设置时间不同，所以这里还要注意一下这个超时问题，在同步版本中关于mysql主动断开连接的问题可以参考我之前的文章,解决mysql服务器在无操作超时主动断开连接的问题 ,异步版本同样也要注意这个问题。 为了测试，我在docker中启了一个mysql服务，并且设置interactive_timeout为5秒，非常短，这样测试以后，如果一个连接在5秒钟之内都没有任何查询则主动将该连接断开。数据很简单就两条12345678mysql&gt; select * from person;+----+------+-----+| id | name | age |+----+------+-----+| 1 | yang | 18 || 2 | fan | 16 |+----+------+-----+2 rows in set 使用单独的connection根据官方文档，我对其进行了一点封装,采用单例模式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8import aiomysqlimport asyncioimport loggingimport traceback'''mysql 异步版本'''logobj = logging.getLogger('mysql')class Pmysql: __connection = None def __init__(self): self.cursor = None self.connection = None @staticmethod async def getconnection(): if Pmysql.__connection == None: conn = await aiomysql.connect( host='127.0.0.1', port=3306, user='root', password='123456', db='mytest', ) if conn: Pmysql.__connection = conn return conn else: raise(\"connect to mysql error \") else: return Pmysql.__connection async def query(self,query,args=None): self.cursor = await self.connection.cursor() await self.cursor.execute(query,args) r = await self.cursor.fetchall() await self.cursor.close() return rasync def test(): conn = await Pmysql.getconnection() mysqlobj.connection = conn await conn.ping() r = await mysqlobj.query(\"select * from person\") for i in r: print(i) conn.close()if __name__ == '__main__': mysqlobj = Pmysql() loop = asyncio.get_event_loop() loop.run_until_complete(test()) 这个小脚本执行很顺利，得到的结果12(1, &apos;yang&apos;, 18)(2, &apos;fan&apos;, 16) 简单说明一个这个脚本，由于aiomysql.connect是异步的，在python里 __init__ 方法不能使用async关键词，也就是在对象的初始化时不能异步，所以我将获取连接的操作单独的使用单例模式来创建一个连接，当然也可以不使用单例，每次进行查询的时候，都重新获取一个新的连接connection。 处理连接无操作超时问题还是那个老生常谈的问题，如果某个连接在一段时间内无操作，mysql会主动断开这个连接，我这里设置的5秒钟，那么我们看看停顿6秒钟以后再次尝试查询操作会怎样？123456789101112async def test(): conn = await Pmysql.getconnection() mysqlobj.connection = conn await conn.ping() r = await mysqlobj.query(\"select * from person\") for i in r: print(i) await asyncio.sleep(6) r2 = await mysqlobj.query(\"select * from person\") for i in r2: print(i) conn.close() sleep了6秒钟以后，当再次使用该connection的cursor对象进行查询操作时，由于mysql服务已经将该连接关闭，所以会得到2013, &#39;Lost connection to MySQL server during query&#39;错误。123456789101112C:\\Python35\\python.exe F:/python/python3Test/mysqltest3.py(1, &apos;yang&apos;, 18)(2, &apos;fan&apos;, 16)Traceback (most recent call last): File &quot;C:\\Python35\\lib\\site-packages\\aiomysql\\connection.py&quot;, line 598, in _read_bytes...... File &quot;C:\\Python35\\lib\\site-packages\\aiomysql\\connection.py&quot;, line 601, in _read_bytes raise OperationalError(2013, msg) from epymysql.err.OperationalError: (2013, &apos;Lost connection to MySQL server during query&apos;)...... 解决方法还是和之前同步版本一样，在进行查询操作之前，先使用connection.ping()方法来检查一下连接是否有效，该方法默认会在连接无效的时候进行重新连接。这里我直接修改Pmysql类的query方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding:utf-8import aiomysqlimport asyncioimport loggingimport traceback'''mysql 异步版本'''logobj = logging.getLogger('mysql')class Pmysql: __connection = None def __init__(self): self.cursor = None self.connection = None @staticmethod async def getconnection(): if Pmysql.__connection == None: conn = await aiomysql.connect( host='127.0.0.1', port=3306, user='root', password='123456', db='mytest', ) if conn: Pmysql.__connection = conn return conn else: raise(\"connect to mysql error \") else: return Pmysql.__connection async def query(self,query,args=None): self.cursor = await self.connection.cursor() #每次进行查询操作时都先执行一下ping()方法来检查一下连接是否有效 await self.connection.ping() await self.cursor.execute(query,args) r = await self.cursor.fetchall() await self.cursor.close() return rasync def test(): conn = await Pmysql.getconnection() mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person\") for i in r: print(i) await asyncio.sleep(6) r2 = await mysqlobj.query(\"select * from person\") for i in r2: print(i) conn.close()if __name__ == '__main__': mysqlobj = Pmysql() loop = asyncio.get_event_loop() loop.run_until_complete(test()) 这样上面的脚本就可以正常的执行了。 异步地执行多个查询异步的操作的优势在于它可以”同时”的进行多个操作，如果查询只是一个一个的单独查询，那用不用异步其实都无所谓，这里尝试使用异步来同时执行多个操作12345678910111213141516171819202122232425#coding:utf-8async def test(): conn = await Pmysql.getconnection() mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person\") mysqlobj.connection.close() return rasync def test2(): conn = await Pmysql.getconnection() mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person where id=(%s)\",(1,)) mysqlobj.connection.close() return rasync def querysum(): result = await asyncio.gather(test(),test2()) for i in result: print(i)if __name__ == '__main__': mysqlobj = Pmysql() loop = asyncio.get_event_loop() loop.run_until_complete(querysum()) 这里我准备了两个查询操作，test和test2,并将它们的结果放到另外一个协程querysum中,但是结果却出乎意料，脚本崩了……我看崩溃信息很多，其中有一条RuntimeError: readexactly() called while another coroutine is already waiting for incoming data,这条给我感觉是当一个协程在等待数据的时候突然另外一个协程进来了打断了它的数据读取。我个人推断应该是我采用了单例，它们共用一个connection然后在异步的处理过程中，当一个查询在进行过程中，在等待协程的数据返回，此时由于用了await，执行权会让出给别的协程，但是此时如果别的协程又在该connection上进行了数据库查询，则会影响到被await协程的数据读取。但是他们是用的同一个connection吗？ 我打印一下看看123456789101112131415async def test(): conn = await Pmysql.getconnection() print(\"test...\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person\") mysqlobj.connection.close() return rasync def test2(): conn = await Pmysql.getconnection() print(\"test2..\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person where id=(%s)\",(1,)) mysqlobj.connection.close() return r 得到的结果是：12test... 1719190377360test2.. 1719190377976 惊奇的发现，它们用的居然不是同一个connection…,那么问题是不是出在了单例模式下的初始化connection函数上……我们返来看一下connection初始化条件if Pmysql.__connection == None:,如果__connection 是None的话则进行初始化操作，据此我又推断，由于我在两个协程中共用的是一个全局的mysqlobj,mysqlobj = Pmysql(),所以在这两个协程运行的一开始在同时调用await Pmysql.getconnection()时，由于此时，这个mysqlobj的__connection是空，所以这两个协程此时的判断都是为空，所以都重新进行了数据库连接操作，然后把各自初始化获取的conn赋给了mysqlobj.connection，但是这就有问题了，同一个对象的某个属性的值就变了，所以在之后使用connection的cursor对象进行数据库查询操作时就会出现问题……那么我把其中一个协程在获取connection对象之前先暂停一下呢，让另外一个协程先获取到connection,这样当另外的协程再次获取的时候就可以直接获取到之前初始化过的connection了.12345678910111213141516async def test(): conn = await Pmysql.getconnection() print(\"test...\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person\") mysqlobj.connection.close() return rasync def test2(): await asyncio.sleep(0.1) conn = await Pmysql.getconnection() print(\"test2..\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person where id=(%s)\",(1,)) mysqlobj.connection.close() return r 我在test2()函数获取connection之前sleep(0.1)秒此时在test()函数和test2()函数中得到的connection就是相同的了，但是脚本依然报错12345678test... 2286181241800test2.. 2286181241800Traceback (most recent call last): ... ... &quot;C:\\Python35\\lib\\site-packages\\aiomysql\\connection.py&quot;, line 1064, in _ensure_alive raise InterfaceError(&quot;(0, &apos;Not connected&apos;)&quot;)pymysql.err.InterfaceError: (0, &apos;Not connected&apos;) 脚本报了一个0, &#39;Not connected&#39;错误，这里是由于在test()和test2()函数执行完以后都执行了mysqlobj.connection.close()操作来关闭这个connection，在异步操作中，不一定谁先执行完，谁先执行完就将connection关闭，但是你关闭了，其它协程可能还会用到，所以这里就报了Not connected错误。解决方法是将mysqlobj.connection.close()注掉，在脚本全部执行完以后统一对connection进行关闭操作12345678910111213141516171819202122232425262728async def test(): conn = await Pmysql.getaconnection() print(\"test...\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person\") # mysqlobj.connection.close() return rasync def test2(): await asyncio.sleep(0.1) conn = await Pmysql.getconnection() print(\"test2..\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person where id=(%s)\",(1,)) # mysqlobj.connection.close() return rasync def querysum(): result = await asyncio.gather(test(),test2()) for i in result: print(i)if __name__ == '__main__': mysqlobj = Pmysql() loop = asyncio.get_event_loop() loop.run_until_complete(querysum()) mysqlobj.connection.close() 此时得到正确的执行结果1234test... 1732819440584test2.. 1732819440584((1, &apos;yang&apos;, 18), (2, &apos;fan&apos;, 16))((1, &apos;yang&apos;, 18),) 其实这里还可以不使用全局的mysqlobj，在每次查询的时候使用各自独立的对象，使用独立的连接connection12345678910111213141516171819202122232425262728293031323334353637383940async def getaconnection(): return await aiomysql.connect( host='127.0.0.1', port=3306, user='root', password='123456', db='mytest', )async def test(): mysqlobj = Pmysql() conn = await getaconnection() mysqlobj.connection = conn print(\"test...\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person\") mysqlobj.connection.close() return rasync def test2(): mysqlobj = Pmysql() conn = await getaconnection() mysqlobj.connection = conn print(\"test2..\",id(conn)) mysqlobj.connection = conn r = await mysqlobj.query(\"select * from person where id=(%s)\",(1,)) mysqlobj.connection.close() return rasync def querysum(): result = await asyncio.gather(test(),test2()) for i in result: print(i)if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(querysum()) 如果使用单独的对象，单独的connection,那么我们其实不需要自己来维护这套连接机制，而是使用下面要介绍的连接池操作。 使用连接池pool使用连接池的意义在于，有一个池子，它里保持着指定数量的可用连接，当一个查询结执行之前从这个池子里取一个连接，查询结束以后将连接放回池子中，这样可以避免频繁的连接数据库，节省大量的资源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#coding:utf-8import tracebackimport loggingimport aiomysqlimport asyncio'''mysql 异步版本'''logobj = logging.getLogger('mysql')class Pmysql: def __init__(self): self.coon = None self.pool = None async def initpool(self): try: logobj.debug(\"will connect mysql~\") __pool = await aiomysql.create_pool( minsize=5, maxsize=10, host='127.0.0.1', port=3306, user='root', password='123456', db='mytest', autocommit=False) return __pool except: logobj.error('connect error.', exc_info=True) async def getCurosr(self): conn = await self.pool.acquire() cur = await conn.cursor() return conn,cur async def query(self, query,param=None): conn,cur = await self.getCurosr() try: await cur.execute(query,param) return await cur.fetchall() except: logobj.error(traceback.format_exc()) finally: if cur: await cur.close() # 释放掉conn,将连接放回到连接池中 await self.pool.release(conn)async def test(): mysqlobj = await getAmysqlobj() r = await mysqlobj.query(\"select * from person\") for i in r: print(i) await asyncio.sleep(6) r2 = await mysqlobj.query(\"select * from person where id = (%s)\",(1,)) print(r2)async def getAmysqlobj(): mysqlobj = Pmysql() pool = await mysqlobj.initpool() mysqlobj.pool = pool return mysqlobjif __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(test()) 该脚本在test方法在数据库查询操作分成了两部分，中间停了6秒钟来让mysql服务主动断开连接，当进行第二次查询的时候，并没有报2013, &#39;Lost connection to MySQL server during query&#39;error，这里是由于1234async def getCurosr(self): conn = await self.pool.acquire() cur = await conn.cursor() return conn,cur 在getCurosr方法中是从连接池中重新获取了一个可用的连接。 异步处理多任务和单连接一样，我们这里尝试异步的处理多个任务看看情况如何1234567891011121314151617181920212223async def test(mysqlobj): r = await mysqlobj.query(\"select * from person\") return rasync def test2(mysqlobj): r = await mysqlobj.query(\"select * from person where id = (%s)\",(1,)) return rasync def getAmysqlobj(): mysqlobj = Pmysql() pool = await mysqlobj.initpool() mysqlobj.pool = pool return mysqlobjasync def querysum(): mysqlobj = await getAmysqlobj() result = await asyncio.gather(test(mysqlobj),test2(mysqlobj)) for i in result: print(i)if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(querysum()) 注意这里在运行test()和test2()放入的是同一个mysqlobj,但是它们在进行查询的时候都重新通过pool.acquire()重新获取连接和游标，这样它们相互之间不互影响，可以各自进行各自的查询。 aiomysql 的使用初步就讲到这里，之后我会介绍一下在tornado中如何异步的使用aiomysql进行查询。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"解决mysql服务器在无操作超时主动断开连接的问题","slug":"connect_short_problem","date":"2019-07-18T15:53:38.000Z","updated":"2019-07-19T19:22:32.689Z","comments":true,"path":"article/connect_short_problem.html","link":"","permalink":"https://www.yangyanxing.com/article/connect_short_problem.html","excerpt":"我们在使用mysql服务的时候，正常情况下，mysql的设置的timeout是8个小时(28800秒)，也就是说，如果一个连接8个小时都没有操作，那么mysql会主动的断开连接，当这个连接再次尝试查询的时候就会报个”MySQL server has gone away”的误，但是有时候，由于mysql服务器那边做了一些设置，很多情况下会缩短这个连接timeout时长以保证更多的连接可用。有时候设置得比较变态，很短，30秒，这样就需要客户端这边做一些操作来保证不要让mysql主动来断开。","text":"我们在使用mysql服务的时候，正常情况下，mysql的设置的timeout是8个小时(28800秒)，也就是说，如果一个连接8个小时都没有操作，那么mysql会主动的断开连接，当这个连接再次尝试查询的时候就会报个”MySQL server has gone away”的误，但是有时候，由于mysql服务器那边做了一些设置，很多情况下会缩短这个连接timeout时长以保证更多的连接可用。有时候设置得比较变态，很短，30秒，这样就需要客户端这边做一些操作来保证不要让mysql主动来断开。 查看mysql的timeout使用客户端工具或者Mysql命令行工具输入show global variables like &#39;%timeout%&#39;;就会显示与timeout相关的属性，这里我用docker模拟了一个测试环境。12345678910111213141516171819mysql&gt; show variables like &apos;%timeout%&apos;; +-----------------------------+----------+| Variable_name | Value |+-----------------------------+----------+| connect_timeout | 10 || delayed_insert_timeout | 300 || have_statement_timeout | YES || innodb_flush_log_at_timeout | 1 || innodb_lock_wait_timeout | 50 || innodb_rollback_on_timeout | OFF || interactive_timeout | 30 || lock_wait_timeout | 31536000 || net_read_timeout | 30 || net_write_timeout | 60 || rpl_stop_slave_timeout | 31536000 || slave_net_timeout | 60 || wait_timeout | 30 |+-----------------------------+----------+13 rows in set wait_timeout:服务器关闭非交互连接之前等待活动的秒数，就是你在你的项目中进行程序调用interactive_timeout: 服务器关闭交互式连接前等待活动的秒数,就是你在你的本机上打开mysql的客户端,cmd的那种 使用pymysql进行查询我在数据库里随便创建了一个表，插入两条数据12345678mysql&gt; select * from person;+----+------+-----+| id | name | age |+----+------+-----+| 1 | yang | 18 || 2 | fan | 16 |+----+------+-----+2 rows in set 我使用pymysql这个库对其进行查询操作，很简单1234567891011121314151617181920212223#coding:utf-8import pymysqldef mytest(): connection = pymysql.connect( host='localhost', port=3306, user='root', password='123456', db='mytest', charset='utf8') cursor = connection.cursor() cursor.execute(\"select * from person\") data = cursor.fetchall() cursor.close() for i in data: print(i) cursor.close() connection.close()if __name__ == '__main__': mytest() 可以正确的得到结果12(1, 'yang', 18)(2, 'fan', 16) 连接超时以后的查询上面可以正常得到结果是由于当创建好一个链接以后，就立刻进行了查询，此时还没有超过它的超时时间，如果我sleep一段时间，看看什么效果。 1234567891011121314151617181920212223242526272829303132#coding:utf-8import pymysqlimport timedef mytest(): connection = pymysql.connect( host='localhost', port=3306, user='root', password='123456', db='mytest', charset='utf8') cursor = connection.cursor() cursor.execute(\"select * from person\") data = cursor.fetchall() for i in data: print(i) cursor.close() time.sleep(31) cursor = connection.cursor() cursor.execute(\"select * from person\") data2 = cursor.fetchall() for i in data2: print(i) cursor.close() connection.close()if __name__ == '__main__': mytest() 这里进行了两次查询，因为我把mysql的wait_timeout设置了30秒，所以我在第一次查询之后停了31秒，目的让mysql服务主动的和我刚才创建的连接断开，得到的结果是1234567891011121314(1, 'yang', 18)(2, 'fan', 16)Traceback (most recent call last): File \"F:/python/python3Test/mysqltest.py\", line 29, in &lt;module&gt; mytest() File \"F:/python/python3Test/mysqltest.py\", line 22, in mytest cursor.execute(\"select * from person\") ... ... File \"C:\\Python35\\lib\\site-packages\\pymysql\\connections.py\", line 702, in _read_bytes CR.CR_SERVER_LOST, \"Lost connection to MySQL server during query\")pymysql.err.OperationalError: (2013, 'Lost connection to MySQL server during query')Process finished with exit code 1 可以看到在停了31秒钟以后，再次使用该连接进行查询将抛出2013, &#39;Lost connection to MySQL server during query&#39;错误。 解决办法解决的方法有两种，既然这里的超时是由于在规定时间内没有任何操作导致mysql主动的将链接关闭，pymysql的connection对象有一个ping()方法，可以检查连接是否有效，在每次执行查询操作之前先执行一下ping()方法,该方法默认的有个reconnect参数，默认是True，如果失去连接了会重连。 12345678910111213141516171819202122232425262728293031323334#coding:utf-8import pymysqlimport timedef mytest(): connection = pymysql.connect( host='localhost', port=3306, user='root', password='123456', db='mytest', charset='utf8') connection.ping() cursor = connection.cursor() cursor.execute(\"select * from person\") data = cursor.fetchall() for i in data: print(i) cursor.close() time.sleep(31) connection.ping() cursor = connection.cursor() cursor.execute(\"select * from person\") data2 = cursor.fetchall() for i in data2: print(i) cursor.close() connection.close()if __name__ == '__main__': mytest() 我曾尝试使用另外一个线程不停来执行ping()操作，但是当我这样做以后连接就会丢失，之后的操作就不能进行了。这个问题我再研究研究。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#coding:utf-8import pymysqlimport timeimport threadingimport tracebackdef ping(conn): while True: try: conn.ping() except: print(traceback.format_exc()) finally: time.sleep(1)def mytest(): connection = pymysql.connect( host='localhost', port=3306, user='root', password='123456', db='mytest', charset='utf8') cursor = connection.cursor() # 放在此处不行，必须等待cursor的一个execute之后再运行才可以 # th = threading.Thread(target=ping, args=(connection,)) # th.setDaemon(True) # th.start() cursor.execute(\"select * from person\") data = cursor.fetchall() for i in data: print(i) cursor.close() # 线程放在此处启动可以 th = threading.Thread(target=ping, args=(connection,)) th.setDaemon(True) th.start() time.sleep(31) cursor = connection.cursor() cursor.execute(\"select * from person\") data2 = cursor.fetchall() for i in data2: print(i) cursor.close() connection.close()if __name__ == '__main__': mytest() 还有一种方法是使用连接池，连接池中保持着指定数量的可用连接，每次重新获取一个有效的连接进行查询操作,pymysql本身不具有连接池功能，需要借住DBUtils12345678910111213141516171819202122232425262728293031323334353637383940#coding:utf-8import pymysqlimport timefrom DBUtils.PooledDB import PooledDB, SharedDBConnectiondef mytest(): pool = PooledDB( creator=pymysql, # 初始化时,连接池至少创建的空闲连接,0表示不创建 maxconnections=3, # 连接池中空闲的最多连接数,0和None表示没有限制 mincached=2, # 连接池中最多共享的连接数量,0和None表示全部共享(其实没什么卵用) maxcached=5, maxshared=3, host='localhost', port=3306, user='root', password='123456', db='mytest', charset='utf8' ) connection = pool.connection() cursor = connection.cursor() cursor.execute(\"select * from person\") data = cursor.fetchall() for i in data: print(i) time.sleep(40) cursor.execute(\"select * from person\") data2 = cursor.fetchall() for i in data2: print(i) cursor.close() connection.close()if __name__ == '__main__': mytest() 这种方式虽然可以正确的获取结果，但是实际的项目中并不会这么使用，而是在执行完查询语句以后要将connection关闭，注意这里的关闭并不是真正的关闭，而只是将连接返回给连接池让其它人使用.123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8import pymysqlimport timefrom DBUtils.PooledDB import PooledDB, SharedDBConnectiondef mytest(): pool = PooledDB( creator=pymysql, maxconnections=3, # 初始化时,连接池至少创建的空闲连接,0表示不创建 mincached=2, # 连接池中空闲的最多连接数,0和None表示没有限制 maxcached=5, # 连接池中最多共享的连接数量,0和None表示全部共享(其实没什么卵用) maxshared=3, host='localhost', port=3306, user='root', password='123456', db='mytest', charset='utf8' ) connection = pool.connection() cursor = connection.cursor() cursor.execute(\"select * from person\") data = cursor.fetchall() for i in data: print(i) cursor.close() # 关闭连接，其实并没有真正关闭，只是将连接返回给连接池 connection.close() time.sleep(40) connection = pool.connection() cursor = connection.cursor() cursor.execute(\"select * from person\") data2 = cursor.fetchall() for i in data2: print(i) cursor.close() connection.close()if __name__ == '__main__': mytest()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"使用Filter过滤python中的日志输出","slug":"use_filter_in_python_logging","date":"2019-07-16T15:53:38.000Z","updated":"2019-07-16T14:23:56.073Z","comments":true,"path":"article/use_filter_in_python_logging.html","link":"","permalink":"https://www.yangyanxing.com/article/use_filter_in_python_logging.html","excerpt":"事情是这样的，我写了一个tornado的服务，过程当中我用logging记录一些内容，由于一开始并没有仔细观察tornado自已的日志管理，所以我就一般用debug来记录普通日志，error记录有问题的日志，但是当服务跑起来以后才发现，tornado的访问日志的级别是info，也就是20，debug是10的，所以如果我定义了日志的级别是debug，那么默认情况下肯定也会输出到日志文件中的。但是我现在并不关心访问日志，而且由于我这个服务可能每时每刻都会有访问，这样在我对日志信息进行搜索的时候就会有很大的影响。该怎么办呢？","text":"事情是这样的，我写了一个tornado的服务，过程当中我用logging记录一些内容，由于一开始并没有仔细观察tornado自已的日志管理，所以我就一般用debug来记录普通日志，error记录有问题的日志，但是当服务跑起来以后才发现，tornado的访问日志的级别是info，也就是20，debug是10的，所以如果我定义了日志的级别是debug，那么默认情况下肯定也会输出到日志文件中的。但是我现在并不关心访问日志，而且由于我这个服务可能每时每刻都会有访问，这样在我对日志信息进行搜索的时候就会有很大的影响。该怎么办呢？ 有以下几种办法 修改初始化日志时的级别一种是修改我初始化时定义的日志级别，定成比info还高的，这样就不会再记录info的日志了但是这种方法需要我将之前记录日志的debug方法也要修改为比info更高的级别，也就是要大于20。修改的地方有点多，且我已经习惯了用debug来记录，改起来成本有点大。 修改tornado 本身可以到site-packages中修改tornado下的web.py 1234567891011121314151617181920def log_request(self, handler): \"\"\"Writes a completed HTTP request to the logs. By default writes to the python root logger. To change this behavior either subclass Application and override this method, or pass a function in the application settings dictionary as ``log_function``. \"\"\" if \"log_function\" in self.settings: self.settings[\"log_function\"](handler) return if handler.get_status() &lt; 400: log_method = access_log.info elif handler.get_status() &lt; 500: log_method = access_log.warning else: log_method = access_log.error request_time = 1000.0 * handler.request.request_time() log_method(\"%d %s %.2fms\", handler.get_status(), handler._request_summary(), request_time) 其中log_method = access_log.info 可以修改它，access_log在log.py中定义， access_log = logging.getLogger(“tornado.access”) 这里可以定义access_log的级别，然后再修改log_request的实现，想想都复杂，而且直接修改site-packes里的库文件是一个比较笨的方法，日后迁移会发生很多莫名其妙的问题。 使用logging.Filter设置过滤规则其实logging早就有了相应的解决方法，logging库中有一个Filterer类，logging库中的Handler和Logger类都是继承自Filter类的Filter类中有三个方法，addFilter(filter),removeFilter(filter)和filter(record)方法，这里主要使用addFilter和filter方法。 addFilter方法需要一个filter对象，这里我定义一个新的类，并且重写filter方法,将日志名为tornado.access且日志级别是20的过滤掉。12345class NoParsingFilter(logging.Filter): def filter(self, record): if record.name == 'tornado.access' and record.levelno == 20: return False return True 这样我在初始化 logging对象以后，将这个过滤器添加进去12logobj = logging.getLogger('server')logobj.addFilter(NoParsingFilter()) 这样添加一个过滤以后日志就会随心所欲的按照自已的方式来记录了，record也是logging的一个类LogRecord,常用的属性有name, level, pathname, lineno,msg, args, exc_infoname 就是初始化logger对象时传入的名字level 是级别pathname 是哪个文件输出的这行日志lineno 是行号msg 是日志本身","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的双星参数展开问题","slug":"kwargs_in_python","date":"2019-07-11T15:53:38.000Z","updated":"2019-07-11T16:58:15.612Z","comments":true,"path":"article/kwargs_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/kwargs_in_python.html","excerpt":"在python的函数中允许有不定参数，我们对于这种参数已经习以为常了，并且这种写法很方便的，但是对于它背后的运行机制却不是很熟悉，正好最近在写项目过程中有遇到过这种双星不定参数的问题，这里也记录一下","text":"在python的函数中允许有不定参数，我们对于这种参数已经习以为常了，并且这种写法很方便的，但是对于它背后的运行机制却不是很熟悉，正好最近在写项目过程中有遇到过这种双星不定参数的问题，这里也记录一下 基本使用123456789101112131415# coding:utf-8def test(name, age, *args, **kwargs): print(\"args:\",args) print(\"kwargs:\",kwargs) print(\"name:\", name) print(\"age\", age) for i in args: print(\"args:\", i) for k, v in kwargs.items(): print(\"kwargs:\", k, v)if __name__ == '__main__': test('yang', 18, 'is', 'a', 'good', 'man', sex=\"male\") 这个脚本的测试结果为：123456789args: (&apos;is&apos;, &apos;a&apos;, &apos;good&apos;, &apos;man&apos;)kwargs: &#123;&apos;sex&apos;: &apos;male&apos;&#125;name: yangage 18args: isargs: aargs: goodargs: mankwargs: sex male 我们看到，调用函数test的参数为&#39;yang&#39;, 18, &#39;is&#39;, &#39;a&#39;, &#39;good&#39;, &#39;man&#39;, sex=&quot;male&quot;,python依次将yang和18赋给了name和age，将&#39;is&#39;, &#39;a&#39;, &#39;good&#39;, &#39;man&#39;赋给了args元组，将sex=&quot;male&quot;转换成了一个字典给了kwargs. 双星操作到底做了什么？我们知道kwargs是一个字典，但是是否考虑过**kwargs是个什么东西吗？打印一下看看。12345&gt;&gt;&gt; d = &#123;\"name\":\"yangyanxing\"&#125;&gt;&gt;&gt; print(**d)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'name' is an invalid keyword argument for this function 试图打印**dict的时候却报错了，它的意思是name并不是print函数的参数，那么标准库中的print函数都有哪些参数呢？我们来看一下print在标准库中的定义print(self, *args, sep=&#39; &#39;, end=&#39;\\n&#39;, file=None),它确实没有一个name的形参，如果使用print(**d)是不是就和print(name=”yangyanxing”)的效果是一样的呢？123456789&gt;&gt;&gt; d = &#123;\"name\":\"yangyanxing\"&#125;&gt;&gt;&gt; print(**d)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'name' is an invalid keyword argument for this function&gt;&gt;&gt; print(name=\"yangyanxing\")Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'name' is an invalid keyword argument for this function 它们报了相同的错误，这里们先假定使用**dict其实就是将一个字典里的各项依次展开，比如d={‘name’:”yangyanxing”},使用**d则返回name=”yangyanxing”的形式。 我们写一个函数检测一下12345678910# coding:utf-8def test(name, age): print(\"name:\", name) print(\"age\", age)if __name__ == '__main__': d = &#123;\"name\":\"杨彦星\",'age':18&#125; test(**d) 这里test函数需要两个参数，name和age，但是我们在传参数的时候并没有直接传这两个参数，而是传一个**字典，**号会把字典展开成key=value的形式并且传递到test函数中。于是得到了以下的输出12name: 杨彦星age 18 如果所传入的字典中包含了不只包含了函数所需要的参数，还有更多的参数呢？12345678910111213# coding:utf-8def test(name, age,**kwargs): print(\"name:\", name) print(\"age\", age) print(\"kwargs:\", kwargs)if __name__ == '__main__': d = &#123;\"name\":\"杨彦星\",'age':18, 'sex':\"male\",'school':\"bjut\"&#125; test(**d) 它得到的结果是123name: 杨彦星age 18kwargs: &#123;&apos;school&apos;: &apos;bjut&apos;, &apos;sex&apos;: &apos;male&apos;&#125; 可以看到，它将字典里多余的键值对放到了kwargs字典中了。 同理，一个*也是自动展开列表和元组123456789101112131415# coding:utf-8def test(name,age,*args,**kwargs): print(\"args:\", args) print(\"kwargs:\",kwargs) print(\"name:\",name) print('age:',age)if __name__ == '__main__': d = &#123;\"name1\":\"杨彦星\",'age1':18&#125; l = ['a','b','c'] t = ('d','e','f') test(*l,*t,**d) 这里我们将列表l和元组t展开传到test函数中，相当于test(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,name1=&quot;杨彦星&quot;,age1=18),于是得到以下输出1234args: (&apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;)kwargs: &#123;&apos;age1&apos;: 18, &apos;name1&apos;: &apos;杨彦星&apos;&#125;name: aage: b 这里有几个问题需要注意下，由于**kwargs 只能定义在函数参数的最后，它后面不能再有形参了，但是*参数可以不限制参数的位置，所以上面的代码在定义d的时候不能再有name和age的定义了，因为在传参的时候，已经将’a’赋给了name,’b’赋给了age，所以如果之后再有name的定义则会报参数重复定义的错误。但是却可以如下的定义123456789101112131415# coding:utf-8def test(*args,name,age,**kwargs): print(\"args:\", args) print(\"kwargs:\",kwargs) print(\"name:\",name) print('age:',age)if __name__ == '__main__': d = &#123;\"name\":\"杨彦星\",'age':18,'sex':'male'&#125; l = ['a','b','c'] t = ('d','e','f') test(*l,*t,**d) 因为把*args放到了第一个参数，所以在调用函数时为test(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,name=&quot;杨彦星&quot;,age=18,sex=&#39;male&#39;),此时如果d的定义的时候没有name和age也会报错。 我觉得这种写法并不是很优雅，但是看到过有些库里有过类似的写法，所以之后看到不用太困惑，只需要理解**和*只是把后面的字典和列表或者元组进行展示即可。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"在mongodb中按天进行聚合查询","slug":"aggregate-perday-mongodb","date":"2019-07-09T15:53:38.000Z","updated":"2019-07-09T17:47:07.340Z","comments":true,"path":"article/aggregate-perday-mongodb.html","link":"","permalink":"https://www.yangyanxing.com/article/aggregate-perday-mongodb.html","excerpt":"最近在写项目的时候遇到一个问题，使用mongodb记录了用例的执行结果，但是在时间的记录上使用的是date格式，现在有一个需求，以天为单位，统计一下每天成功的用例和失败的用例，说到统计，肯定是要用到聚合查询，但是如果以date格式的时间为group依据，那么等同于没有分组，因为在记录用例的时间几乎不可能同时，今天查阅了一下相关文档，可以使用mongodb的$dateToString命令来完成这个需求","text":"最近在写项目的时候遇到一个问题，使用mongodb记录了用例的执行结果，但是在时间的记录上使用的是date格式，现在有一个需求，以天为单位，统计一下每天成功的用例和失败的用例，说到统计，肯定是要用到聚合查询，但是如果以date格式的时间为group依据，那么等同于没有分组，因为在记录用例的时间几乎不可能同时，今天查阅了一下相关文档，可以使用mongodb的$dateToString命令来完成这个需求 问题来源假如我们以如下的数据123456789101112131415161718192021222324252627282930/* 1 */&#123; \"_id\" : ObjectId(\"5d24c09651a456efbc231669\"), \"time\" : ISODate(\"2019-07-08T10:12:35.125Z\"), \"result\" : \"Pass\"&#125;/* 2 */&#123; \"_id\" : ObjectId(\"5d24c09e51a456efbc23166a\"), \"time\" : ISODate(\"2019-07-08T10:12:36.125Z\"), \"result\" : \"Pass\"&#125;....../* 10 */&#123; \"_id\" : ObjectId(\"5d24c0d851a456efbc231672\"), \"time\" : ISODate(\"2019-07-06T10:10:52.125Z\"), \"result\" : \"Pass\"&#125;/* 11 */&#123; \"_id\" : ObjectId(\"5d24c0e751a456efbc231673\"), \"time\" : ISODate(\"2019-07-06T10:10:52.125Z\"), \"result\" : \"Fail\"&#125; 我的预期结果是123456&#123;'_id': '2019-07-06', 'Pass': 1&#125;&#123;'_id': '2019-07-06', 'Fail': 2&#125;&#123;'_id': '2019-07-07', 'Pass': 2&#125;&#123;'_id': '2019-07-07', 'Fail': 1&#125;&#123;'_id': '2019-07-08', 'Pass': 2&#125;&#123;'_id': '2019-07-08', 'Fail': 3&#125; 如果按照以前的聚合方式，通过$time来分组，由于每个时间都不相同，所以这样的聚合就相当于没有聚合123456789101112#coding:utf-8from pymongo import MongoClientclient = MongoClient(host=['%s:%s'%(\"127.0.0.1\",27017)])G_mongo = client['test']pipeline = [ &#123;'$group': &#123;'_id': '$time', 'count': &#123;'$sum': 1&#125;&#125;&#125;, ]for i in G_mongo['test'].aggregate(pipeline): print(i) 得到的结果12345678910&#123;'_id': datetime.datetime(2019, 7, 6, 10, 10, 32, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 7, 10, 10, 32, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 8, 10, 11, 22, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 6, 10, 10, 52, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 8, 10, 11, 32, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 8, 10, 12, 32, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 7, 10, 11, 22, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 8, 10, 12, 36, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 8, 10, 12, 35, 125000), 'count': 1&#125;&#123;'_id': datetime.datetime(2019, 7, 7, 10, 10, 22, 125000), 'count': 1&#125; 可以看到，由于$time上的时间，谁和谁都不一样，所以如果以$time为分组对象的话每个统计都是1。 问题的解决在分组的时候有一个$dateToString指令，可以将日期格式的值转化为字符串，比如这里因为需求是要以天为单位，所以我将其转为%Y-%m-%d的字符串格式，具体的$grouop如下1&#123;'$group': &#123;'_id': &#123;\"$dateToString\":&#123;'format':'%Y-%m-%d','date':'$time'&#125;&#125;, 'count': &#123;'$sum': 1&#125;&#125;&#125; $dateToString的说明文档可以访问https://docs.mongodb.com/manual/reference/operator/aggregation/dateToString/ 查看，简单介绍一个123456&#123; $dateToString: &#123; date: &lt;dateExpression&gt;, format: &lt;formatString&gt;, timezone: &lt;tzExpression&gt;, onNull: &lt;expression&gt;&#125; &#125; 它需要四个参数，只有date参数是必须的，指定数据来源，format是转化的格式，timezone为时区，onNull是如果日期值不存在时返回的值。 123456789101112131415#coding:utf-8from pymongo import MongoClientclient = MongoClient(host=['%s:%s'%(\"127.0.0.1\",27017)])G_mongo = client['test']pipeline = [ # &#123;'$group': &#123;'_id': '$time', 'count': &#123;'$sum': 1&#125;&#125;&#125;, &#123;'$group': &#123;'_id': &#123;\"$dateToString\":&#123;'format':'%Y-%m-%d','date':'$time'&#125;&#125;, 'count': &#123;'$sum': 1&#125;&#125;&#125; ]for i in G_mongo['test'].aggregate(pipeline): print(i) 上面代码执行的结果如下123&#123;'_id': '2019-07-06', 'count': 2&#125;&#123;'_id': '2019-07-07', 'count': 3&#125;&#123;'_id': '2019-07-08', 'count': 5&#125; 这个看起来还不错，但是离我的目标还差一点，因为它还没有按照用例执行结果进行分组，再以天进行倒序排列12345678910111213141516#coding:utf-8from pymongo import MongoClientclient = MongoClient(host=['%s:%s'%(\"127.0.0.1\",27017)])G_mongo = client['test']pipeline = [ # &#123;'$group': &#123;'_id': '$time', 'count': &#123;'$sum': 1&#125;&#125;&#125;, &#123;'$group': &#123;'_id': &#123;'date':&#123;\"$dateToString\":&#123;'format':'%Y-%m-%d','date':'$time'&#125;&#125;,'result':'$result'&#125;, 'count': &#123;'$sum': 1&#125;&#125;&#125;, &#123;'$sort':&#123;\"_id.date\":-1&#125;&#125; ]for i in G_mongo['test'].aggregate(pipeline): print(i) 得到的结果如下123456&#123;'_id': &#123;'date': '2019-07-08', 'result': 'Fail'&#125;, 'count': 3&#125;&#123;'_id': &#123;'date': '2019-07-08', 'result': 'Pass'&#125;, 'count': 2&#125;&#123;'_id': &#123;'date': '2019-07-07', 'result': 'Pass'&#125;, 'count': 2&#125;&#123;'_id': &#123;'date': '2019-07-07', 'result': 'Fail'&#125;, 'count': 1&#125;&#123;'_id': &#123;'date': '2019-07-06', 'result': 'Fail'&#125;, 'count': 1&#125;&#123;'_id': &#123;'date': '2019-07-06', 'result': 'Pass'&#125;, 'count': 2&#125; 查看文档，除了使用$dateToString指令还可以使用$dayOfMonth指令1234pipeline = [ &#123;'$group': &#123;'_id': &#123;'date':&#123;\"$dayOfMonth\":&#123;'date':'$time'&#125;&#125;,'result':'$result'&#125;, 'count': &#123;'$sum': 1&#125;&#125;&#125;, &#123;'$sort':&#123;\"_id.date\":-1&#125;&#125;, ] 但是这个指令只能适用于单一月份，如果两个月就会有交集，如7月6号和6月6号的会聚合到一起上面得到的结果是123456&#123;'_id': &#123;'date': 8, 'result': 'Fail'&#125;, 'count': 3&#125;&#123;'_id': &#123;'date': 8, 'result': 'Pass'&#125;, 'count': 2&#125;&#123;'_id': &#123;'date': 7, 'result': 'Pass'&#125;, 'count': 2&#125;&#123;'_id': &#123;'date': 7, 'result': 'Fail'&#125;, 'count': 1&#125;&#123;'_id': &#123;'date': 6, 'result': 'Pass'&#125;, 'count': 2&#125;&#123;'_id': &#123;'date': 6, 'result': 'Fail'&#125;, 'count': 1&#125; 所以需要根据需求灵活的使用各种指令。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"在python异步协程中处理流程分析(二)","slug":"sync_in_asyncio2","date":"2019-06-13T16:00:00.000Z","updated":"2019-06-14T11:31:49.000Z","comments":true,"path":"article/sync_in_asyncio2.html","link":"","permalink":"https://www.yangyanxing.com/article/sync_in_asyncio2.html","excerpt":"上一篇文章在python异步协程中处理流程分析(一)介绍了在python3中使用asyncio创建单个协程和多个协程，这篇文章介绍在异步的应用里如何调用同步的函数。","text":"上一篇文章在python异步协程中处理流程分析(一)介绍了在python3中使用asyncio创建单个协程和多个协程，这篇文章介绍在异步的应用里如何调用同步的函数。 依然是之前准备的三个函数，一个阻塞的，两个异步的。123456789101112131415161718192021# 定义阻塞的函数def ping(url): print(\"阻塞函数开始运行\") time.sleep(2) os.system(\"ping %s\"%url) print(\"阻塞函数运行结束\") # 定义两个异步函数async def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\" async def asyncfunc2(): print(\"Suspending func2\") await asyncio.sleep(1) print(\"func func2 \", threading.current_thread()) print('Resuming func2') return \"func2\" 使用传统的多线程的方式跑同步代码1234567891011121314151617181920212223242526272829303132333435363738#coding:gbkimport asyncioimport time,sysimport threadingimport concurrentimport functoolsimport subprocessimport os# 定义阻塞的函数def ping(url): print(\"阻塞函数开始运行,当前的线程ID为:\",threading.current_thread()) time.sleep(2) os.system(\"ping %s\"%url) print(\"阻塞函数运行结束\") async def main(): task1 = loop.create_task(asyncfunc1()) task1.add_done_callback(callbackfunc) task2 = loop.create_task(asyncfunc2()) task2.add_done_callback(callbackfunc) result = await asyncio.gather(task1,task2) print(result) async def mian2(): result = await asyncio.gather(asyncfunc1(),asyncfunc2()) print(result) if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) # 创建三个子线程 t1 = threading.Thread(target=ping,args=(\"www.baidu.com\",)) t2 = threading.Thread(target=ping,args=(\"www.yangyanxing.com\",)) t3 = threading.Thread(target=ping,args=(\"www.qq.com\",)) t1.start() t2.start() t3.start() 输出结果123456789101112131415In main thread &lt;_MainThread(MainThread, started 9208)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-1, started 8720)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-2, started 9368)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-3, started 8320)&gt;正在 Ping https.qq.com [123.151.137.18] 具有 32 字节的数据:来自 123.151.137.18 的回复: 字节=32 时间=4ms TTL=53正在 Ping www.a.shifen.com [220.181.38.150] 具有 32 字节的数据:来自 220.181.38.150 的回复: 字节=32 时间=1ms TTL=54正在 Ping yangyanxing.coding.me [119.28.76.36] 具有 32 字节的数据:........阻塞函数运行结束 可以看到，主线程和子线程跑在了不同的线程中。 在事件循环中动态的添加同步函数解决方案是，先启一个子线程，这个线程用来跑事件循环loop，然后动态的将同步函数添加到事件循环中1234567891011121314151617181920212223242526272829303132#coding:gbkimport asyncioimport time,sysimport threadingimport concurrentimport functoolsimport subprocessimport os# 定义阻塞的函数print(\"阻塞函数开始运行,当前的线程ID为:\",threading.current_thread()) time.sleep(2) print(\"模拟ping 输出 \",url) print(\"阻塞函数运行结束,当前的线程ID为:\",threading.current_thread()) #定义一个跑事件循环的线程函数 def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() # 在子线程中运行事件循环,让它run_forever t = threading.Thread(target= start_thread_loop, args=(loop,)) t.start() # 在主线程中动态添加同步函数 loop.call_soon_threadsafe(ping,\"www.baidu.com\") loop.call_soon_threadsafe(ping,\"www.qq.com\") loop.call_soon_threadsafe(ping,\"www.yangyanxing.com\") print('主线程不会阻塞') 由于使用ping 命令得到很多输出，所以我对函数稍稍做了修改,只是模拟打印了一行文字，但是函数中的time.sleep(2) 这个是一个阻塞式的函数得到的输出为1234567891011In main thread &lt;_MainThread(MainThread, started 7924)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-1, started 10716)&gt;主线程不会阻塞模拟ping 输出 www.baidu.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-1, started 10716)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-1, started 10716)&gt;模拟ping 输出 www.qq.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-1, started 10716)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-1, started 10716)&gt;模拟ping 输出 www.yangyanxing.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-1, started 10716)&gt; 从输出结果可以看出，loop.call_soon_threadsafe()和主线程是跑在同一个线程中的，虽然loop.call_soon_threadsafe()没有阻塞主线程的运行，但是由于需要跑的函数ping是阻塞式函数，所以调用了三次，这三次结果是顺序执行的，并没有实现并发。如果想要实现并发，需要通过run_in_executor 把同步函数在一个执行器里去执行。该方法需要传入三个参数，run_in_executor(self, executor, func, *args) 第一个是执行器，默认可以传入None，如果传入的是None，将使用默认的执行器，一般执行器可以使用线程或者进程执行器。 12345678910111213141516171819202122232425262728293031323334#coding:gbkimport asyncioimport time,sysimport threadingimport concurrentimport functoolsimport subprocessimport os# 定义阻塞的函数def ping(url): print(\"阻塞函数开始运行,当前的线程ID为:\",threading.current_thread()) time.sleep(2) print(\"模拟ping 输出 \",url) print(\"阻塞函数运行结束,当前的线程ID为:\",threading.current_thread()) #定义一个跑事件循环的线程函数 def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() # 在子线程中运行事件循环,让它run_forever t = threading.Thread(target= start_thread_loop, args=(loop,)) t.start() # 在主线程中动态添加同步函数 loop.run_in_executor(None,ping,\"www.baidu.com\") loop.run_in_executor(None,ping,\"www.qq.com\") loop.run_in_executor(None,ping,\"www.yangyanxing.com\") print('主线程不会阻塞') 得到的输出结果1234567891011In main thread &lt;_MainThread(MainThread, started 8588)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-2, started daemon 9068)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-3, started daemon 7200)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-4, started daemon 10924)&gt;主线程不会阻塞模拟ping 输出 www.yangyanxing.com模拟ping 输出 www.baidu.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-4, started daemon 10924)&gt;阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-2, started daemon 9068)&gt;模拟ping 输出 www.qq.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-3, started daemon 7200)&gt; 可以看到同步函数实现了并发，但是它们跑在了不同的线程中，这个就和之前传统的使用多线程是一样的了。 上文说到，run_in_executor的第一个参数是执行器，这里执行器是使用concurrent.futures 下的两个类，一个是thread一个是process，也就是执行器可以分为线程执行器和进程执行器。它们在初始化的时候都有一个max_workers参数，如果不传则根据系统自身决定。 123456789101112131415161718192021222324252627282930313233343536#coding:gbkimport asyncioimport time,sysimport threadingimport concurrentimport functoolsimport subprocessimport os# 定义阻塞的函数def ping(url): print(\"阻塞函数开始运行,当前的线程ID为:\",threading.current_thread(),\"进程ID为:\",os.getpid()) time.sleep(2) print(\"模拟ping 输出 \",url) print(\"阻塞函数运行结束,当前的线程ID为:\",threading.current_thread()) #定义一个跑事件循环的线程函数 def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() # 在子线程中运行事件循环,让它run_forever t = threading.Thread(target= start_thread_loop, args=(loop,)) t.start() threadingexecutor = concurrent.futures.ThreadPoolExecutor(2) processExetutor = concurrent.futures.ProcessPoolExecutor() # 在主线程中动态添加同步函数 loop.run_in_executor(processExetutor,ping,\"www.baidu.com\") loop.run_in_executor(processExetutor,ping,\"www.qq.com\") loop.run_in_executor(processExetutor,ping,\"www.yangyanxing.com\") print('主线程不会阻塞') 这里初始化了两个执行器，一个是线程的，一个是进程的，它们执行的效果一样，只是一个跑在了多线程，一个跑在了多进程使用concurrent.futures.ThreadPoolExecutor()执行器的结果是1234567891011In main thread &lt;_MainThread(MainThread, started 7688)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-2, started daemon 10924)&gt; 进程ID为: 8188阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-3, started daemon 9068)&gt; 进程ID为: 8188主线程不会阻塞模拟ping 输出 www.baidu.com模拟ping 输出 www.qq.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-2, started daemon 10924)&gt;阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-3, started daemon 9068)&gt;阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-2, started daemon 10924)&gt; 进程ID为: 8188模拟ping 输出 www.yangyanxing.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-2, started daemon 10924)&gt; 这们的进程ID都是8188，是跑在了同一个进程下。另外注意一下，我这里在初始化的时候传一个max_workers为2，注意看结果的输出，它是先执行了前两个，当有一个执行完了以后再开始执行第三个，而不是三个同时运行的。 使用concurrent.futures.ProcessPoolExecutor()执行器的执行结果1234567891011In main thread &lt;_MainThread(MainThread, started 10220)&gt;主线程不会阻塞阻塞函数开始运行,当前的线程ID为: &lt;_MainThread(MainThread, started 3928)&gt; 进程ID为: 6652阻塞函数开始运行,当前的线程ID为: &lt;_MainThread(MainThread, started 10992)&gt; 进程ID为: 9436阻塞函数开始运行,当前的线程ID为: &lt;_MainThread(MainThread, started 9740)&gt; 进程ID为: 9000模拟ping 输出 www.qq.com阻塞函数运行结束,当前的线程ID为: &lt;_MainThread(MainThread, started 3928)&gt;模拟ping 输出 www.baidu.com阻塞函数运行结束,当前的线程ID为: &lt;_MainThread(MainThread, started 10992)&gt;模拟ping 输出 www.yangyanxing.com阻塞函数运行结束,当前的线程ID为: &lt;_MainThread(MainThread, started 9740)&gt; 可以看出来它们的进程ID是不同的。 这样看使用run_in_executor和使用多进程和多线程其实意义是一样的。别着急，在讲完异步函数以后就可以看到区别了。 在事件循环中动态的添加异步函数通过asyncio.run_coroutine_threadsafe 方法来动态的将一个协程绑定到事件循环上，并且不会阻塞主线程123456789101112131415161718192021222324252627282930313233343536373839404142#coding:gbkimport asyncioimport time,sysimport threadingimport concurrentimport functoolsimport subprocessimport os# 定义两个异步函数async def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\" async def asyncfunc2(): print(\"Suspending func2\") await asyncio.sleep(1) print(\"func func2 \", threading.current_thread()) print('Resuming func2') return \"func2\" #定义一个跑事件循环的线程函数 def start_thread_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() # 在子线程中运行事件循环,让它run_forever t = threading.Thread(target= start_thread_loop, args=(loop,)) t.start() asyncio.run_coroutine_threadsafe(asyncfunc1(),loop) asyncio.run_coroutine_threadsafe(asyncfunc1(),loop) asyncio.run_coroutine_threadsafe(asyncfunc2(),loop) asyncio.run_coroutine_threadsafe(asyncfunc2(),loop) print('主线程不会阻塞') 通过asyncio.run_coroutine_threadsafe在loop上绑定了四个协程函数，得到的输出结果为1234567891011121314In main thread &lt;_MainThread(MainThread, started 4772)&gt;Suspending func1主线程不会阻塞Suspending func1Suspending func2Suspending func2func func1 &lt;Thread(Thread-1, started 3948)&gt;Resuming func1func func2 &lt;Thread(Thread-1, started 3948)&gt;Resuming func2func func1 &lt;Thread(Thread-1, started 3948)&gt;Resuming func1func func2 &lt;Thread(Thread-1, started 3948)&gt;Resuming func2 主线程不会被阻塞，起的四个协程函数几乎同时返回的结果，但是注意，协程所在的线程和主线程不是同一个线程，因为此时事件循环loop是放到了另外的子线程中跑的，所以此时这四个协程放到事件循环的线程中运行的。注意这里只有run_coroutine_threadsafe方法，没有run_coroutine_thread 方法。 获取协程的返回结果获取结果可以使用asyncio.gather()方法,这里面传的是coros_or_futures就是协程或者task对象，asyncio.run_coroutine_threadsafe()和run_in_executor()返回的都是Future对象,所以可以将它们共同放到gather里,获取返回值. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:gbkimport asyncioimport time,sysimport threadingimport concurrentimport functoolsimport subprocessimport os# 定义阻塞的函数def ping(url): print(\"阻塞函数开始运行,当前的线程ID为:\",threading.current_thread(),\"进程ID为:\",os.getpid()) time.sleep(4) print(\"模拟ping 输出 \",url) print(\"阻塞函数运行结束,当前的线程ID为:\",threading.current_thread()) return url # 定义两个异步函数async def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\" async def asyncfunc2(): print(\"Suspending func2\") await asyncio.sleep(2) print(\"func func2 \", threading.current_thread()) print('Resuming func2') return \"func2\" #定义一个跑事件循环的线程函数 def start_thread_loop(loop): print(\"loop线程 id 为\",threading.current_thread()) asyncio.set_event_loop(loop) loop.run_forever() # 定义一个回调函数def callbackfunc(task): print(\"task 运行结束,它的结果是:\",task.result()) # loop.stop() async def main(): t1 = time.time() # 使用loop.create_task创建task对象,返回asyncio.tasks.Task对象 task1 = loop.create_task(asyncfunc1()) task2 = loop.create_task(asyncfunc2()) # 使用asyncio.run_coroutine_threadsafe 返回的是concurrent.futures._base.Future对象 # 注意这个对象没有__await__方法，所以不能对其使用await 但是可以给它添加回调add_done_callback task3 = asyncio.run_coroutine_threadsafe(asyncfunc1(),loop) task4 = asyncio.run_coroutine_threadsafe(asyncfunc2(),loop) # 使用loop.run_in_executor创建阻塞的任务，返回asyncio.futures.Future对象 task5 = loop.run_in_executor(None,ping,\"www.baidu.com\") task6 = loop.run_in_executor(None,ping,\"www.yangyanxing.com\") # 使用asyncio.ensure_future()创建任务对象 task7 = asyncio.ensure_future(asyncfunc1()) task8 = asyncio.ensure_future(asyncfunc2()) task1.add_done_callback(callbackfunc) task2.add_done_callback(callbackfunc) task3.add_done_callback(callbackfunc) task4.add_done_callback(callbackfunc) task5.add_done_callback(callbackfunc) task6.add_done_callback(callbackfunc) task7.add_done_callback(callbackfunc) task8.add_done_callback(callbackfunc) result = await asyncio.gather(task1,task2,task5,task6,task7,task8) print(result) t2 = time.time() print(\"一共用了%s时间\"%(t2-t1)) async def mian2(): result = await asyncio.gather(asyncfunc1(),asyncfunc2(),) print(result) def shutdown(loop): loop.stop() if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() loop2 = asyncio.new_event_loop() # 在子线程中运行事件循环,让它run_forever t = threading.Thread(target= start_thread_loop, args=(loop,)) t.start() asyncio.run_coroutine_threadsafe(main(),loop) print('主线程不会阻塞') 代码执行结果:12345678910111213141516171819202122232425262728293031323334353637In main thread &lt;_MainThread(MainThread, started 6052)&gt;loop线程 id 为 &lt;Thread(Thread-1, started 2388)&gt;主线程不会阻塞阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-2, started daemon 11644)&gt; 进程ID为: 12280阻塞函数开始运行,当前的线程ID为: &lt;Thread(Thread-3, started daemon 1180)&gt; 进程ID为: 12280Suspending func1Suspending func2Suspending func1Suspending func2Suspending func1Suspending func2func func1 &lt;Thread(Thread-1, started 2388)&gt;Resuming func1func func1 &lt;Thread(Thread-1, started 2388)&gt;Resuming func1func func1 &lt;Thread(Thread-1, started 2388)&gt;Resuming func1task 运行结束,它的结果是: func1task 运行结束,它的结果是: func1task 运行结束,它的结果是: func1func func2 &lt;Thread(Thread-1, started 2388)&gt;Resuming func2func func2 &lt;Thread(Thread-1, started 2388)&gt;Resuming func2func func2 &lt;Thread(Thread-1, started 2388)&gt;Resuming func2task 运行结束,它的结果是: func2task 运行结束,它的结果是: func2task 运行结束,它的结果是: func2模拟ping 输出 www.baidu.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-2, started daemon 11644)&gt;模拟ping 输出 www.yangyanxing.com阻塞函数运行结束,当前的线程ID为: &lt;Thread(Thread-3, started daemon 1180)&gt;task 运行结束,它的结果是: www.baidu.comtask 运行结束,它的结果是: www.yangyanxing.com[&apos;func1&apos;, &apos;func2&apos;, &apos;www.baidu.com&apos;, &apos;www.yangyanxing.com&apos;, &apos;func1&apos;, &apos;func2&apos;]一共用了4.002800464630127时间 总的时间是取决于所有运行的函数中耗时最长的,这里同步函数有个阻塞的sleep(4) ,所以总的时间是4秒多一点点. 关于在异步协程中的处理流程先总结这么多,之后再学习总结一个与异步相关的各种库如aiohttp的使用等等.","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"在python异步协程中处理流程分析(一)","slug":"sync_in_asyncio","date":"2019-06-12T16:00:00.000Z","updated":"2019-06-14T13:58:16.973Z","comments":true,"path":"article/sync_in_asyncio.html","link":"","permalink":"https://www.yangyanxing.com/article/sync_in_asyncio.html","excerpt":"之前的一篇文章python中的asyncio使用详解介绍了在python3 中的asyncio的基础使用，可以在实际的工作中，由于以前写了太多的多线程与多进程，所以对于以前编写风格和一些由于没有异步支持的库函数来说，由于要写在异步里，所以对于编写代码来说还是要处理很多同步的方法，今天在这里整理一下在异步操作中如果处理同步的函数问题。","text":"之前的一篇文章python中的asyncio使用详解介绍了在python3 中的asyncio的基础使用，可以在实际的工作中，由于以前写了太多的多线程与多进程，所以对于以前编写风格和一些由于没有异步支持的库函数来说，由于要写在异步里，所以对于编写代码来说还是要处理很多同步的方法，今天在这里整理一下在异步操作中如果处理同步的函数问题。 为了更好的演示，我准备了三个函数，一个同步的函数，两个异步的函数123456789101112131415161718192021# 定义阻塞的函数def ping(url): print(\"阻塞函数开始运行\") time.sleep(2) os.system(\"ping %s\"%url) print(\"阻塞函数运行结束\") # 定义两个异步函数async def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\" async def asyncfunc2(): print(\"Suspending func2\") await asyncio.sleep(1) print(\"func func2 \", threading.current_thread()) print('Resuming func2') return \"func2\" 协程中控制任务单个协程任务的运行上面的函数，比如说我只想将asyncfunc1() 函数运行并且得结果，可以使用loop.create_task()方法创建一个task对象，task是Futures的子类，当调用loop.run_until_complete() 以后，协程跑完以后，通过task.result()获取协程函数的返回结果。12345678910111213async def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\"if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() task = loop.create_task(asyncfunc1()) loop.run_until_complete(task) print(\"task result is \",task.result()) 输出结果为12345In main thread &lt;_MainThread(MainThread, started 6140)&gt;Suspending func1func func1 &lt;_MainThread(MainThread, started 6140)&gt;Resuming func1task result is func1 主线程和跑的协程函数是在同一个线程中。 也可以给task对象添加一个回调方法1234567891011121314151617181920212223#coding:gbkimport asyncioimport time,sysasync def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\" # 定义一个回调函数def callbackfunc(task): print(\"task 运行结束,它的结果是:\",task.result()) if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() task = loop.create_task(asyncfunc1()) task.add_done_callback(callbackfunc) loop.run_until_complete(task) 输出结果为12345In main thread &lt;_MainThread(MainThread, started 11248)&gt;Suspending func1func func1 &lt;_MainThread(MainThread, started 11248)&gt;Resuming func1task 运行结束,它的结果是: func1 loop.run_until_complete 是一个阻塞方法，只有当它里面的协程运行结束以后这个方法才结束，才会运行之后的代码。 其实也可以不调用loop.run_until_complete方法，创建一个task以后，其实就已经在跑协程函数了，只不过当事件循环如果准备开始运行了，此时的task状态是pending,如果不调用事件循环的话，则不会运行协程函数，由于主线程跑完了，子线程也就被销毁了，如代码写成这样：12345if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() task = loop.create_task(asyncfunc1()) time.sleep(3) 得到的输出是1234In main thread &lt;_MainThread(MainThread, started 6056)&gt;Task was destroyed but it is pending!task: &lt;Task pending coro=&lt;asyncfunc1() running at test.py:18&gt; cb=[callbackfunc() at test.py:39]&gt;sys:1: RuntimeWarning: coroutine &apos;asyncfunc1&apos; was never awaited 所以想要使得协程函数得到执行，需要调用事件循环来执行任务，上面的loop.run_until_complete就是使循环开始跑了，其实也可以使用loop.run_forever(),这个函数就像它的名字一样，会一直跑。只有事件循环跑起来了，那么使用该循环注册的协程才会得到执行，但是如果使用loop.run_forever()则会阻塞在这里，事件循环还有一个stop方法，可以结束循环，我们可以在task对象上添加一个回调方法，当协程执行结束以后，调用事件循环的stop方法来结束整个循环 1234567891011121314151617181920212223#coding:gbkimport asyncioimport time,sysasync def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\" # 定义一个回调函数def callbackfunc(task): print(\"task 运行结束,它的结果是:\",task.result()) loop.stop() if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() task = loop.create_task(asyncfunc1()) task.add_done_callback(callbackfunc) loop.run_forever() 除了使用loop.run_until_complete方法，还可以使用asyncio.ensure_future() 方法来运行协程，将上面代码中的task = loop.create_task(asyncfunc1()) 改为 task = asyncio.ensure_future(asyncfunc1())会得到相同的结果,它的参数是协程对象或者futures，也可以传task对象，因为task是futures的子类,当传入的是一个协程对象时，返回一个task对象，传入一个futures的时候，直接返回futures对象,也就是说，在调用asyncio.ensure_future()以后，都会返回一个task对象,都可以为它添加一个回调方法，并且可以调用task.result()方法得到结果(注意如果task没有执行结束就调用result方法，则会抛异常)。 多个协程任务的并行最上面我准备了两个异步的函数asyncfunc1和asyncfunc2，如果我想要这两个函数同时执行，并且得到它们的返回值该怎么操作呢？有了上面单协程的经验，我们也可以使用事件循环创建两个task,然后在run_forever()来执行，可以对task添加回调，将结果输出。1234567891011121314151617181920212223242526272829303132#coding:gbkimport asyncio# 定义两个异步函数async def asyncfunc1(): print(\"Suspending func1\") await asyncio.sleep(1) print(\"func func1 \", threading.current_thread()) print('Resuming func1') return \"func1\" async def asyncfunc2(): print(\"Suspending func2\") await asyncio.sleep(1) print(\"func func2 \", threading.current_thread()) print('Resuming func2') return \"func2\" # 定义一个回调函数def callbackfunc(task): print(\"task 运行结束,它的结果是:\",task.result()) if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() task1 = loop.create_task(asyncfunc1()) task1.add_done_callback(callbackfunc) task2 = loop.create_task(asyncfunc2()) task2.add_done_callback(callbackfunc) loop.run_forever() 输出结果是123456789In main thread &lt;_MainThread(MainThread, started 8040)&gt;Suspending func1Suspending func2func func1 &lt;_MainThread(MainThread, started 8040)&gt;Resuming func1func func2 &lt;_MainThread(MainThread, started 8040)&gt;Resuming func2task 运行结束,它的结果是: func1task 运行结束,它的结果是: func2 此时由于loop调用了run_forever方法，且没有方法调用stop方法，所以程序会一直卡着。 这样是可以将多个协程跑起来，但这样的处理一是繁琐，二是不方便结果的回收。 asyncio有一个gather方法，可以传入多个任务对象，当调用await asyncio.gather(*) 时，它会将结果全部返回 由于await 只能写在async def 函数中，所以这里还需要新创建一个函数1234567891011async def main(): task1 = loop.create_task(asyncfunc1()) task1.add_done_callback(callbackfunc) task2 = loop.create_task(asyncfunc2()) task2.add_done_callback(callbackfunc) result = await asyncio.gather(task1,task2) print(result) async def mian2(): result = await asyncio.gather(asyncfunc1(),asyncfunc2()) print(result) 两种定义方式都可以，一个是向gather函数传的是协程对象，一个是传的task对象。之后在调用1234if __name__==\"__main__\": print(\"In main thread \",threading.current_thread()) loop = asyncio.get_event_loop() loop.run_until_complete(main()) # or main2() 得到的输出为12345678910In main thread &lt;_MainThread(MainThread, started 7016)&gt;Suspending func1Suspending func2func func1 &lt;_MainThread(MainThread, started 7016)&gt;Resuming func1func func2 &lt;_MainThread(MainThread, started 7016)&gt;Resuming func2task 运行结束,它的结果是: func1task 运行结束,它的结果是: func2[&apos;func1&apos;, &apos;func2&apos;] 这样就达到的协程的并行与结果的回收。这篇文章先简单介绍到这里，之后会继续分析同步代码的执行。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的asyncio使用详解","slug":"asyncio_in_python","date":"2019-06-08T15:53:38.000Z","updated":"2019-06-09T17:55:52.798Z","comments":true,"path":"article/asyncio_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/asyncio_in_python.html","excerpt":"在python的异步实践中，每次看asynicio都会有新的收获，本篇总结一下最近看这个库的使用。","text":"在python的异步实践中，每次看asynicio都会有新的收获，本篇总结一下最近看这个库的使用。 一些核心概念异步函数的定义普通函数的定义是使用 def 关键词，异步的函数，协程函数(Coroutine)本质上是一个函数，特点是在代码块中可以将执行权交给其他协程，使用async def 来定义 123456789# 普通函数定义def add2(x): print(x+2) return x+2# 异步函数的定义async def add3(x): print(\"in async fun add\") return x+3 如何调用协程并且得到它的运行结果?调用普通的函数只需要 result = add2(2),这时函数就可以得到运行，并且将结果4返回给result,如果使用result = add3(2),此时再打印 result 呢？得到的是一个coroutine对象，&lt;coroutine object add3 at 0x000002ED564A5048&gt;，并不是2+3=5这个结果，怎样才能得到结果呢？协程函数想要执行需要放到事件循环里执行。 事件循环 EventloopEventloop 是asyncio应用的核心,把一些异步函数注册到这个事件循环上，事件循环会循环执行这些函数,当执行到某个函数时，如果它正在等待I/O返回，如它正在进行网络请求，或者sleep操作，事件循环会暂停它的执行去执行其他的函数；当某个函数完成I/O后会恢复，下次循环到它的时候继续执行。因此，这些异步函数可以协同(Cooperative)运行：这就是事件循环的目标。 返回到上面的函数,想要得到函数执行结果，需要有一个Eventloop1234567891011121314import asyncioloop = asyncio.get_event_loop()async def add3(x): print(\"in async fun add\") return x+3result = loop.run_until_complete(add3(2))print(result)#运行的结果是#in async fun add#5 或者使用await 关键字来修饰函数的调用，如result = await add3(2),但是await只能用在协程函数中，所以想要用await关键字就还需要定义一个协程函数1234567async def add3(x): print(\"in async fun add\") return x+3async def main(): result = await add3(2) return result 但最终的执行还是需要放到一个事件循环中进行. 稍微复杂一点的例子12345678910111213141516171819202122232425262728293031# coding:utf-8import asyncioimport timeasync def testa(x): print(\"in test a\") await asyncio.sleep(3) print(\"Resuming a\") return xasync def testb(x): print(\"in test b\") await asyncio.sleep(1) print('Resuming b') return xasync def main(): start = time.time() resulta = await testa(1) resultb = await testb(2) print(\"test a result is %d\"%resulta) print(\"test b result is %d\"%resultb) print(\"use %s time\"%(time.time()-start))if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) 这段代码定义了两个协程，并将它们放到另外一个协程main函数中，想要获得它们运行的结果，事件循环的特点是当它遇到某个I/O需要等待(如这里的asyncio.sleep()函数)的时候，可以去执行其它的函数，这样，整个函数执行所需要的时间，应该是所有协程中执行时间最长的那个，对于上面这个代码来说，一个sleep了3秒，一个sleep了1秒，总的用时应该是3秒多一点，但结果是这样吗？ 它的输出是这样的1234567in test aResuming ain test bResuming btest a result is 1test b result is 2use 4.001966714859009 time 它的用时是4秒多一点，而且是先执行了testa函数，然后再执行了testb函数，是串行的依次执行的，并没有像我们想象中的并发执行。那应该怎样才能并发执行呢？1234567891011async def main(): start = time.time() resulta,resultb = await asyncio.gather(testa(1),testb(2)) print(\"test a result is %d\" % resulta) print(\"test b result is %d\" % resultb) print(\"use %s time\" % (time.time() - start))if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) 需要将协程放到asyncio.gather() 中运行，上面的代码得到的输出是1234567in test bin test aResuming bResuming atest a result is 1test b result is 2use 3.001237392425537 time 可以看到，testa和testb是同步在运行，由于testb只sleep了1秒钟，所以testb先输出了Resuming b,最后将每个协程函数的结果返回，注意，这里是gather()函数里的每一个协程函数都执行完了，它才结果，结果是一个列表，列表里的值顺序和放到gather函数里的协程的顺序是一致的。 除了使用asyncio.gather 来执行协程函数以外，还可以使用Task任务对象123456789101112131415161718192021async def main(): start = time.time() taska = asyncio.ensure_future(testa(1)) taskb = asyncio.ensure_future(testb(2)) print(taska) print(taskb) print(taska.done(), taskb.done()) await taskb await taska print(taska.done(), taskb.done()) print(taskb.result()) print(taska.result()) print(\"use %s time\" % (time.time() - start))if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) 使用asyncio.ensure_future(testa(1)) 返回一个task对象，此时task进入pending状态，并没有执行，这时print(taska) 得到&lt;Task pending coro=&lt;testa() running at F:/python/python3Test/asynctest.py:7&gt;&gt; 些时，taska.done()返回False,表示它还没有结束，当调用await taska 时表示开始执行该协程，当执行结束以后，taska.done() 返回True，这时可以调用taska.result() 得到函数的返回值，如果协程还没有结束就调用result()方法则会抛个异常，raise InvalidStateError(&#39;Result is not ready.&#39;). 创建task对象除了使用asyncio.ensure_future()方法还可以使用loop.create_task() 方法1234567891011121314151617181920async def main(): start = time.time() taska = loop.create_task(testa(1)) taskb = loop.create_task(testb(2)) print(taska) print(taskb) print(taska.done(), taskb.done()) await taskb await taska print(taska.done(), taskb.done()) print(taskb.result()) print(taska.result()) print(\"use %s time\" % (time.time() - start))if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) 上面一直在使用asyncio.gather()函数来执行协程函数，还有一个asyncio.wait()函数，它的参数是协程的列表。123456789101112async def main(): start = time.time() done,pending = await asyncio.wait([testa(1),testb(2)]) print(list(done)) print(list(pending)) print(list(done)[0].result()) print(\"use %s time\" % (time.time() - start))if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) asyncio.wait() 返回一个tuple对象，对象里又包含一个已经完成的任务set和未完成任务的set，上面代码得到的结果是12345678in test bin test aResuming bResuming a[&lt;Task finished coro=&lt;testa() done, defined at F:/python/python3Test/asynctest.py:7&gt; result=1&gt;, &lt;Task finished coro=&lt;testb() done, defined at F:/python/python3Test/asynctest.py:14&gt; result=2&gt;][]1use 3.0003058910369873 time 使用wait和gather有哪些区别呢？首先，gather是需要所有任务都执行结束，如果某一个协程函数崩溃了，则会抛异常，都不会有结果。wait可以定义函数返回的时机，可以是FIRST_COMPLETED(第一个结束的), FIRST_EXCEPTION(第一个出现异常的), ALL_COMPLETED(全部执行完，默认的)123456789101112131415161718192021222324252627282930313233# coding:utf-8import asyncioimport timeasync def testa(x): print(\"in test a\") await asyncio.sleep(3) print(1/0) print(\"Resuming a\") return xasync def testb(x): print(\"in test b\") await asyncio.sleep(1) print(1/0) print('Resuming b') return xasync def main(): start = time.time() done,pending = await asyncio.wait([testa(1),testb(2)],return_when=asyncio.tasks.FIRST_EXCEPTION) print(list(done)) print(list(pending)) print(\"use %s time\" % (time.time() - start))if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) 这段代码要求在出现第一个异常的时候就结果，函数整体不会崩溃，只是如果这里想要获取结果的话它是一个异常对象。12345in test bin test a[&lt;Task finished coro=&lt;testb() done, defined at F:/python/python3Test/asynctest.py:16&gt; exception=ZeroDivisionError('division by zero',)&gt;][&lt;Task pending coro=&lt;testa() running at F:/python/python3Test/asynctest.py:10&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;]use 1.0000195503234863 time 这篇文章介绍了一些asyncio的基本使用，之后会对Future和Task类做更深入的学习。 参考文章深入理解asyncio(一)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的面向对象中容易忽略的问题","slug":"oop_in_python","date":"2019-03-29T16:00:00.000Z","updated":"2019-03-30T13:13:05.374Z","comments":true,"path":"article/oop_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/oop_in_python.html","excerpt":"作为一门面向对象的语言，如果在实际的工作中不能很好的使用其面向对象的特性，那始终不能领悟这门语言的精髓，以下这篇文章我会尽量详尽的从基础到深入的介绍面向对象的内容，内容篇幅较长,有些基础的可以选择性的观看。","text":"作为一门面向对象的语言，如果在实际的工作中不能很好的使用其面向对象的特性，那始终不能领悟这门语言的精髓，以下这篇文章我会尽量详尽的从基础到深入的介绍面向对象的内容，内容篇幅较长,有些基础的可以选择性的观看。 类和实例类(Class)和实例(Instance),类是抽象的模板,比如人类，鸟类，而实例则是一个真正的对象。简单写一个类，类的定义是使用class 关键字1234567891011class Persion: def __init__(self): pass def run(self): print \"Person can run\"p = Persion()p.run()# output:Person can run 非常简单的类的定义，定义了一个人类并且定义了一个run方法，之后初始化了一个对象p,并且调用了这个类的run方法。实例类的对象的时候，要在类名后加上(),如果类的__ini__ 方法没有参数，实例对象的时候就不用传参,如果__init__方法中有参数，那么在实例的时候也要有参数。 注意__init__ 方法init前后是两条下划线. 1234567891011class Persion: def __init__(self,name,age,sex='M'): self.name = name self.age = age self.sex = sex def run(self): print \"Person can run\"p = Persion(\"yangyanxing\",31)p.run() 一、 类的访问限制类中的方法和属性，但是有些方法和属性并不希望外部直接访问到，那么这时候就需要在属性前面加上两个下划线1234567891011121314151617#coding:gbkclass Persion: def __init__(self,name,age,sex='M'): self.__name = name self.__age = age self.__sex = sex def run(self): print \"Person can run\" def showInfo(self): print(\"name:%s,age:%s,sex:%s\"%(self.__name,self.__age,self.__sex))p = Persion(\"yangyanxing\",31)print p.__name#output AttributeError: Persion instance has no attribute '__name' 得到的结果是Persion实例没有__name 属性。那如何才能获取到呢，可以写一个方法，在类里进行访问，就像上面的showInfo() 在这个类方法里进行访问。 注意：私有属性是以两个下划线开始但是不是以两个下划线结束的，也就是说__name 是私有属性，但是__name__就是公开属性了，一般以双下划线开始双下划线结束的属性是特殊的变量。 类方法的规则和属性相同，以双下划线开始非双下划线结束的是私有方法，不可以通过实例直接调用。 二、 继承在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。子类从父类继承方法，注意这里并不一定会继承父类的属性，这里的继承说法其实也不准确，这里先挖一个坑，之后再讲self的时候再填上。上面定义了一个Person类，下面定义一个Student类，它继承自Persion123456789101112131415161718192021222324252627282930#coding:gbkclass Persion: def __init__(self,name,age,sex='M'): self.__name = name self.__age = age self.__sex = sex self.name = name def run(self): print \"Person can run\" def showInfo(self): print(\"Person class name:%s,age:%s,sex:%s\"%(self.__name,self.__age,self.__sex))class Student(Persion): def __init__(self,name,age,grade,sex='M'): Persion.__init__(self,name,age,sex) self.grade=grade def showInfo2(self): print(\"Student class:%s\"%self.name)s = Student(\"yang\",32,'大三')s.showInfo()s.showInfo2()#output # Person class name:yang,age:32,sex:M# Student class:yang 可以看到，子类继承了父类的showInfo()方法，并且有自已的showInfo2() 方法。 2.1 显示的调用父类的构造方法子类的__ini__方法需要显示的调用父类的__init__方法，当然也可以不调用，只是父类中定义的属性在子类中就没有了 123456789101112131415161718192021222324#coding:gbkclass Persion: def __init__(self,name,age,sex='M'): self.age = age self.sex = sex self.name = name def showInfo(self): print self.name def showInfo2(self): print 'xxxxx'class Student(Persion): def __init__(self,name,age,grade,sex='M'): # Persion.__init__(self,name,age,sex) self.grade=grades = Student(\"yang\",32,'大三')s.showInfo2()s.showInfo()print s.name 运行结果1234567xxxxxTraceback (most recent call last): File \"ooptest.py\", line 23, in &lt;module&gt; s.showInfo() File \"ooptest.py\", line 9, in showInfo print self.nameAttributeError: Student instance has no attribute 'name' 子类中把父类的初始化方法注释掉以后，当调用showInfo2() 方法时由于是继承了父类中的showInfo2，只是打印了’xxxxx’,这里不会报错，但是当调用showInfo()方法时，父类中需要打印self.name，这时由于没有初始化父类，所以根本就没有给self.name赋值，所以这里就会报错了。 2.2 私有变量与方法的继承问题私有的方法和属性是不能继承的，如上面的Persion类中的__name属性，如果想要在子类中使用的话就会报错.1234def showInfo2(self): print(\"Student class:%s\"%self.__name)#output AttributeError: Student instance has no attribute '_Student__name' 2.3 多继承python 是支持多继承的，也就是一个类可以继承自多个类，但是这样就会造成一个问题，比如有一个A类，它有一个test方法，B继承自A但是重写的test()方法，C也继承自A，也重写的test方法，D继承自B和C，但是它没有自己的test方法，现在调用D对象的test方法，那它该调用谁的test方法呢？这个要区别在python2和python3，它们的运行结果不同12345678910111213141516class A: def test(self): print(\"A test\")class B(A): passclass C(A): def test(self): print(\"C test\")class D(B,C): passd = D()d.test() 上面的代码运行结果12python2 A testpython3 C test 但是如果将A类继承自object类，则python2 和python3的运行结果是一样的1234567891011121314151617181920class A(object): def test(self): print(\"A test\")class B(A): passclass C(A): def test(self): print(\"C test\")class D(B,C): passd = D()d.test()#output#python2 C test#python3 C test 是不是有点乱，不用担心，这个和新式类与经典类有关，之后会详细说明。不过多继承用的比较少，所以大家了解即可。 2.4 多继承中的方法重复问题如果一个类(如C类)继承自多个类(如A,B)，在A和B类中都有test方法，那么C类该如何继承test方法呢？别着急，和上面的问题一样，在之后讲过经典类与新式类以后大家就明白了。 三、 多态由于python是一种弱类型语言，并不能很好的实现像java中的父类引用指向子类对象，但是python中也可以模拟实现类似于java中的多态。 3.1 实例的类型判断某一个对象是否是一个类的实例时可以使用isinstance()函数123456s = Student(\"yang\",32,'大三')p = Persion(\"yangyanxing\",32)print isinstance(s,Student)print isinstance(s,Persion)print isinstance(p,Persion)print isinstance(p,Student) 结果1234TrueTrueTrueFalse 可以看出，s既是Student实例，也是Persion实例，但是p只是Persion实例，并不是Student实例,这个也很好理解，说某个人是一个学生，那么他肯定也是个人，但是如果说某个人是一个人，那么他并不一定是个学生. 3.2 方法的重载子类可以重写父类的方法，这样可以根据子类的行为做出一些调整123456789101112131415161718192021222324252627282930#coding:gbkclass Persion: def __init__(self,name,age,sex='M'): self.__name = name self.__age = age self.__sex = sex self.name = name def run(self): print \"Person can run\" def showInfo(self): print(\"Person class name:%s,age:%s,sex:%s\"%(self.__name,self.__age,self.__sex)) def __showInfo(self): print(\"Person class Private name:%s,age:%s,sex:%s\"%(self.__name,self.__age,self.__sex))class Student(Persion): def __init__(self,name,age,grade,sex='M'): Persion.__init__(self,name,age,sex) self.grade=grade def showInfo(self): print(\"Student class:%s\"%self.name)s = Student(\"yang\",32,'大三')p = Persion(\"yangyanxing\",32)s.showInfo()p.showInfo() 运行结果 12Student class:yangPerson class name:yangyanxing,age:32,sex:M 3.3 实现多态上面介绍过，如果一个对象的类型既是它所属的类，同时也属于该类的父类，那么可以写一个函数，它的参数是某一个父类，那么在传参数的时候，既可以传这个父类对象，也可以传子类对象12345678s = Student(\"yang\",32,'大三')p = Persion(\"yangyanxing\",32)def showDetail(Persion): Persion.showInfo()showDetail(s)showDetail(p) 这么看也没有多大的优势嘛，你的s和p的对象本身就有showInfo() 方法，可以调用也不稀奇呀，但是如果现在我再写一个Teacher类，但是我不实现他的showInfo方法，这时如果再调用showDetail函数会不会报错呢？123456789101112131415class Teacher(Persion): def __init__(self,name,age,tech,sex='F'): Persion.__init__(self,name,age,sex) self.tech = techs = Student(\"yang\",32,'大三')p = Persion(\"yangyanxing\",32)t = Teacher(\"fan\",24,'PE')def showDetail(Persion): Persion.showInfo()showDetail(s)showDetail(p)showDetail(t) 运行结果:123Student class:yangPerson class name:yangyanxing,age:32,sex:MPerson class name:fan,age:24,sex:F 结果并不会报错，当调用showDetail()函数传入的是一个Teacher对象时，由于这个对象并没有自已的showInfo方法，但是他从父类中继承了showInfo方法，所以这里也就会调用父类的showInfo函数。 四、 经典类和新式类上面当说到多继承的时候说到有两个问题在看完经典类与新式类以后就会明白了，这里详细说明一下，别被名字给唬了，没什么特殊的，就是在python2的时候，当一个类没有继承任务类的时候就上上面的Person类，它就是经典类，如果一个类显示的继承自「object」则它是一个新式类，在python3中默认都是新式类，也就是都是继承自object，一般的使用情况下差异不大，只是在多继承的时候在搜索类属性与方法的时候会有些差异，请看以下代码123456789101112131415161718192021class A(): def __init__(self): pass def save(self): print(\"This is from A\")class B(A): def __init__(self): passclass C(A): def __init__(self): pass def save(self): print(\"This is from C\")class D(B,C): def __init__(self): passfun = D()fun.save() 上面的代码在python2和python3上运行的结果是 也就是说在经典类(老式类或者称之为旧类)上，搜索类的属性或者方法是按照深度优先的，即从下往上搜索，在经典类中，当调用fun.save() 时，先从D这个类里查找，发现它没有save方法，之后再从它继承的B类中查找，B类中也没有，那么再从B的父类A中查找，A类中有save方法，则停止搜索，调用A类的save方法。新式类的查找顺序，新式类有一个mro()方法，显示查找顺序调用D.mro() 显示1[&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;] 它的搜索顺序是D,B,C,A，这里由于C类有save方法，则直接调用C类的save方法，停止搜索。 五、 super 类super 是一个类，当子类中想要调用父类的方法时需要使用super类。1234567891011121314151617181920212223242526272829303132# coding:gbkclass Persion(object): def __init__(self, name, age, sex='M'): self.age = age self.sex = sex self.name = name def showInfo(self): print(self.name) def showInfo2(self): print('parent fun')class Student(Persion): def __init__(self, name, age, grade, sex='M'): Persion.__init__(self,name,age,sex) self.grade = grade def showInfo2(self): super(Student,self).showInfo2() super(Student,self).showInfo() print('child fun')s = Student(\"yang\",32,'大三')s.showInfo2()#outputparent funyangchild fun 注意想要使用super类，它一般有两个参数，第一个参数是一个类名，第二个参数是一个实例(也可以是个类)，如果第二个参数是个实例的话(比如这里的self,你可以理解为sefl就是一个实例)需要满足isinstance(obj, type) == True,如果第二个参数也是个类名的话，那么需要满足issubclass(type2, type) == True，也就是第二个类要是第一个类的子类，super 以后做了些什么呢？super 包含了两个非常重要的信息: 一个 MRO(Method Resolution Order) 列表以及 MRO 中的一个类。上面有介绍新式类有一个mro()方法，调用某个类的mro方法会显示方法和属性的查找顺序，如调用D.mro() 显示1[&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;] 当使用super初始化一个类以后，则会在该类以后的类中去查找对应的方法，如某一个类的mro列表是[A, B, C, D, E, object]，当使用super(C,self)初始化super类以后，这个mro则只会从C以后的类中去查找，如调用super(C,self).test() 方法，则只会从D,E,object类中去查找是否有test() 方法，这样也就实现了调用父类的方法。看以下的代码1234567891011121314151617181920212223242526272829303132333435class A(object): def __init__(self): self.n = 2 def test(self): print(\"A test\")class B(A): def test(self): print('B test')class C(B): def test(self): print(\"C test\")class D(C): def test(self): super(D,self).test() super(C,self).test() super(B,self).test() print(\"D test\")print(D.mro())d = D()d.test()#output[&lt;class '__main__.D'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]C testB testA testD test D.mro() 方法显示列表为[D,C,B,A,object] (简写了)，当使用super(D,self).test()时就是在查询D类之后的第一个有test()方法的类，C类中就有test方法，所以这里调用了C类的test方法，之后的类似。注意，这里最上面的类要显示的继承object类，也就是要新式类。 六、self 到底是什么？上面有提到挖了一个坑，这里填一下,self究竟是什么？看以下代码1234567891011121314class A(object): def __init__(self): self.n = 2 def test(self): print(\"A test\")class B(A): def __init__(self,n): self.n = n A.__init__(self)b = B(10)print b.n 它的结果是 2 并不是10，这里self其实就是一个对象实例，虽然在父类中的self，但是这里的self其实是子类的一个对象。 这里啰里啰唆的说了很多关于面向对象的东西，有些东西在编码的时候不一定用的上，但是会有一些莫名的bug当更加理解面向对象后可能会更好的找到原因。 参考文章python新式类和经典类的区别？Python新式类与经典类的区别Python: super 没那么简单","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中使用分步式进程计算","slug":"fractional_in_python","date":"2019-03-20T16:00:00.000Z","updated":"2019-03-21T14:37:10.765Z","comments":true,"path":"article/fractional_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/fractional_in_python.html","excerpt":"在python中使用多进程和多线程都能达到同时运行多个任务，和多进程和多线程的选择上，应该优先选择多进程的方式，因为多进程更加稳定，且对于进程的操作管理也更加方便，但有一点是多进程独有的杀手锏，多进程可以将进程分步到多台机器上跑，假如有很多个任务，一台机器即使开了多进程或者多进程跑起来还是要耗很多时间，那么这时就要想一下可否将任务分配到多台机器上跑，这样可以更快的完成任务。","text":"在python中使用多进程和多线程都能达到同时运行多个任务，和多进程和多线程的选择上，应该优先选择多进程的方式，因为多进程更加稳定，且对于进程的操作管理也更加方便，但有一点是多进程独有的杀手锏，多进程可以将进程分步到多台机器上跑，假如有很多个任务，一台机器即使开了多进程或者多进程跑起来还是要耗很多时间，那么这时就要想一下可否将任务分配到多台机器上跑，这样可以更快的完成任务。 在分步式进程运算中，进程之前的通信还是依赖于Queue,但此时的队列不能直接使用，需要使用multiprocessing.managers.BaseManager 进行包装，通过回调以后才能使用，既然是分步式的调用，那么应该有一个服务端和一个客户端，服务端通过网络协议将队列中的信息给各个客户端进行调用，客户端也可以通过队列将结果返回，然后服务端进行结果的收集展示，流程如下 服务端将任务放到 task_queue 中，然后四个客户端通过网络端口从task_queue中获取到任务，然后进行计算，再将结果放到result_queue中，最后服务端统一处理结果。整体的流程比较清晰，只是需要强调，这里的队列不能是原始的队列，需要使用BaseManager 进行包装。 先看一下服务端的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding:gbkimport time, queuefrom multiprocessing.managers import BaseManagerfrom multiprocessing import freeze_support# 任务个数task_number = 10# 定义收发队列task_queue = queue.Queue(task_number)result_queue = queue.Queue(task_number)def gettask(): return task_queuedef getresult(): return result_queuedef test(): # windows下绑定调用接口不能使用lambda，所以只能先定义函数再绑定 BaseManager.register('get_task', callable=gettask) BaseManager.register('get_result', callable=getresult) # 绑定端口并设置验证码，windows下需要填写ip地址，linux下不填默认为本地 manager = BaseManager(address=('127.0.0.1', 5002), authkey=b'123') # 启动 manager.start() try: # 通过网络获取任务队列和结果队列 task = manager.get_task() result = manager.get_result() # 添加任务 for i in range(task_number): print('Put task %d...' % i) task.put(i) # 每秒检测一次是否所有任务都被执行完 while not result.full(): print(task.qsize()) time.sleep(1) for i in range(result.qsize()): ans = result.get() print('task %d is finish , runtime:%d s' % ans) except: print('Manager error') finally: manager.shutdown()if __name__ == '__main__': # windows下多进程可能会炸，添加这句可以缓解 freeze_support() test() 这里重点说一下 BaseManager.register(&#39;get_task&#39;, callable=gettask) 这行代码，它的意思是注册一个get_task的操作，执行的操作是gettask()函数，上面定义了gettask()函数，返回的是task_queue,这也是之前说的不能直接使用queue.Queue,必须要使用通过BaseManager的register接口封装过的的队列,下面使用task = manager.get_task()来获取到这个队列。 1manager = BaseManager(address=('127.0.0.1', 5002), authkey=b'123') 这行代码初始了一个manager,它绑定了本机的5002端口，并且在客户端连接的时候需要一个密码:123。 接下来看一下客户端代码。123456789101112131415161718192021222324#coding:gbkimport time, sys, queue, randomfrom multiprocessing.managers import BaseManagerBaseManager.register('get_task')BaseManager.register('get_result')conn = BaseManager(address = ('127.0.0.1',5002), authkey = b'123')try: conn.connect()except: print('连接失败') sys.exit()task = conn.get_task()result = conn.get_result()while not task.empty(): print(task.qsize()) n = task.get(timeout = 1) print('run task %d' % n) sleeptime = random.randint(0,3) time.sleep(sleeptime) rt = (n, sleeptime) result.put(rt)if __name__ == '__main__': pass; 这里主要看以下的代码12BaseManager.register('get_task')BaseManager.register('get_result') 这两个是注册函数，和之前的服务端所对应，之前服务端注册了这两个函数，这里才能注册使用，注意这里不能注册服务端没有注册的函数 运行一下，先运行服务端，然后再启两个cmd运行客户端，也可以在局域网中的另外的机器上运行，但是要修改服务端的ip地址 服务端的结果如下1234567891011121314151617181920Put task 0...Put task 1...Put task 2...Put task 3...Put task 4...Put task 5...Put task 6...Put task 7...Put task 8...Put task 9...task 0 is finish , runtime:3 stask 1 is finish , runtime:0 stask 2 is finish , runtime:2 stask 4 is finish , runtime:1 stask 3 is finish , runtime:3 stask 6 is finish , runtime:1 stask 7 is finish , runtime:0 stask 5 is finish , runtime:3 stask 8 is finish , runtime:2 stask 9 is finish , runtime:3 s 两个客户端的结果分别如下客户端112345678910111210run task 09run task 18run task 26run task 45run task 51run task 9 客户端2123456787run task 34run task 63run task 72run task 8 一起运行的截图如下 由于队列是线程安全的，所以这里不用加锁，在客户端中打印print(task.qsize()) 当前的队列大小，可以看到队列的信息中同步到各个客户端的。 最后还是要多说一句，分步式多进程虽然可以把任务分散到不同的机器上运行，可以处理多任务，但是如果此时服务端挂掉的话，任务就全丢掉了，所以在生产环境下还是考虑使用消息中间件如kafka等。 参考文章python 分布式计算","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"pymongo中使用聚合查询","slug":"aggregate_in_pymongo","date":"2019-03-19T16:00:00.000Z","updated":"2019-03-20T14:24:55.275Z","comments":true,"path":"article/aggregate_in_pymongo.html","link":"","permalink":"https://www.yangyanxing.com/article/aggregate_in_pymongo.html","excerpt":"在使用mongo数据库时，简单的查询基本上可以满足大多数的业务场景，但是试想一下，如果要统计某一荐在指定的数据中出现了多少次该怎么查询呢？笨的方法是使用find 将数据查询出来，再使用count() 方法进行数据统计，这个场景还好，但是如果要求其中某个字段的和呢？是不是就非得遍历出相应的数据然后再进行求和运算呢？在mysql中我们经常会用到count、group by 等查询，在mongodb中我们也可以使用聚合查询。","text":"在使用mongo数据库时，简单的查询基本上可以满足大多数的业务场景，但是试想一下，如果要统计某一荐在指定的数据中出现了多少次该怎么查询呢？笨的方法是使用find 将数据查询出来，再使用count() 方法进行数据统计，这个场景还好，但是如果要求其中某个字段的和呢？是不是就非得遍历出相应的数据然后再进行求和运算呢？在mysql中我们经常会用到count、group by 等查询，在mongodb中我们也可以使用聚合查询。 假设有这样的一组数据 里面记录了每种水果的价格，现在我要统计一下，各种水果在这张表中出现的次数，如果不用聚合查询的话，思路应该是这样，先把表中所有的数据都取出来，然后初始化一个字典，然后再遍历每一行的数据，获取它的fName ，然后再更新字典中的计数，这种方法的时间复杂度是O(N)的，如果数据量很大的话不是很好，下面来看一下使用聚合是怎么查询的。 聚合查询使用的是aggregate函数，它的参数是 pipeline 管道，管道的概念是用于将当前命令的输出结果作为下一个命令的参数，管道是有顺序的，比如通过第一个管道操作以后没有符合的数据那么之后的管道操作也就不会有输入，所以一定得要注意管道操作的顺序。由于对于上述问题，我们要的是所的数据统计，所以这里就不需要$match了12345678910from pymongo import MongoClientclient = MongoClient(host=['%s:%s'%(mongoDBhost,mongoDBport)])G_mongo = client[mongoDBname]['FruitPrice']pipeline = [ &#123;'$group': &#123;'_id': \"$fName\", 'count': &#123;'$sum': 1&#125;&#125;&#125;, ]for i in G_mongo['test'].aggregate(pipeline): print i 数据大家可以自已构造，这里主要是看aggregate的用法。得到的结果是123&#123;u'count': 8, u'_id': u'banana'&#125;&#123;u'count': 9, u'_id': u'pear'&#125;&#123;u'count': 14, u'_id': u'apple'&#125; 可以看到，一步操作就可以得到相应的统计了。 如果想要获取价格在50以上的各种统计呢？这时有pipeline应该再$group 之前加上$match 操作1234pipeline = [ &#123;'$match':&#123;'price':&#123;'$gte':50&#125;&#125;&#125;, &#123;'$group': &#123;'_id': \"$fName\", 'count': &#123;'$sum': 1&#125;&#125;&#125;, ] 一定要注意顺序 $match里的条件其实就和使用find函数里是一样的。 下面重点来说说$group操作,group意为分组,指数据根据哪个字段进行分组，上面使用的{&#39;$group&#39;: {&#39;_id&#39;: &quot;$fName&quot;, &#39;count&#39;: {&#39;$sum&#39;: 1},_id为所要分的组，这里是以fName字段分的，后面的&#39;count&#39;: {&#39;$sum&#39;: 1},这里的$sum就是求和的意思，后面的值是1，也就是说每出现一次就加1，这样就能达到计数的目的了，如果要计算价格 price 的和，那么这里就应该写成这样1&#123;'$group': &#123;'_id': \"$fName\", 'count': &#123;'$sum': '$price'&#125;&#125;&#125; 注意这里的字段要有$ 的，如果我想要求价格的平均值呢？也就是先要求出价格的总数，再除以商品的个数，但是这里有一个$avg 操作1234pipeline = [ &#123;'$match':&#123;'price':&#123;'$gte':50&#125;&#125;&#125;, &#123;'$group': &#123;'_id': \"$fName\", 'avg': &#123;'$avg': '$price'&#125;&#125;&#125;, ] 得到的结果123&#123;u'_id': u'banana', u'avg': 66.200000000000003&#125;&#123;u'_id': u'pear', u'avg': 77.0&#125;&#123;u'_id': u'apple', u'avg': 74.0&#125; 类似于$ave的操作还有很多，比较常用的是$min(求最小值)，$max(求最大值) 12345678910111213pipeline = [ &#123;'$match':&#123;'price':&#123;'$gte':50&#125;&#125;&#125;, &#123;'$group': &#123;'_id': \"$fName\", 'count':&#123;'$sum':1&#125;, 'priceAll':&#123;'$sum':'$price'&#125;, 'avg': &#123;'$avg': '$price'&#125;, 'min': &#123;'$min':'$price'&#125;, 'max': &#123;'$max':'$price'&#125; &#125; &#125;, ]for i in G_mongo['test'].aggregate(pipeline): print i 所有支持的操作可以参考官方文档:group 支持的操作 以哪个字段进行分组时必须使用_id。 接下来看一下多键分组。以上在使用group 进行分组查询的时候，用到的_id都是单一字段，比如我的数据库中有如下数据 带有一个user 字段了，那如果我要根据user和fName进行分组该如何操作呢?这里可以传一个字典进去12345678910111213pipeline = [ &#123;'$match':&#123;'price':&#123;'$gte':50&#125;&#125;&#125;, &#123;'$group': &#123;'_id': &#123;'fName':'$fName','user':'$user'&#125;, 'count':&#123;'$sum':1&#125;, 'priceAll':&#123;'$sum':'$price'&#125;, 'avg': &#123;'$avg': '$price'&#125;, 'min': &#123;'$min':'$price'&#125;, 'max': &#123;'$max':'$price'&#125; &#125; &#125;, ]for i in G_mongo['test2'].aggregate(pipeline): print i 得到的结果如下：123456789&#123;u'count': 1, u'avg': 93.0, u'min': 93, u'max': 93, u'_id': &#123;u'user': u'fanjieying', u'fName': u'pear'&#125;, u'priceAll': 93&#125;&#123;u'count': 2, u'avg': 88.0, u'min': 87, u'max': 89, u'_id': &#123;u'user': u'yangyanxing', u'fName': u'banana'&#125;, u'priceAll': 176&#125;&#123;u'count': 2, u'avg': 70.0, u'min': 69, u'max': 71, u'_id': &#123;u'user': u'yangyanxing', u'fName': u'pear'&#125;, u'priceAll': 140&#125;&#123;u'count': 2, u'avg': 65.5, u'min': 58, u'max': 73, u'_id': &#123;u'user': u'fanjieying', u'fName': u'banana'&#125;, u'priceAll': 131&#125;&#123;u'count': 3, u'avg': 92.333333333333329, u'min': 86, u'max': 97, u'_id': &#123;u'user': u'fantuan', u'fName': u'banana'&#125;, u'priceAll': 277&#125;&#123;u'count': 2, u'avg': 78.5, u'min': 73, u'max': 84, u'_id': &#123;u'user': u'yangyanxing', u'fName': u'apple'&#125;, u'priceAll': 157&#125;&#123;u'count': 3, u'avg': 56.666666666666664, u'min': 51, u'max': 60, u'_id': &#123;u'user': u'fantuan', u'fName': u'pear'&#125;, u'priceAll': 170&#125;&#123;u'count': 2, u'avg': 81.5, u'min': 73, u'max': 90, u'_id': &#123;u'user': u'fanjieying', u'fName': u'apple'&#125;, u'priceAll': 163&#125;&#123;u'count': 2, u'avg': 69.5, u'min': 53, u'max': 86, u'_id': &#123;u'user': u'fantuan', u'fName': u'apple'&#125;, u'priceAll': 139&#125; 这里的结果显示出每个用户买了哪个商品，一共花了多少钱，最大最小平均值等都可以一次性的展示了，如果要是使用for循环自已遍历的话这种时间复杂度相当高。 这里只是简单的说了下$group和$match 的用法，聚合查询支持很多种操作(称为stages)，可以通官方文档进行查看pymongo 中pipeline中的stages 参考文章pymongo 的 group by 方法","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python3中的字符编码问题","slug":"charset_in_python3","date":"2019-03-10T16:00:00.000Z","updated":"2019-07-15T16:04:47.744Z","comments":true,"path":"article/charset_in_python3.html","link":"","permalink":"https://www.yangyanxing.com/article/charset_in_python3.html","excerpt":"如果说在python2中处理字符编码很蛋疼的话，如果幻想着python3不那么蛋疼，那么我只想说，你想多了，好不容易在python2中把字符编码的问题捣腾清楚了，但是换成python3，它会将之前的体系重新构建，使得之前的知识体系不能很好的运用，只能重新来构建。感觉是从一个坑跳到了另外一个坑，下面来看看这个令人头疼的python编码问题。","text":"如果说在python2中处理字符编码很蛋疼的话，如果幻想着python3不那么蛋疼，那么我只想说，你想多了，好不容易在python2中把字符编码的问题捣腾清楚了，但是换成python3，它会将之前的体系重新构建，使得之前的知识体系不能很好的运用，只能重新来构建。感觉是从一个坑跳到了另外一个坑，下面来看看这个令人头疼的python编码问题。 python2中的编码处理python2中将ASCII 码作为默认编码方式，对中文处理很不友好。123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'ascii' 关于 GBK 和 UTF-8，概念性的东西就不解释了，网上一搜便知，这里主要是来说明一下，将一个 GBK 编码的字符串转换成 UTF-8 编码，只需要通过 Unicode 来转换 123456789101112131415&gt;&gt;&gt; s = '杨'&gt;&gt;&gt; s'\\xd1\\xee'&gt;&gt;&gt; type(s)&lt;class 'str'&gt;&gt;&gt;&gt; print s杨&gt;&gt;&gt; su = s.decode('gbk')&gt;&gt;&gt; suu'\\u6768'&gt;&gt;&gt; sutf8 = su.encode('utf-8')&gt;&gt;&gt; sutf8'\\xe6\\x9d\\xa8'&gt;&gt;&gt; print sutf8鏉? 其实就是将 unicode 作为一个中转站，将各种编码转换(decode)成unicode 使用 s.decode(chaset) ，然后再将unicode编码的字符串转换(encode)成想要的编码 s.encode(chaset)。 其实这么看在python2中的字符编码问题也不是很复杂，主要是要弄清楚字符串本身是什么编码即可。有一个库可以检测字符编码，chardet ，使用chardet.detect(str) 来检查字符串编码，注意，它这里给出的只能做为参考，并不能很准确的给出编码，所以他的返回值中会有一个 confidence 的值，如果值是1.0，说明它100%的肯定是这个编码。 python3中的编码处理 再来看看python3的编码处理，python3中将unicode合并成了str，已经没有unicode这种类型了。 12345678910&gt;&gt;&gt; s = '杨'&gt;&gt;&gt; type(s)&lt;class 'str'&gt;&gt;&gt;&gt; su = u'杨'&gt;&gt;&gt; type(su)&lt;class 'str'&gt;&gt;&gt;&gt; s'杨'&gt;&gt;&gt; su'杨' 可以看出它们都是 str 类型。 那么如何在python3中将一个GBK编码的字符串转成utf-8呢？ python3中有一种全新的数据类型 bytes ，它表示二进制字节数据，初始化是在字符前加 b ,bytes 类型可以是 ASCII范围内的字符和其它十六进制形式的字符数据，但不能用中文等非ASCII字符表示。1234567891011&gt;&gt;&gt; b = b'a'&gt;&gt;&gt; bb'a'&gt;&gt;&gt; type(b)&lt;class 'bytes'&gt;&gt;&gt;&gt; a = 'a'&gt;&gt;&gt; type(a)&lt;class 'str'&gt;&gt;&gt;&gt; b = b'杨彦星' File \"&lt;stdin&gt;\", line 1SyntaxError: bytes can only contain ASCII literal characters. 虽然在python3中不能直接的以 b = b&#39;杨彦星&#39; 来初始化bytes，但是却可以用在python2中得到的十六进制码表示来初始化 在python2中123&gt;&gt;&gt; '杨彦星''\\xd1\\xee\\xd1\\xe5\\xd0\\xc7'&gt;&gt;&gt; 在python3中1234567891011&gt;&gt;&gt; s = b'\\xd1\\xee\\xd1\\xe5\\xd0\\xc7'&gt;&gt;&gt; print(s)b'\\xd1\\xee\\xd1\\xe5\\xd0\\xc7'&gt;&gt;&gt; type(s)&lt;class 'bytes'&gt;&gt;&gt;&gt; ss = s.decode('gbk')&gt;&gt;&gt; ss'杨彦星'&gt;&gt;&gt; type(ss)&lt;class 'str'&gt;&gt;&gt;&gt; 熟悉的中文又出现了，有了str 那么就可以将其转换成对应的编码了12&gt;&gt;&gt; ss.encode('utf-8')b'\\xe6\\x9d\\xa8\\xe5\\xbd\\xa6\\xe6\\x98\\x9f' 依然不知道它显示的是个啥，但是你可以明确的知道，它在python3里就是杨彦星这个字符串的utf-8编码 123&gt;&gt;&gt; s8 = b'\\xe6\\x9d\\xa8\\xe5\\xbd\\xa6\\xe6\\x98\\x9f'&gt;&gt;&gt; s8.decode('utf-8')'杨彦星' 十六进制中文码转bytes还有一种需求，给你一个十六进制中文码字符串，有时候会从一些不是很规范的接口中获得的数据 ，比如 ‘\\xbd\\xf1\\xcc\\xec\\xcc\\xec\\xc6\\xf8\\xb2\\xbb\\xb4\\xed’,这时候该怎么把它转成str呢？ 在这种情况下，可以使用’iso-8859-1’来初始化bytes12345&gt;&gt;&gt; s = '\\xbd\\xf1\\xcc\\xec\\xcc\\xec\\xc6\\xf8\\xb2\\xbb\\xb4\\xed'&gt;&gt;&gt; bytes(s,'iso-8859-1')b'\\xbd\\xf1\\xcc\\xec\\xcc\\xec\\xc6\\xf8\\xb2\\xbb\\xb4\\xed'&gt;&gt;&gt; bytes(s,'iso-8859-1').decode('gbk')'今天天气不错' 如果明确知道十六进制字符码是UTF-8的，则在decode时可以不加参数123&gt;&gt;&gt; s = '\\xe4\\xbb\\x8a\\xe5\\xa4\\xa9\\xe5\\xa4\\xa9\\xe6\\xb0\\x94\\xe4\\xb8\\x8d\\xe9\\x94\\x99'&gt;&gt;&gt; bytes(s,'iso-8859-1').decode()'今天天气不错' 最后使用代码做个总结 1234567891011121314str = '杨彦星'str_utf8 = str.encode('UTF-8')str_gbk = str.encode('GBK')print(str)print('str 对象类型：', type(str))print('\\r')print('UTF-8 编码：', str_utf8)print('str_utf-8 对象类型：', type(str_utf8))print('\\r')print('GBK 编码： ', str_gbk)print('str_gbk 对象类型：', type(str_gbk))print('\\r')print('UTF-8 解码：', str_utf8.decode('UTF-8', 'strict'))print('GBK 解码： ', str_gbk.decode('GBK', 'strict')) 结果如下1234567891011杨彦星str 对象类型： &lt;class 'str'&gt;UTF-8 编码： b'\\xe6\\x9d\\xa8\\xe5\\xbd\\xa6\\xe6\\x98\\x9f'str_utf-8 对象类型： &lt;class 'bytes'&gt;GBK 编码： b'\\xd1\\xee\\xd1\\xe5\\xd0\\xc7'str_gbk 对象类型： &lt;class 'bytes'&gt;UTF-8 解码： 杨彦星GBK 解码： 杨彦星 参考文章 python3 字符集编码以及python3 乱码问题 Python3 是如何解决棘手的字符编码问题的？","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中使用优先队列","slug":"priorityqueue_in_python","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-19T16:36:37.248Z","comments":true,"path":"article/priorityqueue_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/priorityqueue_in_python.html","excerpt":"相信对于队列的概念大家都不会陌生，这种先入先出的数据结构应用很广泛，像一般的生产消费都会用到队列，关于Queue的用法介绍可以参考我之前的文章 python中的Queue与多进程（multiprocessing）还有栈，栈是一种先入后出的数据结构,面优先队列有别于普通的队列与栈，在实现上，它一般通过堆这一数据结构，而堆其实是一种完全二叉树，它会对进入容器的元素进行排序（根据事先指定的规则），出队的顺序则会是二叉树的根结点代表的元素。接下来介绍几种优先队列的实现。","text":"相信对于队列的概念大家都不会陌生，这种先入先出的数据结构应用很广泛，像一般的生产消费都会用到队列，关于Queue的用法介绍可以参考我之前的文章 python中的Queue与多进程（multiprocessing）还有栈，栈是一种先入后出的数据结构,面优先队列有别于普通的队列与栈，在实现上，它一般通过堆这一数据结构，而堆其实是一种完全二叉树，它会对进入容器的元素进行排序（根据事先指定的规则），出队的顺序则会是二叉树的根结点代表的元素。接下来介绍几种优先队列的实现。 通过heapq模块heapq是一个二叉堆的实现，它内部使用内置的list对象，它无论插入还是获取最小元素复杂度都在O(log n)。这里主要用到它的heappush与heappop方法，heappush 方法需要传入两个参数，一个是列表(list)，另外是一个对象，这里的对象须是可比较对象，就是它可以通过cmp方法来比较大小，以下是在 python2 中的代码实现123456789101112#coding:gbkimport heapqtasks = []heapq.heappush(tasks,(10,'aaa'))heapq.heappush(tasks,(40,'bbb'))heapq.heappush(tasks,(30,'ccc'))heapq.heappush(tasks,(20,'ddd'))while tasks: task = heapq.heappop(tasks) print(task) 运行结果如下1234(10, &apos;aaa&apos;)(20, &apos;ddd&apos;)(30, &apos;ccc&apos;)(40, &apos;bbb&apos;) 可以看到，我放入 tasks 列表里的元素是个 set 对象，对象第一个元素是个 int 类型的数字，如果使用cmp方法进行比较的话123456&gt;&gt;&gt; cmp(10,20)-1&gt;&gt;&gt; cmp(10,10)0&gt;&gt;&gt; cmp(10,5)1 对于小于，等于，大于分别返回的是-1，0，1，其实这也是在定义sorted的实现方法,12345678&gt;&gt;&gt; sorted([(10,'aaaa'),(30,'bbbb')])[(10, 'aaaa'), (30, 'bbbb')]&gt;&gt;&gt; sorted([(40,'aaaa'),(30,'bbbb')])[(30, 'bbbb'), (40, 'aaaa')]&gt;&gt;&gt; sorted([(30,'aaaa'),(30,'bbbb')])[(30, 'aaaa'), (30, 'bbbb')]&gt;&gt;&gt; sorted([(30,'bbbb'),(30,'abbb')])[(30, 'abbb'), (30, 'bbbb')] 可以看到在sorted方法里，它的排序算法是通过比较第一个元素的大小，小的排在前面，第一个元素相同再比较第二个元素，看返回之前的代码，heapq.heappush 将 set 元素添加到列表元素以后，将对其进行重新排序，将最小的放在前面，于是就得到了上面的打印结果。 上面是使用python自带的 set 数据结构，可否自定义一种类型呢，比较在实现生活中，在上班的第一件事是给自已写一下今天要完成哪些事情，其实哪些事情的优先级比较高就是先做哪些事情，其实在上面也说到 sorted 方法，这个方法其实就是在调用对象的 __cmp__ 方法，好么我可以单独定义一个带有 __cmp__ 方法的对象则可以实现优先队列中的对象排序。 123456789101112131415161718192021222324252627282930#coding:gbkimport heapq# 使用heapq实现优先队列#定义一个可比较对象class CompareAble: def __init__(self,priority,jobname): self.priority = priority self.jobname = jobname def __cmp__(self, other): if self.priority &lt; other.priority: return -1 elif self.priority == other.priority: return 0 else: return 1joblist = []heapq.heappush(joblist,CompareAble(80,'eat'))heapq.heappush(joblist,CompareAble(70,'a write plan2'))heapq.heappush(joblist,CompareAble(70,'write plan'))heapq.heappush(joblist,CompareAble(90,'sleep'))heapq.heappush(joblist,CompareAble(100,'write code'))while joblist: task = heapq.heappop(joblist) print(task.priority,task.jobname) 运行结果：12345(70, &apos;write plan&apos;)(70, &apos;a write plan2&apos;)(80, &apos;eat&apos;)(90, &apos;sleep&apos;)(100, &apos;write code&apos;) 上面的compareAble 类初始化有两个参数，一个是优先级，一个是事情的名字，我这里定义的是优先级数值越小排序越靠前，也可以定义成数值越大越靠前。如果优先级相同，则按照插入顺序来排序。 通过Queue,PriorityQueue类型实现这个优先级队列内部使用了heapq,不同的是PriorityQueue的操作是同步的，提供锁操作，支持并发的生产者和消费者，而且它的接口更加友好，它继承自Queue，所以好多Queue的方法可以直接使用123456789101112131415161718192021222324252627282930#coding:gbkimport heapqfrom queue import Queue,PriorityQueue# 使用heapq实现优先队列#定义一个可比较对象class CompareAble: def __init__(self,priority,jobname): self.priority = priority self.jobname = jobname def __cmp__(self, other): if self.priority &lt; other.priority: return -1 elif self.priority == other.priority: return 0 else: return 1pq = PriorityQueue()pq.put(CompareAble(80,'eat'))pq.put(CompareAble(70,'a write plan2'))pq.put(CompareAble(70,'write plan'))pq.put(CompareAble(90,'sleep'))pq.put(CompareAble(100,'write code'))while pq.qsize()!= 0: task = pq.get_nowait() print(task.jobname,task.priority) 接下来通过一个生产消费的实例来说明优先队列的使用有三个生产者和二个消费者，生产者向队列中生产有优先级的任务，消费者也是优先消费高级别的任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:gbkfrom queue import PriorityQueueimport timeimport randomimport threading# 使用heapq实现优先队列#定义一个可比较对象class CompareAble: def __init__(self,priority,jobname): self.priority = priority self.jobname = jobname def __cmp__(self, other): if self.priority &lt; other.priority: return -1 elif self.priority == other.priority: return 0 else: return 1tasks = [(i, \"do task %s\"%i) for i in range(10,100,5)]def produce(pq,lock): while True: lock.acquire() task = tasks[random.randint(0,len(tasks)-1)] print('put %s %s in pq'%(task[0],task[1])) pq.put(CompareAble(task[0],task[1])) time.sleep(1) lock.release()def consumer(pq,lock): while True: lock.acquire() task = pq.get_nowait() if task: print(task.priority, task.jobname) else: time.sleep(1) lock.release()if __name__ == '__main__': task_queue = PriorityQueue() task_lock = threading.Lock() for i in range(3): t = threading.Thread(target=produce,args=(task_queue,task_lock)) t.setDaemon(False) t.start() for i in range(2): t = threading.Thread(target=consumer,args=(task_queue,task_lock)) t.setDaemon(False) t.start() 运行结果：12345678910111213141516171819202122232425262728put 30 do task 30 in pqput 20 do task 20 in pqput 75 do task 75 in pq(20, &apos;do task 20&apos;)(30, &apos;do task 30&apos;)put 20 do task 20 in pqput 15 do task 15 in pqput 70 do task 70 in pq(15, &apos;do task 15&apos;)(20, &apos;do task 20&apos;)put 85 do task 85 in pqput 10 do task 10 in pqput 30 do task 30 in pq(10, &apos;do task 10&apos;)(30, &apos;do task 30&apos;)put 70 do task 70 in pqput 10 do task 10 in pqput 55 do task 55 in pq(10, &apos;do task 10&apos;)(55, &apos;do task 55&apos;)put 20 do task 20 in pqput 45 do task 45 in pqput 75 do task 75 in pq(20, &apos;do task 20&apos;)(45, &apos;do task 45&apos;)put 40 do task 40 in pqput 40 do task 40 in pq ... 可以看出，每次取出来的都是当前队列中 priority 最小的数 python3 中的使用方法上面的代码无法在python3中运行，主要是因为python3没有cmp方法，运行得到的异常信息是1TypeError: unorderable types: CompareAble() &lt; CompareAble() 就是没有一个 &lt; 的操作 需要在上面定义一个 __lt__ 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding:gbkfrom queue import PriorityQueueimport timeimport randomimport threading# 使用heapq实现优先队列#定义一个可比较对象class CompareAble: def __init__(self,priority,jobname): self.priority = priority self.jobname = jobname # def __cmp__(self, other): # if self.priority &lt; other.priority: # return -1 # elif self.priority == other.priority: # return 0 # else: # return 1 def __lt__(self, other): if self.priority &lt;= other.priority: return False else: return Truetasks = [(i, \"do task %s\"%i) for i in range(10,100,5)]def produce(pq,lock): while True: lock.acquire() task = tasks[random.randint(0,len(tasks)-1)] print('put %s %s in pq'%(task[0],task[1])) pq.put(CompareAble(task[0],task[1])) lock.release() time.sleep(1)def consumer(pq,lock): while True: lock.acquire() try: if pq.empty(): continue task = pq.get_nowait() if task: print(task.priority, task.jobname) finally: lock.release() time.sleep(1)if __name__ == '__main__': task_queue = PriorityQueue() task_lock = threading.Lock() for i in range(3): t = threading.Thread(target=produce,args=(task_queue,task_lock)) t.setDaemon(False) t.start() for i in range(2): t = threading.Thread(target=consumer,args=(task_queue,task_lock)) t.setDaemon(False) t.start() 上面的代码我修改了一点对于大小的判断，与之前的是反的，这里 priority 越大则越先返回，上面的代码在 python2 中也可以运行，所有如果为了兼容性可以选择定义使用 __lt__ 方法。 参考文章用Python实现优先级队列的3种方法python的优先队列示例","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中使用加盐哈希函数加密密码","slug":"python_generate_password_hash","date":"2019-01-20T16:00:00.000Z","updated":"2019-01-21T16:37:31.643Z","comments":true,"path":"article/python_generate_password_hash.html","link":"","permalink":"https://www.yangyanxing.com/article/python_generate_password_hash.html","excerpt":"开发网站离不开用户的注册与登录，今天来说说在网站开发的时候关于用户密码的保存方式，传统的方式有以下几种 明文存储：肉眼就可以识别，没有任何安全性。 谁用谁傻缺 加密存储：通过一定的变换形式，使得密码原文不易被识别。密码加密的几类方式： 明文转码加密：BASE64, 7BIT等，这种方式只是个障眼法，不是真正的加密。 对称算法加密：DES, RSA等。 签名算法加密：也可以理解为单向哈希加密，比如MD5, SHA1等。加密算法固定，容 易被暴力破解。如果密码相同，得到的哈希值是一样的。 加盐哈希加密：加密时混入一段“随机”字符串（盐值）再进行哈希加密。即使 密码相同，如果盐值不同，那么哈希值也是不一样的。现在网站开发中主要是运 用这种加密方法 本篇文章主要介绍第四种 「加盐哈希加密」","text":"开发网站离不开用户的注册与登录，今天来说说在网站开发的时候关于用户密码的保存方式，传统的方式有以下几种 明文存储：肉眼就可以识别，没有任何安全性。 谁用谁傻缺 加密存储：通过一定的变换形式，使得密码原文不易被识别。密码加密的几类方式： 明文转码加密：BASE64, 7BIT等，这种方式只是个障眼法，不是真正的加密。 对称算法加密：DES, RSA等。 签名算法加密：也可以理解为单向哈希加密，比如MD5, SHA1等。加密算法固定，容 易被暴力破解。如果密码相同，得到的哈希值是一样的。 加盐哈希加密：加密时混入一段“随机”字符串（盐值）再进行哈希加密。即使 密码相同，如果盐值不同，那么哈希值也是不一样的。现在网站开发中主要是运 用这种加密方法 本篇文章主要介绍第四种 「加盐哈希加密」 werkzeug介绍Werkzeug是一个WSGI工具包，他可以作为一个Web框架的底层库。但是 werkzeug 不是一个 web 服务器，也不是一个 web 框架，而是一个工具包，因为它封装好了很多 Web 框架的东西，例如 Request，Response 等等，大名鼎鼎的Flask就是基于werkzeug开发的。 安装 werkzeug pip install Werkzeug 密码生成函数 generate_password_hash1234567891011&gt;&gt;&gt; from werkzeug.security import generate_password_hash&gt;&gt;&gt; generate_password_hash('123')'pbkdf2:sha256:50000$fESwY4Cl$38fdf741069ef37c207211b9bee69514582dc366660563d75c00e7cbfd7cbd8a'&gt;&gt;&gt; generate_password_hash('123')'pbkdf2:sha256:50000$hUhR8Gr3$73d44814d5cd490c04e0559141fb327c31766a0314d82ee05e33c33e1559af78'&gt;&gt;&gt; generate_password_hash('123')'pbkdf2:sha256:50000$EDHR93sZ$0d72a4c15a1c07b03f4190c7ac30b48ae8b478a4977a0262fa16d38417450b21'&gt;&gt;&gt; generate_password_hash('123')'pbkdf2:sha256:50000$ntpFkKsc$bd062cd0b35c5b26c91242fc72eb0e889cf71b9dd4c1ae291587a7a3e84db293'&gt;&gt;&gt; generate_password_hash('123')'pbkdf2:sha256:50000$sVP5IXJG$b93a86f5343d2a243ec701bfdf0cff745a5b1532c66cb7f82fb7d252d3b5ffb0' 可以看到，每次计算出来的值都是不一样的,generate_password_hash 函数定义为1generate_password_hash(password, method=&apos;pbkdf2:sha256&apos;, salt_length=8) password 为明文密码 method 哈希的方式,格式为 pbpdf2:&lt;method&gt; 主要有sha1,sha256,md5 salt_length 盐值的长度，默认为8 12345678&gt;&gt;&gt; generate_password_hash('123',method='pbkdf2:sha1',salt_length=10)'pbkdf2:sha1:50000$4GUBRzzizn$45b0f6b84a4ca4352b45feea8283fc48186f9ee8'&gt;&gt;&gt; generate_password_hash('123',method='pbkdf2:sha1',salt_length=8)'pbkdf2:sha1:50000$4kHPpS9R$1f87c09c052342fd0d65b75aa70ababb1c17e7df'&gt;&gt;&gt; generate_password_hash('123',method='pbkdf2:md5',salt_length=8)'pbkdf2:md5:50000$zppMHqux$01acb41e0b2858bbc849abf77692a9c0'&gt;&gt;&gt; generate_password_hash('123',method='pbkdf2:md5',salt_length=8)'pbkdf2:md5:50000$rMaQutjR$1cc67c05e063cec0c8e5f8e048ddb5e1' 密码验证函数：check_password_hash有生成函数就得有相应的解密函数，check_password_hash的定义为1check_password_hash(pwhash, password) pwhash 为密文password 为明文 相同则返回True，不同返回 False 1234&gt;&gt;&gt; check_password_hash('pbkdf2:sha256:50000$ntpFkKsc$bd062cd0b35c5b26c91242fc72eb0e889cf71b9dd4c1ae291587a7a3e84db293','123')True&gt;&gt;&gt; check_password_hash('pbkdf2:sha256:50000$ntpFkKsc$bd062cd0b35c5b26c91242fc72eb0e889cf71b9dd4c1ae291587a7a3e84db293','1234')False 结语这个加盐哈希加密以后的密文，放到另外一台服务器上也是可以校验通过的，如果做网站数据库迁移也不用重新生成数据，使用这套加密算法可以很大程度上规避暴力破解密码，还是那句老话，密码是123456的就算使用再牛逼的加密你依然是不安全的，另外撞库也是不可避免的，所以作为用户可以尝试不同的网站使用不同的密码来规避撞库问题。 参考文章Flask加盐密码生成和验证函数","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的异步实践与tornado应用","slug":"async_in_python","date":"2019-01-10T16:00:00.000Z","updated":"2019-01-14T13:15:47.911Z","comments":true,"path":"article/async_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/async_in_python.html","excerpt":"最近项目中由于在python3中使用tornado,之前也有用过，是在python2中，由于对于协程理解不是很透彻，只是套用官方文档中的写法，最近比较细致的看了下协程的用法，也将tornado在python3中异步的实践了一下。","text":"最近项目中由于在python3中使用tornado,之前也有用过，是在python2中，由于对于协程理解不是很透彻，只是套用官方文档中的写法，最近比较细致的看了下协程的用法，也将tornado在python3中异步的实践了一下。 异步基础要理解协程，先要理解异步，要理解异步，先要理解同步，与同步相关的概念又有阻塞与非阻塞，下面一一做简单介绍。 阻塞 阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。常见的阻塞形式有：网络 I/O 阻塞、磁盘 I/O 阻塞、用户输入阻塞等。阻塞是无处不在的，包括 CPU 切换上下文时，所有的进程都无法真正干事情，它们也会被阻塞。如果是多核 CPU 则正在执行上下文切换操作的核不可被利用。 非阻塞 程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情，则称该程序在该操作上是非阻塞的。非阻塞并不是在任何程序级别、任何情况下都可以存在的。仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。 同步 不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，称这些程序单元是同步执行的。例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。简言之，同步意味着有序。 异步 为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式，不相关的程序单元之间可以是异步的。例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。简言之，异步意味着无序。 这个概念让我想起了上学时学过的一篇文章，讲统筹安排的，比如你现在要烧水，做饭，洗衣服三件事，如果同步的进行，先烧水，在水烧开的过程中你什么都不做就等着它烧开，然后水烧开以后你再接着做饭，饭做熟的过程中你也是什么都不干，就干等着，饭做熟后再去将洗衣服放入洗衣机中去洗，之后又是干等着。如果单做一件事的时间是烧水10分别，做饭30分钟，洗衣服20分钟，那么完成这三件事总共需要60分钟。如果将这三件事异步的去进行，我先将水烧上，然后再将衣服放到洗衣机里，然后去做饭，这三件事同时进行，当水烧开的时候给我一个信号，这里就是水壶会响，我听到响声以后我会中止做饭这件事情去处理烧开的水，比如把它倒到保温瓶中，衣服洗完以后洗衣机也会给我一个信号，那么我就会将衣服拿出来晾晒。这样处理完三件事总共的时间就由三件事情中最长的时间决定，这里就是30分钟，其实异步的处理就是最大程度的发挥cup的处理能力，让其在同一时间内做更多的事情。 上面的过程用代码来实现大概是这个样子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#coding:gbkimport timeimport threading,multiprocessingdef water(): print(\"开始烧水了\") start = time.time() time.sleep(2) end = time.time() return (\"水开了\", end - start)def wash(): print(\"开始洗衣服了\") start = time.time() time.sleep(4) end = time.time() return (\"衣服洗完了\", end - start)def cook(): print(\"开始做饭了\") start = time.time() time.sleep(10) end = time.time() return (\"饭熟了\",end - start)def alarm(info): print(\"%s 一共用了%s 时间\"%(info[0],info[1]))class DoWork(threading.Thread): def __init__(self, func, callback,*params, **paramMap): threading.Thread.__init__(self) self.func = func self.params = params self.paramMap = paramMap self.rst = None self.finished = False self.isDaemon = True self.isDaemon = False self.callback = callback def run(self): self.rst = self.func(*self.params, **self.paramMap) self.callback(self.rst) self.finished = Trueif __name__ == '__main__': task1 = DoWork(water,alarm) task2 = DoWork(wash,alarm) task3 = DoWork(cook,alarm) start = time.time() task1.start() task2.start() task3.start() task1.join() task2.join() task3.join() end = time.time() print(\"一共用了%s时间\"%(end-start)) 执行结果如下1234567开始烧水了开始洗衣服了开始做饭了水开了 一共用了2.0003998279571533 时间衣服洗完了 一共用了4.00029993057251 时间饭熟了 一共用了10.000999689102173 时间一共用了10.001499891281128时间 yield 语法以上是用了多线程的方式来达到异步的效果，但是并没有用到协程，协程在python2就有，现在来看看在python2中通过yield语法。以下方法是在python2.6中执行. 要了解 yield 语法，先要了解一个概念： Generator 『生成器』，关于generator的概念可以参考廖雪峰的教程，写的很好，生成器 如果一个函数定义中包含 yield 关键字，那么这个函数就不再是一个普通函数，而是一个 generator 1234567def h(): print('I am yangyanxing') yield 5if __name__ == '__main__': c = h() 运行该脚本以后程序并没有任何输出，因为它有yield表达式，因此，我们通过next()语句让它执行。next()语句将恢复Generator执行，并直到下一个yield表达式处。比如： 123456789def h(): print('I am yangyanxing') yield 5 print(\"I am fjy\")if __name__ == '__main__': c = h() c.next() 调用 c.nect() 以后，函数开始执行，这时先打印 “I am yangyanxing”, 之后遇到 yield 关键字，此时函数又被中断，脚本执行结束，程序只打印了一行 “I am yangyanxing”,如果想要打印出 I am fjy 呢，以时需要再调用一次 c.next(), 当再次调用 c.next() 时，函数从之前的 yield 处开始执行，由于函数在之后没有 yield 了，所以程序会抛一个 StopIteration 异常。 与 next() 函数相关的还有一个 send() 函数，next 函数传递的是 None ， send 函数可以传递对应的值。其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做c.next() 和 c.send(None) 作用是一样的。看如下的代码。123456789101112def h(): print('I am yangyanxing') m = yield 5 print(m) print(\"I am fjy\") yield 6 print(\"They love too much\")if __name__ == '__main__': c = h() c.next() c.send(\"hahaha\") 函数的输出为123I am yangyanxinghahahaI am fjy 这代码解析，首先通过 c = h() 定义了一个 generator ,然后调用 c.next() 启动这个生成器，生成器先打印出 I am yangyanxing 然后遇到 m = yield 5 这行代码，后停止，之后再调用 c.send(&quot;hahaha&quot;) ，这时候 m 的值就是 hahaha, 然后再打印出 m ,之后再打印出 I am fjy,之后又遇到了 yield 关键字，程序又中止了，整个脚本执行结束,需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会出错的，因为没有yield语句来接收这个值。那么 next() 与 send() 函数的返回值是什么呢？ 注意到上面函数中的 yield 之后是一个5了吗？其实这就是调用 netx 或者 send 以后得到的返回值.1234567891011def h(): print('I am yangyanxing') m = yield 5 print(m) print(\"I am fjy\") yield 6if __name__ == '__main__': c = h() print(c.next()) print(c.send(\"hahaha\")) 得到的输出为12345I am yangyanxing5hahahaI am fjy6 异步使用同步的困扰首先看以下的代码，以下是在python2中编写12345678910111213141516171819202122import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webimport tornado.httpclientimport timefrom tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class IndexHandler(tornado.web.RequestHandler): def get(self): query = self.get_argument('q') time.sleep(5) self.write(\"hello %s\"%query)if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 我分别用浏览器和和用脚本对 http://127.0.0.1:8000/?q=yangyanxing 该 url 进行访问，脚本如下123456789101112131415import requests,timedef geturl(url): s = time.time() r = requests.get(url) e = time.time() print(int(e-s))getrul(r\"http://127.0.0.1:8000/?q=yangyanxing\")``` 服务端显示``` [I 190114 00:03:46 web:2162] 304 GET /?q=yangyanxing (127.0.0.1) 5000.97ms[I 190114 00:03:51 web:2162] 200 GET /?q=yangyanxing (127.0.0.1) 5006.78ms 脚本打印为 7或者8 在同步应用中，由于同时只能提供一个请求。所以，如果一个路由中有一个比较耗时的操作，如代码中的 time.sleep(5) 那么意味着如果同时有两个请求，那么第二个请求只能等待服务器处理完第一个请求之后才能处理第二个请求，也就中处理两个请求，最短要5秒，最长要10秒,这还只是2个，如果有10个那就是要50秒处理完所有的请求，这个效率是无法接受的，服务端可否同时处理10个请求，就像文章一开始提到的同时做三件事情，在处理一个耗时的操作时，不是干等着这件事情处理完，而是去做别的事情，当那件事情结束以后，再通过调用回调函数来通知调用者。 异步的使用 客户端的实现异步的使用可以分为客户端的调用与服务端的处理，先从简单的来看，客户端的调用，比如你要同时访问 baidu.com 10次，你会怎么做？可以依次的对 baidu 发起10次请求，每次请求结束以后再发起下一次请求，假如每次请求是1秒钟，那么10次请求至少要用10秒钟，排除IO相关耗时，代码可能是这个样子的 12345678910111213141516171819#coding:utf-8import timeimport requestsdef geturl(url): start = time.time() r = requests.get(url) end = time.time() print(\"用了%s时间\"%(end-start)) return r.status_codeif __name__ == '__main__': start = time.time() for i in range(10): geturl(r\"https://www.baidu.com\") end = time.time() print(\"all done,use %s time\"%(end-start)) 执行结果如下：1234567891011用了0.2974998950958252时间用了0.0494999885559082时间用了0.0410001277923584时间用了0.029999971389770508时间用了0.18199992179870605时间用了0.02700018882751465时间用了0.022499799728393555时间用了0.020000219345092773时间用了0.020999908447265625时间用了0.019999980926513672时间all done,use 0.7105000019073486 time 一共用了0.7秒，百度的反应可能太快了，我们准备一个本地的环境来模拟慢返回。这里我先使用tornado的异步协程处理，之后再详细说明该处的用法。12345678910111213141516171819202122232425262728293031import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webimport tornado.httpclientimport asyncioimport urllibimport jsonimport datetimeimport timefrom tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class IndexHandler(tornado.web.RequestHandler): async def get(self): query = self.get_argument('q') await asyncio.sleep(5) self.writeres(\"hello %s\"%query) self.finish() def writeres(self,returnstr): self.write(returnstr)if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 请求代码改为三次，只是为了说明问题 1234567891011121314def geturl(url): start = time.time() r = requests.get(url) end = time.time() print(\"用了%s时间\"%(end-start)) return r.status_codeif __name__ == '__main__': start = time.time() for i in range(3): geturl(r\"http://127.0.0.1:8000/?q=yangyanxing\") end = time.time() print(\"all done,use %s time\"%(end-start)) 结果：1234用了5.009501695632935时间用了5.012002229690552时间用了5.012502193450928时间all done,use 15.035006284713745 time 可以看到，总是时间是15秒，同步对一个url发请求，在没有做异步处理的时候时间是累积的。 接下来说本篇的重点，协程. 定义协程 在一个普通的函数前面加上 async 关键字，此时该函数会返回一个coroutine对象，函数里也不会立刻执行.12345678910async def getUrlByCor(url): start = time.time() r = requests.get(url) end = time.time() print(\"用了%s时间\" % (end - start)) return r.status_codeif __name__ == '__main__': s = getUrlByCor(r'http://127.0.0.1:8000/?q=yangyanxing') print(s) 运行结果：1&lt;coroutine object getUrlByCor at 0x00000000034BBF10&gt; 此处的 s 是一个coroutine对象，那么怎么才能执行函数里面的方法呢？ 将这个协程对象放到事件循环 event_loop 中执行 1234567891011async def getUrlByCor(url): start = time.time() r = requests.get(url) end = time.time() print(\"用了%s时间\" % (end - start)) return r.status_codeif __name__ == '__main__': s = getUrlByCor(r\"http://127.0.0.1:8000/?q=yangyanxing\") loop = asyncio.get_event_loop() loop.run_until_complete(s) 执行结果： 用了5.009500026702881时间 如果同时发三个请求呢？这里要对协程做一个封装，将其封装成一个 task 对象1234567891011121314151617async def getUrlByCor(url): start = time.time() r = requests.get(url) end = time.time() print(\"用了%s时间\" % (end - start)) return r.textif __name__ == '__main__': s = time.time() tasks = [asyncio.ensure_future(getUrlByCor(r\"http://127.0.0.1:8000/?q=yangyanxing\")) for i in range(3)] print(len(tasks),tasks) loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) e = time.time() print(\"use %s time\"%(e-s)) for task in tasks: print('Task Result:', task.result()) 结果如下：123456783 [&lt;Task pending coro=&lt;getUrlByCor() running at E:/Github/asyncTorMysql/asynctest.py:69&gt;&gt;, &lt;Task pending coro=&lt;getUrlByCor() running at E:/Github/asyncTorMysql/asynctest.py:69&gt;&gt;, &lt;Task pending coro=&lt;getUrlByCor() running at E:/Github/asyncTorMysql/asynctest.py:69&gt;&gt;]用了5.008501291275024时间用了5.012002229690552时间用了5.012002229690552时间use 15.03450632095337 timeTask Result: hello yangyanxingTask Result: hello yangyanxingTask Result: hello yangyanxing 总的时间还是15秒，并没有实现异步呢，还是同步的依次执行请求。其实，要实现异步处理，我们得先要有挂起的操作，当一个任务需要等待 IO 结果的时候，可以挂起当前任务，转而去执行其他任务，这样我们才能充分利用好资源，上面方法都是一本正经的串行走下来，连个挂起都没有，怎么可能实现异步？ 上面的函数存在耗时的操作就是r = requests.get(url) 那么将它写成挂起的呢？r = await requests.get(url) 1234567891011121314151617async def getUrlByCor(url): start = time.time() r = await requests.get(url) end = time.time() print(\"用了%s时间\" % (end - start)) return r.textif __name__ == '__main__': s = time.time() tasks = [asyncio.ensure_future(getUrlByCor(r\"http://127.0.0.1:8000/?q=yangyanxing\")) for i in range(3)] print(len(tasks),tasks) loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) e = time.time() print(\"use %s time\"%(e-s)) for task in tasks: print('Task Result:', task.result()) 不出意外的报错了 Task exception was never retrievedfuture: exception=TypeError(“object Response can’t be used in ‘await’ expression”,)&gt;Traceback (most recent call last): File “C:\\Python35\\lib\\asyncio\\tasks.py”, line 240, in _step result = coro.send(None) File “E:/Github/asyncTorMysql/asynctest.py”, line 71, in getUrlByCor r = await requests.get(url)TypeError: object Response can’t be used in ‘await’ expression 这个错误的意思是 requests 返回的 Response 对象不能和 await 一起使用,await 后面的对象必须是如下格式之一 原生 coroutine 对象 一个由 types.coroutine() 修饰的生成器，这个生成器可以返回 coroutine 对象。 一个包含 __await 方法的对象返回的一个迭代器。 reqeusts 返回的 Response 不符合上面任一条件，因此就会报上面的错误了。 既然 await 后面的对象要是 coroutine 对象 ，那么将其包装在async 后面不就可以了吗？1234567891011121314151617181920async def get(url): return requests.get(url)async def getUrlByCor(url): start = time.time() r = await get(url) end = time.time() print(\"用了%s时间\" % (end - start)) return r.textif __name__ == '__main__': s = time.time() tasks = [asyncio.ensure_future(getUrlByCor(r\"http://127.0.0.1:8000/?q=yangyanxing\")) for i in range(3)] print(len(tasks),tasks) loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) e = time.time() print(\"use %s time\"%(e-s)) for task in tasks: print('Task Result:', task.result()) 这次不报错了，但是依然没有异步的执行1234567用了5.0090014934539795时间用了5.011002063751221时间用了5.011502027511597时间use 15.03450632095337 timeTask Result: hello yangyanxingTask Result: hello yangyanxingTask Result: hello yangyanxing 也就是说我们仅仅将涉及 IO 操作的代码封装到 async 修饰的方法里面是不可行的！我们必须要使用支持异步操作的请求方式才可以实现真正的异步，所以这里就需要 aiohttp 派上用场了 aiohttp 是一个支持异步请求的库，利用它和 asyncio 配合我们可以非常方便地实现异步请求操作。 123456789101112131415161718192021222324async def get(url): session = aiohttp.ClientSession() res = await session.get(url) result = await res.text() await session.close() return resultasync def getUrlByCor(url): start = time.time() r = await get(url) end = time.time() print(\"用了%s时间\" % (end - start)) return rif __name__ == '__main__': s = time.time() tasks = [asyncio.ensure_future(getUrlByCor(r\"http://127.0.0.1:8000/?q=yangyanxing\")) for i in range(3)] print(len(tasks),tasks) loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) e = time.time() print(\"use %s time\"%(e-s)) for task in tasks: print('Task Result:', task.result()) 执行结果：1234567用了5.006500005722046时间用了5.006499767303467时间用了5.006500005722046时间use 5.008500099182129 timeTask Result: hello yangyanxingTask Result: hello yangyanxingTask Result: hello yangyanxing 这次终于实现了异步请求。 还记得最开始的洗衣做饭的例子吗？可以使用异步协程来实现，代码大概是这个样子12345678910111213141516171819202122232425262728293031323334353637383940414243444546#coding:utf-8import timeimport threading,multiprocessingimport requestsimport asyncioimport aiohttpasync def water(): print(\"开始烧水了\") start = time.time() await asyncio.sleep(2) # 这里使用asyncio.sleep 异步休眠 end = time.time() return (\"水开了\", end - start)async def wash(): print(\"开始洗衣服了\") start = time.time() await asyncio.sleep(4) end = time.time() return (\"衣服洗完了\", end - start)async def cook(): print(\"开始做饭了\") start = time.time() await asyncio.sleep(10) end = time.time() return (\"饭熟了\",end - start)def alarm(task): print(\"%s 一共用了%s 时间\"%(task.result()[0],task.result()[1]))if __name__ == '__main__': tasks = [] # 初始化task task_water = asyncio.ensure_future(water()) task_wash = asyncio.ensure_future(wash()) task_cook = asyncio.ensure_future(cook()) tasks.extend([task_water,task_wash,task_cook]) # 将这三个task 绑定回调函数 task_water.add_done_callback(alarm) task_wash.add_done_callback(alarm) task_cook.add_done_callback(alarm) # 将task放入事件循环中 loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 执行结果： 开始烧水了开始洗衣服了开始做饭了水开了 一共用了2.0 时间衣服洗完了 一共用了4.003999948501587 时间饭熟了 一共用了9.994499921798706 时间 服务端的实现 先看下tornado在python2中的解决方案. 我们再来翻过头来看之前用tornado写的服务端同步代码 12345678910111213141516171819202122import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webimport tornado.httpclientimport timefrom tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class IndexHandler(tornado.web.RequestHandler): def get(self): query = self.get_argument('q') time.sleep(5) self.write(\"hello %s\"%query)if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 在 IndexHandler 中的 get 方法，由于当中存在了一个比较耗时的操作，time.sleep(5) 处理完这个请求需要卡5秒，在卡住的这段时间，tornado无法再完成别的请求，如果此时再发来一个 / 的请求，那么只能等待这前的请求操作结束之后再对处理新发过来的请求，如果同时有1万个请求发过来，可想而知，最后一个请求就等到猴年马月才能处理完呢…… 解决方法是使用@tornado.web.asynchronous 和@tornado.gen.coroutine 装饰器，将耗时的操作放到线程中去执行，这里的耗时操作 time.sleep(5) 是阻塞的，所以将阻塞函数放加上 @run_on_executor 装饰器1234567891011121314151617181920212223242526272829303132333435import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webimport tornado.httpclientimport tornado.autoreloadfrom tornado.concurrent import run_on_executorimport timefrom concurrent.futures import ThreadPoolExecutorfrom tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class IndexHandler(tornado.web.RequestHandler): executor = ThreadPoolExecutor(100) @tornado.web.asynchronous @tornado.gen.coroutine def get(self): query = self.get_argument('q') res = yield self.sleepBlock(2,query) self.write(\"hello %s\"%res) self.finish() @run_on_executor def sleepBlock(self,sleeptime,query): time.sleep(sleeptime) return queryif __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)],settings=&#123;\"debug\":True&#125;) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 注意到在 IndexHandler 中有一行初始化 executor 的代码 executor = ThreadPoolExecutor(100) 这里的参数100是最大的线程数，我这里传的是100，也就意味着同时能处理100个请求，当有101个请求的时候，前100个请求可以同时在2秒内执行，最后的那一个请求就要等之前有结束的线程以后再去执行了。 再看下tornado在python3.5 中的解决方案 由于在python3.5以后引入了 asyncio这个标准库，很多异步的操作可以用这个库来操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webimport tornado.httpclientimport tornado.autoreloadfrom tornado.concurrent import run_on_executorimport asyncioimport timefrom concurrent.futures import ThreadPoolExecutorfrom tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class IndexHandler(tornado.web.RequestHandler): executor = ThreadPoolExecutor(100) @tornado.web.asynchronous @tornado.gen.coroutine def get(self): query = self.get_argument('q') res = yield self.sleepBlock(2,query) self.write(\"hello %s\"%res) self.finish() @run_on_executor def sleepBlock(self,sleeptime,query): time.sleep(sleeptime) return queryclass asyncIndexHandler(tornado.web.RequestHandler): async def get(self): query = self.get_argument('q') res = await self.sleepBlock(2,query) self.write(\"hello %s\"%res) self.finish() async def sleepBlock(self,sleeptime,query): await asyncio.sleep(sleeptime) # 使用异步的sleep方法 return queryif __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[ (r\"/\", IndexHandler), (r\"/async\",asyncIndexHandler) ],settings=&#123;\"debug\":True&#125;) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() IndexHandler 中的 get 方法使用了async 与await 关键字来达到异步的处理请求，这里的asyncio.sleep(5) 是异步的暂停5秒，如果此处的方法涉及到无法使用异步请求的库该怎么处理，比如说我就想使用time.sleep(5) 则需要在线程池中运行，就像上面的/ 路由里使用 @run_on_executor 中执行。 结语异步操作涉及的知识点比较多，不同版本的 python 对于异步的处理也不一样，有些东西如 yield 理解起来比较费劲，需要多在项目中实践，tornado 这个框架的设计初衷也是异步网络库，过使用非阻塞网络I/O, Tornado 可以支持上万级的连接，所以要使用过程中要多多考虑异步非阻塞的编码。 参考文章 爬虫速度太慢？来试试用异步协程提速吧！ Python3 异步协程函数async具体用法 Python天天美味(25) - 深入理解yield 理解Python协程:从yield/send到yield from再到async/await 使用tornado让你的请求异步非阻塞","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"pymongo中的特殊查询","slug":"specialUse-in-pymongo","date":"2018-12-27T15:53:38.000Z","updated":"2019-01-23T07:57:50.000Z","comments":true,"path":"article/specialUse-in-pymongo.html","link":"","permalink":"https://www.yangyanxing.com/article/specialUse-in-pymongo.html","excerpt":"python操作mongo常用的增删改查看这一篇就够了Python操作MongoDB看这一篇就够了 最近在整理一些在pymongo中相对使用较少的查询。","text":"python操作mongo常用的增删改查看这一篇就够了Python操作MongoDB看这一篇就够了 最近在整理一些在pymongo中相对使用较少的查询。 忽略大小写查询可以使用正则(re)来查询 1234567import reimport pymongo name = r\"^%s$\"%filenamere_name = re.compile(name,re.I)conn = pymongo.MongoClient(host, port)fileinfos = conn.fileRecode.fileTask.find(&#123;'filename':re_name&#125;,projection=&#123;'_id': False&#125;) 也可以使用 $regex 表达式，上面的代码可以使用下面替换1fileinfos = conn.fileRecode.fileTask.find(&#123;'filename':&#123;'$regex':r\"^%s$\"%filename,'$options':\"i\"&#125;&#125;,projection=&#123;'_id': False&#125;) $options 目前支持四种，比较常用的是i 选项 含义 使用要求 i 大小写不敏感 m 查询匹配中使用了锚，例如^（代表开头）和$（代表结尾），以及匹配\\n后的字符串 x 忽视所有空白字符 要求$regex与$option合用 s 允许点字符（.）匹配所有的字符，包括换行符。 要求$regex与$option合用 判断有某个字段和某个字段是否为空的查询比如要查找字段中不包含 name 的记录12&gt;&gt;&gt; db.find_one(&#123;'name':&#123;'$exists':False&#125;&#125;)&#123;u'info': &#123;u'age': u'30', u'name': u'yangyanxing'&#125;, u'_id': ObjectId('5c24a27ddb1f5a209cf8799a'), u'id': 1&#125; 如果要检查字段 name 为None 比如数据库中有以下的数据1234567891011121314151617181920/* 1 */&#123; \"_id\" : ObjectId(\"5c25faa3db1f5a2f7019b6d8\"), \"age\" : 40, \"name\" : \"fan3\"&#125;/* 2 */&#123; \"_id\" : ObjectId(\"5c4813a1db1f5a14a061d8da\"), \"age\" : 31, \"name\" : null&#125;/* 3 */&#123; \"_id\" : ObjectId(\"5c4819b3db1f5a14a061d8db\"), \"age\" : 31, \"sex\" : \"M\"&#125; 当我想要查找 name 为 null 的该怎么查呢？如果使用db.find({&#39;name&#39;:None})时得到的以下结果12345678910111213/* 1 */&#123; \"_id\" : ObjectId(\"5c4813a1db1f5a14a061d8da\"), \"age\" : 31, \"name\" : null&#125;/* 2 */&#123; \"_id\" : ObjectId(\"5c4819b3db1f5a14a061d8db\"), \"age\" : 31, \"sex\" : \"M\"&#125; 它将name 不存在的也给查出来了，正确的方式是还要加一个存在的条件1db.find(&#123;'name':&#123;'$exists':True,'$in':[None]&#125;&#125;) 字段的多层结构查询比如有如下格式的数据12345678910111213141516171819/* 1 */&#123; \"_id\" : ObjectId(\"5c24a27ddb1f5a209cf8799a\"), \"info\" : &#123; \"age\" : \"30\", \"name\" : \"yangyanxing\" &#125;, \"id\" : 1&#125;/* 2 */&#123; \"_id\" : ObjectId(\"5c24a2acdb1f5a209cf8799b\"), \"info\" : &#123; \"age\" : \"20\", \"name\" : \"fanjy\" &#125;, \"id\" : 1&#125; 比如我要查询info下的name为yangyanxing的该如何查询呢？使用.来连接查询，这里就是info.name12&gt;&gt;&gt; conn.yang.test.find_one(&#123;\"info.name\":\"fanjy\"&#125;)&#123;u'info': &#123;u'age': u'20', u'name': u'fanjy'&#125;, u'_id': ObjectId('5c24a2acdb1f5a209cf8799b'), u'id': 1&#125; 查询指定时间段的数据有时候在插入数据的时候会使用datetime.datetime.now() 来插入一个datatime格式的数据，比如要查询某段时间的数据该怎么查询呢？可以使用$gte(大于等于)与$lte(小于等于)来查询，比如说要查询一年以来的数据，可以这样1234567import datedatefrom pymongo import Connectionstart_check = datetime.datetime.now()-datetime.timedelta(days=365)checkCon = &#123;'addtime':&#123;\"$gte\":start_check&#125;&#125;conn = Connection(host, port)fileinfos = conn.Documents.find(checkCon) #逻辑关系查询一般的逻辑查询包括与 或 非 关系与 (and)其实这个不要特殊的关键词，直接将要查询的内容依次写到查询条件中就是与的关系 12&gt;&gt;&gt; conn.yang.test.find_one(&#123;\"info.name\":\"fanjy\",\"id\":1&#125;)&#123;u'info': &#123;u'age': u'20', u'name': u'fanjy'&#125;, u'_id': ObjectId('5c24a2acdb1f5a209cf8799b'), u'id': 1&#125; 关系或 (or) 需要使用$or,比如要查询名字叫 yangyanxing 或者 地址在tongzhou的 1coon.yang.test.find(&#123;\"$or\":[&#123;\"name\":\"yangyanxing\"&#125;,&#123;\"address\":\"tongzhou\"&#125;]&#125;) $or的值为一个列表，列表中的每一项是一个字典，字典中是各种查询条件。 列表也可以用列表迭代，比如我要找到 taskid 为1,2,4,6,7,9,10,20,34的任务,可以使用1conn.yang.test.find(&#123;'$or':[&#123;\"taskid\":i&#125; for i in l]&#125;) $in 操作123456789&gt;&gt;&gt; for i in conn.yang.test.find(&#123;\"info.name\":&#123;\"$in\":['yangyanxing','fanjy']&#125;&#125;):... print i...&#123;u'info': &#123;u'age': u'30', u'name': u'yangyanxing'&#125;, u'_id': ObjectId('5c24a27ddb1f5a209cf8799a'), u'id': 1&#125;&#123;u'info': &#123;u'age': u'20', u'name': u'fanjy'&#125;, u'_id': ObjectId('5c24a2acdb1f5a209cf8799b'), u'id': 1&#125;&gt;&gt;&gt; for i in conn.yang.test.find(&#123;\"info.name\":&#123;\"$in\":['yangyanxing','xxxxx']&#125;&#125;):... print i...&#123;u'info': &#123;u'age': u'30', u'name': u'yangyanxing'&#125;, u'_id': ObjectId('5c24a27ddb1f5a209cf8799a'), u'id': 1&#125; 参考文章3分钟掌握MongoDB中的regex几种用法","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"别小看元组","slug":"tulple_detail","date":"2018-11-28T15:53:38.000Z","updated":"2018-11-29T15:45:06.002Z","comments":true,"path":"article/tulple_detail.html","link":"","permalink":"https://www.yangyanxing.com/article/tulple_detail.html","excerpt":"元组(tuple)和列表(list)，每个写python的都知道，而且都知道，元组是不可变的，但是仅仅因为一个不可变就要创造出一个新的数据类型吗？答案肯定不是，那么我们来看看元组究竟有哪些用法","text":"元组(tuple)和列表(list)，每个写python的都知道，而且都知道，元组是不可变的，但是仅仅因为一个不可变就要创造出一个新的数据类型吗？答案肯定不是，那么我们来看看元组究竟有哪些用法 1 把元组用作记录元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。正是这个位置信息给数据赋予了意义比如经纬度信息就可以用一个元组来表示123&gt;&gt;&gt; lax_coordinates = (33.9425, -118.408056)&gt;&gt;&gt; print('%s/%s'%lax_coordinates)33.9425/-118.408056 这里使用元组来表示一个位置的经纬度，在print 时可以将其信息直接打印出来. 2 元组拆包 分别赋值1city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014) 我们把元组 (‘Tokyo’, 2003, 32450, 0.66, 8014) 里的元素分别赋值给变量 city、year、pop、chg 和 area,最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋值到由对应的变量组成的元组中. 还可以用 * 运算符把一个可迭代对象拆开作为函数的参数 12345678def add(a,b): return a+btu = (3,4)print add(*tu)# 打印 7 也可以返回一个元组，在调用函数的时候分开接受这些返回值 123456def returntuple(): lax_coordinates = (33.9425, -118.408056) return lax_coordinateslatitude, longitude = returntuple()print latitude,longitude 用*来处理剩下的元素 123456789101112131415&gt;&gt;&gt; a, b, *rest = range(5)&gt;&gt;&gt; a, b, rest(0, 1, [2, 3, 4])&gt;&gt;&gt; a, b, *rest = range(3)&gt;&gt;&gt; a, b, rest(0, 1, [2])&gt;&gt;&gt; a, b, *rest = range(2)&gt;&gt;&gt; a, b, rest(0, 1, [])&gt;&gt;&gt; a, *body, c, d = range(5)&gt;&gt;&gt; a, body, c, d(0, [1, 2], 3, 4)&gt;&gt;&gt; *head, b, c, d = range(5)&gt;&gt;&gt; head, b, c, d([0, 1], 2, 3, 4) 3 具名元组这个之前很少接触，collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类，用 namedtuple 构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些。 1234567891011121314151617#coding:utf-8from collections import namedtupleCity = namedtuple('City', 'name country population coordinates')Loca = namedtuple('Loca','lat,lon')locatinfo = Loca(40.808611, -74.020386)city = City('New York-Newark', 'US', 20.104, locatinfo)print cityprint city.nameprint city.countryprint city.populationprint city.coordinatesprint city.coordinates.latprint city.coordinates.lon 打印结果为 City(name=’New York-Newark’, country=’US’, population=20.103999999999999, coordinates=Loca(lat=40.808610999999999, lon=-74.020386000000002))New York-NewarkUS20.104Loca(lat=40.808610999999999, lon=-74.020386000000002)40.808611-74.020386 创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字. 元组在平时的工作中使用较少,主要还是用列表比较多,具名元组这个非常适用于那些比较小的类,以后可以多用用. 参考书籍:流畅的python,文中大部分代码是从中摘抄","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中关于map,lambda,高阶函数与装饰器的使用","slug":"higher-order-function","date":"2018-07-01T15:53:38.000Z","updated":"2018-07-01T17:21:21.935Z","comments":true,"path":"article/higher-order-function.html","link":"","permalink":"https://www.yangyanxing.com/article/higher-order-function.html","excerpt":"有一点python基础的朋友在看到一些老鸟写的一些函数的时候，他们会有意的写出一些高阶函数，要么带个map啊，要么带个lambda呀，再高一点的带个@装饰器啊，其它这些也没有什么难的，用法上高级一些，如果能捋顺它的逻辑，准确的在实际应用中使用，还是会给程序效率上带来一定的提高，至于可读性，当你习惯了这些用法时你就会觉得它的可读性也很好，之所以你不习惯，主要还是由于你不懂它的用法，说到可读性，这是另外的话题，以后再详细的聊聊，今天要说的主要是高阶函数与装饰器的使用。希望看完此篇文章的朋友有所收获。","text":"有一点python基础的朋友在看到一些老鸟写的一些函数的时候，他们会有意的写出一些高阶函数，要么带个map啊，要么带个lambda呀，再高一点的带个@装饰器啊，其它这些也没有什么难的，用法上高级一些，如果能捋顺它的逻辑，准确的在实际应用中使用，还是会给程序效率上带来一定的提高，至于可读性，当你习惯了这些用法时你就会觉得它的可读性也很好，之所以你不习惯，主要还是由于你不懂它的用法，说到可读性，这是另外的话题，以后再详细的聊聊，今天要说的主要是高阶函数与装饰器的使用。希望看完此篇文章的朋友有所收获。 高阶函数高阶函数的定义：一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。常规函数的参数一般是个变量或者是个对象，比如定义一个求和函数1234567# coding:utf-8def sum(x,y): return x + yif __name__ == '__main__': print sum(3,4) 这里传入的参数，x,y 都是整数，返回的是它们的和。变量可否是一个函数呢？ 1234567&gt;&gt;&gt; s = sum&gt;&gt;&gt; s&lt;function sum at 0x01F96B70&gt;&gt;&gt;&gt; s.__name__'sum'&gt;&gt;&gt; s(6,7)13 把sum()函数 赋给变量s，s现在为一个函数，s的name为’sum’,可以调用s(6,7) 返回的就是sum(6,7)。 上面很简单，再来看一下高阶函数的定义，一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数,既然函数也可以作为另外的一个函数的参数，那么我们再来定义另外一个函数12345678910# coding:utf-8def sum(x,y): return x + ydef sum2(func,x,y): return func(x,y)if __name__ == '__main__': print sum2(sum,5,6) 这里定义一个sum2函数，它的返回值是func(x,y)。 函数作为返回值函数可以作为参数，也可以作为返回值12345678def sum3(x,y): def sum4(): return x+y return sum4f3 = sum3(1,2)print f3print f3() sum3 函数的返回值是sum4,但直接打印f3时显示的是&lt;function sum4 at 0x02142DB0&gt;,要执行这个函数需要调用执行一个f3函数f3() map函数上面的代码似乎没有什么具体的应用，只要为了说明，函数也可以作为参数传入另外的函数中，下面来看一下map函数map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。最简单的应用，给一个列表，返回该列表中每个元素的平方。1234567def f(x): return x*xl = range(1,10)l2 = map(f,l)print type(l2)print l2 在python2中map返回的是一个list,在python3中返回的是一个map对象，如果要得到新的列表，需要执行list(l2)操作，以下代码都是在python2环境下操作。 lambda 函数说叫函数，其实它是一种没有名字的函数，一次性使用，适用于那种简单的表达式可以不用定义一个函数，上面的求和与求立方。12345678l3 = map(lambda x:x*x,[1,2,3,4])print l3l4 = map(lambda x,y:x+y,[1,2,3,4],[5,6,7,8])print l4fl = lambda x:x*3print fl(10) 注意到lambda用在map函数中时，如果它的参数需要两个或者更多，那么在map的参数里也要传入相应个数的列表，且它的计算是列表中对应位置的表达式，比如求和，它是将列表1中的第一个元素和列表中第一个元素求和放到返回列表中的第一荐，列表的长度要一致，不能第一个列表有4个元素，第二个列表有3个或者5个，第二个列表也只能是4个。 装饰器有了上面的一些基础，接下来咱们看看本文的重点—-装饰器首先看一个简单函数的定义，打印当时日期时间 1234567from datetime import datetimedef showTime(): print datetime.now()showTime() 现在，假设我们要增强showTime函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改showTime函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。 定义一个函数12345def log(func): def wrapper(*args, **kw): print 'call %s():' % func.__name__ return func(*args, **kw) return wrapper 观察这个log函数，它的参数是一个函数，要执行传入参数的函数时，将其包了一层，做了一些别的事情，然后又将函数返回，return wrapper 所以本质上这个log就是一个返回函数的高阶函数。参考上面定义sum2函数,再来回看一下上面说明的函数作为返回值，其实这里它已经执行了func函数，对于上面的代码就是print datetime.now()装饰器的使用是在函数的定义处上面加上@符12345678910111213def log(func): def wrapper(*args, **kw): print 'call %s():' % func.__name__ return func(*args, **kw) return wrapper@logdef showTime(a,b): print a print datetime.now() print bshowTime('yang','fan') 加了装饰器以后，我们把调用showTime函数分解一下，它实际上是执行了log(showTime(&quot;yang&quot;,&quot;fan&quot;)) 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：123456789101112131415def log2(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator @log2(\"yyx\")def showTime(a,b): print a print datetime.now() print bshowTime('yang','fan') 上面的执行是这样的：首先执行log2(&#39;yyx&#39;)返回的是decorator函数，再调用返回的函数(decorator)，参数是showTime函数，返回值最终是wrapper函数,而wrapper函数将会执行showTime函数,所以在经过了log2装饰以后的调用分解开来应该是log2(“yyx”)(showTime(“yang”,”fan”))。 所以在写一个装饰器的时候，要区别装饰器本身是否需要有参数，如果没有，包一层即可，有参数的话需要包两层。 参考文章廖雪峰-函数式编程","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的list排序问题以及sort,sorted的使用","slug":"python-list-sort","date":"2018-06-28T15:53:38.000Z","updated":"2018-08-06T16:01:06.562Z","comments":true,"path":"article/python-list-sort.html","link":"","permalink":"https://www.yangyanxing.com/article/python-list-sort.html","excerpt":"列表list排序是一种非常常见的操作，里面有很多的方法也有很多的坑，这里简单的记录一下。","text":"列表list排序是一种非常常见的操作，里面有很多的方法也有很多的坑，这里简单的记录一下。 sorted 方法 123456789101112&gt;&gt;&gt; l = ['1','2','A','z','a',1,2]&gt;&gt;&gt; sorted(l)[1, 2, '1', '2', 'A', 'a', 'z']&gt;&gt;&gt; l['1', '2', 'A', 'z', 'a', 1, 2]&gt;&gt;&gt; l2 = sorted(l)&gt;&gt;&gt; l2[1, 2, '1', '2', 'A', 'a', 'z']&gt;&gt;&gt; id(l2)38967136&gt;&gt;&gt; id(l)38985520 sorted 方法传入一个列表，返回一个新的列表，并不影响原来列表的顺序，从上面的结果来看，数字排在了字符串之前，其实它是按照字符的ASCII的顺序排列的，那如果列表里是字符串呢？ 123&gt;&gt;&gt; l = [\"yang\",\"yan\",\"xing\",\"is\",\"a\",\"boy\"]&gt;&gt;&gt; sorted(l)['a', 'boy', 'is', 'xing', 'yan', 'yang'] 明显它是按照第一个字符来排，第一个字符相同再按第二个排。 sorted() 方法还有另外一个参数，reverse，当它为True的时候，将会倒序排列。 12&gt;&gt;&gt; sorted(l,reverse=True)&gt;&gt;&gt; ['yang', 'yan', 'xing', 'is', 'boy', 'a'] 可否直接改变原list的结构，而不是生成一个新的list呢？ 当然可以 sort方法 123456&gt;&gt;&gt; l[&apos;yang&apos;, &apos;yan&apos;, &apos;xing&apos;, &apos;is&apos;, &apos;a&apos;, &apos;boy&apos;]&gt;&gt;&gt; l.sort()&gt;&gt;&gt; l[&apos;a&apos;, &apos;boy&apos;, &apos;is&apos;, &apos;xing&apos;, &apos;yan&apos;, &apos;yang&apos;]&gt;&gt;&gt; 此时原列表l的结构已经变了，且该函数没有返回值，所以如果写成newL = l.sorr() 并不能得到一个新的列表，newL为空，所以不要用错了 这种排序也太简单了，我可否按照我自已的方法来排序呢？当然可以 自定义排序 需要提供一个排序的方法，该方法要有三种返回值，假如有两个值a1和a2，通过某种计算，如果返回大于0(True)的值，则a1排在后面，如果小于0(False)，a1排在前面，如果等于0，则a1和a2顺序不变，看代码 1234567891011121314151617181920212223#coding:gbka = [ &#123;'name':'jk', 'score':100, 'first':50, 'second':50, 'third':0&#125;, &#123;'name':'zz', 'score':90, 'first':50, 'second':30, 'third': 10&#125;, &#123;'name': 'yyx', 'score':90, 'first':40, 'second':30, 'third':20&#125;, &#123;'name': 'zs', 'score':90, 'first':40, 'second':30, 'third':20&#125;,]def cmp(a1, a2): if a1['score'] != a2['score']: return a1['score'] - a2['score'] elif a1['first'] != a2['first']: return a1['first'] - a2['first'] elif a1['second'] != a2['second']: return a1['second'] - a2['second'] else: return a1['third'] - a2['third'] a.sort(cmp)for i in a: print i 这里引出另外一个问题，字典是无序的，想要排字典，其实是排一组字典这里希望将上述的list排序，按照每条记录中的’score’排序。如果’score’字段的值相等，则按照’first’的值排序。如果’first’依旧相等，则按照’second’排序。如果’second’相等，则按照’third’字段的值来排序。该排序的结果为 {‘second’: 50, ‘score’: 100, ‘name’: ‘jk’, ‘third’: 0, ‘first’: 50}{‘second’: 30, ‘score’: 90, ‘name’: ‘zz’, ‘third’: 10, ‘first’: 50}{‘second’: 30, ‘score’: 90, ‘name’: ‘yyx’, ‘third’: 20, ‘first’: 40}{‘second’: 30, ‘score’: 90, ‘name’: ‘zs’, ‘third’: 20, ‘first’: 40} 还可以用sorted方法 1234&gt;&gt;&gt; student_tuples = [('john', 'A', 15),('jane', 'B', 12),('dave', 'B', 10)]# sort by age&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2])[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 参考文章python list 自定义排序Python之排序函数sort() 和 sorted()Python的排序：关于sort()与sorted()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的日志按天保存单独的文件","slug":"python-logging-day-file","date":"2018-06-24T15:53:38.000Z","updated":"2018-07-01T13:51:04.508Z","comments":true,"path":"article/python-logging-day-file.html","link":"","permalink":"https://www.yangyanxing.com/article/python-logging-day-file.html","excerpt":"在运行web的python程序时,日志最好是使用按天的保存,这样查看起来会很方便,也不至于日志文件太大不好打开python 自带的logging模块有着非常强大的作用","text":"在运行web的python程序时,日志最好是使用按天的保存,这样查看起来会很方便,也不至于日志文件太大不好打开python 自带的logging模块有着非常强大的作用 1234567891011121314151617181920212223242526import loggingimport time,sysfrom logging.handlers import TimedRotatingFileHandlerlog = logging.getLogger('yyx')log.setLevel(logging.DEBUG)formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")log_file_handler = TimedRotatingFileHandler(filename=\"log\", when=\"S\", interval=2)log_file_handler.setFormatter(formatter)log_file_handler.setLevel(logging.DEBUG)log.addHandler(log_file_handler)stream_handler = logging.StreamHandler(sys.stdout)stream_handler.setFormatter(formatter)log.addHandler(stream_handler)log.debug('111')log.error('11error')log.info('11info')time.sleep(2)log.error('222')time.sleep(2)log.info('333') TimedRotatingFileHandler类的参数意义如下: filename：日志文件名的prefix； when：是一个字符串，用于描述滚动周期的基本单位，字符串的值及意义如下：&nbsp;“S”: Seconds&nbsp;“M”: Minutes&nbsp;“H”: Hours&nbsp;“D”: Days&nbsp;“W”: Week day (0=Monday)&nbsp;“midnight”: Roll over at midnight interval: 滚动周期，单位有when指定，比如：when=’D’,interval=1，表示每天产生一个日志文件； backupCount: 表示日志文件的保留个数； 不写则全保存 除了上述参数之外，TimedRotatingFileHandler还有两个比较重要的成员变量，它们分别是suffix和extMatch。suffix是指日志文件名的后缀,suffix中通常带有格式化的时间字符串，filename和suffix由“.”连接构成文件名（例如：filename=“runtime”， suffix=“%Y-%m-%d.log”,生成的文件名为runtime.2015-07-06.log）","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"利用logging模块轻松地进行Python日志记录(转)","slug":"use-logging-in-python","date":"2018-06-23T15:53:38.000Z","updated":"2018-07-01T13:49:36.670Z","comments":true,"path":"article/use-logging-in-python.html","link":"","permalink":"https://www.yangyanxing.com/article/use-logging-in-python.html","excerpt":"在开发过程中，如果程序运行出现了问题，我们是可以使用我们自己的 Debug 工具来检测到到底是哪一步出现了问题，如果出现了问题的话，是很容易排查的。但程序开发完成之后，我们会将它部署到生产环境中去，这时候代码相当于是在一个黑盒环境下运行的，我们只能看到其运行的效果，是不能直接看到代码运行过程中每一步的状态的。在这个环境下，运行过程中难免会在某个地方出现问题，甚至这个问题可能是我们开发过程中未曾遇到的问题，碰到这种情况应该怎么办？如果我们现在只能得知当前问题的现象，而没有其他任何信息的话，如果我们想要解决掉这个问题的话，那么只能根据问题的现象来试图复现一下，然后再一步步去调试，这恐怕是很难的，很大的概率上我们是无法精准地复现这个问题的，而且 Debug 的过程也会耗费巨多的时间，这样一旦生产环境上出现了问题，修复就会变得非常棘手。但这如果我们当时有做日志记录的话，不论是正常运行还是出现报错，都有相关的时间记录，状态记录，错误记录等，那么这样我们就可以方便地追踪到在当时的运行过程中出现了怎样的状况，从而可以快速排查问题。因此，日志记录是非常有必要的，任何一款软件如果没有标准的日志记录，都不能算作一个合格的软件。作为开发者，我们需要重视并做好日志记录过程。","text":"在开发过程中，如果程序运行出现了问题，我们是可以使用我们自己的 Debug 工具来检测到到底是哪一步出现了问题，如果出现了问题的话，是很容易排查的。但程序开发完成之后，我们会将它部署到生产环境中去，这时候代码相当于是在一个黑盒环境下运行的，我们只能看到其运行的效果，是不能直接看到代码运行过程中每一步的状态的。在这个环境下，运行过程中难免会在某个地方出现问题，甚至这个问题可能是我们开发过程中未曾遇到的问题，碰到这种情况应该怎么办？如果我们现在只能得知当前问题的现象，而没有其他任何信息的话，如果我们想要解决掉这个问题的话，那么只能根据问题的现象来试图复现一下，然后再一步步去调试，这恐怕是很难的，很大的概率上我们是无法精准地复现这个问题的，而且 Debug 的过程也会耗费巨多的时间，这样一旦生产环境上出现了问题，修复就会变得非常棘手。但这如果我们当时有做日志记录的话，不论是正常运行还是出现报错，都有相关的时间记录，状态记录，错误记录等，那么这样我们就可以方便地追踪到在当时的运行过程中出现了怎样的状况，从而可以快速排查问题。因此，日志记录是非常有必要的，任何一款软件如果没有标准的日志记录，都不能算作一个合格的软件。作为开发者，我们需要重视并做好日志记录过程。 日志记录的流程框架那么在 Python 中，怎样才能算作一个比较标准的日志记录过程呢？或许很多人会使用 print 语句输出一些运行信息，然后再在控制台观察，运行的时候再将输出重定向到文件输出流保存到文件中，这样其实是非常不规范的，在 Python 中有一个标准的 logging 模块，我们可以使用它来进行标注的日志记录，利用它我们可以更方便地进行日志记录，同时还可以做更方便的级别区分以及一些额外日志信息的记录，如时间、运行模块信息等。接下来我们先了解一下日志记录流程的整体框架。整个日志记录的框架可以分为这么几个部分： Logger：即 Logger Main Class，是我们进行日志记录时创建的对象，我们可以调用它的方法传入日志模板和信息，来生成一条条日志记录，称作 Log Record。 Log Record：就代指生成的一条条日志记录。 Handler：即用来处理日志记录的类，它可以将 Log Record 输出到我们指定的日志位置和存储形式等，如我们可以指定将日志通过 FTP 协议记录到远程的服务器上，Handler 就会帮我们完成这些事情。 Formatter：实际上生成的 Log Record 也是一个个对象，那么我们想要把它们保存成一条条我们想要的日志文本的话，就需要有一个格式化的过程，那么这个过程就由 Formatter 来完成，返回的就是日志字符串，然后传回给 Handler 来处理。 Filter：另外保存日志的时候我们可能不需要全部保存，我们可能只需要保存我们想要的部分就可以了，所以保存前还需要进行一下过滤，留下我们想要的日志，如只保存某个级别的日志，或只保存包含某个关键字的日志等，那么这个过滤过程就交给 Filter 来完成。 Parent Handler：Handler 之间可以存在分层关系，以使得不同 Handler 之间共享相同功能的代码。 以上就是整个 logging 模块的基本架构和对象功能，了解了之后我们详细来了解一下 logging 模块的用法。 日志记录的相关用法总的来说 logging 模块相比 print 有这么几个优点： 可以在 logging 模块中设置日志等级，在不同的版本（如开发环境、生产环境）上通过设置不同的输出等级来记录对应的日志，非常灵活。 print 的输出信息都会输出到标准输出流中，而 logging 模块就更加灵活，可以设置输出到任意位置，如写入文件、写入远程服务器等。 logging 模块具有灵活的配置和格式化功能，如配置输出当前模块信息、运行时间等，相比 print 的字符串格式化更加方便易用。 下面我们初步来了解下 logging 模块的基本用法，先用一个实例来感受一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import logginglogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')logger = logging.getLogger(__name__)logger.info('This is a log info')logger.debug('Debugging')logger.warning('Warning exists')logger.info('Finish')``` 在这里我们首先引入了 logging 模块，然后进行了一下基本的配置，这里通过 basicConfig 配置了 level 信息和 format 信息，这里 level 配置为 INFO 信息，即只输出 INFO 级别的信息，另外这里指定了 format 格式的字符串，包括 asctime、name、levelname、message 四个内容，分别代表运行时间、模块名称、日志级别、日志内容，这样输出内容便是这四者组合而成的内容了，这就是 logging 的全局配置。接下来声明了一个 Logger 对象，它就是日志输出的主类，调用对象的 info() 方法就可以输出 INFO 级别的日志信息，调用 debug() 方法就可以输出 DEBUG 级别的日志信息，非常方便。在初始化的时候我们传入了模块的名称，这里直接使用 __name__ 来代替了，就是模块的名称，如果直接运行这个脚本的话就是 __main__，如果是 import 的模块的话就是被引入模块的名称，这个变量在不同的模块中的名字是不同的，所以一般使用 __name__ 来表示就好了，再接下来输出了四条日志信息，其中有两条 INFO、一条 WARNING、一条 DEBUG 信息，我们看下输出结果：&gt;2018-06-03 13:42:43,526 - __main__ - INFO - This is a log info2018-06-03 13:42:43,526 - __main__ - WARNING - Warning exists2018-06-03 13:42:43,526 - __main__ - INFO - Finish可以看到输出结果一共有三条日志信息，每条日志都是对应了指定的格式化内容，另外我们发现 DEBUG 的信息是没有输出的，这是因为我们在全局配置的时候设置了输出为 INFO 级别，所以 DEBUG 级别的信息就被过滤掉了。这时如果我们将输出的日志级别设置为 DEBUG，就可以看到 DEBUG 级别的日志输出了：logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')输出结果：&gt; 2018-06-03 13:49:22,770 - __main__ - INFO - This is a log info2018-06-03 13:49:22,770 - __main__ - DEBUG - Debugging2018-06-03 13:49:22,770 - __main__ - WARNING - Warning exists2018-06-03 13:49:22,770 - __main__ - INFO - Finish由此可见，相比 print 来说，通过刚才的代码，我们既可以输出时间、模块名称，又可以输出不同级别的日志信息作区分并加以过滤，是不是灵活多了？当然这只是 logging 模块的一小部分功能，接下来我们首先来全面了解一下 basicConfig 的参数都有哪些：- filename：即日志输出的文件名，如果指定了这个信息之后，实际上会启用 FileHandler，而不再是 StreamHandler，这样日志信息便会输出到文件中了。- filemode：这个是指定日志文件的写入方式，有两种形式，一种是 w，一种是 a，分别代表清除后写入和追加写入。- format：指定日志信息的输出格式，即上文示例所示的参数，详细参数可以参考：docs.python.org/3/library/l…，部分参数如下所示：&gt; %(levelno)s：打印日志级别的数值。%(levelname)s：打印日志级别的名称。%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]。%(filename)s：打印当前执行程序名。%(funcName)s：打印日志的当前函数。%(lineno)d：打印日志的当前行号。%(asctime)s：打印日志的时间。%(thread)d：打印线程ID。%(threadName)s：打印线程名称。%(process)d：打印进程ID。%(processName)s：打印线程名称。%(module)s：打印模块名称。%(message)s：打印日志信息。- datefmt：指定时间的输出格式。- style：如果 format 参数指定了，这个参数就可以指定格式化时的占位符风格，如 %、&#123;、$ 等。- level：指定日志输出的类别，程序会输出大于等于此级别的信息。- stream：在没有指定 filename 的时候会默认使用 StreamHandler，这时 stream 可以指定初始化的文件流。- handlers：可以指定日志处理时所使用的 Handlers，必须是可迭代的。下面我们再用一个实例来感受一下：``` pythonimport logginglogging.basicConfig(level=logging.DEBUG, filename='output.log', datefmt='%Y/%m/%d %H:%M:%S', format='%(asctime)s - %(name)s - %(levelname)s - %(lineno)d - %(module)s - %(message)s')logger = logging.getLogger(__name__)logger.info('This is a log info')logger.debug('Debugging')logger.warning('Warning exists')logger.info('Finish') 这里我们指定了输出文件的名称为 output.log，另外指定了日期的输出格式，其中年月日的格式变成了 %Y/%m/%d，另外输出的 format 格式增加了 lineno、module 这两个信息，运行之后便会生成一个 output.log 的文件，内容如下： 2018/06/03 14:43:26 - main - INFO - 9 - demo3 - This is a log info2018/06/03 14:43:26 - main - DEBUG - 10 - demo3 - Debugging2018/06/03 14:43:26 - main - WARNING - 11 - demo3 - Warning exists2018/06/03 14:43:26 - main - INFO - 12 - demo3 - Finish 可以看到日志便会输出到文件中，同时输出了行号、模块名称等信息。 以上我们通过 basicConfig 来进行了一些全局的配置，我们同样可以使用 Formatter、Handler 进行更灵活的处理，下面我们来了解一下。 Level首先我们来了解一下输出日志的等级信息，logging 模块共提供了如下等级，每个等级其实都对应了一个数值，列表如下： 等级 数值 CRITICAL 50 FATAL 50 ERROR 40 WARNING 30 WARN 30 INFO 20 DEBUG 10 NOTSET 0 这里最高的等级是 CRITICAL 和 FATAL，两个对应的数值都是 50，另外对于 WARNING 还提供了简写形式 WARN，两个对应的数值都是 30。我们设置了输出 level，系统便只会输出 level 数值大于或等于该 level 的的日志结果，例如我们设置了输出日志 level 为 INFO，那么输出级别大于等于 INFO 的日志，如 WARNING、ERROR 等，DEBUG 和 NOSET 级别的不会输出。 1234567891011import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.WARN)# Loglogger.debug('Debugging')logger.critical('Critical Something')logger.error('Error Occurred')logger.warning('Warning exists')logger.info('Finished') 这里我们设置了输出级别为 WARN，然后对应输出了五种不同级别的日志信息，运行结果如下： Critical SomethingError OccurredWarning exists 可以看到只有 CRITICAL、ERROR、WARNING 信息输出了，DEBUG、INFO 信息没有输出。 Handler下面我们先来了解一下 Handler 的用法，看下面的实例： 12345678910111213import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.INFO)handler = logging.FileHandler('output.log')formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')handler.setFormatter(formatter)logger.addHandler(handler)logger.info('This is a log info')logger.debug('Debugging')logger.warning('Warning exists')logger.info('Finish') 这里我们没有再使用 basicConfig 全局配置，而是先声明了一个 Logger 对象，然后指定了其对应的 Handler 为 FileHandler 对象，然后 Handler 对象还单独指定了 Formatter 对象单独配置输出格式，最后给 Logger 对象添加对应的 Handler 即可，最后可以发现日志就会被输出到 output.log 中，内容如下： 2018-06-03 14:53:36,467 - main - INFO - This is a log info2018-06-03 14:53:36,468 - main - WARNING - Warning exists2018-06-03 14:53:36,468 - main - INFO - Finish 另外我们还可以使用其他的 Handler 进行日志的输出，logging 模块提供的 Handler 有： StreamHandler：logging.StreamHandler；日志输出到流，可以是 sys.stderr，sys.stdout 或者文件。 FileHandler：logging.FileHandler；日志输出到文件。 BaseRotatingHandler：logging.handlers.BaseRotatingHandler；基本的日志回滚方式。 RotatingHandler：logging.handlers.RotatingHandler；日志回滚方式，支持日志文件最大数量和日志文件回滚。 TimeRotatingHandler：logging.handlers.TimeRotatingHandler；日志回滚方式，在一定时间区域内回滚日志文件。 SocketHandler：logging.handlers.SocketHandler；远程输出日志到TCP/IP sockets。 DatagramHandler：logging.handlers.DatagramHandler；远程输出日志到UDP sockets。 SMTPHandler：logging.handlers.SMTPHandler；远程输出日志到邮件地址。 SysLogHandler：logging.handlers.SysLogHandler；日志输出到syslog。 NTEventLogHandler：logging.handlers.NTEventLogHandler；远程输出日志到Windows NT/2000/XP的事件日志。 MemoryHandler：logging.handlers.MemoryHandler；日志输出到内存中的指定buffer。 HTTPHandler：logging.handlers.HTTPHandler；通过”GET”或者”POST”远程输出到HTTP服务器。 下面我们使用三个 Handler 来实现日志同时输出到控制台、文件、HTTP 服务器： 12345678910111213141516171819202122232425262728import loggingfrom logging.handlers import HTTPHandlerimport syslogger = logging.getLogger(__name__)logger.setLevel(level=logging.DEBUG)# StreamHandlerstream_handler = logging.StreamHandler(sys.stdout)stream_handler.setLevel(level=logging.DEBUG)logger.addHandler(stream_handler)# FileHandlerfile_handler = logging.FileHandler('output.log')file_handler.setLevel(level=logging.INFO)formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')file_handler.setFormatter(formatter)logger.addHandler(file_handler)# HTTPHandlerhttp_handler = HTTPHandler(host='localhost:8001', url='log', method='POST')logger.addHandler(http_handler)# Loglogger.info('This is a log info')logger.debug('Debugging')logger.warning('Warning exists')logger.info('Finish') 运行之前我们需要先启动 HTTP Server，并运行在 8001 端口，其中 log 接口是用来接收日志的接口。运行之后控制台输出会输出如下内容： This is a log infoDebuggingWarning existsFinish output.log 文件会写入如下内容： 2018-06-03 15:13:44,895 - main - INFO - This is a log info2018-06-03 15:13:44,947 - main - WARNING - Warning exists2018-06-03 15:13:44,949 - main - INFO - Finish HTTP Server 会收到控制台输出的信息。 这样一来，我们就通过设置多个 Handler 来控制了日志的多目标输出。 另外值得注意的是，在这里 StreamHandler 对象我们没有设置 Formatter，因此控制台只输出了日志的内容，而没有包含时间、模块等信息，而 FileHandler 我们通过 setFormatter() 方法设置了一个 Formatter 对象，因此输出的内容便是格式化后的日志信息。 另外每个 Handler 还可以设置 level 信息，最终输出结果的 level 信息会取 Logger 对象的 level 和 Handler 对象的 level 的交集。 Formatter在进行日志格式化输出的时候，我们可以不借助于 basicConfig 来全局配置格式化输出内容，可以借助于 Formatter 来完成，下面我们再来单独看下 Formatter 的用法： 123456789101112131415import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.WARN)formatter = logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%Y/%m/%d %H:%M:%S')handler = logging.StreamHandler()handler.setFormatter(formatter)logger.addHandler(handler)# Loglogger.debug('Debugging')logger.critical('Critical Something')logger.error('Error Occurred')logger.warning('Warning exists')logger.info('Finished') 在这里我们指定了一个 Formatter，并传入了 fmt 和 datefmt 参数，这样就指定了日志结果的输出格式和时间格式，然后 handler 通过 setFormatter() 方法设置此 Formatter 对象即可，输出结果如下： 2018/06/03 15:47:15 - main - CRITICAL - Critical Something2018/06/03 15:47:15 - main - ERROR - Error Occurred2018/06/03 15:47:15 - main - WARNING - Warning exists 这样我们可以每个 Handler 单独配置输出的格式，非常灵活。 捕获 Traceback如果遇到错误，我们更希望报错时出现的详细 Traceback 信息，便于调试，利用 logging 模块我们可以非常方便地实现这个记录，我们用一个实例来感受一下： 1234567891011121314151617181920212223242526import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.DEBUG)# Formatterformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')# FileHandlerfile_handler = logging.FileHandler('result.log')file_handler.setFormatter(formatter)logger.addHandler(file_handler)# StreamHandlerstream_handler = logging.StreamHandler()stream_handler.setFormatter(formatter)logger.addHandler(stream_handler)# Loglogger.info('Start')logger.warning('Something maybe fail.')try: result = 10 / 0except Exception: logger.error('Faild to get result', exc_info=True)logger.info('Finished') 这里我们在 error() 方法中添加了一个参数，将 exc_info 设置为了 True，这样我们就可以输出执行过程中的信息了，即完整的 Traceback 信息。运行结果如下： 2018-06-03 16:00:15,382 - main - INFO - Start print log2018-06-03 16:00:15,382 - main - DEBUG - Do something2018-06-03 16:00:15,382 - main - WARNING - Something maybe fail.2018-06-03 16:00:15,382 - main - ERROR - Faild to get resultTraceback (most recent call last): File “/private/var/books/aicodes/loggingtest/demo8.py”, line 23, in result = 10 / 0ZeroDivisionError: division by zero2018-06-03 16:00:15,383 - main - INFO - Finished可以看到这样我们就非常方便地记录下来了报错的信息，一旦出现了错误，我们也能非常方便地排查。 配置共享在写项目的时候，我们肯定会将许多配置放置在许多模块下面，这时如果我们每个文件都来配置 logging 配置那就太繁琐了，logging 模块提供了父子模块共享配置的机制，会根据 Logger 的名称来自动加载父模块的配置。例如我们这里首先定义一个 main.py 文件： 1234567891011121314151617import loggingimport corelogger = logging.getLogger('main')logger.setLevel(level=logging.DEBUG)# Handlerhandler = logging.FileHandler('result.log')handler.setLevel(logging.INFO)formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')handler.setFormatter(formatter)logger.addHandler(handler)logger.info('Main Info')logger.debug('Main Debug')logger.error('Main Error')core.run() 这里我们配置了日志的输出格式和文件路径，同时定义了 Logger 的名称为 main，然后引入了另外一个模块 core，最后调用了 core 的 run() 方法。接下来我们定义 core.py，内容如下： 12345678import logginglogger = logging.getLogger('main.core')def run(): logger.info('Core Info') logger.debug('Core Debug') logger.error('Core Error') 这里我们定义了 Logger 的名称为 main.core，注意这里开头是 main，即刚才我们在 main.py 里面的 Logger 的名称，这样 core.py 里面的 Logger 就会复用 main.py 里面的 Logger 配置，而不用再去配置一次了。运行之后会生成一个 result.log 文件，内容如下： 2018-06-03 16:55:56,259 - main - INFO - Main Info2018-06-03 16:55:56,259 - main - ERROR - Main Error2018-06-03 16:55:56,259 - main.core - INFO - Core Info2018-06-03 16:55:56,259 - main.core - ERROR - Core Error 可以看到父子模块都使用了同样的输出配置。如此一来，我们只要在入口文件里面定义好 logging 模块的输出配置，子模块只需要在定义 Logger 对象时名称使用父模块的名称开头即可共享配置，非常方便。文件配置在开发过程中，将配置在代码里面写死并不是一个好的习惯，更好的做法是将配置写在配置文件里面，我们可以将配置写入到配置文件，然后运行时读取配置文件里面的配置，这样是更方便管理和维护的，下面我们以一个实例来说明一下，首先我们定义一个 yaml 配置文件： 1234567891011121314151617181920212223242526272829303132version: 1formatters: brief: format: \"%(asctime)s - %(message)s\" simple: format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"handlers: console: class : logging.StreamHandler formatter: brief level : INFO stream : ext://sys.stdout file: class : logging.FileHandler formatter: simple level: DEBUG filename: debug.log error: class: logging.handlers.RotatingFileHandler level: ERROR formatter: simple filename: error.log maxBytes: 10485760 backupCount: 20 encoding: utf8loggers: main.core: level: DEBUG handlers: [console, file, error]root: level: DEBUG handlers: [console] 这里我们定义了 formatters、handlers、loggers、root 等模块，实际上对应的就是各个 Formatter、Handler、Logger 的配置，参数和它们的构造方法都是相同的。接下来我们定义一个主入口文件，main.py，内容如下： 12345678910111213141516171819202122232425262728import loggingimport coreimport yamlimport logging.configimport osdef setup_logging(default_path='config.yaml', default_level=logging.INFO): path = default_path if os.path.exists(path): with open(path, 'r', encoding='utf-8') as f: config = yaml.load(f) logging.config.dictConfig(config) else: logging.basicConfig(level=default_level)def log(): logging.debug('Start') logging.info('Exec') logging.info('Finished')if __name__ == '__main__': yaml_path = 'config.yaml' setup_logging(yaml_path) log() core.run() 这里我们定义了一个 setup_logging() 方法，里面读取了 yaml 文件的配置，然后通过 dictConfig() 方法将配置项传给了 logging 模块进行全局初始化。另外这个模块还引入了另外一个模块 core，所以我们定义 core.py 如下： 12345678import logginglogger = logging.getLogger('main.core')def run(): logger.info('Core Info') logger.debug('Core Debug') logger.error('Core Error') 这个文件的内容和上文是没有什么变化的。观察配置文件，主入口文件 main.py 实际上对应的是 root 一项配置，它指定了 handlers 是 console，即只输出到控制台。另外在 loggers 一项配置里面，我们定义了 main.core 模块，handlers 是 console、file、error 三项，即输出到控制台、输出到普通文件和回滚文件。这样运行之后，我们便可以看到所有的运行结果输出到了控制台： 2018-06-03 17:07:12,727 - Exec2018-06-03 17:07:12,727 - Finished2018-06-03 17:07:12,727 - Core Info2018-06-03 17:07:12,727 - Core Info2018-06-03 17:07:12,728 - Core Error2018-06-03 17:07:12,728 - Core Error 在 debug.log 文件中则包含了 core.py 的运行结果： 2018-06-03 17:07:12,727 - main.core - INFO - Core Info2018-06-03 17:07:12,727 - main.core - DEBUG - Core Debug2018-06-03 17:07:12,728 - main.core - ERROR - Core Error 可以看到，通过配置文件，我们可以非常灵活地定义 Handler、Formatter、Logger 等配置，同时也显得非常直观，也非常容易维护，在实际项目中，推荐使用此种方式进行配置。以上便是 logging 模块的基本使用方法，有了它，我们可以方便地进行日志管理和维护，会给我们的工作带来极大的方便。 日志记录使用常见误区在日志输出的时候经常我们会用到字符串拼接的形式，很多情况下我们可能会使用字符串的 format() 来构造一个字符串，但这其实并不是一个好的方法，因为还有更好的方法，下面我们对比两个例子： 12345678import logginglogging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')# badlogging.debug('Hello &#123;0&#125;, &#123;1&#125;!'.format('World', 'Congratulations'))# goodlogging.debug('Hello %s, %s!', 'World', 'Congratulations') 这里有两种打印 Log 的方法，第一种使用了字符串的 format() 的方法进行构造，传给 logging 的只用到了第一个参数，实际上 logging 模块提供了字符串格式化的方法，我们只需要在第一个参数写上要打印输出的模板，占位符用 %s、%d 等表示即可，然后在后续参数添加对应的值就可以了，推荐使用这种方法。运行结果如下： 2018-06-03 22:27:51,220 - root - DEBUG - Hello World, Congratulations!2018-06-03 22:27:51,220 - root - DEBUG - Hello World, Congratulations! 另外在进行异常处理的时候，通常我们会直接将异常进行字符串格式化，但其实可以直接指定一个参数将 traceback 打印出来，示例如下： 12345678910111213import logginglogging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')try: result = 5 / 0except Exception as e: # bad logging.error('Error: %s', e) # good logging.error('Error', exc_info=True) # good logging.exception('Error') 如果我们直接使用字符串格式化的方法将错误输出的话，是不会包含 Traceback 信息的，但如果我们加上 exc_info 参数或者直接使用 exception() 方法打印的话，那就会输出 Traceback 信息了。运行结果如下： 2018-06-03 22:24:31,927 - root - ERROR - Error: division by zero2018-06-03 22:24:31,927 - root - ERROR - ErrorTraceback (most recent call last): File “/private/var/books/aicodes/loggingtest/demo9.py”, line 6, in result = 5 / 0ZeroDivisionError: division by zero2018-06-03 22:24:31,928 - root - ERROR - ErrorTraceback (most recent call last): File “/private/var/books/aicodes/loggingtest/demo9.py”, line 6, in result = 5 / 0ZeroDivisionError: division by zero 出处信息 作者：崔庆才丨静觅链接：https://juejin.im/post/5b13fdd0f265da6e0b6ff3dd来源：掘金","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"配置多个ssh密钥对并且永久多ssh管理","slug":"config-local-ssh","date":"2018-06-16T15:53:38.000Z","updated":"2018-06-16T18:21:46.106Z","comments":true,"path":"article/config-local-ssh.html","link":"","permalink":"https://www.yangyanxing.com/article/config-local-ssh.html","excerpt":"这两天捣腾SSH，一直对其使用一知半解，由于要把博客迁移，弄来弄去发现还是部署到国内的coding吧之前也弄过，但是由于重新安装了git-for-windows客户端，所以一开始用hexo d命令部署的时候报错了趁着这次迁移也好好弄了一下本地的ssh管理，虽然还有些问题，但是至少比之前清晰一些了，这里也记录一下过程中遇到的问题","text":"这两天捣腾SSH，一直对其使用一知半解，由于要把博客迁移，弄来弄去发现还是部署到国内的coding吧之前也弄过，但是由于重新安装了git-for-windows客户端，所以一开始用hexo d命令部署的时候报错了趁着这次迁移也好好弄了一下本地的ssh管理，虽然还有些问题，但是至少比之前清晰一些了，这里也记录一下过程中遇到的问题 我的目的，将hexo生成的静态文件同时部署到github与coding上 安装git-for-windows客户端下载地址 https://git-scm.com/download/win无论是github还是coding都需要上传你的公钥，这两个地方可以上传相同的公钥，但也可以像我这样闲的蛋疼上传不同的公钥。 创建密钥对使用ssh-keygen 来创建密钥对，命令为 ssh-keygen -t rsa -C &quot;your_email@example.com&quot;,其实这里-C 后面的email地址无所谓，可以随便写，只是为了你方便而已。输入完该命令以后，首先会让你给密钥文件起个名字，这个是文件名，叫什么随心情接下来让你输入密码，我这里直接回车，不用密码然后它就会生成一个密钥对，像我这个设置就会生成yyxtest和yyxtest_pub两个文件，yyxtest.pub是公钥，谁都可以给，但是你私钥要自已保存好，谁拿到了你私钥就呵呵了。 上传公钥到github与coding中根据github上的提示将公钥上传到github上你的个人账户中的ssh中 同样的操作再生成一对密钥，将公钥上传到coding中，注意我这里是为了测试，你完全没有必要重新生成，你当然可以上传刚才生成的yyxtest.pub这个公钥，当然后面会有一些问题，之后再详细说明。 上传文件到github上 赶紧上传个文件到github上试试吧(使用hexo d 来部署)，其实你可以先不用上传文件，可以用ssh -vT git@github.com 来查看一下信息这里你不用试了，肯定是不行的…… 抗都被我踩了提示Permission denied,原因是你现在用的私钥还是id_rsa，并不是刚才生成的yyxtest，ssh默认使用id_rsa，如果连id_rsa都没有，那你还不赶紧生成一个默认的。 添加yyxtest私钥到git bash中根据github上的提示generate SSH keys 先将yyxtest添加到git bash中, 使用ssh-add ~/.ssh/yyxtest ,然后顺利提交代码成功，但是在提交文件到coding时又不行了，提示 Error: git@git.coding.net: Permission denied (publickey).fatal: Could not read from remote repository. 没办法，再用刚才的ssh-add 命令将用于coding的私钥也添加到git bash中，这次coding也可以提交了 配置ssh本地的config文件试试关掉这个git bash,然后再试着用hexo d 提交一些文件，这次又不行了，还是提示Permission denied，这怎么能行，总不能每次提交更新都输入ssh-add 添加各种私钥吧，这时就要用到config这个文件了。如果git安装是默认的话，将会把生成的公钥保存在C:\\Users\\username.ssh目录中(我用的是windows，不丢人)，里面如果没有config文件，自已生成一个,里面写一些配置信息,各种字段说明如下 Host：代码托管平台的别名,但是这个别名和后面要用到的ssh链接 git@github.com:xxx/xxx.git 中的 @ 符号后面的内容要一致，而一般来说github默认提供的就是git@github.com，因此为了方便，github的Host写github.com即可，别取别名了 HostName：代码托管平台真正的IP地址或域名,写域名就行， IdentityFile：对应的密钥文件路径。必须写绝对路径，windows下可以写 C:\\Users\\xxx.ssh\\yyxtest PreferredAuthentications：配置登录时用什么权限认证。可设为publickey，password publickey，keyboard-interactive等 User：对应的用户名。 我这里有两个私钥，所以我的配置文件如下1234567891011Host git.coding.net HostName git.coding.net IdentityFile C:\\Users\\kevin\\.ssh\\rsa_coding PreferredAuthentications publickey User yangyanxingHost github.com HostName github.com IdentityFile C:\\Users\\kevin\\.ssh\\yyx PreferredAuthentications publickey User kevinkelin 之前说过，你没有必要为不同的网站生成不同的密钥，用同一份也可以，如果用同一份，这里IdentityFile也要写一样的保存之后先不用着急提交，使用ssh -vT 查看一下连接是否有问题github 提示 Hi kevinkelin! You&#39;ve successfully authenticated, but GitHub does not provide shell access.coding提示 yangyanxing，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥这样就可以直接使用hexo d来提交文件更新了！ 注意的问题 config文件中的host 配置是区分大小写的，github.com 和github.COM是不同的，一定要写对 coding的host是git.coding.net 而不是coding.net 遗留问题git bash客户端，如果在非C盘上右键的方式启动，那么还是不行，它会寻找当前盘的中的.ssh目录，根本不存在的目录，所有找私钥肯定也找不到，只能先启动git bash,然后cd 到操作的目录中，这个我再研究研究怎么回事。 参考文章 配置本地和github的ssh密钥对：永久多ssh管理(win10) git window下配置SSH连接GitHub Generating a new SSH key and adding it to the ssh-agent","categories":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/tags/web/"}]},{"title":"将hexo生成的静态网站部署到七牛","slug":"put-html-to-qiniu","date":"2018-06-13T15:53:38.000Z","updated":"2018-06-13T15:21:08.515Z","comments":true,"path":"article/put-html-to-qiniu.html","link":"","permalink":"https://www.yangyanxing.com/article/put-html-to-qiniu.html","excerpt":"最近由于百度的BAE引擎取消了对基础版的支持，所以没有办法，继续寻找可以托管html的服务器。之前用过gitpages,coding与bae，这几个可以说各有各的特点，也各有各的缺点gitpages什么都好，就是访问相对慢，coding非要你加一个它们的链接，否则就要在访问网站最开始加个广告BAE呢，其实BAE基础版挺好的，访问速度快，价钱也合理，没想到他们将要取消了。在查找新的部署方案时发现有人提到七牛云存储，看了一下他们的文档，可以暂时的满足托管html纯静态网页需求。开始动工！","text":"最近由于百度的BAE引擎取消了对基础版的支持，所以没有办法，继续寻找可以托管html的服务器。之前用过gitpages,coding与bae，这几个可以说各有各的特点，也各有各的缺点gitpages什么都好，就是访问相对慢，coding非要你加一个它们的链接，否则就要在访问网站最开始加个广告BAE呢，其实BAE基础版挺好的，访问速度快，价钱也合理，没想到他们将要取消了。在查找新的部署方案时发现有人提到七牛云存储，看了一下他们的文档，可以暂时的满足托管html纯静态网页需求。开始动工！ 准备 备了案的域名 七牛账户，并且充了10块钱 一、使用hexo生成静态html资源，这个不用多说，使用hexo的都知道二、登录七牛账号，进入管理控制台，点击镜像存储，新建一个存储空间，访问控制一定要选择公开空间三、再点击绑定域名,将你网站的域名绑定到刚才创建的空间四、将静态网站资源上传到七牛，这里七牛会提供一些工具，windows下有可视化工具，linux与mac下有对应的命令行工具，选自已喜欢的，由于我现在是在windows下操作，所以我使用了可视化工具,下载https://developer.qiniu.com/kodo/tools/1666/qsunsync打开这个工具，先点击账号设置,输入你的AK与SK,这两个值可以到个人中心下的密钥管理中获取AK与SK设置好了以后就可以点击新建同步任务本地目录选择hexo生成的public目录，目标空间选择你刚才创建的空间切换到高级设置，这里一定要设置一下，遇到空间中存在同名文件则强制覆盖，否则之后生成的html如果同名的话就不会上传了每次同步前检查本地增量文件并上传也要勾上，否则新产生的文件不会上传 设置好了以后就可以点击开始同步了上传过程有点慢，要耐心等待。 五、根据七牛的提示，将域名cname到它给你的地址 六、最最关键的一步，空间设置如果不设置空间，那么你现在的七牛就是一个普通的存储文件的地址，还不能通过域名访问比如你的首页是 http://www.abc.com/ 如果你现在访问这个，会提示 error: “Document not found”，必须要加上 http://www.abc.com/index.html七牛现在比较人性化的添加了默认首页展示设定，一定要将其打开 这样就可以通过 http://www.abc.com/ 来访问网页了，访问categories等也会自动跳到相应的index.html页面 当cname生效以后就可以正常访问了 更新文章以后，有一个问题，七牛的缓存刷新的很慢，或者说刷新规则里设置的很慢，可以在域名管理处点击绑定的域名然后设置一些缓存规则 点击修改配置我将html的更新频率设置为1小时，并且全站缓存设置为1分钟 另外还可以根据自身的需求设置一些防盗链 大功告成，享受一下吧 要时刻关注一下域名的备案信息，如果哪天积案被注销了，七牛也会停止该域名的访问的！！！","categories":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/tags/web/"}]},{"title":"使用python操作selenium操作第三方浏览器(360浏览器)","slug":"use-selenium-op-browser","date":"2018-04-26T14:41:32.000Z","updated":"2018-04-26T16:50:55.574Z","comments":true,"path":"article/use-selenium-op-browser.html","link":"","permalink":"https://www.yangyanxing.com/article/use-selenium-op-browser.html","excerpt":"最近在测试一个项目，使用360浏览器来做一些操作之前使用过selenium来操作chrome和FireFox，这里记录一下","text":"最近在测试一个项目，使用360浏览器来做一些操作之前使用过selenium来操作chrome和FireFox，这里记录一下 环境：windows7 python2.6 webdriver 使用chrome进行测试安装selenium pip install selenium 下载浏览器驱动(chrome)浏览器驱动 一定要根据自已的chrome版本来下载对应的chromedriver 将chromedriver.exe的路径加到系统的环境变量中，个人用户和系统的都行简单的测试一下selenium是否工作正常123from selenium import webdriverd = webdriver.Chrome()d.get(r'http://www.yangyanxing.com') 当输入 d = webdriver.Chrome() 时，如果没有异常，那会将会打开Chrome浏览器 接下来就可以用selenium的接口来进行相应的操作了selenium的接口文档selenium接口文档 print d.find_element_by_class_name(‘text-muted’).text.encode(‘gbk’)京ICP备18004468号 使用第三方浏览器进行测试，这里以360安全浏览器为例首先查看它的chrome内核版本 它的版本是55的，好低啊，对应的chromedriver.exe是2.28，到https://chromedriver.storage.googleapis.com/index.html?path=2.28/ 处下载 这里要用到的是实例webdriver.Chrome()时要加上一些参数 1234chrome_options = webdriver.ChromeOptions()chrome_options.binary_location = r\"C:\\Users\\kevin\\AppData\\Roaming\\360se6\\Application\\360se.exe\" #这里是360安全浏览器的路径chrome_options.add_argument(r'--lang=zh-CN') # 这里添加一些启动的参数d = webdriver.Chrome(chrome_options=chrome_options) 不出意外的话将启动360安全浏览器，之后就可以继续使用selenium的api来操作网页了 可能出现的问题浏览器闪退 查看报错信息 raise exception_class(message, screen, stacktrace)selenium.common.exceptions.WebDriverException: Message: session not created exception: Chrome version must be &gt;= 65.0.3325.0 这个的意思就是chromedriver.exe版本不对，请下载与chrome内核版本对应的chromedriver.exe selenium.common.exceptions.WebDriverException: Message: ‘chromedriver’ executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home 这个的意思是chromedriver.exe 没有在环境变量里，请将chromedrive.exe放到环境变量里即可。 之后将研究一下远程的WebDriver。 参考文章Python爬虫利器五之Selenium的用法selenium 定制启动 chrome 的选项","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.yangyanxing.com/tags/自动化测试/"}]},{"title":"使用Redis作为消息队列实现生产消费与发布订阅","slug":"use-redis-for-mq-in-python","date":"2017-08-19T15:53:38.000Z","updated":"2019-01-23T13:33:30.752Z","comments":true,"path":"article/use-redis-for-mq-in-python.html","link":"","permalink":"https://www.yangyanxing.com/article/use-redis-for-mq-in-python.html","excerpt":"日常的工作中，经常会用到队列(Queue)，在python中有原生的队列，但是由于原生的队列是存在于内存当中，当系统重启后队列里的消息就没有，且无法进行分步式，Redis中的List数据有四种原语，LPUSH,LPOP,RPUSH,RPOP，配合使用可以实现简单的生产消费模型。","text":"日常的工作中，经常会用到队列(Queue)，在python中有原生的队列，但是由于原生的队列是存在于内存当中，当系统重启后队列里的消息就没有，且无法进行分步式，Redis中的List数据有四种原语，LPUSH,LPOP,RPUSH,RPOP，配合使用可以实现简单的生产消费模型。 原语说明push 是向列表中添加信息，pop是从列表中读取信息，l与r 则是左和右或者说列表头和列表尾，lpush将消息放到列表头，rpush将消息放到列表尾。 1234567891011121314151617&gt;&gt;&gt; import redis&gt;&gt;&gt; pool = redis.ConnectionPool(host='192.168.99.100', port=6739, db=0)&gt;&gt;&gt; r=redis.Redis(connection_pool=pool)&gt;&gt;&gt; r.lpush('task',\"task1\")1L&gt;&gt;&gt; r.lpush('task',\"task2\")2L&gt;&gt;&gt; r.lpush('task',\"task10\")3L&gt;&gt;&gt; r.lindex('task',0)'task10'&gt;&gt;&gt; r.lindex('task',1)'task2'&gt;&gt;&gt; r.lindex('task',2)'task1'&gt;&gt;&gt; r.lindex('task',3)&gt;&gt;&gt; 可以看出每次调用lpush时，数据都添加到列表的最前面. lpop是从列表的头开始出数据,现在task中有三条数据,[‘task10’,’task2’,’task1’],现在调用三次lpop12345678&gt;&gt;&gt; r.lpop('task')'task10'&gt;&gt;&gt; r.lpop('task')'task2'&gt;&gt;&gt; r.lpop('task')'task1'&gt;&gt;&gt; r.lpop('task')&gt;&gt;&gt; r.lpop('task') 可以看到lpop是从列表头中开始弹出数据的，当列表中没有数据的时候，则返回空。 rpush与rpop与其相反，从列表尾部进行操作123456789101112131415161718192021222324&gt;&gt;&gt; r.rpush('task',1)1L&gt;&gt;&gt; r.rpush('task',2)2L&gt;&gt;&gt; r.rpush('task',3)3L&gt;&gt;&gt; r.rpush('task',10)4L&gt;&gt;&gt; for i in range(4):... print r.lindex('task',i)...12310&gt;&gt;&gt; r.rpop('task')'10'&gt;&gt;&gt; r.rpop('task')'3'&gt;&gt;&gt; r.rpop('task')'2'&gt;&gt;&gt; r.rpop('task')'1'&gt;&gt;&gt; r.rpop('task') 实现生产消费模型那么利用列表的push与pop命令就可以实现简单的生产消费了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding:gbkimport redisimport time,threadingpool = redis.ConnectionPool(host='192.168.99.100', port=6739, db=0)r=redis.Redis(connection_pool=pool)def ping(r): # 一直执行ping命令，防止连接丢失 while 1: try: r.ping() except: pass finally: time.sleep(1)def producer(r,l): times = 10 while times &gt;0 : l.acquire() try: r.lpush('task','%s produce data'%threading.current_thread().name) finally: l.release() time.sleep(2) times -=1def consumer(r,l): while 1: l.acquire() task = None try: task = r.lpop('task') if task: print \"%s get a task %s \"%(threading.current_thread().name,task) finally: l.release() time.sleep(1)if __name__ == '__main__': thlist = [] t1 = threading.Thread(target=ping,args=(r,)) t1.setDaemon(True) thlist.append(t1) lock_c = threading.Lock() lock_p = threading.Lock() for i in range(10): #10个生产者与消费者 t_p = threading.Thread(target=producer,args=(r,lock_p),name=\"Producer:%s\"%i) t_c = threading.Thread(target=consumer, args=(r, lock_c), name=\"Consumer:%s\" % i) thlist.append(t_p) thlist.append(t_c) t_p.setDaemon(True) t_c.setDaemon(True) for th in thlist: th.start() # th.join() print 2222 time.sleep(10) 阻塞poplpop与rpop还有一个阻塞的版本,当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。 另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。 发布订阅可以配合使用publish 和 pubsub 来实现发布订阅 发布123pool = redis.ConnectionPool(host='192.168.99.100', port=6739, db=0)r=redis.Redis(connection_pool=pool)r.publish('mychanel','hello everyone') 该方法返回的是订阅者的数量 订阅12345pool = redis.ConnectionPool(host='192.168.99.100', port=6739, db=0)r=redis.Redis(connection_pool=pool)p = r.pubsub() #打开订阅功能p.subscribe(['mychanel']) # 订阅关注的频道，可以是多个p.parse_response() 订阅者能收到的信息只能是自它开始订阅之后的消息，之前已经发布的就不能收到了。 parse_response() 是阻塞的，只有当收到消息时才结束，可以写一个while 循环，但还有一个更好的方法，是调用它的listen() 方法 12&gt;&gt;&gt; for i in p.listen():... print i.get('data') redis可以作为简单的消息队列来用，但是它毕竟不是专业的消息队列，如果对于有很大的消息队列需求的系统还是考虑使用专业的MQ如kafka等。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的异常处理","slug":"try_in_python","date":"2017-08-19T15:53:38.000Z","updated":"2018-04-27T15:51:49.557Z","comments":true,"path":"article/try_in_python.html","link":"","permalink":"https://www.yangyanxing.com/article/try_in_python.html","excerpt":"写程序肯定要接触异常处理，还好python中的异常处理比较简单，但是有些细节还是需要好好看一下这里记录一下try在python中的使用。","text":"写程序肯定要接触异常处理，还好python中的异常处理比较简单，但是有些细节还是需要好好看一下这里记录一下try在python中的使用。 最简单的，try…except先看一下以下的代码执行情况1234567def test(): print 'yangyanxing' print 5/0 print 'end script....'if __name__ == '__main__': test() 程序运行到 print ‘yangyanxing’ 时，并没有出错，可以正常的输出但是当走到5/0的时候，会触发除0的错误，我们都知道，0是不能做为除数的，所以程序会在此处崩溃，下面的 print &#39;end script... &#39; 也就不会执行了执行程序得到以下的输出1234567yangyanxingTraceback (most recent call last): File &quot;try.py&quot;, line 11, in &lt;module&gt; test() File &quot;try.py&quot;, line 7, in test print 5/0ZeroDivisionError: integer division or modulo by zero 如何让程序可以正常的运行呢？很简单，加个try呗，把可能出现异常的地方进行捕获 1234567891011def test(): print 'yangyanxing' try: print 5/0 except Exception as e: print e print 'end script....'if __name__ == '__main__': test() 将得到以下的输出123yangyanxinginteger division or modulo by zeroend script.... 这样，当程序运行到出错的那行代码时，将执行except处定义代码，即 print e，然后程序接着就执行print &#39;end script....&#39; 可是，你不可能在执行每一步操作的时候都对其加上单独的try语句，那样程序看上去会很诡异，有时你也不知道会出什么错误，所以try的范围可以加大一些12345678910def test(): try: print 'yangyanxing' print 5/0 print 'end script....' except Exception as e: print eif __name__ == '__main__': test() 这时得到的输出是123yangyanxinginteger division or modulo by zero[Finished in 0.0s] 嗯，很简单是不是，你也不知道是哪行出的错误？你是不是想要得到更加详细的信息？python标准库已经为你准备好了，可以使用traceback来打印更加详细的异常信息 1234567891011121314151617#coding:utf-8import tracebackdef test(): try: print 'yangyanxing' print 5/0 print 'end script....' except Exception as e: print e print 1111 print traceback.format_exc()if __name__ == '__main__': test() 它的输出结果为1234567yangyanxinginteger division or modulo by zero1111Traceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test print 5/0ZeroDivisionError: integer division or modulo by zero 请看1111下面的那个trackback信息,这里标记的错误在哪一行，什么错误，一定要善用trackback try…except…finally这个比之前那个try…except多了一个finally，功能上也强大一些，这个finally不是必须的，使用的时候也根据实际情况自己来定。而且加了finally以后也有很多注意的地方。finally的意思是，无论程序是否有异常，最后都要执行它的代码。 看这样的例子12345678910111213141516#coding:utf-8import tracebackdef test(): try: print 'yangyanxing' print 5/0 print 'hello world' except Exception as e: print traceback.format_exc() finally: print 'end script....'if __name__ == '__main__': test() 得到的输出为1234567yangyanxingTraceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test print 5/0ZeroDivisionError: integer division or modulo by zeroend script.... 注意，这里print &#39;end script....&#39;被执行了，程序在print 5/0的时候发生的错误，在此中断，开始执行except代码，执行完except代码以后，就会执行finally代码，而出异常处后面的代码就不会被执行了 关于返回值的问题，看以下的代码 1234567891011121314151617181920#coding:utf-8import tracebackdef test(): try: if 2&gt;1: return 1 else: return 0 except Exception as e: print traceback.format_exc() return 2 finally: print 'end script....' return 3if __name__ == '__main__': print test() 它的返回值是什么呢？0？1？2？3？ 看一下程序运行的结果12end script....3 结果是3 也就是说，即使在try里定义了返回值，也是没有用的，程序最终返回的是finally中执行的返回值，所以如果使用finally的话，那么在try与except中最好不要定义返回值，可以将其保存到变量中，然后在finally中返回.1234567891011121314151617181920#coding:utf-8import tracebackdef test(): try: if 2&gt;1: result = 1 else: result = 0 except Exception as e: print traceback.format_exc() result = 2 finally: print 'end script....' return resultif __name__ == '__main__': print test() 这样程序返回值就是1了 函数中异常的嵌套使用这里不是try 里再加了个try，而是函数间的嵌套，看如下代码12345678910111213141516171819#coding:utf-8import tracebackdef test(): print 'start test...' test2() print 'end script...'def test2(): try: print 'start test2...' print 5/0 print 'end test2...' except Exception as e: print traceback.format_exc()if __name__ == '__main__': test() 它会有什么结果呢？ 12345678start test...start test2...Traceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 13, in test2 print 5/0ZeroDivisionError: integer division or modulo by zeroend script... 注意，这里在test2()函数中，已经将除0错误给逮到了，并且做了处理，所以在test函数中，不会受到什么影响，end script也可以正常的运行。但是，对于某些复杂的程序，当test2函数中发生异常的时候，调用它的函数以接下来的操作中得是在test2运行正常才会执行正常，这种就比较尴尬。怎么处理呢？ 答案是在test2中使用raise将这个异常抛出，让调用者知道，它出错了。123456789101112131415161718192021222324#coding:utf-8import tracebackdef test(): try: print 'start test...' test2() print 'end script...' except Exception as e: print traceback.format_exc()def test2(): try: print 'start test2...' print 5/0 print 'end test2...' except Exception as e: print traceback.format_exc() raise eif __name__ == '__main__': test() 得到的输出为12345678910111213start test...start test2...Traceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 16, in test2 print 5/0ZeroDivisionError: integer division or modulo by zeroTraceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test test2() File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 20, in test2 raise eZeroDivisionError: integer division or modulo by zero 上面的输出为test2()中打印的，下面的是test()函数打印的，这里test()函数中的print &#39;end script...&#39;因为抓到了异常而没有执行。 这里也是根据业务流程来灵活的使用raise，有时某个异常会导致大流程失败的时候则要将其抛出，比如最近在做的一个项目，虚拟机启动并且执行相应的测试代码，有时经常会遇到虚拟机没有启动成功，但是程序还是会执行接下来的代码，检查原因就是虚拟机的会滚操作，它抓了异常，但是并没有抛出，然后上层在调用的时候就没有判断它的会滚是否成功，这样就会造成程序一直错误的执行。 自定义异常有时候系统定义的这些异常不能满足需求时就需要自己定义一些异常，这个用的也比较多，比如要设计以下的场景，当循环到5次的时候，抛出一个’老子不干了，太累了’的异常12345678910111213141516171819202122232425262728#coding:utf-8import tracebackimport timedef test(): try: print 'start test...' test2() print 'end script...' except Exception as e: print traceback.format_exc()def test2(): try: times = 10 while times &gt; 0: print times if times == 5: raise TypeError('i don\\'t want to work....') times -=1 time.sleep(1) except Exception as e: print traceback.format_exc() raise eif __name__ == '__main__': test() 得到以下输出 1234567891011Traceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 19, in test2 raise TypeError(&apos;i don\\&apos;t want to work....&apos;)TypeError: i don&apos;t want to work....Traceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test test2() File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 24, in test2 raise eTypeError: i don&apos;t want to work.... 其实这里还不是自定义的异常，这里只是定义了异常信息，异常的类型还是TypeError，自定义的异常是写一个类继承自Exception123456789101112131415161718192021222324#coding:utf-8import tracebackimport timeclass IdontWantWork(Exception): def __init__(self,err=''): Exception.__init__(self,err)def test2(): try: times = 10 while times &gt; 0: print times if times == 5: raise IdontWantWork('老子不干了，太累了') times -=1 time.sleep(1) except Exception as e: print traceback.format_exc()if __name__ == '__main__': test2() 输出如下 123456789101098765Traceback (most recent call last): File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 25, in test2 raise IdontWantWork(&apos;老子不干了，太累了&apos;)IdontWantWork: 老子不干了，太累了 简单的异常就记录这些，以后再补充。 参考文章python 自定义异常和异常捕捉Python中的异常处理","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"使用python抓取自住房信息","slug":"use-python-get-house-info","date":"2017-07-11T14:41:32.000Z","updated":"2018-01-27T05:18:53.748Z","comments":true,"path":"article/use-python-get-house-info.html","link":"","permalink":"https://www.yangyanxing.com/article/use-python-get-house-info.html","excerpt":"使用python也有一段时间了，最近比较关注自住房信息，虽说它更新的比较缓慢，但是平时也不怎么会特意的去它的网站上去看，于是就想用python抓它的信息，如果有新的信息就给自己发个邮件，这样手机上得到通知以后就可以再去它的网站上看看。功能比较简单，但是用到的点还是挺多的，这里记录一下。主要有以下几个步骤 python beautifulsoup 与requests的使用 ubuntu 中安装 mysql 与mysql-python beautifulsoup与requests编码的问题 使用gmail发送邮件，其中gmail采用两步认证要单独申请一个密码 在ubuntu中使用crontab定时来触发脚本","text":"使用python也有一段时间了，最近比较关注自住房信息，虽说它更新的比较缓慢，但是平时也不怎么会特意的去它的网站上去看，于是就想用python抓它的信息，如果有新的信息就给自己发个邮件，这样手机上得到通知以后就可以再去它的网站上看看。功能比较简单，但是用到的点还是挺多的，这里记录一下。主要有以下几个步骤 python beautifulsoup 与requests的使用 ubuntu 中安装 mysql 与mysql-python beautifulsoup与requests编码的问题 使用gmail发送邮件，其中gmail采用两步认证要单独申请一个密码 在ubuntu中使用crontab定时来触发脚本 网站分析自住房信息的网址为 http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/tzgg/index.shtml主要就是抓取上面的通知，使用数据库或者本地文件记录一下url和标题主要就是以下这块html123456789&lt;ul opentype=\"page\"&gt; &lt;li&gt;&lt;a href=\"/bjjs/fwgl/zzxspzf/tzgg/427793/index.shtml\" onclick=\"void(0)\" target=\"_blank\" title=\"富兴鹏城自住型商品住房递补选房公告\"&gt;富兴鹏城自住型商品住房递补选房公告&lt;/a&gt;&lt;span&gt;2017-07-06&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/bjjs/fwgl/zzxspzf/tzgg/425403/index.shtml\" onclick=\"void(0)\" target=\"_blank\" title=\"朝阳区锦都家园自住型商品住房项目申购登记公告\"&gt;朝阳区锦都家园自住型商品住房项目申购登记公告&lt;/a&gt;&lt;span&gt;2017-06-12&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/bjjs/fwgl/zzxspzf/tzgg/425259/index.shtml\" onclick=\"void(0)\" target=\"_blank\" title=\"住总万科&amp;middot;TBD万科天地自住型商品住房递补选房公告\"&gt;住总万科&amp;middot;TBD万科天地自住型商品住房递补选房公告&lt;/a&gt;&lt;span&gt;2017-06-09&lt;/span&gt;&lt;/li&gt; .... ... .. .&lt;/ul&gt; 我这里使用的是beautifulsoup来进行解析。beautifulsoup的使用参考 beautifulsoup使用我一开始使用requests库的get方法来抓取网页，后来我被它的编码逼疯了，在网上查了下，requests与beautifulsoup都会对网页的编码进行优化， 但是它们同时优化就会出现很多头疼的问题，所以最后我使用python的urllib来抓取网页 1234url = r'http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/tzgg/index.shtml's = urllib.urlopen(url)if s.code == 200: soup = BeautifulSoup(s.read(),\"lxml\") 解析出url 与title信息123456789ulcontent = soup.find('ul',opentype=\"page\") for i in ulcontent.children: acontent = i.find('a') if type(acontent)!=int: title = acontent.get('title').encode('utf-8') if acontent.get('href').startswith(r'/'): url = \"%s%s\"%(r'http://www.bjjs.gov.cn',acontent.get('href')) else: url = acontent.get('href') 使用 soup.find(&#39;ul&#39;,opentype=&quot;page&quot;) 来定位到通知的ul dom结构，然后再寻找下面的a结构，美汤的用法还是很牛逼的。 使用mysql来记录得到url与title信息后，就去数据库中查寻一下，我一开始想用mongo，但是由于我的VPS是OpenVZ的，所以安装mongodb以后发现有很多问题，最后索性放弃，改用mysql。ubuntu 上安装mysql还是挺简单的 sudo apt-get install mysql-server mysql-client 安装过程中会设置root密码，安装结束后，我创建了一个库和表123mysql&gt; CREATE DATABASE houseinfo；mysql&gt; use houseinfo;mysql&gt; create table house ( id int NOT NULL AUTO_INCREMENT PRIMARY KEY, url text NOT NULL, title text NOT NULL) DEFAULT CHARSET=utf8; 在表中查询url字段是否存在,不存在的话就插入123456789101112131415161718192021222324252627282930313233343536def executesql(sql): dbo = MySQLdb.connect(\"localhost\",\"root\",\"password\",\"houseinfo\") cursor = dbo.cursor() data = '' try: cursor.execute(sql) if sql.startswith('select'): data = cursor.fetchall() elif sql.startswith('insert'): data = dbo.commit() except: print \"Error: unable to fecth data\" print traceback.format_exc() dbo.rollback() finally: dbo.close() return datas = urllib.urlopen(url)if s.code == 200: soup = BeautifulSoup(s.read(),\"lxml\") ulcontent = soup.find('ul',opentype=\"page\") for i in ulcontent.children: acontent = i.find('a') if type(acontent)!=int: title = acontent.get('title').encode('utf-8') if acontent.get('href').startswith(r'/'): url = \"%s%s\"%(r'http://www.bjjs.gov.cn',acontent.get('href')) else: url = acontent.get('href') sql = 'select * from house where url = \"%s\"'% url rst = executesql(sql) if not rst: insertsql = 'insert into house (url,title) values(\"%s\",\"%s\")'%(url,title) executesql(insertsql) 发送新通知邮件当有一个新的通知发出来以后需要发送一封邮件 因为VPS是在国外，所在我这里使用的是gmail的smtp服务，因为我的google账户采用了两步认证，所以这里还得重新申请一个临时密码，这里不得不提一下google的服务，太人性化了！具体使用请参考 https://support.google.com/accounts/answer/185833 1234567891011121314151617181920212223HOST = 'smtp.gmail.com'PORT = 587mail_username='yanxingyang@gmail.com' mail_password='linshimima'to_addrs=['yanxingyang@gmail.com'] def sendmail(contents,title): try: smtp = smtplib.SMTP() smtp.set_debuglevel(1) smtp.connect(HOST,PORT) smtp.starttls() smtp.login(mail_username,mail_password) msg = email.mime.text.MIMEText(contents,'html') msg['From'] = 'yanxingyang@gmail.com' msg['To'] = ';'.join(to_addrs) msg['Subject']= '有新的房产信息,请注意查看《%s》'% title smtp.sendmail('yanxingyang@gmail.com',to_addrs,msg.as_string()) except: print traceback.format_exc() finally: smtp.quit() 设置crontab任务在linux的世界里crontab绝对是神一样的存在使用参考 crontab使用 我这里设置的是每隔一个小时执行一次1* */1 * * * python /root/gethouseinfo.py 最终的效果是我收到了好多邮件。。。 mac上也可以实时的收到 最张的全代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8import time,os,sys,chardetfrom datetime import datetimeimport requestsfrom bs4 import BeautifulSoupimport jsonimport MySQLdbimport smtplibimport email.mime.textimport tracebackfrom email.utils import parseaddr, formataddrfrom email import encodersfrom email.header import Headerimport urllibHOST = 'smtp.gmail.com'PORT = 587mail_username='yanxingyang@gmail.com' mail_password='linshimima' to_addrs=['yanxingyang@gmail.com'] urls = [r'http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/tzgg/index.shtml']def sendmail(contents,title): try: smtp = smtplib.SMTP() smtp.set_debuglevel(1) smtp.connect(HOST,PORT) smtp.starttls() smtp.login(mail_username,mail_password) msg = email.mime.text.MIMEText(contents,'html') msg['From'] = 'yanxingyang@gmail.com' msg['To'] = ';'.join(to_addrs) msg['Subject']= '有新的房产信息,请注意查看《%s》'% title smtp.sendmail('yanxingyang@gmail.com',to_addrs,msg.as_string()) except: print traceback.format_exc() finally: smtp.quit()def executesql(sql): dbo = MySQLdb.connect(\"localhost\",\"root\",\"password\",\"houseinfo\") cursor = dbo.cursor() data = '' try: cursor.execute(sql) if sql.startswith('select'): data = cursor.fetchall() elif sql.startswith('insert'): data = dbo.commit() except: print \"Error: unable to fecth data\" print traceback.format_exc() dbo.rollback() finally: dbo.close() return datadef main(): for url in urls: # r = requests.get(url) s = urllib.urlopen(url) if s.code == 200: soup = BeautifulSoup(s.read(),\"lxml\") ulcontent = soup.find('ul',opentype=\"page\") for i in ulcontent.children: acontent = i.find('a') if type(acontent)!=int: title = acontent.get('title').encode('utf-8') if acontent.get('href').startswith(r'/'): url = \"%s%s\"%(r'http://www.bjjs.gov.cn',acontent.get('href')) else: url = acontent.get('href') sql = 'select * from house where url = \"%s\"'% url rst = executesql(sql) if not rst: insertsql = 'insert into house (url,title) values(\"%s\",\"%s\")'%(url,title) executesql(insertsql) contents = '&lt;h1&gt;%s&lt;/h1&gt;&lt;/br&gt;&lt;p&gt;%s&lt;/p&gt;'%(title,url) sendmail(contents,title)if __name__ == '__main__': main() 遗留的问题如果长时间的使用某个IP去抓该网站的信息它如果给封了IP就不行了，而且我也没有设置访问的header，以后可以设置一下代理或者header信息","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"用于python的定时任务apscheduler的使用","slug":"use-apscheduler","date":"2017-06-17T13:42:13.000Z","updated":"2017-12-26T16:10:18.786Z","comments":true,"path":"article/use-apscheduler.html","link":"","permalink":"https://www.yangyanxing.com/article/use-apscheduler.html","excerpt":"最近在项目中有一个比较特殊的需求，要求在每个月第二个周二暂停任务，然后周三再开启于是在网上查了一下，python中有一个apscheduler库可以实现，而且这个框架还挺强大的这里记录一下它的使用","text":"最近在项目中有一个比较特殊的需求，要求在每个月第二个周二暂停任务，然后周三再开启于是在网上查了一下，python中有一个apscheduler库可以实现，而且这个框架还挺强大的这里记录一下它的使用 安装我一开始在python2.6中安装的，但是安装有错误，估计是支持不好，在python2.7中是可以的 pip install apscheduler -i https://pypi.douban.com/simple 安装过程中会额外安装一个pytz的库，是关于timezone的 基础概念 参考 http://debugo.com/apscheduler/ 触发器(trigger)包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。除了他们自己初始配置意外，触发器完全是无状态的。作业存储(job store)存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。一个作业的数据讲在保存在持久化作业存储时被序列化，并在加载时被反序列化。调度器不能分享同一个作业存储。执行器(executor)处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。调度器(scheduler)是其他的组成部分。你通常在应用只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。你需要选择合适的调度器，这取决于你的应用环境和你使用APScheduler的目的。通常最常用的两个：– BlockingScheduler: 当调度器是你应用中唯一要运行的东西时使用。– BackgroundScheduler: 当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。 最主要用的就是scheduler与job store 作业存储一般存储分为内存存储和持久化的存储，推荐使用持久化的存储，这样一旦主机挂了或者重启了，这样只要重新运行脚本就可以接着运行了，我这里使用的是mongodb来存储。 调度器任务的执行调度工作由其来完成，主要用到的有BlockingScheduler（阻塞的），BackgroundScheduler（非阻塞的） 一个简单的例子，每隔5s钟输出‘hello world’，每天的13点50分输出‘i m blocking task’ 12345678910111213141516171819202122232425262728293031323334353637383940#coding:utf-8from apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.schedulers.blocking import BlockingSchedulerimport timefrom datetime import datetimefrom pymongo import MongoClientmongoDBhost = 'vps.yangyanxing.com' #mongodb 服务器mongoDBport = '29017' # 端口号mongoDBuser = 'yangyanxing' # 用户名mongoDBpwd = 'pwd' # 密码mongoclient = MongoClient(host=['%s:%s'%(mongoDBhost,mongoDBport)])mongoclient.admin.authenticate(mongoDBuser,mongoDBpwd)dbjob = mongoclient.mac.jobs # mongodb所用到的collection，这里是BackgroundScheduler的dbjob_b = mongoclient.mac.jobs_block # mongodb所用到的collection，这里是blockingScheduler的job_defaults = &#123; 'coalesce': False, 'max_instances': 3, 'misfire_grace_time': 30&#125;def timetest(): print 'hello world'def timetestblock(): print 'i m blocking task'if __name__ == '__main__': scheduler = BackgroundScheduler(job_defaults=job_defaults) scheduler_b = BlockingScheduler(job_defaults=job_defaults) scheduler.add_jobstore('mongodb', client=dbjob) scheduler_b.add_jobstore('mongodb', client=dbjob_b) scheduler.add_job(timetest, 'interval', seconds=5) scheduler_b.add_job(timetestblock, 'cron', minute=50, hour=13, start_date=datetime.now()) scheduler.start() scheduler_b.start() 运行脚本发现报错了。。。 pytz.exceptions.UnknownTimeZoneError: u’Can not find timezone China Standard time’ 有的环境是不报这个错误的，如果报的话就手动指定一个时区，指定一个pytz库中定义了的时区，可以在site-packages中查看一下，具体原因没有细追。。。 1234timez = pytz.timezone(&apos;Asia/Shanghai&apos;)# 初始化scheduler的时候加上timezone参数scheduler = BackgroundScheduler(job_defaults=job_defaults,timezone=timez)scheduler_b = BlockingScheduler(job_defaults=job_defaults,timezone=timez) 再次运行该脚本，则可以正常运行了，查看mongo数据库 这里也记录着next_run_time 最终的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding:utf-8from apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.schedulers.blocking import BlockingSchedulerimport timefrom datetime import datetimefrom pymongo import MongoClientimport pytz'''两个问题1. 对于 interval，比如说每5秒钟进行一次的任务，当该脚本被停了，重新运行该脚本的时候，已经过了nexttime了， 程序是怎么操作的2. 报pytz.exceptions.UnknownTimeZoneError: u'Can not find timezone China Standard time' 的问题'''timez = pytz.timezone('Asia/Shanghai')# 当有不识别的timezone的时候，初始化的时候可以加上timezone，最好也要加上，否则时间日期不对应会出问题mongoDBhost = 'vps.yangyanxing.com'mongoDBport = '29017'mongoDBuser = 'yangyanxing'mongoDBpwd = 'pwd'mongoclient = MongoClient(host=['%s:%s'%(mongoDBhost,mongoDBport)])mongoclient.admin.authenticate(mongoDBuser,mongoDBpwd)dbjob = mongoclient.mac.jobsdbjob_b = mongoclient.mac.jobs_blockjob_defaults = &#123; 'coalesce': False, 'max_instances': 3, 'misfire_grace_time': 30&#125;def timetest(): print time.strftime('%Y%m%d--%H:%M:%S',time.localtime(time.time())),'hello world'def timetestblock(): print 'i m blocking task'if __name__ == '__main__': scheduler = BackgroundScheduler(timezone=timez) scheduler_b = BlockingScheduler(timezone=timez) scheduler.add_jobstore('mongodb', client=dbjob) scheduler_b.add_jobstore('mongodb', client=dbjob_b) scheduler.add_job(timetest, 'interval', seconds=5) scheduler_b.add_job(timetestblock, 'cron', minute=50, hour=13, start_date=datetime.now()) scheduler.start() scheduler_b.start() 几个问题1、运行的时候会有一些误差，由于我这个mongodb在国外的VPS上，所以在操作的时候就有一些延迟，正常如果很快的话误差不会很大2、关于timezone，如果有报错的话则要手工的指定，在中国境内可以定义为’Asia/Shanghai’3、添加作业的时候，类型可以为cron,这个定义和linux中的crontab格式，比较灵活，而且它本身就可以定义第周几进行，第几个星期几等，推荐使用4、添加作业的时候也可以使用装饰器123@scheduler_b.scheduled_job('cron',id='timetest_b',minute=50, hour=13)def timetestblock(): print 'i m blocking task'","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"webpy的常规使用与踩过的坑","slug":"use-webpy","date":"2016-12-21T13:42:13.000Z","updated":"2017-12-16T10:11:00.516Z","comments":true,"path":"article/use-webpy.html","link":"","permalink":"https://www.yangyanxing.com/article/use-webpy.html","excerpt":"在使用python做网站的时候首先接触的就是webpy了，这个框架小巧简单，对于小型的网络应用功能足以了，在使用的过程中也遇到过一些总是，在这里也记录总结一下 基础的框架搭建安装1pip install web.py -i https://pypi.douban.com/simple","text":"在使用python做网站的时候首先接触的就是webpy了，这个框架小巧简单，对于小型的网络应用功能足以了，在使用的过程中也遇到过一些总是，在这里也记录总结一下 基础的框架搭建安装1pip install web.py -i https://pypi.douban.com/simple hello world1234567891011import weburls = (\"/.*\", \"hello\")app = web.application(urls, globals())class hello: def GET(self): return 'Hello, world!'if __name__ == \"__main__\": app.run() return 可以返回字符串也可以返回字典，不过直接返回字符串不是一个很好的网页习惯，如果是对外提供的api是很好的，但是如果是做的网页，最好还是将数据render（渲染）到模板中 使用GET或者POST接收数据web.input() 既可以接收GET的数据，也可以接收POST过来的数据 web.data() 通过这个方法可以取到数据 12345678910111213import weburls = (\"/.*\", \"hello\")app = web.application(urls, globals())class hello: def GET(self): return 'Hello, world!' def POST(self): username = web.input().get('username','')if __name__ == \"__main__\": app.run() 模板的定义使用123456789101112131415import weburls = (\"/.*\", \"hello\")app = web.application(urls, globals())class hello: def GET(self): return 'Hello, world!' app_root = os.path.dirname(__file__) #定义根路径templates_root = os.path.join(app_root, 'templates') #定义模板所在的路径render = web.template.render(templates_root)if __name__ == \"__main__\": app.run() 使用的时候用return render如： return rende.index() 则需要在templates目录下创建一个index.html 这样访问 模板中使用渲染的数据当有以下代码的时候12name = 'yangyanxing'return render.index(name) 此时可以在index.html中使用渲染过来的name值 1234567$def with(name_t)&lt;html&gt; &lt;body&gt; hello $name_t &lt;/body&gt;&lt;/html&gt; $def with 必须写在首行，with里面有多少个参数，那个在之前的py文件中就需要render多少个参数，多了少了都不行，with里可以使用默认参数，这个和一般的函数定义是一样的。 中级使用session的使用 session 可以使用文件的形式也可以存储在数据库中 1234567891011121314151617181920212223import weburls = (\"/.*\", \"hello\")app = web.application(urls, globals())store = web.session.DiskStore('sessions') #定义session使用文件存储方式#定义session格式，使用本地存储，还可以使用数据库存储方式if web.config.get('_session') is None: session = web.session.Session(app, store,) web.config._session = sessionelse: session = web.config._sessionclass hello: def GET(self): return 'Hello, world!' app_root = os.path.dirname(__file__) #定义根路径templates_root = os.path.join(app_root, 'templates') #定义模板所在的路径render = web.template.render(templates_root,globals=&#123;'session': session&#125;) #将session应用到模板中if __name__ == \"__main__\": app.run() session的赋值 12username = 'yangyanxing'session.realname = username session的读取 print session.realname session在模板中的使用 123$def with (something)$session.realname 上面在定义 render = web.template.render(templates_root,globals={‘session’: session}) 时globals={&#39;session&#39;: session} 这里如果定义成globals={&#39;session_t&#39;: session} 那么在模板中使用session中也要使用`$session_t 模板布局的使用有时候对于一个小型网站，它的header与footer是一样的，只是中间的内容不一样，那么可以定义一个模板，base.html包括了header与footer，其它模板在定义的时候只要引用这个模板就行了，这样做的好处也在于当修改base.html，不用修改每一个模板。首先定义一个基础的模板，我这里就叫做base.html123456789101112131415161718192021222324$def with (content)&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;meta name=”renderer” content=”webkit” /&gt;&lt;title&gt;欢迎来到我们的世界&lt;/title&gt;&lt;/head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt; something here &lt;/div&gt; &lt;div class=\"container\"&gt; $:content &lt;footer&gt; &lt;p&gt;&amp;copy; yangyanxing.com 2016&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这里有两个要点 $def with (content) 这里的content可以随意写，而下面的$:content 则是别的模板文件内容，可以这样理解，当你再使用return render.index(name) 时，其实它是将index.html里的内容当成这里的content 这样也就实现了一个基础的模板，只更新里面的内容的效果。 定义完基础模板还不行，如果要使其生效还得在py文件中修改以下定义render的代码render = web.template.render(templates_root,globals={&#39;session&#39;: session},base=&#39;base&#39;)这样定义render才能将base.html设置为基础模板 此时如果index.html中是以下的样子12$def with (name)hello $name 那么当你有以下代码的时候12myname = 'yangyanxing'return render.index(myname) 那么最终生成的html应该是12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;meta name=”renderer” content=”webkit” /&gt;&lt;title&gt;欢迎来到我们的世界&lt;/title&gt;&lt;/head&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt; something here &lt;/div&gt; &lt;div class=\"container\"&gt; hello yangyanxing &lt;footer&gt; &lt;p&gt;&amp;copy; yangyanxing.com 2016&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 高级使用(踩过的坑)checkbox传过来多个值的时候数据的处理有这种情况，有一个表单它的name值下面是checkbox，如以下的html123456789&lt;form action='/groupaddcase' method='POST'&gt;&lt;input type=\"checkbox\" name=\"caseids\" value=\"1\" checked=\"true\"&gt;1&lt;input type=\"checkbox\" name=\"caseids\" value=\"2\" &gt;2&lt;input type=\"checkbox\" name=\"caseids\" value=\"3\" &gt;3&lt;input type=\"checkbox\" name=\"caseids\" value=\"4\" &gt;4&lt;input type=\"checkbox\" name=\"caseids\" value=\"5\" &gt;5&lt;input class=\"btn btn-success\" type=\"submit\" value=\"修改\"&gt;&lt;/form&gt; 此时如果在py中处理如下1234class Groupaddcase: def POST(self): caseids = web.input().get('caseids') print caseids 这样处理的话那么传过来的caseids只有一个，当你勾选了多个checkbox时也只有一个数据传过来，解决的办法是在接收的时候将其定义成数组1234class Groupaddcase: def POST(self): groupinfo = web.input(caseids=[]) groupid = groupinfo.get('groupid','') 这样groupid就以数组的形式保存了传过来的checkbox的值,多个checkbox可以定义多个数组groupinfo = web.input(caseids=[],casenames=[]) 添加一个hook来处理在所有请求前做的处理有时会有这样的需求，需要屏蔽某一个IP的客户端访问或者在访问前需要检查一下是否登录了，这种情况下可以使用hook方法来控制12345678def __redirect(): rejectIP = ['192.168.0.101'] if web.ctx.ip in rejectIP: raise web.seeother(r'http://so.com') if __name__ == \"__main__\": app.add_processor(web.loadhook(__redirect)) app.run() 模板中使用python的逻辑处理方法 判断 1234$if condition: &lt;td&gt;yes&lt;/td&gt;$else: &lt;td&gt;no&lt;/td&gt; 循环 12$for item in some_array: &lt;td&gt;$item['title']&lt;/td&gt; 判断和循环的使用都要在前面加一个$,以: 结尾，且下面的语句也要遵守缩进规则","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"webpy","slug":"webpy","permalink":"https://www.yangyanxing.com/tags/webpy/"}]},{"title":"在MAC下加载NTFS移动硬盘或者U盘","slug":"use-mac-mount-ntfs-disk","date":"2016-07-12T05:49:01.000Z","updated":"2017-12-16T10:10:41.887Z","comments":true,"path":"article/use-mac-mount-ntfs-disk.html","link":"","permalink":"https://www.yangyanxing.com/article/use-mac-mount-ntfs-disk.html","excerpt":"在windows下使用的移动硬盘或者U盘大部分都是ntfs格式，在MAC下默认是不支持的，将一块硬盘分两个区一个给windows用一个给MAC用也不大方便，可以借用第三方软件来支持，其实仔细想想这样的功能苹果公司在技术上肯定是可以支持的，只是由于种种原因微软不让其默认支持，以下的方法不借用任何第三方软件，几条命令搞定在MAC下挂载nfts硬盘。","text":"在windows下使用的移动硬盘或者U盘大部分都是ntfs格式，在MAC下默认是不支持的，将一块硬盘分两个区一个给windows用一个给MAC用也不大方便，可以借用第三方软件来支持，其实仔细想想这样的功能苹果公司在技术上肯定是可以支持的，只是由于种种原因微软不让其默认支持，以下的方法不借用任何第三方软件，几条命令搞定在MAC下挂载nfts硬盘。 打开终端查看磁盘的Volume Name 插件移动硬盘或者U盘，打开终端，输入diskutil list 命令来查看磁盘信息 上面的是本机的磁盘，下面那个disk2是U盘，可以看到type是windows_NTFS,NAME是奔波霸记住这个奔波霸 sudo打开/etc/fstab sudo vim /etc/fstab 有的系统可能没有这个文件，那么就新建一个输入LABEL=奔波霸 none ntfs rw,auto,nobrowseLABEL为刚才记录的值，这里也可以是中文(有时中文会有问题，最好还是将磁盘设置为英文的)，如果有空格的话使用\\040代替 后面的ntfs rw表示把这个分区挂载为可读写的ntfs格式，最后nobrowse非常重要，因为这个代表了在finder里不显示这个分区，这个选项非常重要，如果不打开的话挂载是不会成功的。编辑好以后重新插入磁盘，就能识别到了。 建立一个软链接到Volumes文件夹下 sudo ln -s /Volumes ~/Desktop/Volumes 这样就在桌面上创建了一个指向/Volumes的链接，以后接上磁盘的时候就可以方便的从桌面上进入磁盘了。 参考文章：http://www.tianwaihome.com/2014/07/mac-osx-ntfs.html","categories":[{"name":"mac","slug":"mac","permalink":"https://www.yangyanxing.com/categories/mac/"}],"tags":[]},{"title":"Xposed框架初体验","slug":"first-use-Xposed","date":"2016-06-11T16:05:17.000Z","updated":"2017-12-16T10:10:42.287Z","comments":true,"path":"article/first-use-Xposed.html","link":"","permalink":"https://www.yangyanxing.com/article/first-use-Xposed.html","excerpt":"想必很多人都听说过微信抢红包插件，但是很少有人想过它是怎么实现的，以前我以为是可能通过监听某个消息广播或者什么的，但是前几天在testerhome中看到有一篇介绍Xposed框架的文章用黑客思维做测试——神器 Xposed 框架介绍,我觉得这应该是广大抢红包插件的实现。正好有个同事和我说过有一个微信计步的作弊器(汗，怎么这个东西净用在这方面呢)手把手教你当微信运动第一名,于是对这个大名鼎鼎的Xposed学习了一番，觉得它有很多潜能！","text":"想必很多人都听说过微信抢红包插件，但是很少有人想过它是怎么实现的，以前我以为是可能通过监听某个消息广播或者什么的，但是前几天在testerhome中看到有一篇介绍Xposed框架的文章用黑客思维做测试——神器 Xposed 框架介绍,我觉得这应该是广大抢红包插件的实现。正好有个同事和我说过有一个微信计步的作弊器(汗，怎么这个东西净用在这方面呢)手把手教你当微信运动第一名,于是对这个大名鼎鼎的Xposed学习了一番，觉得它有很多潜能！ 参考文章用黑客思维做测试——神器 Xposed 框架介绍Android Hook神器：XPosed入门与登陆劫持演示Xposed Home 关于XposedXposed 框架是一款可以在不修改APK的情况下影响程序运行（修改系统）的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。 基本原理Zygote 进程是 Android 的核心，所有的应用程序进程以及系统服务进程都是由Zygote进程 fork 出来的。Xposed Framework 深入到了 Android 核心机制中，通过改造 Zygote 来实现一些很牛逼的功能。Zygote 的启动配置在/init.rc 脚本中，由系统启动的时候开启此进程，对应的执行文件是/system/bin/app_process，这个文件完成类库加载及一些初始化函数调用的工作。 当系统中安装了 Xposed Framework 之后，会拿自己实现的 app_process 覆盖掉 Android 原生提供的文件，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。 安装在android5.0以上要使用不同的包，具体可以参考http://repo.xposed.info/module/de.robv.android.xposed.installer为了方便我使用了一台android4.4的手机，只要安装一个apk即可，手机要有root，因为安装Xposed的时候需要root，但是一旦安装成功则不再需要root了，安装后启动 按照上面的说明点击安装，如果顺利的话重启后就可以正常的使用了 写hook模块使用Xposed网站已经有很多别人写好的模块，可以直接下载安装使用，也可以自已写模块，模块其实就是一个apk，按照一定的规则生成的，当安装模块以后，Xposed会自已识别。开始自已写一个小demo吧，采用testerhome中的那个hook取时间的例子。 首先先写测试的apk1234567891011121314151617181920212223242526272829303132333435363738package com.example.showtimer;import java.util.Calendar;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.view.Window;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); final TextView tv = (TextView) findViewById(R.id.tv); Button show = (Button) findViewById(R.id.showTimer); show.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH); int day = c.get(Calendar.DAY_OF_MONTH); int hour = c.get(Calendar.HOUR); int min = c.get(Calendar.MINUTE); String time = \"\"+year+\"-\"+month+\"-\"+day+\" \"+hour+\":\"+min; tv.setText(time); &#125; &#125;);&#125; 这个apk很简单，点击按钮后，显示了当前的时间 写hook模块只要修改系统的java.util.Calendar类中的get函数，并修改相应的返回值则能达到hook目的 新建一个hookTest的android项目并将XposedBridgeApi-54.jar加入项目的build-path中api下载地址 http://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067在项目中新建一个lib目录，将jar包放进去，添加到build paht中 新建一个Hook类实现IXposedHookLoadPackage接口实现handleLoadPackage方法12345public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable &#123; if (!lpparam.packageName.equals(\"com.example.showtimer\")) return; XposedBridge.log(\"Loaded app name : \" + lpparam.packageName); &#125; 上面的代码定义了只有packageName是com.example.showtimer才进行hook操作，其它的放过 findAndHookMethod() 方法是找到并且Hook方法findAndHookMethod的参数说明第一个参数定义了要hook的类，对于某个akp来说就是其包名+activity，第二个参数是个固定的lpparam.classLoader，第三个是要hook的方法名，之后的参数是这个方法需要的参数类型class，有几个就写几个，最后是初始化一个XC_MethodHook的对象。然后重写其beforeHookedMethod与afterHookedMethod方法。12345678910111213findAndHookMethod(\"java.util.Calendar\", lpparam.classLoader,\"get\",int.class,new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; // this will be called before the clock was updated by the original method XposedBridge.log(\"Enter-&gt;beforeHookedMethod:Calendar.get\"); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // this will be called after the clock was updated by the original method XposedBridge.log(\"Enter-&gt;afterHookedMethod:Calendar.get\"); param.setResult((int)11); &#125; &#125;); 在findAndHookMethod中重写了两个方法，beforeHookedMethod和afterHookedMethod，看名字也能猜出它们的作用，before是在hook之前，可以得到一些正常的值，after那个函数则可以修改一些返回值。上面这里就是将java.util.Calendar这个类的get方法所有返回值都修改为11 Hook.java的总代码为12345678910111213141516171819202122232425262728293031323334353637383940package com.example.xposedtest;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;import java.util.ArrayList;import java.util.List;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import android.widget.Toast; public class Hook implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable &#123; if (!lpparam.packageName.equals(\"com.example.showtimer\")) return; XposedBridge.log(\"Loaded app name : \" + lpparam.packageName); findAndHookMethod(\"java.util.Calendar\", lpparam.classLoader,\"get\",int.class,new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; // this will be called before the clock was updated by the original method XposedBridge.log(\"Enter-&gt;beforeHookedMethod:Calendar.get\"); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // this will be called after the clock was updated by the original method XposedBridge.log(\"Enter-&gt;afterHookedMethod:Calendar.get\"); param.setResult((int)11); &#125; &#125;); &#125;&#125; 声明主入口路径需要在assets文件夹中新建一个xposed_init的文件，并在其中声明主入口类。如这里我们的主入口类为com.example.xposedtest.Hook 在AndroidManifest.xml文件中配置插件名称与Api版本号12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.xposedtest\" android:versionCode=\"1\" android:versionName=\"4.0\" &gt; &lt;uses-sdk android:minSdkVersion=\"17\" android:targetSdkVersion=\"21\" /&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; &lt;meta-data android:name=\"xposedmodule\" android:value=\"true\" /&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"劫持获得时间函数\" /&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"30\" /&gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 编译并安全这个apkXposed会自已识别，打开Xposed的”模块”，启用刚才安装的模块 再打开之前写的showTime应用，点击按钮看看 使用XposedBridge.log() 记录的log可以在Xposed的日志里看到 Hook自定义的函数刚才hook的是系统的函数，下面写一个hook自定义的函数还是在刚才showTime的项目中再加一个用户登录的模拟操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.showtimer;import java.util.Calendar;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.view.Window;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); final EditText usename = (EditText) findViewById(R.id.username); final EditText password = (EditText) findViewById(R.id.password); Button login = (Button) findViewById(R.id.button1); final TextView tv = (TextView) findViewById(R.id.tv); Button show = (Button) findViewById(R.id.showTimer); show.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH); int day = c.get(Calendar.DAY_OF_MONTH); int hour = c.get(Calendar.HOUR); int min = c.get(Calendar.MINUTE); String time = \"\"+year+\"-\"+month+\"-\"+day+\" \"+hour+\":\"+min; tv.setText(time); &#125; &#125;); login.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; String user = usename.getText()+\"\"; String pass = password.getText()+\"\"; if (validate(user,pass)) &#123; Toast.makeText(MainActivity.this, \"登录成功\", Toast.LENGTH_LONG).show(); &#125;else&#123; Toast.makeText(MainActivity.this, \"登录失败\", Toast.LENGTH_LONG).show(); &#125; &#125; &#125;); &#125; private boolean validate(String user, String pass) &#123; if (user.equals(\"yang\")&amp;&amp;pass.equals(\"123\")) &#123; return true; &#125; return false; &#125;&#125; 这里自定义了一个validate方法，校验user为”yang”且pass为123则返回真，Toast显示登录成功其它的都返回假。 接着再刚才的Hook类中写hook方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.xposedtest;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;import java.util.ArrayList;import java.util.List;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import android.widget.Toast; public class Hook implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable &#123; if (!lpparam.packageName.equals(\"com.example.showtimer\")) return; XposedBridge.log(\"Loaded app name : \" + lpparam.packageName); XposedBridge.log(\"Loaded app process: \" + lpparam.processName); XposedBridge.log(\"Loaded app appInfo: \" + lpparam.appInfo); findAndHookMethod(\"java.util.Calendar\", lpparam.classLoader,\"get\",int.class,new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; // this will be called before the clock was updated by the original method XposedBridge.log(\"Enter-&gt;beforeHookedMethod:Calendar.get\"); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // this will be called after the clock was updated by the original method XposedBridge.log(\"Enter-&gt;afterHookedMethod:Calendar.get\"); param.setResult((int)11); &#125; &#125;); findAndHookMethod(\"com.example.showtimer.MainActivity\", lpparam.classLoader, \"validate\", String.class,String.class,new XC_MethodHook()&#123; protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; XposedBridge.log(\"Enter-&gt;beforeHookedMethod:validate\"); XposedBridge.log(\"afterHookedMethod userName:\" + param.args[0]); //传入参数2 XposedBridge.log(\"afterHookedMethod pass:\" + param.args[1]); //函数返回值 XposedBridge.log(\"afterHookedMethod result:\" + param.getResult()); &#125; protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // this will be called after the clock was updated by the original method XposedBridge.log(\"Enter-&gt;afterHookedMethod:validate\"); param.setResult(true); XposedBridge.log(\"afterHookedMethod userName:\" + param.args[0]); //传入参数2 XposedBridge.log(\"afterHookedMethod pass:\" + param.args[1]); //函数返回值 XposedBridge.log(\"afterHookedMethod result:\" + param.getResult()); &#125; &#125;);&#125; 在afterHookedMethod方法中将param.setResult(true);则无论输入什么或者不输入都会返回真，这样无论如何都能显示一个Toast登录成功。 后记：如果测试的apk用了混淆，则hook的时候也要修改相应的函数为混淆后的函数。Xposed这个工具可以做很多事情，在测试行业里可以用于构造一些很不好模拟的环境，另外各种插件也能玩的很6。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"}]},{"title":"使用wireshark抓取解密https包","slug":"use-wireshark-capture-https","date":"2016-06-11T14:40:07.000Z","updated":"2017-12-16T10:10:41.871Z","comments":true,"path":"article/use-wireshark-capture-https.html","link":"","permalink":"https://www.yangyanxing.com/article/use-wireshark-capture-https.html","excerpt":"今天在看https的相关技术，于是想要使用wireshark抓取并解密https流量关于https的基础可以看看这篇文章HTTPS理论基础 本文参考文章使用 Wireshark 调试 HTTP/2 流量","text":"今天在看https的相关技术，于是想要使用wireshark抓取并解密https流量关于https的基础可以看看这篇文章HTTPS理论基础 本文参考文章使用 Wireshark 调试 HTTP/2 流量 当系统环境变量中存在SSLKEYLOGFILE这个变量的时候，chrome与firefox在访问https网站的时候会将密钥写入这个环境变量中，如果在wireshark中设置一下，这样就可以解析https的流量了。 设置环境变量，添加SSLKEYLOGFILE变量，不同的系统不一样 在wireshark中设置，打开wireshark,点击编辑-&gt;首选项，切换到PRotocols，选择SSL，在(Pre)-Master-Secret log filename那选择刚刚SSLKEYLOGFILE的值 开始抓包吧 可以看到，wireshark已经将http/2转成了http，并且在下面显示了相应的Decrypted SSL data的tab，我随便输入了用户名与密码，已经可以在wireshark上显示了","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://www.yangyanxing.com/tags/安全/"}]},{"title":"在wireshark上显示host","slug":"display-host-clumn-in-wireshark","date":"2016-06-10T14:19:45.000Z","updated":"2017-12-16T10:10:42.100Z","comments":true,"path":"article/display-host-clumn-in-wireshark.html","link":"","permalink":"https://www.yangyanxing.com/article/display-host-clumn-in-wireshark.html","excerpt":"","text":"wireshark默认不显示目标的host，只显示IP，有时对于查看非常不直观。可以自定义显示一些列 点击”编辑”–&gt;”首选项” 点击下面的”+”，添加一个列，类型选择Custom,字段那填写http.host,字段发生那填写0,点击OK，界面上就会显示host字段了","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://www.yangyanxing.com/tags/安全/"}]},{"title":"HTTPS理论基础","slug":"https-basic","date":"2016-06-09T07:51:32.000Z","updated":"2017-12-16T10:10:42.337Z","comments":true,"path":"article/https-basic.html","link":"","permalink":"https://www.yangyanxing.com/article/https-basic.html","excerpt":"在网上看了好多https的相关文章，但一般都是千篇一律，越看越糊涂今天在网上看了一篇文章，觉得还不错，讲的还比较清晰，看完以后对于https有了相对深入的理解HTTPS理论基础及其在Android中的最佳实践以下是我读后的一些理解","text":"在网上看了好多https的相关文章，但一般都是千篇一律，越看越糊涂今天在网上看了一篇文章，觉得还不错，讲的还比较清晰，看完以后对于https有了相对深入的理解HTTPS理论基础及其在Android中的最佳实践以下是我读后的一些理解 对称加密与非对称加密对称加密对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文解密过程如下：密文 + 解密算法 + 私钥 =&gt; 明文对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难 以下是参考网上的java实现DES加密与解密的demoJava DES 加密 解密 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package desTest;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;public class DESTest &#123; /** * @param args */ public static void main(String[] args) &#123; String content = \"杨彦星\"; String password = \"123456789\";//不明白原文为啥说密码必须是8的位数。。。 System.out.println(\"密 钥：\" + password); System.out.println(\"加密前：\" + content); byte[] result = encrypt(content, password); System.out.println(\"加密后：\" + new String(result)); String decryResult = decrypt(result, password); System.out.println(\"解密后：\" + decryResult); &#125; /** * 加密 * * @param content * 待加密内容 * @param key * 加密的密钥 * @return */ public static byte[] encrypt(String content, String key) &#123; try &#123; SecureRandom random = new SecureRandom(); DESKeySpec desKey = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\"); SecretKey securekey = keyFactory.generateSecret(desKey); Cipher cipher = Cipher.getInstance(\"DES\"); cipher.init(Cipher.ENCRYPT_MODE, securekey, random); byte[] result = cipher.doFinal(content.getBytes()); return result; &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 解密 * * @param content * 待解密内容 * @param key * 解密的密钥 * @return */ public static String decrypt(byte[] content, String key) &#123; try &#123; SecureRandom random = new SecureRandom(); DESKeySpec desKey = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\"); SecretKey securekey = keyFactory.generateSecret(desKey); Cipher cipher = Cipher.getInstance(\"DES\"); cipher.init(Cipher.DECRYPT_MODE, securekey, random); byte[] result = cipher.doFinal(content); return new String(result); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 可见其实这里的私钥其实就是一个字符串，如果知道了这个私钥，同时也知道了加密算法是DES，那么就可以轻松的解密加密数据了。 非对称加密非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。被公钥加密过的密文只能被私钥解密，过程如下：明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文被私钥加密过的密文只能被公钥解密，过程如下：明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。 HTTPS通信过程HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。 https传输过程，为了效率数据采用对称加密，但是对称加密所采用的私钥为了安全采用非对称加密 整个过程中会涉及到三个密钥 服务器端的公钥与私钥，用来进行非对称加密 客户端生成的随机密钥，用来对数据进行对称加密 客户端发起https请求，用户输入一个https网址以后，访问服务器的443端口 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。 传送证书，也就是公钥，服务端将公钥传给客户端。 客户端解析证书，客户端收到服务器发过来的公钥以后先要对其有效性进行校验，如果公钥有问题则无法进行https传输，这个公钥也就是服务器发过来的数字证书。如果没有问题，则会生成一个随机值，这个随机值就是对于对称加密的密钥。然后用服务端发过来的公钥对这个随机值(也就是客户端私钥)进行非对称加密，至此，HTTPS中的第一次HTTP请求结束。 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 然后服务器将加密后的密文发送给客户端。 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。 数字证书在整个https的传输过程中，当服务器发送自已的公钥时，会有黑客进行篡改，那个客户端怎么信赖这个公钥呢？这里就用到了了数字证书。数字证书可以很方便的生成，黑客也可以很方便的生成，但是一个客户端凭什么就相信你的数字证书呢？这里就有数字认证中心CA 专门对公钥进行认证，全球知名的CA也就100多个，客户端默认只信任这100多个CA颁发的证书，客户端也可以自已添加信任的证书。但是很有可能你网站的数字证书不是这100家CA颁发的，而是其下属的认证中心，好比说，我相信了A,A又相信了B，B又相信了C，那么我也就相信了C。那CA怎么对公钥做担保认证呢？CA本身也有一对公钥和私钥，CA会用CA自己的私钥对要进行认证的公钥进行非对称加密，此处待认证的公钥就相当于是明文，加密完之后，得到的密文再加上证书的过期时间、颁发给、颁发者等信息，就组成了数字证书。 当客户端接收到服务器的数字证书的时候，会进行如下验证： 首先客户端会用设备中内置的CA的公钥尝试解密数字证书，如果所有内置的CA的公钥都无法解密该数字证书，说明该数字证书不是由一个全球知名的CA签发的，这样客户端就无法信任该服务器的数字证书。 如果有一个CA的公钥能够成功解密该数字证书，说明该数字证书就是由该CA的私钥签发的，因为被私钥加密的密文只能被与其成对的公钥解密。 除此之外，还需要检查客户端当前访问的服务器的域名是与数字证书中提供的“颁发给”这一项吻合，还要检查数字证书是否过期等。 12306网站的数字证书问题当用户访问 https://kyfw.12306.cn/otn/regist/init 如果没有导入其根证书的话那个浏览器上会显示一个不安全的提示 为什么会这样呢？看一下12306的证书信息 可以看到，该12306.cn的证书是由SRCA这个机构签发的，也就是说SRCA是证书链上的根CA。但是SRCA是啥呢？没听过啊！因为其不在默认的100多个CA里，所以这里安全校验不通过，浏览器认为它是不安全的解决办法12306的网站上也说明了，要导入它的根证书","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://www.yangyanxing.com/tags/安全/"}]},{"title":"(转)Android Context完全解析，你所不知道的Context的各种细节","slug":"learning-context","date":"2016-05-29T15:55:59.000Z","updated":"2017-12-16T10:10:41.944Z","comments":true,"path":"article/learning-context.html","link":"","permalink":"https://www.yangyanxing.com/article/learning-context.html","excerpt":"以下转自郭霖大神的博客 转载请注明出处：http://blog.csdn.net/guolin_blog/article/details/47028975前几篇文章，我也是费劲心思写了一个ListView系列的三部曲，虽然在内容上可以说是绝对的精华，但是很多朋友都表示看不懂。好吧，这个系列不仅是把大家给难倒了，也确实是把我给难倒了，之前为了写瀑布流ListView的Demo就写了大半个月的时间。那么本篇文章我们就讲点轻松的东西，不去分析那么复杂的源码了，而是来谈一谈大家都熟知的Context。Context相信所有的Android开发人员基本上每天都在接触，因为它太常见了。但是这并不代表Context没有什么东西好讲的，实际上Context有太多小的细节并不被大家所关注，那么今天我们就来学习一下那些你所不知道的细节。","text":"以下转自郭霖大神的博客 转载请注明出处：http://blog.csdn.net/guolin_blog/article/details/47028975前几篇文章，我也是费劲心思写了一个ListView系列的三部曲，虽然在内容上可以说是绝对的精华，但是很多朋友都表示看不懂。好吧，这个系列不仅是把大家给难倒了，也确实是把我给难倒了，之前为了写瀑布流ListView的Demo就写了大半个月的时间。那么本篇文章我们就讲点轻松的东西，不去分析那么复杂的源码了，而是来谈一谈大家都熟知的Context。Context相信所有的Android开发人员基本上每天都在接触，因为它太常见了。但是这并不代表Context没有什么东西好讲的，实际上Context有太多小的细节并不被大家所关注，那么今天我们就来学习一下那些你所不知道的细节。 Context类型我们知道，Android应用都是使用Java语言来编写的，那么大家可以思考一下，一个Android程序和一个Java程序，他们最大的区别在哪里？划分界限又是什么呢？其实简单点分析，Android程序不像Java程序一样，随便创建一个类，写个main()方法就能跑了，而是要有一个完整的Android工程环境，在这个环境下，我们有像Activity、Service、BroadcastReceiver等系统组件，而这些组件并不是像一个普通的Java对象new一下就能创建实例的了，而是要有它们各自的上下文环境，也就是我们这里讨论的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。下面我们来看一下Context的继承结构： Context的继承结构还是稍微有点复杂的，可以看到，直系子类有两个，一个是ContextWrapper，一个是ContextImpl。那么从名字上就可以看出，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。而ContextWrapper又有三个直接的子类，ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity。那么在这里我们至少看到了几个所比较熟悉的面孔，Activity、Service、还有Application。由此，其实我们就已经可以得出结论了，Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的。那么Context到底可以实现哪些功能呢？这个就实在是太多了，弹出Toast、启动Activity、启动Service、发送广播、操作数据库等等等等都需要用到Context。由于Context的具体能力是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 Context数量那么一个应用程序中到底有多少个Context呢？其实根据上面的Context类型我们就已经可以得出答案了。Context一共有Application、Activity和Service三种类型，因此一个应用程序中Context数量的计算公式就可以这样写：[plain] view plain copy Context数量 = Activity数量 + Service数量 + 1 上面的1代表着Application的数量，因为一个应用程序中可以有多个Activity和多个Service，但是只能有一个Application。 Application Context的设计基本上每一个应用程序都会有一个自己的Application，并让它继承自系统的Application类，然后在自己的Application类中去封装一些通用的操作。其实这并不是Google所推荐的一种做法，因为这样我们只是把Application当成了一个通用工具类来使用的，而实际上使用一个简单的单例类也可以实现同样的功能。但是根据我的观察，有太多的项目都是这样使用Application的。当然这种做法也并没有什么副作用，只是说明还是有不少人对于Application理解的还有些欠缺。那么这里我们先来对Application的设计进行分析，讲一些大家所不知道的细节，然后再看一下平时使用Application的问题。首先新建一个MyApplication并让它继承自Application，然后在AndroidManifest.xml文件中对MyApplication进行指定，如下所示：12345678&lt;application android:name=\".MyApplication\" android:allowBackup=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; ...... &lt;/application&gt; 指定完成后，当我们的程序启动时Android系统就会创建一个MyApplication的实例，如果这里不指定的话就会默认创建一个Application的实例。前面提到过，现在很多的Application都是被当作通用工具类来使用的，那么既然作为一个通用工具类，我们要怎样才能获取到它的实例呢？如下所示：1234567891011public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MyApplication myApp = (MyApplication) getApplication(); Log.d(\"TAG\", \"getApplication is \" + myApp); &#125; &#125; 可以看到，代码很简单，只需要调用getApplication()方法就能拿到我们自定义的Application的实例了，打印结果如下所示： 那么除了getApplication()方法，其实还有一个getApplicationContext()方法，这两个方法看上去好像有点关联，那么它们的区别是什么呢？我们将代码修改一下：12345678910111213public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MyApplication myApp = (MyApplication) getApplication(); Log.d(\"TAG\", \"getApplication is \" + myApp); Context appContext = getApplicationContext(); Log.d(\"TAG\", \"getApplicationContext is \" + appContext); &#125; &#125; 同样，我们把getApplicationContext()的结果打印了出来，现在重新运行代码，结果如下图所示： 咦？好像打印出的结果是一样的呀，连后面的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是MyApplication本身的实例。那么有的朋友可能就会问了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了，如下所示：123456789public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; MyApplication myApp = (MyApplication) context.getApplicationContext(); Log.d(\"TAG\", \"myApp is \" + myApp); &#125; &#125; 也就是说，getApplicationContext()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。那么更加细心的朋友会发现，除了这两个方法之外，其实还有一个getBaseContext()方法，这个baseContext又是什么东西呢？我们还是通过打印的方式来验证一下： 哦？这次得到的是不同的对象了，getBaseContext()方法得到的是一个ContextImpl对象。这个ContextImpl是不是感觉有点似曾相识？回去看一下Context的继承结构图吧，ContextImpl正是上下文功能的实现类。也就是说像Application、Activity这样的类其实并不会去具体实现Context的功能，而仅仅是做了一层接口封装而已，Context的具体功能都是由ContextImpl类去完成的。那么这样的设计到底是怎么实现的呢？我们还是来看一下源码吧。因为Application、Activity、Service都是直接或间接继承自ContextWrapper的，我们就直接看ContextWrapper的源码，如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Proxying implementation of Context that simply delegates all of its calls to * another Context. Can be subclassed to modify behavior without changing * the original Context. */ public class ContextWrapper extends Context &#123; Context mBase; /** * Set the base context for this ContextWrapper. All calls will then be * delegated to the base context. Throws * IllegalStateException if a base context has already been set. * * @param base The new base context for this wrapper. */ protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(\"Base context already set\"); &#125; mBase = base; &#125; /** * @return the base context as set by the constructor or setBaseContext */ public Context getBaseContext() &#123; return mBase; &#125; @Override public AssetManager getAssets() &#123; return mBase.getAssets(); &#125; @Override public Resources getResources() &#123; return mBase.getResources(); &#125; @Override public ContentResolver getContentResolver() &#123; return mBase.getContentResolver(); &#125; @Override public Looper getMainLooper() &#123; return mBase.getMainLooper(); &#125; @Override public Context getApplicationContext() &#123; return mBase.getApplicationContext(); &#125; @Override public String getPackageName() &#123; return mBase.getPackageName(); &#125; @Override public void startActivity(Intent intent) &#123; mBase.startActivity(intent); &#125; @Override public void sendBroadcast(Intent intent) &#123; mBase.sendBroadcast(intent); &#125; @Override public Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter); &#125; @Override public void unregisterReceiver(BroadcastReceiver receiver) &#123; mBase.unregisterReceiver(receiver); &#125; @Override public ComponentName startService(Intent service) &#123; return mBase.startService(service); &#125; @Override public boolean stopService(Intent name) &#123; return mBase.stopService(name); &#125; @Override public boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; return mBase.bindService(service, conn, flags); &#125; @Override public void unbindService(ServiceConnection conn) &#123; mBase.unbindService(conn); &#125; @Override public Object getSystemService(String name) &#123; return mBase.getSystemService(name); &#125; ...... &#125; 由于ContextWrapper中的方法还是非常多的，我就进行了一些筛选，只贴出来了部分方法。那么上面的这些方法相信大家都是非常熟悉的，getResources()、getPackageName()、getSystemService()等等都是我们经常要用到的方法。那么所有这些方法的实现又是什么样的呢？其实所有ContextWrapper中方法的实现都非常统一，就是调用了mBase对象中对应当前方法名的方法。那么这个mBase对象又是什么呢？我们来看第16行的attachBaseContext()方法，这个方法中传入了一个base参数，并把这个参数赋值给了mBase对象。而attachBaseContext()方法其实是由系统来调用的，它会把ContextImpl对象作为参数传递到attachBaseContext()方法当中，从而赋值给mBase对象，之后ContextWrapper中的所有方法其实都是通过这种委托的机制交由ContextImpl去具体实现的，所以说ContextImpl是上下文功能的实现类是非常准确的。那么另外再看一下我们刚刚打印的getBaseContext()方法，在第26行。这个方法只有一行代码，就是返回了mBase对象而已，而mBase对象其实就是ContextImpl对象，因此刚才的打印结果也得到了印证。 使用Application的问题虽说Application的用法确实非常简单，但是我们平时的开发工作当中也着实存在着不少Application误用的场景，那么今天就来看一看有哪些比较容易犯错的地方是我们应该注意的。Application是Context的其中一种类型，那么是否就意味着，只要是Application的实例，就能随时使用Context的各种方法呢？我们来做个实验试一下就知道了：12345678public class MyApplication extends Application &#123; public MyApplication() &#123; String packageName = getPackageName(); Log.d(\"TAG\", \"package name is \" + packageName); &#125; &#125; 这是一个非常简单的自定义Application，我们在MyApplication的构造方法当中获取了当前应用程序的包名，并打印出来。获取包名使用了getPackageName()方法，这个方法就是由Context提供的。那么上面的代码能正常运行吗？跑一下就知道了，你将会看到如下所示的结果： 应用程序一启动就立刻崩溃了，报的是一个空指针异常。看起来好像挺简单的一段代码，怎么就会成空指针了呢？但是如果你尝试把代码改成下面的写法，就会发现一切正常了：12345678910public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); String packageName = getPackageName(); Log.d(\"TAG\", \"package name is \" + packageName); &#125; &#125; 运行结果如下所示： 在构造方法中调用Context的方法就会崩溃，在onCreate()方法中调用Context的方法就一切正常，那么这两个方法之间到底发生了什么事情呢？我们重新回顾一下ContextWrapper类的源码，ContextWrapper中有一个attachBaseContext()方法，这个方法会将传入的一个Context参数赋值给mBase对象，之后mBase对象就有值了。而我们又知道，所有Context的方法都是调用这个mBase对象的同名方法，那么也就是说如果在mBase对象还没赋值的情况下就去调用Context中的任何一个方法时，就会出现空指针异常，上面的代码就是这种情况。Application中方法的执行顺序如下图所示： Application中在onCreate()方法里去初始化各种全局的变量数据是一种比较推荐的做法，但是如果你想把初始化的时间点提前到极致，也可以去重写attachBaseContext()方法，如下所示：12345678910public class MyApplication extends Application &#123; @Override protected void attachBaseContext(Context base) &#123; // 在这里调用Context的方法会崩溃 super.attachBaseContext(base); // 在这里可以正常调用Context的方法 &#125; &#125; 以上是我们平时在使用Application时需要注意的一个点，下面再来介绍另外一种非常普遍的Application误用情况。其实Android官方并不太推荐我们使用自定义的Application，基本上只有需要做一些全局初始化的时候可能才需要用到自定义Application，官方文档描述如下： 但是就我的观察而言，现在自定义Application的使用情况基本上可以达到100%了，也就是我们平时自己写测试demo的时候可能不会使用，正式的项目几乎全部都会使用自定义Application。可是使用归使用，有不少项目对自定义Application的用法并不到位，正如官方文档中所表述的一样，多数项目只是把自定义Application当成了一个通用工具类，而这个功能并不需要借助Application来实现，使用单例可能是一种更加标准的方式。不过自定义Application也并没有什么副作用，它和单例模式二选一都可以实现同样的功能，但是我见过有一些项目，会把自定义Application和单例模式混合到一起使用，这就让人大跌眼镜了。一个非常典型的例子如下所示：123456789101112public class MyApplication extends Application &#123; private static MyApplication app; public static MyApplication getInstance() &#123; if (app == null) &#123; app = new MyApplication(); &#125; return app; &#125; &#125; 就像单例模式一样，这里提供了一个getInstance()方法，用于获取MyApplication的实例，有了这个实例之后，就可以调用MyApplication中的各种工具方法了。但是这种写法对吗？这种写法是大错特错！因为我们知道Application是属于系统组件，系统组件的实例是要由系统来去创建的，如果这里我们自己去new一个MyApplication的实例，它就只是一个普通的Java对象而已，而不具备任何Context的能力。有很多人向我反馈使用 LitePal 时发生了空指针错误其实都是由于这个原因，因为你提供给LitePal的只是一个普通的Java对象，它无法通过这个对象来进行Context操作。那么如果真的想要提供一个获取MyApplication实例的方法，比较标准的写法又是什么样的呢？其实这里我们只需谨记一点，Application全局只有一个，它本身就已经是单例了，无需再用单例模式去为它做多重实例保护了，代码如下所示：123456789101112131415public class MyApplication extends Application &#123; private static MyApplication app; public static MyApplication getInstance() &#123; return app; &#125; @Override public void onCreate() &#123; super.onCreate(); app = this; &#125; &#125; getInstance()方法可以照常提供，但是里面不要做任何逻辑判断，直接返回app对象就可以了，而app对象又是什么呢？在onCreate()方法中我们将app对象赋值成this，this就是当前Application的实例，那么app也就是当前Application的实例了。好了，关于Context的介绍就到这里吧，内容还是比较简单易懂的，希望大家通过这篇文章可以理解Context更多的细节，并且不要去犯使用Context时的一些低级错误。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/tags/Android/"}]},{"title":"Uiautomator中watcher的使用","slug":"use-watcher-in-uiautomator","date":"2016-05-13T15:09:30.000Z","updated":"2017-12-16T10:10:42.473Z","comments":true,"path":"article/use-watcher-in-uiautomator.html","link":"","permalink":"https://www.yangyanxing.com/article/use-watcher-in-uiautomator.html","excerpt":"今天在uiautomator中实践了watcher的用法，这个也是之前在python中使用uiautomator中比较喜欢的功能，它可以提前定义一些条件，当满足一些条件时，进行一些操作，这个常用于处理测试过程中某些意料之外的或者不知道什么时候弹出来的框而阻碍测试的正常进行。之前在写自动化用例的时候，遇到过小米手机在安装app的时候，会弹一个框来让用户点击安装，还有弹出一个升级检测的框点击“取消”按钮，或者遇到退出的时候点击确定，当然这些完全可以在用例里写逻辑来处理，而且有些还是程序本身要测试的检测点，当然这些对于大多数测试来说没有太大的意义，所以可以将其放入一个watcher里来让uiautomator来帮你进行相应的点击处理。","text":"今天在uiautomator中实践了watcher的用法，这个也是之前在python中使用uiautomator中比较喜欢的功能，它可以提前定义一些条件，当满足一些条件时，进行一些操作，这个常用于处理测试过程中某些意料之外的或者不知道什么时候弹出来的框而阻碍测试的正常进行。之前在写自动化用例的时候，遇到过小米手机在安装app的时候，会弹一个框来让用户点击安装，还有弹出一个升级检测的框点击“取消”按钮，或者遇到退出的时候点击确定，当然这些完全可以在用例里写逻辑来处理，而且有些还是程序本身要测试的检测点，当然这些对于大多数测试来说没有太大的意义，所以可以将其放入一个watcher里来让uiautomator来帮你进行相应的点击处理。查看官方文档， UiWatcher是由UiDevice来registerWatcher (String name, UiWatcher watcher)，name为一个名字，这个名字相当于一个key,可以在之后的查看该watcher是否被检测到了使用和remove的时候使用 初始化UiWatcher时要重写一个checkForCondition()这个抽象方法，这个方法主要就是写一些判断哪些UiSelector是否出现了，出现了怎么处理，我重新封装了一个方法 12345678910111213141516171819202122232425public void initwatch(final String name,final UiSelector checkSelecto,final UiSelector opSelector)&#123; //将name添加到watcherNames的list中，为了tearDown方法中remove掉用 watcherNames.add(name); final UiObject check = new UiObject(checkSelecto); final UiObject op = new UiObject(opSelector); mDevice.registerWatcher(name, new UiWatcher() &#123; //这里重写checkForCondition方法 public boolean checkForCondition() &#123; try &#123; if (check.exists()) &#123; op.click(); Thread.sleep(1000); return true; &#125; else&#123; Thread.sleep(1000); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; &#125;); &#125; checkForConditon方法的返回值是boolean值，当返回true的时候，则uidevice.hasWatcherTriggered(name) 则返回true，checkForConditon这里不用写循环，uiautomator会在测试过程中一直在循环的调用。 以下是全部代码TestUtil.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.yangyanxing.test;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.ArrayList;import com.android.uiautomator.core.UiDevice;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.core.UiWatcher;public class TestUtil &#123; public ArrayList&lt;String&gt; watcherNames = new ArrayList&lt;String&gt;(); public UiDevice mDevice = UiDevice.getInstance(); public static String doCmdshell(String commond)&#123; String s = null; try &#123; Process p = Runtime.getRuntime().exec(commond); BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream())); BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream())); String result = \"\"; while ((s = stdInput.readLine()) != null) &#123; result = result + s + \"\\n\"; &#125; while ((s = stdError.readLine()) != null) &#123; System.out.println(s); &#125; return result; &#125; catch (Exception e) &#123; return \"Exception occurred\"; &#125; &#125; //init watcher public void initwatch(final String name,final UiSelector checkSelecto,final UiSelector opSelector)&#123; //将name添加到watcherNames的list中，为了tearDown方法中remove掉用 watcherNames.add(name); final UiObject check = new UiObject(checkSelecto); final UiObject op = new UiObject(opSelector); mDevice.registerWatcher(name, new UiWatcher() &#123; //这里重写checkForCondition方法 public boolean checkForCondition() &#123; try &#123; if (check.exists()) &#123; op.click(); Thread.sleep(1000); return true; &#125; else&#123; Thread.sleep(1000); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; &#125;); &#125; public static Boolean waitForUiselectorAppears(UiSelector selector,int timeout) &#123; UiObject uiObject = new UiObject(selector); return uiObject.waitForExists(timeout*1000); &#125;&#125; UitestRunner.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.yangyanxing.test;import com.android.uiautomator.core.UiDevice;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiObjectNotFoundException;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.testrunner.UiAutomatorTestCase;import static com.yangyanxing.test.TestUtil.doCmdshell;public class UitestRunner extends UiAutomatorTestCase &#123; //初始化一个UiDevice private UiDevice mDevice = UiDevice.getInstance(); private TestUtil tUtil = new TestUtil(); public UitestRunner()&#123; super(); &#125; //写setUp()方法 public void setUp() throws Exception&#123; super.setUp(); //每次测试的时候都需要启动急救箱，所以将这个方法放到setUp里 doCmdshell(\"am start com.qihoo.mkiller/com.qihoo.mkiller.ui.index.AppEnterActivity\"); System.out.println(\"开始测试啦。。。\"); //注册一些watcher tUtil.initwatch(\"ignorSafe\", new UiSelector().textContains(\"安全上网\").className(\"android.widget.TextView\"), new UiSelector().text(\"取消\")); tUtil.initwatch(\"agree\", new UiSelector().text(\"同意并使用\"), new UiSelector().text(\"同意并使用\")); tUtil.initwatch(\"Noupdate\", new UiSelector().textContains(\"升级\"), new UiSelector().text(\"取消\")); mDevice.runWatchers();//将watchers运行起来 &#125; //写tearDown方法，将急救箱force-stop public void tearDown() throws Exception&#123; super.tearDown(); doCmdshell(\"am force-stop com.qihoo.mkiller\"); System.out.println(\"用例测试完了！\"); for (String watcherName : tUtil.watcherNames) &#123; System.out.println(watcherName+\"被remove了！\"); mDevice.removeWatcher(watcherName); &#125; &#125; //检测急救箱启动后是否有\"开始扫描\"按钮 public void test_startScanButton() throws UiObjectNotFoundException&#123; UiSelector scanButton = new UiSelector().className(\"android.widget.Button\").text(\"开始扫描\"); if(TestUtil.waitForUiselectorAppears(scanButton, 20))&#123; UiObject scanoObject = new UiObject(scanButton); if (scanoObject.click()) &#123; System.out.println(\"开始扫描 按钮被点击了！\"); &#125;else&#123; System.out.println(\"开始扫描 按钮点击失败了\"); &#125; &#125;else &#123; System.out.println(\"急救箱启动失败\"); &#125; UiSelector exitbutton = new UiSelector().className(\"android.widget.Button\").text(\"退出\"); assertEquals(Boolean.TRUE, TestUtil.waitForUiselectorAppears(exitbutton, 120)); &#125; public void test_print()&#123; System.out.println(\"用例2开始测试了！\"); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/tags/Android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.yangyanxing.com/tags/自动化测试/"}]},{"title":"使用Uiautomator做基于UI界面的测试","slug":"use-uiautomator-for-uitest","date":"2016-05-11T17:04:03.000Z","updated":"2017-12-16T10:10:42.253Z","comments":true,"path":"article/use-uiautomator-for-uitest.html","link":"","permalink":"https://www.yangyanxing.com/article/use-uiautomator-for-uitest.html","excerpt":"这两天在看原生的uiautomator的测试，之前也有使用，但是只是把Android官方的例子简单的实现一样，并没有什么实际的测试意思，Android官方的uiautomator例子的实现,今天结合最近正在做的自动化项目，简单的使用uiautomator来实现了一下，只是做了一个小例子，但是基本上都如何编译jar与运行调通了，这里也简单的记录一下。之前也有使用别人封装好的python做过，那个写起来也比较简单，使用uiautomator的python封装进行android的UI测试","text":"这两天在看原生的uiautomator的测试，之前也有使用，但是只是把Android官方的例子简单的实现一样，并没有什么实际的测试意思，Android官方的uiautomator例子的实现,今天结合最近正在做的自动化项目，简单的使用uiautomator来实现了一下，只是做了一个小例子，但是基本上都如何编译jar与运行调通了，这里也简单的记录一下。之前也有使用别人封装好的python做过，那个写起来也比较简单，使用uiautomator的python封装进行android的UI测试 新建一个java工程新建工程的时候要注意编码要是utf-8的，不然后面使用ant编译jar文件的时候会有问题.引入JUnit与android.jar和uiautomator.jar，我使用的是api-16的jar，这个16要记住，后面生成build.xml有用 创建测试类新建的类要继承UiAutomatorTestCase类我这个操作要用到am命令来启动手机急救箱和关闭急救箱，所以我创建一个util类来封了两个方法1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.yangyanxing.test;import java.io.BufferedReader;import java.io.InputStreamReader;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiSelector;public class TestUtil &#123; public static String doCmdshell(String commond)&#123; String s = null; try &#123; Process p = Runtime.getRuntime().exec(commond); BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream())); BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream())); String result = \"\"; while ((s = stdInput.readLine()) != null) &#123; result = result + s + \"\\n\"; &#125; while ((s = stdError.readLine()) != null) &#123; System.out.println(s); &#125; return result; &#125; catch (Exception e) &#123; return \"Exception occurred\"; &#125; &#125; //这个方法是在timeout的时间内等待ui元素的出现，出现了返回真，异常了或者超时了返回假 public static Boolean waitForUiselectorAppears(UiSelector selector,int timeout) &#123; UiObject uiObject = new UiObject(selector); return uiObject.waitForExists(timeout*1000); &#125; &#125; 写具体的测试方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.yangyanxing.test;import com.android.uiautomator.core.UiDevice;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiObjectNotFoundException;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.testrunner.UiAutomatorTestCase;public class UitestRunner extends UiAutomatorTestCase &#123; //初始化一个UiDevice private UiDevice mDevice = UiDevice.getInstance(); public UitestRunner()&#123; super(); &#125; //写setUp()方法 public void setUp() throws Exception&#123; super.setUp(); //每次测试的时候都需要启动急救箱，所以将这个方法放到setUp里 TestUtil.doCmdshell(\"am start com.qihoo.mkiller/com.qihoo.mkiller.ui.index.AppEnterActivity\"); &#125; //写tearDown方法，将急救箱force-stop public void tearDown() throws Exception&#123; super.tearDown(); TestUtil.doCmdshell(\"am force-stop com.qihoo.mkiller\"); &#125; //检测急救箱启动后是否有\"开始扫描\"按钮 public void test_startScanButton() throws UiObjectNotFoundException&#123; UiSelector scanButton = new UiSelector().className(\"android.widget.Button\").text(\"开始扫描\"); if(TestUtil.waitForUiselectorAppears(scanButton, 20))&#123; UiObject scanoObject = new UiObject(scanButton); if (scanoObject.click()) &#123; System.out.println(\"开始扫描 按钮被点击了！\"); &#125;else&#123; System.out.println(\"开始扫描 按钮点击失败了\"); &#125; &#125;else &#123; System.out.println(\"急救箱启动失败\"); &#125; UiSelector exitbutton = new UiSelector().className(\"android.widget.Button\").text(\"退出\"); assertEquals(Boolean.TRUE, TestUtil.waitForUiselectorAppears(exitbutton, 120)); &#125;&#125; 使用android.bat生成build.xml文件到android sdk目录的tools目录下，使用 android create uitest-project -n mkillerTest -t 2 -p D:\\EclipseWorkPlace\\uiautomatorTest` 命令生成build.xml -n 为最终生成的jar包的名字，随意起-t 为android targets的id,稍后说怎么获得-p 为刚才创建的工程目录 -t 的值可以通过 sdk/tools 目录下的android list 来获得 刚才使用的uiautomator的api版本为16，那么对应这里的id值就是2 使用ant build…生成mkillerTest.jar文件刷新eclipse里的工程目录，这个build.xml就会出来了，右键build.xml选择Run as-&gt;Ant build….在Targets标签里勾选build[from imort${sdk.dir}/tools/ant/uibuild.xml]然后点击run，如果没有错误的话最终会生成BUILD SUCCESSFUL的提示并且把jar文件位置打印出来 将生成的jar push到手机里进行测试使用adb push 命令将这个mkillerTest.jar推到手机的/data/local/tmp/目录下 adb push mkillerTest.jar /data/local/tmp/ 运行测试adb shell 到手机里，cd到/data/local/tmp目录下，也可以不cd 到这个目录(只要前面将.jar文件push到/data/local/tmp目录下也行)，运行uiautomator命令进行测试 uiautomator runtest mkillerTest.jar 或者 uiautomator runtest mkillerTest.jar -c com.yangyanxing.test.UitestRunner -c 命令为指定类来跑，当有多个类的时候可以选择只跑部分用例 基本的流程就是这样，以后再扩展吧。 扩展Uiautomator中watcher的使用","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.yangyanxing.com/tags/自动化测试/"},{"name":"java","slug":"java","permalink":"https://www.yangyanxing.com/tags/java/"}]},{"title":"过年","slug":"Spring-Festival","date":"2016-02-13T12:11:19.000Z","updated":"2017-12-16T10:10:42.343Z","comments":true,"path":"article/Spring-Festival.html","link":"","permalink":"https://www.yangyanxing.com/article/Spring-Festival.html","excerpt":"首都再见，北京你好又是一年，这个年过的相对平静年味少了很多，不像小时候那样还会放鞭炮，不会像小时候那样盼着大吃大喝现在更加喜欢过了一个清淡的年 春节，对于中国人来说是最重要的节日，家人可以放下手中的工作相聚一起家在农村，平时在城市里工作生活，每逢周末回家，在家里总能睡个很好的觉","text":"首都再见，北京你好又是一年，这个年过的相对平静年味少了很多，不像小时候那样还会放鞭炮，不会像小时候那样盼着大吃大喝现在更加喜欢过了一个清淡的年 春节，对于中国人来说是最重要的节日，家人可以放下手中的工作相聚一起家在农村，平时在城市里工作生活，每逢周末回家，在家里总能睡个很好的觉 在家里才能享受这种平静，过年了，在2015年，有很多没有实现的目标，2016又有一些新的目标在2015年，得到了一些想要的东西，也失去了一些东西工作上，现在可以做一些自已喜欢的东西，自已支配一些时间，没有那么看起来要很忙的样子。今年过年，还是没能带回个儿媳。在网上看到一句话，说有个人其实30岁已经死了，只是到80岁才埋一个人的激情终究能持续多久？自我感觉已经没有之前对新鲜事物的敏感与兴趣，有种得过且过的想法了这样不好，但所幸还是有一些的，还没到那种当一天和尚撞一天钟的状态对于新鲜的技术主观上还是喜欢接受与学习的。这一年，自已的脾气变坏了很多，自我反思应该是平时接触人太少的原因自已的想法有时也很偏激，对于看不惯的事物总想要骂上几句发泄一下才爽但是骂过之后又能怎样呢？前初想要多读一些书，不光是IT技术方面，也要多一些人文方面这点已经算实现了，今年读了不少书，但是感觉还是少，自已的阅历与想法还是太单一16年要读更多的书。 去年开始重新用朋友圈，之前删除过所有的朋友圈，并关闭了此功能其实这种和朋友之间相互沟通相互了解也是很好的，不能太封闭了自已那会也删除了一些好友，后来也觉得后悔，今年过节的时候还能收到人家的微信，说明人家并没有删除我只是当时自已太玻璃心，有些太固执，现在也算了，既然做了也就没必要再想这些这一年也新加了很多好友，很多“朋友圈”里的好友，为什么这么说呢，可能我们在现实生活中不会见面的人，只是在朋友圈里寒暄的好友。16年要在朋友圈里花太多的时间，不用太关注那些留言与他人是否回复了自已的留言好在这一年自已的性格也有了一些变化，说起话来更加的放松，开的玩笑也不那么放肆了，也会注意一些场合。 16年，要有一些变化，15年很长时间都在纠结于工作的问题上，自已技术上没有太大的长进，属于那种吃老本的，所以今年要学习与巩固一些新的技术，技术不能太单一。","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"在ThinkPHP整合新浪微博SDK","slug":"ThinkPHP-workwith-weibo-sdk","date":"2016-02-10T14:28:32.000Z","updated":"2017-12-16T10:10:42.381Z","comments":true,"path":"article/ThinkPHP-workwith-weibo-sdk.html","link":"","permalink":"https://www.yangyanxing.com/article/ThinkPHP-workwith-weibo-sdk.html","excerpt":"最近在玩PHP，在看了基本语法以后就开始看ThinkPHP了，几年以前接触过一些，但是基本上都忘的差不多了现在再看的时候，发现版本更新了好多，添加了很多新的功能特性，使用时候也有很多不一样的，之前写了一篇边看边写的笔记，ThinkPHP的学习笔记今天结合官方的文档来整合一下新浪微博的SDK，在使用的过程中还是有一些问题需要注意的，我使用的是3.2.3版本","text":"最近在玩PHP，在看了基本语法以后就开始看ThinkPHP了，几年以前接触过一些，但是基本上都忘的差不多了现在再看的时候，发现版本更新了好多，添加了很多新的功能特性，使用时候也有很多不一样的，之前写了一篇边看边写的笔记，ThinkPHP的学习笔记今天结合官方的文档来整合一下新浪微博的SDK，在使用的过程中还是有一些问题需要注意的，我使用的是3.2.3版本 ThinkPHP和项目与模块的初始化这个就不详细写了，学习笔记中有记录，也是比较基础的 整合新浪微博的SDK下载SDK 新浪微博SDK下载后将压缩包中的saetv2.ex.class.php取下来，重新命名，叫什么无所谓，只是为了去掉那个点，我重新命名为saetv2.class.php, .class.php 是必须要保留的，我将其放到了ThinkPHP/Library/Org/Com/Sina/ 目录下，文档上说这个目录下的类库是可以自动加载的，但是文档上使用的是namespace的方式我一开始也按照文档的介绍使用namespace方式，但是后来发现这种以名称空间的方式有很多限制，首先一个文件里只能有一个类且文件名还要和这个类名对应，微博SDK里有三个类，如果按照namespace的方法，我还得新建一个文件重新拷贝一下相应的类，很麻烦，后来我直接采用import这个类的方式，使用起来方便了很多。 在WeiboController.class.php中写逻辑首先把新浪微博sdk引入进来，在use Think\\Controller; 下面加入 引用 import(‘Org\\Com.Sina\\saetv2’); 1234&lt;?phpnamespace Home\\Controller;use Think\\Controller;import('Org\\Com.Sina\\saetv2'); 这里的目录结构中的com\\sina 要改成Com.Sina下面如果要使用saetv2中的类就可以直接使用 \\类名调用，如使用SaeTOAuthV2类就可以使用$c = new \\SaeTClientV2() 获得token其实里面的代码基本上就是sdk中的callback.php中的代码,这里又加上了ThinkPHP对于session与cookie的封装 12345678910111213141516$o = new \\SaeTOAuthV2( WB_AKEY , WB_SKEY );$code_url = $o-&gt;getAuthorizeURL( WB_CALLBACK_URL );if(isset($_GET['code']))&#123; $code = $_GET['code']; $keys = array(); $keys['code'] = $_REQUEST['code']; $keys['redirect_uri'] = WB_CALLBACK_URL; $token = $o-&gt;getAccessToken( 'code', $keys ) ; if (!empty($token['uid']) &amp;&amp; !empty($token['access_token'])) &#123; session('token',$token); cookie('weibojs_'.$o-&gt;client_id, http_build_query($token)); $this-&gt;success('新浪微博授权成功',U('index','',''),3); &#125; else&#123; $this-&gt;error('新浪微博授权失败',U('index','',''),3); &#125; 调用微博的接口当获得了token后就可以使用token访问新浪微博的接口了，接口文档 全部代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace Home\\Controller;use Think\\Controller;import('Org\\Com.Sina.weibo\\saetv2');class WeiboController extends Controller &#123; public function index()&#123; // session('[destroy]'); define('WB_AKEY', C('AKEY')); define('WB_SKEY', C('SKEY')); define('WB_CALLBACK_URL', C('CALLBACK')); if (session('token')) &#123; dump(session('token')); $c = new \\SaeTClientV2( WB_AKEY , WB_SKEY , $_SESSION['token']['access_token'] ); // 这个是调用发微博的接口 // $up = $c-&gt;update(\"使用ThinkPHP发微博\".(string)(mt_rand())); $ht = $c-&gt;home_timeline(); $userinfo = $c-&gt;show_user_by_id(session('token')['uid']); dump($userinfo); echo \"点此&lt;a href=\".U('logout','','').\"&gt;退出登录&lt;/a&gt;\"; &#125;else&#123; // 这个是使用namespace方式调用，麻烦 // $o = new \\Org\\Com\\Sina\\SaeTOAuthV2( WB_AKEY , WB_SKEY ); // // 下面这个是使用import库以后使用方法，比较简单 $o = new \\SaeTOAuthV2( WB_AKEY , WB_SKEY ); $code_url = $o-&gt;getAuthorizeURL( WB_CALLBACK_URL ); if(isset($_GET['code']))&#123; $code = $_GET['code']; $keys = array(); $keys['code'] = $_REQUEST['code']; $keys['redirect_uri'] = WB_CALLBACK_URL; // dump($keys); $token = $o-&gt;getAccessToken( 'code', $keys ) ; // dump($token); if (!empty($token['uid']) &amp;&amp; !empty($token['access_token'])) &#123; session('token',$token); cookie('weibojs_'.$o-&gt;client_id, http_build_query($token)); $this-&gt;success('新浪微博授权成功',U('index','',''),3); &#125; else&#123; $this-&gt;error('新浪微博授权失败',U('index','',''),3); &#125; &#125; echo \"您还没有登录，请使用&lt;a href=\".$code_url.\"&gt;新浪微博&lt;/a&gt;进行登录\"; &#125; $this-&gt;show('&lt;style type=\"text/css\"&gt;*&#123; padding: 0; margin: 0; &#125; div&#123; padding: 4px 48px;&#125; body&#123; background: #fff; font-family: \"微软雅黑\"; color: #333;font-size:24px&#125; h1&#123; font-size: 100px; font-weight: normal; margin-bottom: 12px; &#125; p&#123; line-height: 1.8em; font-size: 36px &#125; a,a:hover&#123;color:blue;&#125;&lt;/style&gt;&lt;div style=\"padding: 24px 48px;\"&gt; ','utf-8'); &#125; public function logout()&#123; // 退出实际上就是简单地调用了销毁session的方式 session('[destroy]'); cookie(NULL); $this-&gt;success('您已经退出登录',U('index','',''),2); &#125;&#125; 当访问 index.php/Weibo/index 时，显示授权链接 点击后使用微博账号进行登录，成功后跳转回index.php/Weibo/index","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://www.yangyanxing.com/tags/ThinkPHP/"},{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/tags/PHP/"},{"name":"微博","slug":"微博","permalink":"https://www.yangyanxing.com/tags/微博/"}]},{"title":"ThinkPHP的学习笔记","slug":"thinkphp-study-note","date":"2016-01-30T12:38:08.000Z","updated":"2017-12-16T10:10:41.896Z","comments":true,"path":"article/thinkphp-study-note.html","link":"","permalink":"https://www.yangyanxing.com/article/thinkphp-study-note.html","excerpt":"初始化一个项目thinkphp是单入口文件12345&lt;?phpdefine(\"APP_NAME\", \"THINK_Study\");define(\"APP_PATH\", \"./study/\");define(\"APP_DEBUG\", true);require(\"./ThinkPHP/ThinkPHP.php\"); Note: 要先定义APP_PATH,后再include thinkphp 主入口文件，要不然会在当前目录上建立目录，很乱 各种版本生成的目录有些不同，我现在用的是3.2.3 就没有lib目录，而是只有一个home目录,下面的Controller目录相当于之前版本的是lib目录，里面记录着控制器，是MVC中的C，同级目录还有Model和View目录，这样更明显 各个项目下的Conf\\config.php 里的内容只有自已的项目才能读取，其它项目读取不了，比如admin读不了study配置","text":"初始化一个项目thinkphp是单入口文件12345&lt;?phpdefine(\"APP_NAME\", \"THINK_Study\");define(\"APP_PATH\", \"./study/\");define(\"APP_DEBUG\", true);require(\"./ThinkPHP/ThinkPHP.php\"); Note: 要先定义APP_PATH,后再include thinkphp 主入口文件，要不然会在当前目录上建立目录，很乱 各种版本生成的目录有些不同，我现在用的是3.2.3 就没有lib目录，而是只有一个home目录,下面的Controller目录相当于之前版本的是lib目录，里面记录着控制器，是MVC中的C，同级目录还有Model和View目录，这样更明显 各个项目下的Conf\\config.php 里的内容只有自已的项目才能读取，其它项目读取不了，比如admin读不了study配置 关于多模块的设计 3.2.3以后采用多模块设计，即一个项目里采用多个模块的设计思路，比如可以有一个前台的web模块，再加上一个后台的admin模块，而之前版本的thinkphp则需要建立两个入口文件 index.php=&gt;web,admin.php=&gt;admin 多模块后，则要url上加上模块名，如 http://localhost/index.php/admin/index/index 可以绑定一个默认的模块，在主入口文件中加入define(&#39;BIND_MODULE&#39;,&#39;Home&#39;);则将home模块绑定到默认模块中，这样在访问home模块的时候就可以不用加上home了，如 http://localhost/index.php/index/index 则是访问home模块下的index控制器下的index方法 可以在项目的Config.php文件中自定义模块的访问，达到一种不写Home模块时使用Home模块，写上其他的模块则使用其它的模块,不能写在index.php中，没用的 ‘MODULE_ALLOW_LIST’ =&gt; array(‘Home’,’Admin’,’User’),‘DEFAULT_MODULE’ =&gt; ‘Home’, 我曾尝试一次性生成多个模块目录，但是按照官方的方法不能实现 使用U方法生成urlThinkPHP函数详解：U方法 $url = U(“Index/index@sina.com”,array(‘id’ =&gt; 1),”html”,false); 使用公共库函数在3.2 版本中，不再是common.php，要在项目的Common目录下建立一个function.php 数组在模板中的显示 一维数组1234567$jin = array( 'name' =&gt; 'zhangjin', 'sex' =&gt; 'female', 'age' =&gt; '25', );$this-&gt;assign(\"jin\",$jin);$this-&gt;display(); 上面定义了一个一维数组，将其赋值于jin,然后渲染到对应的模板中我个人比较喜欢用foreach 123&lt;foreach name=\"jin\" item='vo'&gt;&#123;$key&#125;---&#123;$vo&#125;&lt;br /&gt;&lt;/foreach&gt; $key 为一维数组中的key 多维数组在模板中的遍历其实更多的时候是使用的多维数组，很多时候在数据库中取得数据以后在模板中进行渲染 1234567$psersons = array( 1=&gt;array('name'=&gt;'yyx','age'=&gt;28,'sex'=&gt;'male'), 2=&gt;array('name'=&gt;'jin','age'=&gt;24,'sex'=&gt;'female'), 3=&gt;array('name'=&gt;'shi','age'=&gt;28,'sex'=&gt;'female'), )$this-&gt;assign('persons',$persons);$this-&gt;display(); 123&lt;foreach name=\"persons\" item='person'&gt;&#123;$person['name']&#125;---&#123;$person['age']&#125;---&#123;$person['sex']&#125; &lt;br /&gt;&lt;/foreach&gt; 它是将二维数组里第一组作为一项进行遍历 CURD M方法，大M方法可以在不实现模型的基础上对数据库进行简单的curd，多以查询为主 $data = M(‘user’) 查询方式2.1 使用字符串作为查询条件 $User = M(“User”); // 实例化User对象$User-&gt;where(‘type=1 AND status=1’)-&gt;select(); 生成的SQL语句是 SELECT * FROM think_user WHERE type=1 AND status=1 2.2 使用数组作为查询条件 $data = M(‘data’);$condition[‘id’] = 1;$condition[‘data’] = ‘framework’;$condition[‘_logic’] = ‘or’;$rst = $data-&gt;where($condition)-&gt;select(); 生成的SQL语句是 SELECT * FROM think_data WHERE id = 1 OR data = ‘framework’ 注意 如果数组里的key不是表中的列的话则该条件不生效 _logic 默认是and 2.3 表达式查询这种查询比较灵活 表达式 含义EQ 等于（=）NEQ 不等于（&lt;&gt;）GT 大于（&gt;）EGT 大于等于（&gt;=）LT 小于（&lt;）ELT 小于等于（&lt;=）LIKE 模糊查询[NOT] BETWEEN （不在）区间查询[NOT] IN （不在）IN 查询EXP 表达式查询，支持SQL语法 $where[字段名]=array(表达式,查询条件) $condition[‘id’] = array(‘lt’,3);$rst = $data-&gt;where($condition)-&gt;select(); SQL: SELECT * FROM think_data WHERE id &lt; 3 $condition[‘id’] = array(‘lt’,3);$condition[‘data’] = array(‘like’,’%php’);$rst = $data-&gt;where($condition)-&gt;select(); SQL: SELECT * FROM think_data WHERE id &lt; 3 AND data LIKE ‘%php’ 如果想要查询以php结尾或者是fr开头的 $condition[‘id’] = array(‘lt’,3);$condition[‘data’] = array(‘like’,array(‘%php’,’fr%’));$rst = $data-&gt;where($condition)-&gt;select(); SQL: SELECT * FROM think_data WHERE id &lt; 3 AND (data LIKE ‘%php’ OR data LIKE ‘fr%’) 2.4 区间查询 $condition[‘id’] = array(array(‘gt’,0),array(‘lt’,3),’or’);$rst = $data-&gt;where($condition)-&gt;select(); SQL: SELECT * FROM think_data WHERE ( id &gt; 0 OR id &lt; 3 ) 区间查询与上面的表达式查询中的between有一些相似,但是between只能是and的关系，没有区间查询中的or关系 $condition[‘id’] = array(‘between’,’1,5’);$rst = $data-&gt;where($condition)-&gt;select(); SQL: SELECT * FROM think_data WHERE id BETWEEN ‘1’ AND ‘5’","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://www.yangyanxing.com/tags/ThinkPHP/"},{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/tags/PHP/"}]},{"title":"使用python进行文件夹对比","slug":"use-python-dircompare","date":"2015-12-29T15:09:30.000Z","updated":"2017-12-16T10:10:42.499Z","comments":true,"path":"article/use-python-dircompare.html","link":"","permalink":"https://www.yangyanxing.com/article/use-python-dircompare.html","excerpt":"最近写一个小脚本，在使用系统急救箱扫描并且处理完后，要将处理以后的样本和提供的标准进行对比已经提供了样本与处理以后的文件，我要写的脚本就是启急救箱并且将两个文件夹进行比较启动并且扫描比较好实现，但是在进行文件夹对比的时候走了一些弯路上网查到python的标准库里有一个filecmp类，这个类可以对文件夹或者文件进行对比，使用起来还是比较方便的filecmp官方文档/ 使用最下面的例子程序，我又对其进行了扩充我想达到的目的就是先对两个文件夹进行比较，输出不同的文件，然后再输出各自文件夹中独有的文件","text":"最近写一个小脚本，在使用系统急救箱扫描并且处理完后，要将处理以后的样本和提供的标准进行对比已经提供了样本与处理以后的文件，我要写的脚本就是启急救箱并且将两个文件夹进行比较启动并且扫描比较好实现，但是在进行文件夹对比的时候走了一些弯路上网查到python的标准库里有一个filecmp类，这个类可以对文件夹或者文件进行对比，使用起来还是比较方便的filecmp官方文档/ 使用最下面的例子程序，我又对其进行了扩充我想达到的目的就是先对两个文件夹进行比较，输出不同的文件，然后再输出各自文件夹中独有的文件 12345678910111213141516171819202122232425#coding:gbkfrom filecmp import dircmpdef show_diff_files(dcmp): for name in dcmp.diff_files: print \"diff_file %s found in %s and %s\" % (name, dcmp.left,dcmp.right) for sub_dcmp in dcmp.subdirs.values(): show_diff_files(sub_dcmp) def show_only(dcmp): if dcmp.left_only: ave_rst = 1 for i in dcmp.left_only: print \"%s只存在于%s中\"%(i,dcmp.left) if dcmp.right_only: for i in dcmp.right_only: print \"%s只存在于%s中\"%(i,dcmp.right) for sub_dcmp in dcmp.subdirs.values(): show_only(sub_dcmp)def compare(dir1,dir2): dcmp = dircmp(dir1,dir2) show_diff_files(dcmp) show_only(dcmp)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"使用国内镜像源来加速python pypi包的安装","slug":"1389","date":"2015-10-10T14:57:44.000Z","updated":"2017-12-16T16:15:57.185Z","comments":true,"path":"article/1389.html","link":"","permalink":"https://www.yangyanxing.com/article/1389.html","excerpt":"在国内使用pip安装包的时候，很多时候由于各种原因无法正常使用pypi.python.org的源，还好有国内的良心网站提供了国内镜像 网上的方法都是在%HOMEPATH%中新建pip目录，再新建一个pip.ini，可是我试了以后还是不能用，也不知道原作者是否可以用 后来我看了一下它的文档","text":"在国内使用pip安装包的时候，很多时候由于各种原因无法正常使用pypi.python.org的源，还好有国内的良心网站提供了国内镜像 网上的方法都是在%HOMEPATH%中新建pip目录，再新建一个pip.ini，可是我试了以后还是不能用，也不知道原作者是否可以用 后来我看了一下它的文档 这里应该是配制一个%HOME%的环境变量 于是我在环境变量里新建了一个HOME，值为%HOMEPATH%，然后在%HOMEPATH%目录里新建一个pip目录，在里面新建一个pip.ini 里面写入 12[global]index-url = http://pypi.douban.com/simple 或者 1234[global]index-url = http://pypi.douban.com/simple[install]trusted-host=pypi.douban.com 之后再使用pip install 就可以很顺利的安装了，我这里使用的是douban的安装源 20160113 更新今天在我的Raspberry中无论怎么修改pip.conf都不能生效无奈只能查看pip的源代码，把源代码中的默认下载地址改了修改 /usr/lib/python2.7/dist-packages/pip目录下的cmdoptions.py搜索 pypi.python.org将其修改为123456index_url = OptionMaker( '-i', '--index-url', '--pypi-url', dest='index_url', metavar='URL', default='http://pypi.douban.com/simple/', help='Base URL of Python Package Index (default %default).') 这里就直接使用http，而不是https，之后再使用sudo pip install 安装就默认走douban的了还可以修改/usr/lib/python2.7/dist-packages/setuptools/command下面的 easy_install.py也将里面的 self.index_url = self.index_url or “http://pypi.python.org/simple“改为self.index_url = self.index_url or “http://pypi.douban.com/simple“ 这样以后就可以通过 sudo easy_install 来安装，这个也是默认就走douban的源了","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"Android中的listView与ArrayAdapter与LayoutInflater的使用","slug":"1385","date":"2015-10-05T17:21:03.000Z","updated":"2017-12-16T16:16:36.344Z","comments":true,"path":"article/1385.html","link":"","permalink":"https://www.yangyanxing.com/article/1385.html","excerpt":"最近在看《第一行代码-android》，这本书讲的不错，从最android基础的开始讲起，由浅入深，一步一步的教怎么使用android开发中的各种内容，今天看到listView，书中讲到listView可能是使用最多也是最难的一个组件，看过之后觉得还是需要好好消化一下的，借助书中的代码，来记录一下学习的过程 一、在listView中简单的显示一行文字 这个应该是listView应用中最简单的了，在使用listView中，一般的步骤应该是，先在main_activity.xml中创建好listView的布局123456789101112131415LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"xmlns:tools=\"http://schemas.android.com/tools\"android:layout_width=\"match_parent\"android:layout_height=\"match_parent\"android:orientation=\"vertical\" &gt;&lt;ListView android:id=\"@+id/list_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt;&lt;/ListView&gt;&lt;/LinearLayout&gt;","text":"最近在看《第一行代码-android》，这本书讲的不错，从最android基础的开始讲起，由浅入深，一步一步的教怎么使用android开发中的各种内容，今天看到listView，书中讲到listView可能是使用最多也是最难的一个组件，看过之后觉得还是需要好好消化一下的，借助书中的代码，来记录一下学习的过程 一、在listView中简单的显示一行文字 这个应该是listView应用中最简单的了，在使用listView中，一般的步骤应该是，先在main_activity.xml中创建好listView的布局123456789101112131415LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"xmlns:tools=\"http://schemas.android.com/tools\"android:layout_width=\"match_parent\"android:layout_height=\"match_parent\"android:orientation=\"vertical\" &gt;&lt;ListView android:id=\"@+id/list_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt;&lt;/ListView&gt;&lt;/LinearLayout&gt; 之后在MainActivity.java中构造数据，这里应该是从数据库或者网上来获得数据，而为了方便只是简单的使用了一个数组 private String[] data = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot; }; 之后再使用一个arrayAdapter来适配array与listView 1ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1, 关于arrayAdapter的使用，http://www.cnblogs.com/loulijun/archive/2011/12/26/2302287.html 这篇文章介绍的还算比较简单 ArrayAdapter的初始化有多种方法，上面的应该是最简单通用的方法，第一个参数是一个上下文，一般是this,第二个布局文件，这里使用系统自带的android.R.layout.simple_list_item_1，后面有介绍如何使用自定义的布局文件，第三个参数是数据源。 将适配器适配到listView中 MainActivity.java的完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.uilayouttest;import java.util.ArrayList;import java.util.List;import android.app.Activity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.Window;import android.widget.AdapterView;import android.widget.AdapterView.OnItemClickListener;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;public class MainActivity extends Activity &#123;private String[] data = &#123; \"Apple\", \"Banana\", \"Orange\", \"Watermelon\", \"Pear\", \"Grape\", \"Pineapple\", \"Strawberry\",\"Cherry\", \"Mango\" &#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);requestWindowFeature(Window.FEATURE_NO_TITLE);setContentView(R.layout.activity_main);ArrayAdapter&lt;String&gt; adapter = newArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_1, data);ListView listView = (ListView) findViewById(R.id.list_view);listView.setAdapter(adapter);&#125;@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123;// Inflate the menu; this adds items to the action bar if it is present.getMenuInflater().inflate(R.menu.main, menu);return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123;// Handle action bar item clicks here. The action bar will// automatically handle clicks on the Home/Up button, so long// as you specify a parent activity in AndroidManifest.xml.int id = item.getItemId();if (id == R.id.action_settings) &#123;return true;&#125;return super.onOptionsItemSelected(item);&#125;&#125; 二、使用自定义的ListView 上面这个应该说是最简单的，下面来说说自定义的 如果说如果想要在listView和每个项(item)里包含一张图片与一个文字，那么就需要自定义listView了 首先先在layout下自定义一个xml文件,fruit_item.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;ImageView android:id=\"@+id/fruit_image\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/fruit_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_marginLeft=\"10dip\" /&gt; 这个布局文件其实就是定义了每个项的布局，之后创建一个数据源，它这里是使用了一个ArrayLlist，并创建了一个Fruit类，在初始化ArrayList的时候采用泛型限制只能用Fruit类。 Fruit类定义如下 12345678910111213141516171819package com.example.uilayouttest;public class Fruit &#123;private String name;public Fruit(String name)&#123;this.name = name;&#125;public String getName()&#123;return this.name;&#125;public int getImageId() &#123;return R.drawable.ic_launcher;&#125;&#125; 由于我没有那么多的图片，所以我就只返回了一张默认的ic_launcher的图片 自定义一个FruitAdapter类继承自ArrayAdapter类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.uilayouttest;import java.util.List;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ArrayAdapter;import android.widget.ImageView;import android.widget.TextView;public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123;private int resourceId;public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123;super(context, textViewResourceId, objects);resourceId = textViewResourceId;&#125;// 这个方法在每个子项被滚动到屏幕内的时候 会被调用public View getView(int position, View convertView, ViewGroup parent) &#123;Fruit fruit = getItem(position);// getItem()方法得到当前项的 Fruit 实例View view;ViewHolder viewHolder;if (convertView == null) &#123;view = LayoutInflater.from(getContext()).inflate(resourceId, null);viewHolder = new ViewHolder();viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image);viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name);view.setTag(viewHolder);&#125; else &#123;view = convertView;viewHolder = (ViewHolder) view.getTag();&#125;viewHolder.fruitImage.setImageResource(fruit.getImageId());viewHolder.fruitName.setText(fruit.getName());return view;&#125;class ViewHolder &#123;ImageView fruitImage;TextView fruitName;&#125;&#125; 这里有一些要记录的，首先初始化 public FruitAdapter(Context context, int textViewResourceId, List objects) { super(context, textViewResourceId, objects); resourceId = textViewResourceId; } 这里有三个参数，其实和ArrayAdapter的简单初始化一样，但是这里的第二个参数，在之后的初始化时，要传入的就是刚才自定义的fruit_item.xml布局文件。 第三个参数是数据源。 在FruitAdapter适配器的定义中使用到了LayoutInflater view = LayoutInflater.from(getContext()).inflate(resourceId, null); 网上查了查，这个是加载布局文件的函数，之前一直都是使用setContentView(R.layout.activity_main); 其实这个是更深入的函数 http://blog.csdn.net/guolin_blog/article/details/12921889; 这彷文章介绍的比较详细 比如说要在A布局上加载B布局，那么先初始化LayoutInflater的实例 LayoutInflater.from(getContext())，from里的参数就是A，这里就直接使用getContent()，然后再使用inflate(resourceId, null)加载B布局 这里由于在FruitAdapter初始化的时候将resourceId = textViewResourceId;也就是说这里是将自定义的fruit_item布局加载到主的main_activity中 之后为了性能的优化，使用了ViewHolder与convertView，convertView这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用 最终的MainActivity.java如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.example.uilayouttest;import java.util.ArrayList;import java.util.List;import android.app.Activity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.Window;import android.widget.AdapterView;import android.widget.AdapterView.OnItemClickListener;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;public class MainActivity extends Activity &#123;private List&lt;Fruit&gt; frutlist = new ArrayList&lt;Fruit&gt;();private void initFruit() &#123;Fruit apple = new Fruit(\"apple\");Fruit banana = new Fruit(\"banane\");Fruit orange = new Fruit(\"orange\");Fruit Watermelon = new Fruit(\"Watermelon\");Fruit Pear = new Fruit(\"Pear\");Fruit Grape = new Fruit(\"Grape\");Fruit Strawberry = new Fruit(\"Strawberry\");Fruit Pineapple = new Fruit(\"Pineapple\");Fruit Cherry = new Fruit(\"Cherry\");Fruit Mango = new Fruit(\"Mango\");frutlist.add(apple);frutlist.add(banana);frutlist.add(Mango);frutlist.add(Cherry);frutlist.add(Pineapple);frutlist.add(Strawberry);frutlist.add(Grape);frutlist.add(Pear);frutlist.add(Watermelon);frutlist.add(orange);&#125;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);requestWindowFeature(Window.FEATURE_NO_TITLE);setContentView(R.layout.activity_main);initFruit();FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, frutlist);ListView listView = (ListView) findViewById(R.id.list_view);listView.setAdapter(adapter);listView.setOnItemClickListener(new OnItemClickListener() &#123;@Overridepublic void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;String name = frutlist.get(position).getName();Toast.makeText(MainActivity.this, name, Toast.LENGTH_SHORT).show();&#125;&#125;);&#125;@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123;// Inflate the menu; this adds items to the action bar if it is present.getMenuInflater().inflate(R.menu.main, menu);return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123;// Handle action bar item clicks here. The action bar will// automatically handle clicks on the Home/Up button, so long// as you specify a parent activity in AndroidManifest.xml.int id = item.getItemId();if (id == R.id.action_settings) &#123;return true;&#125;return super.onOptionsItemSelected(item);&#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"}]},{"title":"使用jquery在一个页面中有多个form表单做数据有效性校验","slug":"1381","date":"2015-10-02T08:23:48.000Z","updated":"2017-12-16T16:17:49.128Z","comments":true,"path":"article/1381.html","link":"","permalink":"https://www.yangyanxing.com/article/1381.html","excerpt":"最近在做一个小网站的项目，有一个小问题，可能在有经验的前端er面前不是什么问题，但是由于我接触前端很少，所以这个问题也搞了好一会才解决 在一个页面里有两个表单，在各自点击提交时，先要对相应的input里做非空校验，然后再对里面的数据做下简单的字符串判断","text":"最近在做一个小网站的项目，有一个小问题，可能在有经验的前端er面前不是什么问题，但是由于我接触前端很少，所以这个问题也搞了好一会才解决 在一个页面里有两个表单，在各自点击提交时，先要对相应的input里做非空校验，然后再对里面的数据做下简单的字符串判断 html里是这样的 1234567891011121314151617181920212223242526&lt;tbody&gt; &lt;tr&gt; &lt;td class=\"sync\"&gt;&lt;a class=\"btn btn-success\" href=\"/syncfile?redo=1&amp;systype=x86\"&gt;32位同步其他组文件&lt;/a&gt;&lt;/td&gt; &lt;td class=\"update\"&gt;&lt;a class=\"btn btn-success\" href=\"/selfupdate?redo=1&amp;systype=x86\" &gt;32位急救箱自升级文件&lt;/a&gt;&lt;/td&gt; &lt;td class=\"twice\"&gt; &lt;form class=\"form-inline\" action=\"/check2\" method=\"GET\"&gt; &lt;input type=\"hidden\" name=\"type\" value=\"zip\" /&gt; &lt;input type=\"hidden\" name=\"redo\" value=1 /&gt; &lt;input type=\"text\" class=\"form-control sftppath\" name=\"sftppath\" placeholder=\"请输入急救箱捆包地址\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;急救箱捆包二次&lt;/button&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"sync\"&gt;&lt;a class=\"btn btn-success\" href=\"/syncfile?redo=1&amp;systype=x64\"&gt;64位同步其他组文件&lt;/a&gt;&lt;/td&gt; &lt;td class=\"update\"&gt;&lt;a class=\"btn btn-success\" href=\"/selfupdate?redo=1&amp;systype=x64\" &gt;64位急救箱自升级文件&lt;/a&gt;&lt;/td&gt; &lt;td class=\"twice\"&gt; &lt;form class=\"form-inline\" action=\"/check2\" method=\"GET\"&gt; &lt;input type=\"hidden\" name=\"type\" value=\"update\" /&gt; &lt;input type=\"hidden\" name=\"redo\" value=1 /&gt; &lt;input type=\"text\" class=\"form-control sftppath\" name=\"sftppath\" placeholder=\"请输入急救箱升级地址\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" id=\"123\"&gt;急救箱升级二次&lt;/button&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &#160; 起初我只是简单的用jquery做下非空校验 1234$(\"form\").submit(function()&#123; if($(\"input.sftppath\").val()=='')&#123; alert(\"sftp不能为空\"); &#125; 这样写，在点击第一个按钮(急救箱捆包二次)时，当前面的input里没有写数据的时候会有alert提示， 但是点击第二个按钮(急救箱升级二次)时，即使在前面的input里填写上数据也会有alert提示，因为在急救箱捆包二次那的input里没有值。 于是在网上找了一下，没有使用第三方的jquery插件，因为这个功能太小了。 我先打印了一个$(this).html() $(“form”).submit(function(){ alert($(this).html()) }) 在submit里，$(this)所指的节点是form的根节点 于是这里就好弄了 使用$(this).children(“input.sftppath”).val()来获得相应form中的sftppath的内容 12345678910111213141516171819202122232425$(\"form\").submit(function()&#123; if($(this).children(\"input.sftppath\").val() == '')&#123; alert(\"sftp路径不能为空\"); return false; &#125;else&#123; var buttontext = $(this).children('button.btn-primary').text(); var sftppath = $(this).children(\"input.sftppath\").val(); if (buttontext == \"急救箱升级二次\")&#123; if(sftppath.indexOf('-all')==-1)&#123; alert(\"不是有效的升级sftp路径\"); return false; &#125;else&#123; return true; &#125;; &#125;else if (buttontext == \"急救箱捆包二次\")&#123; if(sftppath.indexOf('-zip') == -1)&#123; alert(\"不是有效的捆包sftp路径\"); return false; &#125;else&#123; return true; &#125;; &#125;; &#125;;&#125;); 其实这里也就是明白了在submit函数里，$(this)指的是form的根节点，而不是那个button节点。","categories":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yangyanxing.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://www.yangyanxing.com/tags/jquery/"}]},{"title":"使用uiautomator的python封装进行android的UI测试","slug":"how-to-use-uiautomator-with-python","date":"2015-08-27T17:17:30.000Z","updated":"2017-12-16T10:10:42.396Z","comments":true,"path":"article/how-to-use-uiautomator-with-python.html","link":"","permalink":"https://www.yangyanxing.com/article/how-to-use-uiautomator-with-python.html","excerpt":"最近项目中有个需求要在至少100台手机上对应用进行兼容性测试，首先想到的就是自动化来操作，不想一台台的操作相同的重复操作 基本的需求是这样的，安装被测试的应用，启动并退出，然后安装测试样本，检测是否有相应的弹窗拦截 考虑到市面上的各种测试框架与自已熟悉的编程语言，最后选择了google自家的uiautomator来搞，借助于前人对其进行了python封装，所以一开始还是挺顺利的，但是整个过程中还是有很多需要注意的地方","text":"最近项目中有个需求要在至少100台手机上对应用进行兼容性测试，首先想到的就是自动化来操作，不想一台台的操作相同的重复操作 基本的需求是这样的，安装被测试的应用，启动并退出，然后安装测试样本，检测是否有相应的弹窗拦截 考虑到市面上的各种测试框架与自已熟悉的编程语言，最后选择了google自家的uiautomator来搞，借助于前人对其进行了python封装，所以一开始还是挺顺利的，但是整个过程中还是有很多需要注意的地方 https://github.com/xiaocong/uiautomator 这个是xiaocong对其进行的python封装，也是这个小测试用例使用的，膜拜下 准备：python27,不能使用python26，安装urllib3与uiautomator，可以使用easy_install命令，安装android SDK，配置好adb的环境变量，这些应该都是作为android测试人员最基本的环境配置，要测试的应用是360手机急救箱，可以从http://jijiu.360.cn/ 这个网址下载 下面是基本的测试流程1234567# 需要配置好adb 环境变量# 1.先确定有几台手机# 2.再确定有多少个应用# 3.先安装mkiller,启动mkiller# 4.再安装测试的样本# 5.检查是否有取消安装的按钮出现，出现说明测试通过，没出现说明测试失败 既然要采用自动化，就不能手机测试那样，一台一台的跑，应该可以同时跑多台手机，我的想法就是启用多线程来跑，每个手机用一个线程来跑 确定有几台手机我封了一个方法12345678910111213def finddevices(): rst = util.exccmd('adb devices') devices = re.findall(r'(.*?)\\s+device',rst) if len(devices) &gt;1: deviceIds = devices[1:] logger.info('共找到%s个手机'%str(len(devices)-1)) for i in deviceIds: logger.info('ID为%s'%i) return deviceIds else: logger.error('没有找到手机，请检查') return uiautomator在python中的使用下面来说说uiautomator在python中的使用，其实github中的readme.md写的挺清楚，但是实践起来还是有一些问题 uiautomator在使用的时候都要初始化一个d对象，单个手机可以通过1from uiautomator import device as d 多台手机可以1from uiautomator import Device 然后通过 d=Device(Serial)的方式初始化d对象，以后的操作基本上都是操作这个d对象，可以想象每个d对应着一台手机 我觉得这个设计有点不大好，我现在还经常在device的大小写上犯迷糊 基本的点击操作12345678# press home keyd.press.home()# press back keyd.press.back()# the normal way to press back keyd.press(\"back\")# press keycode 0x07('0') with META ALT(0x02) ond.press(0x07, 0x02) 首先安装启动应用，安装采用adb install 命令，启动采用adb shell am start 命令 手机急救箱的launchable-activity是’com.qihoo.mkiller.ui.index.AppEnterActivity’,第一次启动会弹出使用协议要用户来点击”同意并使用” watcher的使用我这里采用了watcher来监视并且点击，基本的watcher方法是1d.watcher('agree').when(text=u'同意并使用').click(text=u'同意并使用') 先给watcher起一个名字，随便起，我这里叫agree，when里面写条件，我这里就是当text为’同意并使用’,后面写当符合这些条件的时候进行的操作，我这里就是click(text=u’同意并使用’),这里有一个坑，我之前写watcher的时候，就直接写click() 我以为里面不写内容默认就会点击前面找到的元素，但是后来发现这样是不行的，必须要写上要点击哪个对象 其实对于这种只出现一次的view可以不用写在watcher里，可以直接写d(text=u’同意并使用’).click(),但是考虑到这个界面出现之前会有一些延迟，各种手机的性能不同，也不好加time.sleep()时间，所以我建议像这种一律写到watcher里，什么时候出现就什么时候点击。 由于这个应用会请求root权限，所以有时第三方的root工具会弹相应的授权提示框，我想大部分的root工具应该都是有”允许”这个按钮的，于是我就加了一个watcher1d.watcher('allowroot').when(text=u'允许').click(text=u'允许') 点击同意后会再弹一个开启超强模式的弹框，这里我要点击的是取消 1d.watcher('cancel').when(text=u'取消').click(text=u'取消') 之后要点击一下back键，这时又会弹一个是否退出的框，这次我要点击“确认” 这个确认我是后面单独处理的，其实也可以放在watcher里，只是我的考虑是有时点击back键的时候不一定会弹出来这个框，所以我会尝试多点击几次，直到这个框出来 但现在就有一个问题了，刚才写了一个d.watcher(‘cancel’).when(text=u’取消’).click(text=u’取消’)，这时当弹出这个框的时候，watcher就要起作用了，就会先去点击取消，这不是我想要的，所以我将之前点击取消的加了一个限制条件1d.watcher('cancel').when(text=u'取消').when(textContains=u'超强防护能够极大提高').click(text=u'取消') textContains的意思就是和包含里面的文字，上面的意思就是当界面中text是“取消”的同时还要有一个view的text中要包含u’超强防护能够极大提高’,这样的话就限制的点击“取消”的条件，再遇到退出时的提示框就不会再会点击”取消”了 尽可能的想到可能出现的弹框，比较在小米手机中安装应用会弹一个小米的安装确认界面，使用下面的watcher来进行监测点击1d.watcher('install').when(text=u'安装').when(textContains=u'是否要安装该应用程序').click(text=u'安装',className='android.widget.Button') 总的watcher就是下面的样子 123456d.watcher('allowroot').when(text=u'允许').click(text=u'允许') d.watcher('install').when(text=u'安装').when(textContains=u'是否要安装该应用程序').click(text=u'安装',className='android.widget.Button') #专门为小米弹出的安装拦截 d.watcher('cancel').when(text=u'取消').when(textContains=u'超强防护能够极大提高').click(text=u'取消') d.watcher('confirm').when(text=u'确认').when(textContains=u'应用程序许可').click(text=u'确认') d.watcher('agree').when(text=u'同意并使用').click(text=u'同意并使用') d.watcher('weishiuninstall').when(textContains=u'暂不处理').click(textContains=u'暂不处理') 然后使用d.watchers.run()来启动watcher 但是在实际的watcher中，我发现这个watcher并没有想象的那样好用，有时经常是明明有相应的view但是就是点击不上，经过多次尝试，我发现，当界面已经出现的时候，这时我再强行的使用run()方法来启动watchers，这时它就能很好的点击了，所以基于此，我写了一个循环来来无限的调用run方法，times限制了次数，根据项目的实际进行调整吧，sleep时间也可以相应的调整123456789101112def runwatch(d,data): times = 120 while True: if data == 1: return True # d.watchers.reset() d.watchers.run() times -= 1 if times == 0: break else: time.sleep(0.5) 监视的时候又不能只跑监视程序，还要跑相应的测试步骤，所以这里我把这个runwatch方法放到一个线程中去跑，起一个线程用作监视，脚本的测试方法放在另外的线程上跑 线程函数123456789101112131415161718192021222324252627282930#线程函数class FuncThread(threading.Thread): def __init__(self, func, *params, **paramMap): threading.Thread.__init__(self) self.func = func self.params = params self.paramMap = paramMap self.rst = None self.finished = False def run(self): self.rst = self.func(*self.params, **self.paramMap) self.finished = True def getResult(self): return self.rst def isFinished(self): return self.finisheddef doInThread(func, *params, **paramMap): t_setDaemon = None if 't_setDaemon' in paramMap: t_setDaemon = paramMap['t_setDaemon'] del paramMap['t_setDaemon'] ft = FuncThread(func, *params, **paramMap) if t_setDaemon != None: ft.setDaemon(t_setDaemon) ft.start() return ft 所以这里启动线程来跑runwatcher的调用就是 data = 0 doInThread(runwatch,d,data,t_setDaemon=True) 多台手机的运行问题基本的思路就是这样，这样当脚本都写完了以后在单个手机上运行很好，但是一旦插入多个手机就会出现一个问题，所有watcher只在一台手机上有效，另外的手机就只能傻傻的不知道点击，这个问题困扰了很久，我在github上也给作者发issue，但是后来我自已找到了解决的办法，就是在d=Device(Serial)的时候加上local_port端口号，让每台手机使用不同的local_port端口号，这样各自运行各自的，都很完好 最终的代码以下了测试脚本的代码 mkiller.py,主测试脚本文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#coding:gbkimport os,sys,time,re,csvimport logimport utilfrom uiautomator import Deviceimport tracebackimport log,loggingimport multiprocessingoptpath = os.getcwd() #获取当前操作目录imgpath = os.path.join(optpath,'img') #截图目录def cleanEnv(): os.system('adb kill-server') needClean = ['log.log','img','rst'] pwd = os.getcwd() for i in needClean: delpath = os.path.join(pwd,i) if os.path.isfile(delpath): cmd = 'del /f/s/q \"%s\"'% delpath os.system(cmd) elif os.path.isdir(delpath): cmd = 'rd /s/q \"%s\"' %delpath os.system(cmd) if not os.path.isdir('rst'): os.mkdir('rst')def runwatch(d,data): times = 120 while True: if data == 1: return True # d.watchers.reset() d.watchers.run() times -= 1 if times == 0: break else: time.sleep(0.5)def installapk(apklist,d,device): sucapp = [] errapp = [] # d = Device(device) #初始化一个结果文件 d.screen.on() rstlogger = log.Logger('rst/%s.log'%device,clevel = logging.DEBUG,Flevel = logging.INFO) #先安装mkiller mkillerpath = os.path.join(os.getcwd(),'MKiller_1001.apk') cmd = 'adb -s %s install -r %s'% (device,mkillerpath) util.exccmd(cmd) def checkcancel(d,sucapp,errapp): times = 10 while(times): if d(textContains = u'取消安装').count: print d(textContains = u'取消安装',className='android.widget.Button').info['text'] d(textContains = u'取消安装',className='android.widget.Button').click() rstlogger.info(device+'测试成功，有弹出取消安装对话框') break else: time.sleep(1) times -= 1 if times == 0: rstlogger.error(device+'测试失败，没有弹出取消安装对话框') try: d.watcher('allowroot').when(text=u'允许').click(text=u'允许') d.watcher('install').when(text=u'安装').when(textContains=u'是否要安装该应用程序').click(text=u'安装',className='android.widget.Button') #专门为小米弹出的安装拦截 d.watcher('cancel').when(text=u'取消').when(textContains=u'超强防护能够极大提高').click(text=u'取消') d.watcher('confirm').when(text=u'确认').when(textContains=u'应用程序许可').click(text=u'确认') d.watcher('agree').when(text=u'同意并使用').click(text=u'同意并使用') d.watcher('weishiuninstall').when(textContains=u'暂不处理').click(textContains=u'暂不处理') # d.watchers.run() data = 0 util.doInThread(runwatch,d,data,t_setDaemon=True) #启动急救箱并退出急救箱 cmd = 'adb -s %s shell am start com.qihoo.mkiller/com.qihoo.mkiller.ui.index.AppEnterActivity'% device util.exccmd(cmd) time.sleep(5) times = 3 while(times): d.press.back() if d(text=u'确认').count: d(text=u'确认').click() break else: time.sleep(1) times -=1 for item in apklist: apkpath = item if not os.path.exists(apkpath): logger.error('%s的应用不存在，请检查'%apkpath) continue if not device: cmd = 'adb install -r \"%s\"' % apkpath else: cmd = 'adb -s %s install -r \"%s\"'%(device,apkpath) util.doInThread(checkcancel,d,sucapp,errapp) rst = util.exccmd(cmd) except Exception, e: logger.error(traceback.format_exc()) data = 1 data = 1 return sucappdef finddevices(): rst = util.exccmd('adb devices') devices = re.findall(r'(.*?)\\s+device',rst) if len(devices) &gt;1: deviceIds = devices[1:] logger.info('共找到%s个手机'%str(len(devices)-1)) for i in deviceIds: logger.info('ID为%s'%i) return deviceIds else: logger.error('没有找到手机，请检查') return #needcount:需要安装的apk数量，默认为0，既安所有#deviceids:手机的列表#apklist:apk应用程序的列表def doInstall(deviceids,apklist): count = len(deviceids) port_list = range(5555,5555+count) for i in range(len(deviceids)): d = Device(deviceids[i],port_list[i]) util.doInThread(installapk,apklist,d,deviceids[i])#结束应用def uninstall(deviceid,packname,timeout=20): cmd = 'adb -s %s uninstall %s' %(deviceid,packname) ft = util.doInThread(os.system,cmd,t_setDaemon=True) while True: if ft.isFinished(): return True else: time.sleep(1) timeout -= 1 if timeout == 0: return False# 需要配置好adb 环境变量# 1.先确定有几台手机# 2.再确定有多少个应用# 3.先安装mkiller,启动mkiller# 4.再安装测试的样本# 5.检查是否有取消安装的按钮出现，出现说明测试通过，没出现说明测试失败if __name__ == \"__main__\": cleanEnv() logger = util.logger devicelist = finddevices() if devicelist: apkpath = os.path.join(os.getcwd(),'apk') apklist = util.listFile(apkpath) doInstall(devicelist,apklist) #每个手机都要安装apklist里的apk util.py 线程与执行cmd脚本函数文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:gbkimport os,sysimport logimport loggingimport threadingimport multiprocessingimport timelogger = log.Logger('log.log',clevel = logging.DEBUG,Flevel = logging.INFO)def exccmd(cmd): try: return os.popen(cmd).read() except Exception: return None#遍历目录内的文件列表def listFile(path, isDeep=True): _list = [] if isDeep: try: for root, dirs, files in os.walk(path): for fl in files: _list.append('%s\\%s' % (root, fl)) except: pass else: for fn in glob.glob( path + os.sep + '*' ): if not os.path.isdir(fn): _list.append('%s' % path + os.sep + fn[fn.rfind('\\\\')+1:]) return _list#线程函数class FuncThread(threading.Thread): def __init__(self, func, *params, **paramMap): threading.Thread.__init__(self) self.func = func self.params = params self.paramMap = paramMap self.rst = None self.finished = False def run(self): self.rst = self.func(*self.params, **self.paramMap) self.finished = True def getResult(self): return self.rst def isFinished(self): return self.finisheddef doInThread(func, *params, **paramMap): t_setDaemon = None if 't_setDaemon' in paramMap: t_setDaemon = paramMap['t_setDaemon'] del paramMap['t_setDaemon'] ft = FuncThread(func, *params, **paramMap) if t_setDaemon != None: ft.setDaemon(t_setDaemon) ft.start() return ft log.py log相应的函数文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#coding=gbkimport logging,osimport ctypesFOREGROUND_WHITE = 0x0007FOREGROUND_BLUE = 0x01 # text color contains blue.FOREGROUND_GREEN= 0x02 # text color contains green.FOREGROUND_RED = 0x04 # text color contains red.FOREGROUND_YELLOW = FOREGROUND_RED | FOREGROUND_GREENSTD_OUTPUT_HANDLE= -11std_out_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)def set_color(color, handle=std_out_handle): bool = ctypes.windll.kernel32.SetConsoleTextAttribute(handle, color) return boolclass Logger: def __init__(self, path,clevel = logging.DEBUG,Flevel = logging.DEBUG): self.logger = logging.getLogger(path) self.logger.setLevel(logging.DEBUG) fmt = logging.Formatter('[%(asctime)s] [%(levelname)s] %(message)s', '%Y-%m-%d %H:%M:%S') #设置CMD日志 sh = logging.StreamHandler() sh.setFormatter(fmt) sh.setLevel(clevel) #设置文件日志 fh = logging.FileHandler(path) fh.setFormatter(fmt) fh.setLevel(Flevel) self.logger.addHandler(sh) self.logger.addHandler(fh) def debug(self,message): self.logger.debug(message) def info(self,message): self.logger.info(message) def war(self,message,color=FOREGROUND_YELLOW): set_color(color) self.logger.warn(message) set_color(FOREGROUND_WHITE) def error(self,message,color=FOREGROUND_RED): set_color(color) self.logger.error(message) set_color(FOREGROUND_WHITE) def cri(self,message): self.logger.critical(message)if __name__ =='__main__': logyyx = Logger('yyx.log',logging.WARNING,logging.DEBUG) logyyx.debug('一个debug信息') logyyx.info('一个info信息') logyyx.war('一个warning信息') logyyx.error('一个error信息') logyyx.cri('一个致命critical信息') 这个小测试应用虽然比较简单，但是由于刚刚接触uiautomator的python封装，所以还是遇到了一些麻烦，不过还好，最终的结果是很好的解决了相应的问题，这里也算是抛砖引玉吧，这个uiautomator还有很多好玩的值得探索的地方，待以后慢慢发现~","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.yangyanxing.com/tags/自动化测试/"}]},{"title":"使用wxPython建立一个计算文件md5的GUI工具","slug":"1350","date":"2015-06-25T17:13:43.000Z","updated":"2017-12-16T10:10:41.969Z","comments":true,"path":"article/1350.html","link":"","permalink":"https://www.yangyanxing.com/article/1350.html","excerpt":"最近在看wxPython，一开始觉得它的布局好乱，半天整不明白，这里通过写一个小工具来记录一下wxPython的一些基本使用 小工具最终是下面这个样子，将文件拖到上面会自动计算其md5与size","text":"最近在看wxPython，一开始觉得它的布局好乱，半天整不明白，这里通过写一个小工具来记录一下wxPython的一些基本使用 小工具最终是下面这个样子，将文件拖到上面会自动计算其md5与size 下面是全部的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#coding:gbkimport wximport optparseimport time,hashlibimport threadingimport osdef checkMD5(pefile): try: f = open(pefile,'rb') data = f.read() m = hashlib.md5() m.update(data) f.close() return m.hexdigest() except: return 'error'def getFileSize(filename): try: size = int(os.path.getsize(filename)) return size except: return 'error'#线程函数class FuncThread(threading.Thread): def __init__(self, func, *params, **paramMap): threading.Thread.__init__(self) self.func = func self.params = params self.paramMap = paramMap self.rst = None self.finished = False def run(self): self.rst = self.func(*self.params, **self.paramMap) self.finished = True def getResult(self): return self.rst def isFinished(self): return self.finisheddef doInThread(func, *params, **paramMap): t_setDaemon = None if 't_setDaemon' in paramMap: t_setDaemon = paramMap['t_setDaemon'] del paramMap['t_setDaemon'] ft = FuncThread(func, *params, **paramMap) if t_setDaemon != None: ft.setDaemon(t_setDaemon) ft.start() return ftclass FileDropTarget(wx.FileDropTarget): def __init__(self, filetext,md5tx,filesizetx): wx.FileDropTarget.__init__(self) self.filepath = filetext self.md5tx = md5tx self.filesizetx = filesizetx def OnDropFiles(self, x, y, fileNames): filename = fileNames[0].encode('gbk') print filename print type(filename) self.filepath.SetValue(filename) md5 = doInThread(checkMD5,filename) filesize = doInThread(getFileSize,filename) while True: if not md5.isFinished(): time.sleep(0.5) else: self.md5tx.SetValue(md5.getResult()) break while True: if not filesize.isFinished(): time.sleep(0.5) else: self.filesizetx.SetValue(str(filesize.getResult())) breakclass Frame(wx.Frame): #Frame 进行初始化 def __init__(self,title): wx.Frame.__init__(self,None,title=title,size = (400,300)) boxSizer = wx.BoxSizer(wx.VERTICAL) self.panel = wx.Panel(self) # boxSizer.Add(self.panel,1,wx.EXPAND|wx.ALL) #wx.ALL 周围的距离，EXPAND扩充到全部 filepath = wx.StaticText(self.panel,-1,\"FileDir(请将文件拖到本对话框中)\") filetext = wx.TextCtrl(self.panel,-1,\"\",size=(350,20)) md5st = wx.StaticText(self.panel,-1,\"MD5\") md5tx = wx.TextCtrl(self.panel,-1,size=(250,20)) filesizest = wx.StaticText(self.panel,-1,'FileSize') filesizetx = wx.TextCtrl(self.panel,-1,size=(250,20)) # hashst = wx.StaticText(self.panel,-1,'Hash') # hashtx = wx.TextCtrl(self.panel,-1,size=(250,20)) boxSizer.Add(filepath,0,wx.EXPAND|wx.LEFT|wx.TOP,border=10) boxSizer.Add(filetext,0,wx.LEFT|wx.TOP,border=10) boxSizer.Add((-1,20)) boxSizer.Add(md5st,0,wx.LEFT|wx.TOP,border=10) boxSizer.Add(md5tx,0,wx.LEFT|wx.TOP,border=10) boxSizer.Add((-1,10)) boxSizer.Add(filesizest,0,wx.LEFT|wx.TOP,border=10) boxSizer.Add(filesizetx,0,wx.LEFT|wx.TOP,border=10) # boxSizer.Add((-1,10)) # boxSizer.Add(hashst,0,wx.LEFT|wx.TOP,border=10) # boxSizer.Add(hashtx,0,wx.LEFT|wx.TOP,border=10) dropTarget = FileDropTarget(filetext,md5tx,filesizetx) self.panel.SetDropTarget( dropTarget ) self.panel.SetSizer(boxSizer)class App(wx.App): ##继承wx.App def OnInit(self): ##还没有调起来的时候读取初始化 self.frame = Frame('MD5&amp;size信息') self.frame.Centre() self.frame.Show(True) return Truedef killSelf(evt = None): os.system('taskkill /F /T /PID %d &gt;NUL 2&gt;NUL' % win32process.GetCurrentProcessId())if __name__ == '__main__': parser = optparse.OptionParser() parser.add_option('-x', '--no-update', dest = 'test', action = 'store_true', help = 'start without update') parser.add_option('-t', '--no-update-test', dest = 'test2', action = 'store_true', help = 'start without update debug') options, args = parser.parse_args() if options.test: print(\"-x param\") if options.test2: print(\"-t param\") 一点点的解释 class App与App().MainLoop()是固定写法，在class App下有一个def OnInit方法来初始化主的Frame，将其居中并且Show()出来，没什么好说的，主要看一下Frame的定义 这个小工具使用的是boxSizer来布局，为了简单我只使用了一个boxSizer，将里面的所有控件采用VERTICAL(垂直)的方式来布局，如果想要将MD5与后面的文本框放在同一行，那么就需要添加一个水平的boxSizer，然后那将这个水平的boxSizer再放入主的boxSizer boxSizer = wx.BoxSizer(wx.VERTICAL) #初始化一个垂直的boxSizer，也是整个框架的主Sizer self.panel = wx.Panel(self) #初始化一个panel，这个panel是放了放之后的控件的 filepath = wx.StaticText(self.panel,-1,”FileDir(请将文件拖到本对话框中)”) filetext = wx.TextCtrl(self.panel,-1,””,size=(350,20)) md5st = wx.StaticText(self.panel,-1,”MD5”) md5tx = wx.TextCtrl(self.panel,-1,size=(250,20)) filesizest = wx.StaticText(self.panel,-1,’FileSize’) filesizetx = wx.TextCtrl(self.panel,-1,size=(250,20)) 上面是初始化相应的静态文本与文本框，方法中的第一个参数是其所在的父类窗口，这里也就是self.panel，其实也可以不用panel，而是将其直接放入到boxSizer中 boxSizer.Add(filepath,0,wx.EXPAND|wx.LEFT|wx.TOP,border=10) 将filepath加入到主的boxSizer中，这里一开始我有一些困惑，一开始我一直以为先将所有的控件放入到panel中，然后再将panel放入到boxSizer中，但是这样是不对的，而应该是直接就入到boxSizer中，将该控件的父类设置为panel，之后就没有将panel放入boxSizer这一步操作，wx.LEFT|wx.TOP,border=10 这个参数表示的是该控件距离上来左各有10个像素的距离，再使用wx.EXPAND来使其充分的填充其所在的区域，我曾经想，可否设置成距离上10px,左20px，但是貌似不能这样设置，Add函数里只能有一个border参数，换句话说只能设置相同的数值，之后我再找找是否可以实现。 boxSizer.Add((-1,20)) #这个是添加一个空距离，距离上20px dropTarget = FileDropTarget(filetext,md5tx,filesizetx) self.panel.SetDropTarget( dropTarget ) 这个是放该窗口类添加一个拖拽方法，也是比较固定的写法 上面的class FileDropTarget中的init与OnDropFiles方法也是固定的方法，只是里面的处理函数不同。 wxPython中的一些style与flag等参数在布局中使用需要一些经验，还有它的很多控件和与之绑定的方法，要想熟练掌握还需要下一些工夫，下面两个网站算是介绍比较详细，要多多查阅 http://wxpython.org/Phoenix/docs/html/1classindex.html http://docs.wxwidgets.org/2.8.9/wx_classref.html","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"笨方法实现webpy的表单校验功能","slug":"1340","date":"2015-05-02T09:43:01.000Z","updated":"2017-12-16T10:10:42.246Z","comments":true,"path":"article/1340.html","link":"","permalink":"https://www.yangyanxing.com/article/1340.html","excerpt":"最近在写一个小的demo，简单的用户注册与登录，检查在注册的时候要先检测用户名是否已经存在了，还要检查一下密码长度要不得小于3个字符 检查用户是否存在我是写在了一个单独的model.py里123456def check(uname):info = db.select('pytest',where=\"username=$uname\",vars=locals())if len(info)&gt;0:return Falseelse:return True","text":"最近在写一个小的demo，简单的用户注册与登录，检查在注册的时候要先检测用户名是否已经存在了，还要检查一下密码长度要不得小于3个字符 检查用户是否存在我是写在了一个单独的model.py里123456def check(uname):info = db.select('pytest',where=\"username=$uname\",vars=locals())if len(info)&gt;0:return Falseelse:return True 这里的return True与False与实际的是相反的，这里后面做校验操作的时候做说明 官方的文档中有写校验的说明，但写的比较笼统，但是有一点写到了表单的校验12345vpass = form.regexp(r\".&#123;3,20&#125;$\", 'must be between 3 and 20 characters')vemail = form.regexp(r\".*@.*\", \"must be a valid email address\")validators = [ form.Validator(\"Passwords did't match\", lambda i: i.password == i.password2)] vpass 是通过正则表达式来校验密码长度在3-20位， vmail是校验邮箱格式的正确性，要有一个@符 而下面的validators则是由一个form.Validator生成的列表类 我通过这里的lambda函数想到了对表单的校验12345validators=[ form.Validator(u'用户名不能为空',lambda i:len(i.username)&gt;0), form.Validator(u'用户名已经存在',lambda i:model.check(i.username)), form.Validator(u'两次输入的密码不一致',lambda i:i.pwd==i.pwd2), ] 这里的model.check就是调用上面写的函数，如果有，则返回False，触发’用户名已经存在’条件 另外，我看form.py里有一个变量 notnull = Validator(“Required”, bool)，也可以直接调用这个变量，但是它的提示文字是Required，这里可以初始化一个中文的提示 form.Textbox('username',form.Validator(u\"必填\", bool),description=u'用户名(*)') 最终我写的这个表单是这个样子的 ##表单校验 vpass = form.regexp(r\".{3,20}$\", u'密码长度不得小于3位') reg_form = form.Form( # form.Textbox('username',form.Validator(u\"必填\", bool),description=u'用户名(*)'), form.Textbox('username',description=u'用户名(*)'), form.Password('pwd',vpass,description=u'密码'), form.Password('pwd2',description=u'重复密码'), form.Button('submit',type='submit',html=u'注册'), validators=[ form.Validator(u'用户名不能为空',lambda i:len(i.username)>0), form.Validator(u'用户名已经存在',lambda i:model.check(i.username)), form.Validator(u'两次输入的密码不一致',lambda i:i.pwd==i.pwd2), ] ) validators里我不知道还是否有别的调用接收表单值的方法，我尝试过 form.Validator(u’用户名不能为空’,len(web.input().get(‘username’))&gt;0) 但是这个在模板form.render()中就会报错，所以现在还是先以这种笨方式简单的调用表单校验吧！","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"webpy","slug":"webpy","permalink":"https://www.yangyanxing.com/tags/webpy/"}]},{"title":"那天遇到一个杀马特","slug":"1329","date":"2015-03-11T15:51:11.000Z","updated":"2017-12-16T10:10:42.421Z","comments":true,"path":"article/1329.html","link":"","permalink":"https://www.yangyanxing.com/article/1329.html","excerpt":"上小学的时候对于别人如果能有零花钱就感觉很羡慕因为他们可以买到自已喜欢的吃的但是我不会去奢求渴望父母也给我到了初中，我会觉得那些染着黄毛，成天不上学开着大摩托的人比较牛气因为他们可以不用上学，不用写作业，想打认谁就打谁，可以为别人拔份儿可以我也不羡慕他们，我也不会去搞个彩毛儿，穿个喇叭裤到了高中，我觉得那些长的帅气，会打篮球，会弹吉他，会讨女孩子开心的人很好于是我也会在学习之于搞些自已喜欢的东西到了大学，那种八面玲珑，左右逢源的人很好","text":"上小学的时候对于别人如果能有零花钱就感觉很羡慕因为他们可以买到自已喜欢的吃的但是我不会去奢求渴望父母也给我到了初中，我会觉得那些染着黄毛，成天不上学开着大摩托的人比较牛气因为他们可以不用上学，不用写作业，想打认谁就打谁，可以为别人拔份儿可以我也不羡慕他们，我也不会去搞个彩毛儿，穿个喇叭裤到了高中，我觉得那些长的帅气，会打篮球，会弹吉他，会讨女孩子开心的人很好于是我也会在学习之于搞些自已喜欢的东西到了大学，那种八面玲珑，左右逢源的人很好工作后觉得有真正本事的人很好上学的时候，一天10块钱的伙食自已也能过得好好的现在偶尔回趟学校吃个餐厅都觉得太值了随着年龄与见识的增长，心智也根着变化以前觉得那么美好值得追求的东西，像以前的黄毛大喇叭裤，打架，帅气，才华现在觉得都是那么稀松平常但是每个时间里有着自已的追求，有着自已的理想突破枷锁，实现理想，得到自已想要的其实结果看起来那么不值一文，重要的是享受这段过程现在我又想要什么呢？我为之付出与奋斗了吗？有感于今天下班路上看一个杀马特骑个大摩托其实现在看起来挺可笑的，大冷天的还开个摩托，为了显摆杀马特，还不戴头盔……而想想以前我不也想这个样子吗？","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"成就感，一种很久违了的感觉","slug":"1327","date":"2015-03-11T15:48:27.000Z","updated":"2017-12-16T10:10:42.355Z","comments":true,"path":"article/1327.html","link":"","permalink":"https://www.yangyanxing.com/article/1327.html","excerpt":"","text":"以前看到的文字，看到之时已泪流满面 我的孩子,我希望你好好学习,不是因为我要你跟别人比,而是因为我希望你将来会拥有选择的权利,选择有意义你又喜爱的工作,而不是被迫谋生。当你的工作在你心中有意义,你就有成就感，成就感会给你带去快乐。无论工作贵贱，只要你是快乐的，妈妈就支持你，因为腰缠万贯也换不得一个真心的幸福。 每天早起晚归的做着一份看不清未来但又不得不去做的工作，因为要谋生，本来应该朝气蓬勃的年纪却变得暮气沉沉，早起挤地铁，挤电梯，下班还要和中介斗智斗勇，我现在之所以没法选择我想要过的生活也是因为早年没有认真的学习，成就感，一种很久违了的感觉。","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"Android stadio上使用robotium初体验","slug":"1320","date":"2015-03-05T14:57:37.000Z","updated":"2017-12-16T10:10:42.234Z","comments":true,"path":"article/1320.html","link":"","permalink":"https://www.yangyanxing.com/article/1320.html","excerpt":"在Android Stadio(as)上创建一个app的时候默认会自动创建相应的test类，可以直接在里面写单元测试用例 一、在项目(module)中导入robotium的jar包，右键app-&gt;new-&gt;directory,输入libs 然后将robotium-solo-5.3.1.jar复制进去，然后右键robotium-solo-5.3.1.jar选择add as library,之后就可以写测试用例了 如果还有问题，看一下项目的build gradle12345dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile &apos;com.android.support:appcompat-v7:21.0.3&apos; compile files(&apos;libs/robotium-solo-5.3.1.jar&apos;) &#125;","text":"在Android Stadio(as)上创建一个app的时候默认会自动创建相应的test类，可以直接在里面写单元测试用例 一、在项目(module)中导入robotium的jar包，右键app-&gt;new-&gt;directory,输入libs 然后将robotium-solo-5.3.1.jar复制进去，然后右键robotium-solo-5.3.1.jar选择add as library,之后就可以写测试用例了 如果还有问题，看一下项目的build gradle12345dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile &apos;com.android.support:appcompat-v7:21.0.3&apos; compile files(&apos;libs/robotium-solo-5.3.1.jar&apos;) &#125; 加入 compile files(‘libs/robotium-solo-5.3.1.jar’) 以下是我简单的写了一个小的测试app和其单元测试,非常简单，没什么实际意义，只是为了演示，其目录结构如下 app代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.kevin.helloword;import android.support.v7.app.ActionBarActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends ActionBarActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); final TextView tx = (TextView)findViewById(R.id.textView); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this,\"helloWorld\",Toast.LENGTH_SHORT).show(); Toast.makeText(MainActivity.this,\"杨彦星\",Toast.LENGTH_LONG).show(); tx.setText(\"hello yyx\"); &#125; &#125;); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; &#160; 其单元的测试代码如下 123456789101112131415161718192021222324252627282930313233343536373839package com.example.kevin.helloword;import android.test.ActivityInstrumentationTestCase2;import com.robotium.solo.Solo;public class helloTest extends ActivityInstrumentationTestCase2&lt;MainActivity&gt; &#123; private Solo solo; public helloTest() &#123; super(MainActivity.class); &#125; @Override public void setUp() throws Exception &#123; //setUp() is run before a test case is started. //This is where the solo object is created. solo = new Solo(getInstrumentation(), getActivity()); &#125; @Override public void tearDown() throws Exception &#123; //tearDown() is run after a test case has finished. //finishOpenedActivities() will finish all the activities that have been opened during the test execution. solo.finishOpenedActivities(); &#125; public void testclickMe() throws Exception&#123; solo.unlockScreen(); solo.clickOnButton(\"click me\"); boolean expected = true; boolean actual = solo.searchText(\"hello yyx\"); assertEquals(\"word not change\", expected, actual); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"}]},{"title":"sql注入初步","slug":"1314","date":"2015-02-22T10:40:30.000Z","updated":"2017-12-16T10:10:42.279Z","comments":true,"path":"article/1314.html","link":"","permalink":"https://www.yangyanxing.com/article/1314.html","excerpt":"自已用php+mysql写了一个登录页面。其中包含多个sql注入漏洞，在mysql中创建一个表，其中有username password email一个列，添加三个数据 +————-+————-+—————–+| username | password | email |+————-+————-+—————–+| admin | admin | admin@admin.com || yangyanxing | yangyanxing | yyx@yyx.com |+————-+————-+—————–+ 在phpmyadmin中使用一条sql命令 SELECT * FROM admin WHERE 1 where 1 是一个永真，这样它会把admin表中的所有数据返回 写一个testsql.php文件来尝试使用sql注入的方式登录这个系统","text":"自已用php+mysql写了一个登录页面。其中包含多个sql注入漏洞，在mysql中创建一个表，其中有username password email一个列，添加三个数据 +————-+————-+—————–+| username | password | email |+————-+————-+—————–+| admin | admin | admin@admin.com || yangyanxing | yangyanxing | yyx@yyx.com |+————-+————-+—————–+ 在phpmyadmin中使用一条sql命令 SELECT * FROM admin WHERE 1 where 1 是一个永真，这样它会把admin表中的所有数据返回 写一个testsql.php文件来尝试使用sql注入的方式登录这个系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;?phpdefine('DB_HOST', 'localhost');define('DB_USER', 'root');define('DB_PWD', '123456');define('DB_NAME', 'test');_connect(); //连接数据库_select_db();//选择数据库_set_names();//设置字符集//连接数据库function _connect()&#123;//$coon这个变量是全局的，它可以使得其在函数外面也可以访问到。 这里用global修饰global $conn;if(!$conn = mysql_connect(DB_HOST,DB_USER,DB_PWD))&#123;exit('数据库连接失败');&#125;&#125;function _select_db()&#123;if (!mysql_select_db(DB_NAME))&#123;exit('找不到指定的数据库');&#125;&#125;function _set_names()&#123;if (!mysql_query(\"SET NAMES UTF8\"))&#123;exit('设置字符集错误！');&#125;&#125;/** * @param $_sql */function _query($_sql)&#123;if(!$checkResult = mysql_query($_sql))&#123;exit('SQL语句执行失败'.mysql_error());&#125;return $checkResult;&#125;/** * * @param unknown $sql * @return multitype: */function _fetch_array($sql)&#123;return mysql_fetch_array(_query($sql),MYSQL_ASSOC);&#125;/** * @return int */function _mysql_affected_rows()&#123;return mysql_affected_rows();&#125;/** * @param $username * @param $info */function checkUserUni($username,$info)&#123;$sql = \"SELECT tg_username FROM tg_user WHERE tg_username='$username' LIMIT 1\";if(_fetch_array($sql))&#123;go_back($info);&#125;&#125;if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = $_POST['username']; $password = $_POST['password']; $query = \"select * from admin where username = '$username' and password='$password'\"; echo $query.'&lt;br&gt;'; $result = _fetch_array($query); if($result)&#123; echo \"登录成功\"; &#125;else&#123; echo \"登录失败\"; &#125; mysql_close(); print_r($result);&#125;?&gt;&lt;body&gt;&lt;form action='' name='login' method=\"post\"&gt; &lt;dd&gt;用 户 名：&lt;input type=\"text\" name=\"username\" class=\"text\" /&gt;&lt;/dd&gt; &lt;dd&gt;密 码：&lt;input type=\"password\" name=\"password\" class=\"text\" /&gt;&lt;/dd&gt; &lt;dd&gt;&lt;input type=\"submit\" value=\"登录\" class=\"button\" /&gt;&lt;/dd&gt;&lt;/form&gt;&lt;/body&gt; 其中 $query = “select * from admin where username = ‘$username’ and password=’$password’”; 这里的$username与$password未经过任何过滤，而是用户输入什么就是什么 首先在用户名里输入一个单引号（’） 来看看返回什么错误 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’’’ and password=’’’ at line 1 如果有类似于这样的错误则说明程序没有将单引号过滤掉，可能有sql注入漏洞,接着再看sql查询语句 $query = “select * from admin where username = ‘$username’ and password=’$password’”; 只要构造一个where后面是一个永真的条件就可以了，由于后面用了一个and逻辑，要构造两边都为true才行 username=’’ 可以构造一个username=’’ or ‘1’ = ‘1’ password=’’ 也可以构造一个password=’’ or ‘1’=’1’ 那么其实只要在用户名与密码处都填写’or ‘1’=’1 就可以了 &#160; 或者在用户名里输入admin’or ‘1’=’1 密码不输入，这个是在猜测其有一个叫admin的用户","categories":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/categories/web/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://www.yangyanxing.com/tags/sql/"},{"name":"安全","slug":"安全","permalink":"https://www.yangyanxing.com/tags/安全/"}]},{"title":"spinner和适配器模式","slug":"1310","date":"2015-02-21T16:41:48.000Z","updated":"2017-12-16T10:10:42.307Z","comments":true,"path":"article/1310.html","link":"","permalink":"https://www.yangyanxing.com/article/1310.html","excerpt":"原文 http://www.cnblogs.com/UUUP/p/3983394.html spinner相当于html表单中的select下拉列表。 第一种方式在string.xml中添加一个数组spinner_data：12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;string-array name=\"spinner_data\"&gt; &lt;item &gt;北京&lt;/item&gt; &lt;item &gt;湖南&lt;/item&gt; &lt;item &gt;湖北&lt;/item&gt; &lt;/string-array&gt; &lt;/resources&gt;","text":"原文 http://www.cnblogs.com/UUUP/p/3983394.html spinner相当于html表单中的select下拉列表。 第一种方式在string.xml中添加一个数组spinner_data：12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;string-array name=\"spinner_data\"&gt; &lt;item &gt;北京&lt;/item&gt; &lt;item &gt;湖南&lt;/item&gt; &lt;item &gt;湖北&lt;/item&gt; &lt;/string-array&gt; &lt;/resources&gt; 拖拽一个spinner：123456789&lt;Spinner android:id=\"@+id/spinner1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:entries=\"@array/spinner_data\" android:spinnerMode=\"dialog\" /&gt;&lt;!-- entries 显示spinner当中的数据项 spinnerMode=\"dropdown\"是默认值下拉列表，spinnerMode=\"dialog\"是以对话框的形式显示--!&gt; 第二种方式BaseAdapter就Android应用程序中经常用到的基础数据适配器，它的主要用途是将一组数据传到像ListView、Spinner、Gallery、GridView等UI显示组件，它是自动继承接口类Adapter。假如要往spinner中添加string[]或List。a）string[]在MainActivity主类中定义一个字符串数组：private String[] str = new String[] { “山东”,”山西”,”北京”}; 定义一个继承BaseAdapter的类：private class MyAdapter extends BaseAdapter { @Overridepublic int getCount() { // TODO Auto-generated method stub return str.length;//重要方法} @Overridepublic Object getItem(int arg0) { // TODO Auto-generated method stub return null;} @Overridepublic long getItemId(int arg0) { // TODO Auto-generated method stub return 0;} @Overridepublic View getView(int position, View view, ViewGroup group) {//重要方法 // TODO Auto-generated method stub //str.length多长此方法就执行几次 TextView textView = new TextView(MainActivity.this); textView.setText(str[position]); return textView;}} 在onCreate方法中：Spinner spinner = (Spinner) findViewById(R.id.spinner1);spinner.setAdapter(new MyAdapter());b)List在MainActivity主类中定义一个List：private List list = new ArrayList(); 并在onCreate方法中添加内容：list.add(“上海”);list.add(“天津”);list.add(“浙江”); MyAdapter类则只需要修改几处即可：1. public int getCount() { return list.size();} 2. public View getView(int position, View view, ViewGroup group) { TextView textView = new TextView(MainActivity.this); textView.setText((CharSequence) list.get(position)); return textView;} 3.还可以继续给spinner添加事件OnItemSelectedListener：spinner.setOnItemSelectedListener(new OnItemSelectedListener() { @Overridepublic void onItemSelected(AdapterView&lt;?&gt; parent, View view,int position, long id) {// TODO Auto-generated method stub Toast.makeText(MainActivity.this, (CharSequence) list.get(position), 0).show();} @Overridepublic void onNothingSelected(AdapterView&lt;?&gt; parent) {// TODO Auto-generated method stub}}); &#160; &#160; 利用ArrayAdapter构造adapter12345678910111213141516171819202122232425262728//第一步：添加一个下拉列表项的数据源ss，这里添加的项就是下拉列表的菜单项private String[] ss = new String[] &#123; \"云南\", \"北京\", \"香港\" &#125;;Spinner spinner=(Spinner) findViewById(R.id._spinner1_);//第二步：为下拉列表定义一个适配器，这里就用到里前面定义的ss。ArrayAdapter&lt;String&gt; adapter= new ArrayAdapter&lt;String&gt;(this,android.R.layout._simple_spinner_item_, ss);//其中，第一个是conetxt，也就是application的环境，第二个参数是spinner未展开的布局方式，第三个参数是数据源//第三步：为适配器设置下拉列表下拉时的菜单样式。adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);//第四步：将适配器添加到下拉列表上spinner.setAdapter(adapter);//第五步：为下拉列表设置各种事件的响应，这个事响应菜单被选中spinner.setOnItemSelectedListener(new OnItemSelectedListener)&#123;publicvoid onItemSelected(AdapterView&lt;?&gt; parent,View view, int position, long id) &#123;Toast._makeText_(MainActivity.this,ss[position], 0).show();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"}]},{"title":"Android中的UI线程阻塞","slug":"1308","date":"2015-02-19T17:05:19.000Z","updated":"2017-12-16T10:10:42.466Z","comments":true,"path":"article/1308.html","link":"","permalink":"https://www.yangyanxing.com/article/1308.html","excerpt":"当一个应用程序启动之后，android系统会为这个应用程序创建一个主线程，这个线程非常重要，它负责渲染视图，分发事件到响应监听器并执行，对界面进行轮询的监听，一般叫做“UI主线程” Android系统不会给应用程序的多个元素组件建立多个线程来执行，一个视图(activity)中的多个view组件运行在同一个UI线程当中，因此，多个view组件的监听器的执行可能会相互影响。 如有以下两个button，其中一个在会在主view中进行移动动画，另外一个button在点击以后将线程sleep 5秒","text":"当一个应用程序启动之后，android系统会为这个应用程序创建一个主线程，这个线程非常重要，它负责渲染视图，分发事件到响应监听器并执行，对界面进行轮询的监听，一般叫做“UI主线程” Android系统不会给应用程序的多个元素组件建立多个线程来执行，一个视图(activity)中的多个view组件运行在同一个UI线程当中，因此，多个view组件的监听器的执行可能会相互影响。 如有以下两个button，其中一个在会在主view中进行移动动画，另外一个button在点击以后将线程sleep 5秒12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Button moveButton = (Button) findViewById(R.id.button5); //添加一个animation TranslateAnimation animation = new TranslateAnimation(0, 150, 0, 0); animation.setRepeatCount(30); animation.setDuration(2000); moveButton.setAnimation(animation);//将moveButton绑定到这个animation中 button4.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);``` 此时由于button4与moveButton处在同一个UI线程中，button4的Thread.sleep会影响到moveButton的animation，如果UI线程阻塞时间过长，Android系统可能就会干预[![image](/image/2015/02/image_thumb12.png &quot;image&quot;)](/image/2015/02/image12.png) 而用户也基本上会选择OK来关闭程序。&amp;#160;解决线程阻塞问题可以通过将耗时的操作放入一个新的线程中进行，但是会有一个新的问题，在新的线程中又不能对UI线程进行UI操作，于是android官方提供一个post方法来解决这个问题``` javabutton4.setOnClickListener(new OnClickListener() &#123; public void onClick( final View v) &#123; //方法一，新建一个线程，把耗时操作放在这个新线程中进行，而不影响UI线程 new Thread(new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //当新线程中试图改变主UI进程的表现时，可以使用view.post()方法 v.post(new Runnable() &#123; public void run() &#123; TextView textView = (TextView) v; textView.setText(&quot;yangyanxing&quot;); &#125; &#125;); &#125; &#125;).start(); &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"}]},{"title":"Android开发初步","slug":"1303","date":"2015-02-19T11:36:23.000Z","updated":"2017-12-16T10:10:42.150Z","comments":true,"path":"article/1303.html","link":"","permalink":"https://www.yangyanxing.com/article/1303.html","excerpt":"绑定单击事件有两种方法，一种是通过绑定android:onClick属性，一种是绑定一个setOnClickListener回调函数 通过绑定onClick属性在activity_main.xml对应的组件上设置android:onClick=”test” 属性，然后再Java文件里定义一个test方法来实现，这个test方法是MainActivity类的一个方法1234public void test(View view)&#123; Toast.makeText(MainActivity.this, \"你还真敢点啊！\", Toast.LENGTH_LONG).show(); &#125; 这里的view就是要使用的控件，如果是绑定的是个button，那么view就是这个button","text":"绑定单击事件有两种方法，一种是通过绑定android:onClick属性，一种是绑定一个setOnClickListener回调函数 通过绑定onClick属性在activity_main.xml对应的组件上设置android:onClick=”test” 属性，然后再Java文件里定义一个test方法来实现，这个test方法是MainActivity类的一个方法1234public void test(View view)&#123; Toast.makeText(MainActivity.this, \"你还真敢点啊！\", Toast.LENGTH_LONG).show(); &#125; 这里的view就是要使用的控件，如果是绑定的是个button，那么view就是这个button 通过setOnClickListener此时需要将这个setOnClickListener回调函数写在onCreate()函数里 1234567891011protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button)findViewById(R.id.button1); button.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"我是被点击的\", Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; 可以看到setOnClickListener不属于某个控件，在使用的时候要先通过findViewById方法找到要进行onClick方法的控件。 将2中的onClickListener方法分离出来这个方式将OnClickListener分离出来写在MainActibity类方法 123456789101112131415161718private View.OnClickListener myListener = new OnClickListener() &#123; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1: Toast.makeText(MainActivity.this, \"button1被点击了\", Toast.LENGTH_LONG).show(); break; case R.id.button2: Toast.makeText(MainActivity.this, \"button2被点击了\", Toast.LENGTH_LONG).show(); break; case R.id.button3: Toast.makeText(MainActivity.this, \"button3被点击了\", Toast.LENGTH_LONG).show(); break; default: break; &#125; &#125; &#125;; 然后在onCreate方法中使用 Button button1 = (Button)findViewById(R.id.button1);Button button2 = (Button)findViewById(R.id.button2);Button button3 = (Button)findViewById(R.id.button3);button1.setOnClickListener(myListener);button2.setOnClickListener(myListener);button3.setOnClickListener(myListener); 这种方法可以复用方法，也可以多些判断，比较灵活 长按与短按长按有一个返回值，当一个控件既绑定了一个长铵同时又绑定了一个短按，如果长按的返回值是false时，那么在长按以后同时也会触发短按事件123456789101112button4.setOnLongClickListener(new OnLongClickListener() &#123; public boolean onLongClick(View v) &#123; System.out.println(\"按钮进行了长按\"); return true; //返回true后就不会再触发短按事件 &#125; &#125;); button4.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; System.out.println(\"按钮进行了短按\"); &#125; &#125;); setOnTouchListener事件，滑动事件1234567891011121314151617181920final Button button4 = (Button)findViewById(R.id.button4); ViewGroup viewGroup = (ViewGroup) findViewById(R.id.vg1); viewGroup.setOnTouchListener(new OnTouchListener() &#123; public boolean onTouch(View v, MotionEvent event) &#123; int eventType = event.getAction(); if (eventType == MotionEvent.ACTION_DOWN) &#123; button4.setX(event.getX()); button4.setY(event.getY()); System.out.println(\"down…\"); &#125;else if (eventType == MotionEvent.ACTION_MOVE) &#123; button4.setX(event.getX()); button4.setY(event.getY()); System.out.println(\"move…\"); &#125;else if (eventType==MotionEvent.ACTION_UP) &#123; &amp;#160; System.out.println(\"up…\"); &#125; return true; &#125; &#125;); setOnKeyListener 监听键盘按键操作1234567891011121314151617button4.setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; //a:29 s:47 d:32 w:51 if (keyCode == 29) &#123; button4.setX(button4.getX()-10); &#125;else if (keyCode == 47) &#123; button4.setY(button4.getY()+10); &#125;else if (keyCode == 32) &#123; button4.setX(button4.getX()+10); &#125;else if (keyCode == 51) &#123; button4.setY(button4.getY()-10); &#125;else &#123; &#125; return false; &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://www.yangyanxing.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"}]},{"title":"没事别蹭wifi-告诉你公共的wifi有多不安全","slug":"1298","date":"2015-02-11T16:13:33.000Z","updated":"2017-12-16T15:34:10.794Z","comments":true,"path":"article/1298.html","link":"","permalink":"https://www.yangyanxing.com/article/1298.html","excerpt":"经常看到一些朋友每到一个地方就先找wifi，没有密码就直接上了！汗…… 今天通过两个小工具来显示一下公共wifi的安全隐患（爱蹭网的代价） 工具：wireshark与cain下载：wireshark https://www.wireshark.org/download.htmlCain &amp; Abel http://www.oxid.it/cain.html (被墙) 百度网盘链接：http://pan.baidu.com/s/18kshg 密码：9owu md5:EA2EF30C99ECECB1EDA9AA128631FF31 sha1:82407EAF6437D6956F63E85B28C0EC6CA58D298A 如果没有校验工具，我写了一个python脚本来校验 链接：http://pan.baidu.com/s/1i3j93sp 密码：h6gz","text":"经常看到一些朋友每到一个地方就先找wifi，没有密码就直接上了！汗…… 今天通过两个小工具来显示一下公共wifi的安全隐患（爱蹭网的代价） 工具：wireshark与cain下载：wireshark https://www.wireshark.org/download.htmlCain &amp; Abel http://www.oxid.it/cain.html (被墙) 百度网盘链接：http://pan.baidu.com/s/18kshg 密码：9owu md5:EA2EF30C99ECECB1EDA9AA128631FF31 sha1:82407EAF6437D6956F63E85B28C0EC6CA58D298A 如果没有校验工具，我写了一个python脚本来校验 链接：http://pan.baidu.com/s/1i3j93sp 密码：h6gz 使用Cain进行arp欺骗&#160;&#160;&#160; 打开Cain主界面，先点击上面的小网卡标识，然后再点击那个’+’ 号 默认就行了，它会根据网关进行扫描活动的主机 &#160; 可以看到，在和我电脑同网段的有两个三星手机（其中一个是我的）和一台电脑 &#160; 点击下面的arp图标 &#160; 接着先点击上面的列表的空白地方，再点击’+ ’号，左边选择要监听的IP，右边选择网关的IP，这里是192.168.1.1（也就是路由器的地址） 点击OK，回到主界面，这时点击那个小雷达标识开始进行arp欺骗 打开wireshark进行抓包选择capture-&gt;interfaces… 选择进行监听的网卡（也就是你进行上网的网卡），点击strat 抓包分析我这里抓了我手机上网的包，刷了下微博，看了眼朋友圈，并且用手机里的浏览器访问了我的个人博客http://static.yangyanxing.com 并且登录了下后台 现在来看看这些信息 在wireshark的显示过滤里写下过滤ip.addr eq 192.168.1.102 &amp;&amp; !dns &amp;&amp; http 找啊找，找到一条 125&#160;&#160;&#160; 2015-02-11 21:25:25.275021000&#160;&#160;&#160; 192.168.1.102&#160;&#160;&#160; 180.149.139.248&#160;&#160;&#160; HTTP&#160;&#160;&#160; 916&#160;&#160;&#160; POST /2/push/active?c=android&amp;i=5f61746&amp;s=2602e25d&amp;ua=samsung-GT-I9502weibo4.6.2androidandroid4.4.2&amp;wm=4209_8001&amp;v_f=2&amp;from=1046295010&amp;gsid=4up8f9e93Tw5PZz2EqMCx8xEv9p&amp;lang=zh_CN&amp;skin=default&amp;oldwm=2468_1001 HTTP/1.1&#160; (application/x-www-form-urlencoded) 看下它的packet details 打开HTML Form URL Encoded: application/x-www-form-urlencoded，很多信息，但其实没太多的用，顶多那个uid:2035987583 这个是我的微博ID， 打开http://weibo.com/2035987583 就到达了我的微博主页了（如果你是个PLMM的话，闷骚的屌丝会通过这样的方式搞到你的微博账号） 如果得到微博账号不算什么的话（毕竟微博还算是个开放的平台，加个粉对于博主来说也不算什么坏事），那么如果能够看到你朋友圈的图片呢？ 继续往下找抓包信息 会看到这样的包 打开这个包的Hypertext Transfer Protocol 拖到下面 试着在浏览器里打开这个网址，这个地址就是你朋友圈里朋友发的图片……（汗！） 如果可以看到朋友圈里的图片也无所谓的话，那么如果能看到你登录的用户与密码呢？ 继续往下看抓到的包，看到我登录我个人博客后台的包 11695&#160;&#160;&#160; 2015-02-11 21:27:19.177156000&#160;&#160;&#160; 192.168.1.102&#160;&#160;&#160; 118.123.116.226&#160;&#160;&#160; HTTP&#160;&#160;&#160; 121&#160;&#160;&#160; POST /wp-login.php?redirect_to=http%3A%2F%2Fstatic.yangyanxing.com%2F%3Fp%3D1266 HTTP/1.1&#160; (application/x-www-form-urlencoded) 打开packet detail 里面的HTML Form URL Encoded: application/x-www-form-urlencoded username 与password已经明文获得到了。。。 更多如果仔细分析包，还能分析出更多有用的信息，在进行arp过程中，手机上没有任何异常，这下知道免费蹭网有多大的隐患了吧？所以没事别想着瞎蹭网，除非你对你要连接的wifi充分的了解与信任。","categories":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/categories/web/"}],"tags":[]},{"title":"appium简明教程(转)","slug":"1266","date":"2015-01-03T12:03:13.000Z","updated":"2017-12-16T15:40:04.317Z","comments":true,"path":"article/1266.html","link":"","permalink":"https://www.yangyanxing.com/article/1266.html","excerpt":"乙醇的自动化教程写的挺好的，以下是转自他的cnblogs上面的博客appium简明教程（1）——appium和它的哲学世界什么是appium？下面这段介绍来自于appium的官网。 Appium is an open-source tool you can use to automate mobile native, mobile web, and mobile hybrid applications on iOS and Android platforms. “Mobile native apps” are those written using the iOS or Android SDKs. “Mobile web apps” are web apps accessed using a mobile browser (Appium supports Safari on iOS and Chrome on Android). “Mobile hybrid apps” have a native wrapper around a “webview” – a native control that enables interaction with web content. Projects like Phonegap, for example, make it easy to build apps using web technologies that are then bundled into a native wrapper – these are hybrid apps. Importantly, Appium is “cross-platform”: it allows you to write tests against multiple platforms (iOS, Android), using the same API. This enables a large or total amount of code reuse between iOS and Android testsuites.我们可以从上面的介绍里获得这样的一些信息： 1，appium是开源的移动端自动化测试框架； 2，appium可以测试原生的、混合的、以及移动端的web项目； 3，appium可以测试ios，android应用（当然了，还有firefox os）； 4，appium是跨平台的，可以用在osx，windows以及linux桌面系统上；appium的哲学","text":"乙醇的自动化教程写的挺好的，以下是转自他的cnblogs上面的博客appium简明教程（1）——appium和它的哲学世界什么是appium？下面这段介绍来自于appium的官网。 Appium is an open-source tool you can use to automate mobile native, mobile web, and mobile hybrid applications on iOS and Android platforms. “Mobile native apps” are those written using the iOS or Android SDKs. “Mobile web apps” are web apps accessed using a mobile browser (Appium supports Safari on iOS and Chrome on Android). “Mobile hybrid apps” have a native wrapper around a “webview” – a native control that enables interaction with web content. Projects like Phonegap, for example, make it easy to build apps using web technologies that are then bundled into a native wrapper – these are hybrid apps. Importantly, Appium is “cross-platform”: it allows you to write tests against multiple platforms (iOS, Android), using the same API. This enables a large or total amount of code reuse between iOS and Android testsuites.我们可以从上面的介绍里获得这样的一些信息： 1，appium是开源的移动端自动化测试框架； 2，appium可以测试原生的、混合的、以及移动端的web项目； 3，appium可以测试ios，android应用（当然了，还有firefox os）； 4，appium是跨平台的，可以用在osx，windows以及linux桌面系统上；appium的哲学 Appium was designed to meet mobile automation needs according to a certain philosophy. The key points of this philosophy can be stated as 4 requirements: You shouldn’t have to recompile your app or modify it in any way in order to automate it. You shouldn’t be locked into a specific language or framework to write and run your tests. A mobile automation framework shouldn’t reinvent the wheel when it comes to automation APIs. A mobile automation framework should be open source, in spirit and practice as well as in name!appium的设计哲学是这样的： 1，不需要为了自动化而且重新编译或修改测试app； 2，不应该让移动端自动化测试限定在某种语言和某个具体的框架；也就是说任何人都可以使用自己最熟悉最顺手的语言以及框架来做移动端自动化测试； 3，不要为了移动端的自动化测试而重新发明轮子，重新写一套惊天动地的api；也就是说webdriver协议里的api已经够好了，拿来改进一下就可以了； 4，移动端自动化测试应该是开源的； appium的技术架构 OS: Apple’s UIAutomation Android 4.2+: Google’s UiAutomator Android 2.3+: Google’s Instrumentation. (Instrumentation support is provided by bundling a separate project, Selendroid) appium的设计思想 We meet requirement #2 by wrapping the vendor-provided frameworks in one API, theWebDriver API. WebDriver (aka “Selenium WebDriver”) specifies a client-server protocol (known as the JSON Wire Protocol). Given this client-server architecture, a client written in any language can be used to send the appropriate HTTP requests to the server. There are already clients written in every popular programming language. This also means that you’re free to use whatever test runner and test framework you want; the client libraries are simply HTTP clients and can be mixed into your code any way you please. In other words, Appium &amp; WebDriver clients are not technically “test frameworks” – they are “automation libraries”. You can manage your test environment any way you like! We meet requirement #3 in the same way: WebDriver has become the de facto standard for automating web browsers, and is a W3C Working Draft. Why do something totally different for mobile? Instead we have extended the protocol with extra API methods useful for mobile automation. It should be obvious that requirement #4 is a given – you’re reading this because Appium is open source.首先，为了能够实现哲学里描述的第2条，也就是不应该让移动端自动化测试限定在某种语言和某个具体的框架；也就是说任何人都可以使用自己最熟悉最顺手的语言以及框架来做移动端自动化测试；appium选择了client-server的设计模式。只要client能够发送http请求给server，那么的话client用什么语言来实现都是可以的，这就是appium及webdriver如何做到支持多语言的； 其次，为了能够实现不要为了移动端的自动化测试而重新发明轮子，重新写一套惊天动地的api；也就是说webdriver协议里的api已经够好了，拿来改进一下就可以了；这个思想，appium扩展了webdriver的协议，没有自己重新去实现一套。这样的好处是以前的webdriver api能够直接被继承过来，以前的webdriver各种语言的binding都可以拿来就用，省去了为每种语言开发一个client的工作量； 最后appium当然是开源的，这也实现了哲学思想里的最后一点。 appium简明教程（2）——appium的基本概念Client/Server Architectureappium的核心其实是一个暴露了一系列REST API的server。 这个server的功能其实很简单：监听一个端口，然后接收由client发送来的command。翻译这些command，把这些command转成移动设备可以理解的形式发送给移动设备，然后移动设备执行完这些command后把执行结果返回给appium server，appium server再把执行结果返回给client。 在这里client其实就是发起command的设备，一般来说就是我们代码执行的机器，执行appium测试代码的机器。狭义点理解，可以把client理解成是代码，这些代码可以是java/ruby/python/js的，只要它实现了webdriver标准协议就可以。 这样的设计思想带来了一些好处： 1，可以带来多语言的支持； 2，可以把server放在任意机器上，哪怕是云服务器都可以；（是的，appium和webdriver天生适合云测试） Sessionsession就是一个会话，在webdriver/appium，你的所有工作永远都是在session start后才可以进行的。一般来说，通过POST /session这个URL，然后传入Desired Capabilities就可以开启session了。 开启session后，会返回一个全局唯一的session id，以后几乎所有的请求都必须带上这个session id，因为这个seesion id代表了你所打开的浏览器或者是移动设备的模拟器。 进一步思考一下，由于session id是全局唯一，那么在同一台机器上启动多个session就变成了可能，这也就是selenium gird所依赖的具体理论根据。 本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 Desired Capabilities Desired Capabilities携带了一些配置信息。从本质上讲，这个东东是key-value形式的对象。你可以理解成是java里的map，python里的字典，ruby里的hash以及js里的json对象。实际上Desired Capabilities在传输时就是json对象。 Desired Capabilities最重要的作用是告诉server本次测试的上下文。这次是要进行浏览器测试还是移动端测试？如果是移动端测试的话是测试android还是ios，如果测试android的话那么我们要测试哪个app？ server的这些疑问Desired Capabilities都必须给予解答，否则server不买账，自然就无法完成移动app或者是浏览器的启动。 具体例子如下： For example, we might set the platformName capability to iOS to tell Appium that we want an iOS session, rather than an Android one. Or we might set the safariAllowPopupscapability to true in order to ensure that, during a Safari automation session, we’re allowed to use JavaScript to open up new windows. See the capabilities doc for the complete list of capabilities available for Appium Appium Server这就是每次我们在命令行用appium命令打开的东西。 Appium Clients由于原生的webdriver api是为web端设计的，因此在移动端用起来会有点不伦不类。appium官方提供了一套appium client，涵盖多种语言ruby/java/python，在我看来ruby client是实现最好的。在测试的时候，一般要使用这些client库去替换原生的webdriver库。这实际上不是替换，算是client对原生webdriver进行了一些移动端的扩展，加入了一些方便的方法，比如swipe之类，appium client让我们可以更方便的写出可读性更好的测试用例。 Appium.app, Appium.exeappium server的GUI版本，前者用在osx上，后者是windows上。可视化、不需要装node，可以看app的UI结构是这个东东的卖点。 appium简明教程（3）——appium的安装windows版appium的哲学里有一条就是不重新发明轮子。同样，官方已经有明确的安装步骤了，因此在这里纯属搬砖。 原文地址 感谢testerhome的辛勤翻译。 本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 限制如果你在windows上安装appium，你没法使用预编译专用于OS X的.app文件，你也将不能测试IOS apps，因为appium依赖OS X专用的库来支持IOS测试。这意味着你只能通过在mac上来运行IOS的app测试。这点限制挺大。 开始安装 安装nodejs 0.8版本及以上, 通过官方的安装程序来安装。 安装android的sdk包，(http://developer.android.com/sdk/index.html), 运行依赖sdk中的’android’工具。并确保你安装了Level17或以上的版本api。设置ANDROID_HOME系统变量为你的Android SDK路径，并把tools platform-tools两个目录加入到系统的Path路径里。因为这里面包含有一些执行命令 安装java的JDK，并设置JAVA_HOME 变量为你的JDK目录。 安装Apache Ant 或者直接使用Android Windows SDK自带的ant，地址在eclipseplugins目录，你需要把这个目录加到你的系统PATH变量中 安装Apache Maven. 并且设置M2HOME和M2环境变量，把M2环境变量添加到你的系统PATH变量中。 安装Git. 确保你安装了windows下的Git，以便可以运行常用的command命令现在，你已经下载安装了所有的依赖，开始运行 reset.bat 运行Appium要在windows上运行测试用例，你需要先启动Android模拟器或者连接上一个API Level17以上的android真机。 然后在命令行运行appium node . 备注 你必须带上–no-reset和–full-reset标记，以用于windows上的android 有一个硬件加速模拟器用于android，但是它有自己的一些限制，如果你想了解更多，请参考页面 确保在你的AVD的config.ini中有一个配置项为hw.battery=yes 最简略的安装方式出于对官方文档的尊重，我按照原文翻译，如下介绍我的安装心得。官方提到的一些工具，其实并不需要安装。 下面介绍我已经测试过的安装和使用过程 安装appium 安装nodejs2、使用npm安装appium，npm install -g appium 注意：在某些情况下，appium安装的时候并不会把appium的路径放进系统的PATH里，这时候需要手工去加一下。 运行appium启动appium，直接运行appium 即可。 更新appium通过npm install -g appium 来更新appium即可 appium简明教程（4）——appium client的安装appium client是对webdriver原生api的一些扩展和封装。它可以帮助我们更容易的写出用例，写出更好懂的用例。 appium client是配合原生的webdriver来使用的，因此二者必须配合使用缺一不可。 从本节开始，教程的内容将涵盖3个语言，ruby/python/java。 本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 安装appium clientruby篇（一定要在线安装）ruby的appium client叫做appium lib，为什么是这样就不解释了，总之是历史原因。 首先update rubygem和bundler(说老实话，真的不需要，但官方文档上这么写) gem update –system ;gem update bundler 然后使用gem安装 gem uninstall -aIx appium_lib ;(这个也不是必须的)gem install –no-rdoc –no-ri appium_lib python篇（尽量在线安装）推荐使用pip安装 pip install Appium-Python-Client 当然了也可以在Pipy上下载源码安装 tar -xvf Appium-Python-Client-X.X.tar.gz（windows上用7zip可以解压）cd Appium-Python-Client-X.Xpython setup.py install 最后，也可以通过github安装（要git客户端） git clone git@github.com:appium/python-client.gitcd python-clientpython setup.py install java篇（在线安装）java的话用maven安装就可以了 io.appium java-client 1.3.0 当然了，也可以自己下载jar包，请自行选择最新版本。 appium简明教程（5）——appium client方法一览appium client扩展了原生的webdriver client方法 下面以java代码为例，简单过一下appium client提供的适合移动端使用的新方法 resetApp() getAppString() sendKeyEvent() currentActivity() pullFile() pushFile() pullFolder() hideKeyboard() runAppInBackground() performTouchAction() performMultiTouchAction() tap() swipe() pinch() zoom() getNamedTextField() isAppInstalled() installApp() removeApp() launchApp() closeApp() endTestCoverage() lockScreen() shake() complexFind() scrollTo() scrollToExact() openNotifications() Context Switching: .context(), .getContextHandles(), getContext())新增的locator findElementByAccessibilityId() findElementsByAccessibilityId() findElementByIosUIAutomation() findElementsByIosUIAutomation() findElementByAndroidUIAutomator() findElementsByAndroidUIAutomator()这些方法主要覆盖了3大类： driver扩展：比如增加了resetApp等操作app的方法 action扩展：增加一些移动端的特有的action（怎么描述呢，相当于是移动端 特有的操作），比如swipe，shake(嗯，有了这个方法就可以让代码帮你摇一摇了)等； locator扩展：增加了一些移动端专属的定位策略本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 下一节我们开始介绍使用appium启动android模拟器 appium简明教程（6）——启动appium及android模拟器一般情况下，我们都从命令行启动appium。 windows下，dos命令窗口输入 appium 如果该命令报错，那么请重装appium npm install -g appium 如果安装出错，请自行更换npm源。 npm -g –registry http://registry.cnpmjs.org install appium 然后请打开android的模拟器，如果没有请新建一个虚拟设备。请自行解除设备锁定（手动把屏幕解锁了），以防万一。 下面的代码以启动android原生的计算器程序为例 ruby篇12345require 'appium_lib'caps = &#123; caps:&#123; platformName: 'Android', appActivity: '.Calculator', appPackage: 'com.android.calculator2' &#125;, appium_lib: &#123; sauce_username: nil, sauce_access_key: nil &#125; &#125;driver = Appium::Driver.new(caps).start_driver 讨论：可以看出ruby lib里面的Appium::Driver类实际上就是原生的webdriver类的子类，当然了，由于ruby语法灵活，也可以使用monkey patch来实现类似功能。 python篇123456789from appium import webdriverdesired_caps = &#123;&#125;desired_caps['platformName'] = 'Android'desired_caps['platformVersion'] = '4.2'desired_caps['deviceName'] = 'Android Emulator'desired_caps['appPackage'] = 'com.android.calculator2'desired_caps['appActivity'] = '.Calculator'driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) 讨论：webdriver.Remote实际上就是原生webdriver的子类，另外Remote()构造函数的第一个参数中需要显示指定appium server监听的端口 java篇新建java项目时候，请注意将selenium-webdriver以及appium client的jar包导入 1234567891011121314import io.appium.java_client.AppiumDriver;import org.openqa.selenium.By;import org.openqa.selenium.WebElement;import org.openqa.selenium.remote.CapabilityType;import org.openqa.selenium.remote.DesiredCapabilities;DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(CapabilityType.BROWSER_NAME, \"\");//这句不是必须的capabilities.setCapability(\"deviceName\",\"Android Emulator\");capabilities.setCapability(\"platformVersion\", \"4.4\");capabilities.setCapability(\"platformName\",\"Android\");capabilities.setCapability(\"appPackage\", \"com.android.calculator2\");capabilities.setCapability(\"appActivity\", \".Calculator\");AppiumDriver driver = new AppiumDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities); 讨论:AppiumDrvier是原生webdriver的子类。 在这里我们可以看到，新建driver的时候必须要指定一个DesiredCapabilities 对象，该对象究竟是何方神圣，我们下一节会仔细讲解。 appium简明教程（7）——Desired Capabilities详解Desired Capabilities在启动session的时候是必须提供的。 Desired Capabilities本质上是key value的对象，它告诉appium server这样一些事情： 本次测试是启动浏览器还是启动移动设备？ 是启动andorid还是启动ios？ 启动android时，app的package是什么？ 启动android时，app的activity是什么？本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 Appium的Desired Capabilities是扩展了webdriver的Desired Capabilities的，下面的一些通用配置是需要指定的： automationName：使用哪种自动化引擎。appium（默认）还是Selendroid？ platformName：使用哪种移动平台。iOS, Android, orFirefoxOS？ deviceName：启动哪种设备，是真机还是模拟器？iPhone Simulator, iPad Simulator, iPhone Retina 4-inch, Android Emulator, Galaxy S4, etc… app：应用的绝对路径，注意一定是绝对路径。如果指定了appPackage和appActivity的话，这个属性是可以不设置的。另外这个属性和browserName属性是冲突的。 browserName：移动浏览器的名称。比如Safari’ for iOS and ‘Chrome’, ‘Chromium’, or ‘Browser’ for Android；与app属性互斥。 udid：物理机的id。比如1ae203187fc012g。 下面这些属性是android平台特定的： appActivity：待测试的app的Activity名字。比如MainActivity, .Settings。注意，原生app的话要在activity前加个”.”。 appPackage：待测试的app的java package。比如com.example.android.myApp, com.android.settings。本文主要讨论android平台的appium测试方法和技巧，因此在这里就不列出ios设备特定的属性了。 更多信息请参考官方文档 在这里我们发现，我们经常要获取app的package和activity名字，那么有什么工具可以让我们方便的获取到这些信息呢？下一节讲回答这个问题。 appium简明教程（8）——那些工具monitor.bat（hierarchyviewer.bat已经不赞成继续使用了）该文件位于your_andriod_sdk_pathtools下面。以乙醇的机器为例，其位于E:adt-bundle-windows-x86-20131030sdktools下。 该工具可以帮我们找到android控件的content-description，为以后的find_element_by_accessibility_id 定位方法做参数使用。 关于什么是content-description，可以参考官方文档。 本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 好，露个脸。 uiautomatorviewer.bat该文件位于your_andriod_sdk_pathtools下面。以乙醇的机器为例，其位于E:adt-bundle-windows-x86-20131030sdktools下。 该工具主要用来查看控件的属性，比如resource id，class name等。 该工具也可查看被测app的appPackage（Desired Capabilities中使用）。 爆照。 好了，是不是感觉还缺了点什么呢？ 确实如此，被测app的appActivity怎么获取呢？ 下一讲我们详细讲解如何获取被测app的appActivity。 appium简明教程（9）——如何获取android app的Activity有时候在appium的Desired Capabilities中需要指定被测app的appActivity，下面的方法可能会对你有所帮助。 方法一如有你有待测项目的源码，那么直接查看源码就好。如果没有，那么请联系有源码的同学，这是推荐方法。 本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 方法二如果你没有代码，那么可以反编译该app。 这里将用到2个工具，分别是dex2jar和jd-gui。你可以在这里下载目前为止的最新版本以及示例apk。 我们以工具包里的ContactManager.apk为例，简单介绍一下反编译的流程。 1，重命名ContactManager.apk为ContactManager.zip并解压得到文件classes.dex； 2，解压dex2jar-0.0.9.15.zip，并从命令行进入该文件夹； 3，运行命令d2j-dex2jar.bat path_toclasses.dex在当前文件夹下得到classes-dex2jar.jar； 4，解压jd-gui-0.3.6.windows.zip得到文件jd-gui.exe； 5，使用jd-gui.exe打开classes-dex2jar.jar；嗯，好了，可以尽情欣赏了。上图。 上图所示的ContactManager就是待测app的main activity。 方法三参考testerhome的这个帖子 使用log查看大法(嗯，windows上没grep不幸福，好在有powershell的Select-String，可以拿来勉强一用)，直接搬砖。 a、启动待测apk b、开启日志输出：adb logcat&gt;D:/log.txtc、关闭日志输出：ctrl+c d、查看日志 找寻： Displayed com.mm.android.hsy/.ui.LoginActivity: +3s859msappPackage = com.mm.android.hsyappActivity = .ui.LoginActivity好了，准备活动做的差不多了。下一节乙醇带大家进行控件定位之旅。 appium简明教程（10）——控件定位基础狭义上讲，UI级的自动化测试就是让机器代替人去点来点去的过程。 但机器去点什么（点上面还是点左边），怎么点（是长按还是轻触），这些东西是必须由代码的编写者所指示清楚的。 控件定位就是解决机器点什么的问题的。 一般说来，我们可以这样告诉机器：去点登陆按钮。 机器很笨，它并不知道什么是登陆按钮。因为登陆按钮是自然语言的描述。 如果你让一个人去点登陆按钮，那么他其实也是要经过一系列的脑补以后才可以做这件事的。 这个脑补的过程还原如下： 这个一定是个按钮 这个按钮一定在被测的应用上 这个按钮大概上面有登陆这个文字信息 嗯，还真有一个，那么点吧。这就是人探索性测试的一个简单过程。一般来说，如果你给出的信息不太充分，人类还是可以通过一系列的探索性思维去理解你的描述的。这个属于心理学的问题，不展开解释。 但是机器并不是人，如果你给出的描述不精确的话，机器是不会自发性的进行探索和脑补的。 因此控件定位就是精确的描述控件特征并告诉机器的过程。 本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 控件的特征就是控件的属性，我们可以通过上一讲中的uiautomatorviewer去获取。 在appium的定位世界里，下面这些方法是可以为我们使用的。也就是说，我们通过下面几个约定好的方式，按照webdriver和appium的DSL（自行搜索并理解）进行控件特征的描述和定位。 继承自webdriver的方法，也就是通过这3个特征可以定位控件 find by “class” (i.e., ui component type，andorid上可以是android.widget.TextView) find by “xpath” (i.e., an abstract representation of a path to an element, with certain constraints，由于appium的xpath库不完备的原因，这个不太推荐) find by “id”(android上是控件的resource id)由Mobile JSON Wire Protocol 协议中定义的方法，更适合移动设备上的控件定位 -ios uiautomation: a string corresponding to a recursive element search using the UIAutomation library (iOS-only) -android uiautomator: a string corresponding to a recursive element search using the UiAutomator Api (Android-only) accessibility id: a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize.在appium 的client对Mobile JSON Wire Protocol中定义的方法进行了封装，使其调用起来更加方便 ruby篇1234find_element :accessibility_id, 'Animation'find_elements :accessibility_id, 'Animation'find_element :uiautomator, 'new UiSelector().clickable(true)'find_elements :uiautomator, 'new UiSelector().clickable(true)' 当然了，你也可以使用原生的webdriver方法 find_element id: ‘resource_id’ 另外，ruby lib里提供了一些非常好用的简便方法来进行控件的定位，好写，好读。 text(value_or_index) :Find the first TextView that contains value or by index. If int then the TextView at that index is returned. button(value_or_index):Find the first button that contains value or by index. If int then the button at that index is returned更多请看这里 python篇123456789el = self.driver.find_element_by_android_uiautomator('new UiSelector().description(\"Animation\")')self.assertIsNotNone(el)els = self.driver.find_elements_by_android_uiautomator('new UiSelector().clickable(true)')self.assertIsInstance(els, list)el = self.driver.find_element_by_accessibility_id('Animation')self.assertIsNotNone(el)els = self.driver.find_elements_by_accessibility_id('Animation')self.assertIsInstance(els, list) 总的来说就是在driver里增加了 find_element_by_accessibility_id find_elements_by_accessibility_id find_element_by_android_uiautomator find_element_by_android_uiautomator等方法 java篇前面也讲过了，新增了这些方法123456findElementByAccessibilityId()findElementsByAccessibilityId()findElementByIosUIAutomation()findElementsByIosUIAutomation()findElementByAndroidUIAutomator()findElementsByAndroidUIAutomator() 讨论：从上面可以看出来，python 和 java client对移动端控件定位的封装是比较初级的。ruby lib中封装了很多方便和简洁的方法，因此可以看出，使用ruby lib是优于python和java的选择。当然，如果忽略性能的话。 下一节我们开始具体看下如何用resource id去定位控件。 appium简明教程（11）——使用resource id定位上一节乙醇带大家了解了appium的定位策略。实际上appium的控件定位方式是完全遵守webdriver的mobile扩展协议的。 这一节将分享一下如何使用resource id来定位android策略。 什么是resource id，这个不属于本文的范畴，大家可以点这里了解。 我们可以有两种方式来使用resource id进行定位： 使用 findElement(By.id(“resourceId”)) 的方式。这也是原生的webdriver定义的方法，不过竟然在appium的官方文档里没有提及，属于隐藏技； 使用 find_elements_by_android_uiautomator(‘new UiSelector().resourceId(“the_id”)’) 的方式；关于uiautomator定位后面的教程会展开讲解；从上面的代码片段可以看到，使用 find_element_by_id 的方式进行定位是最简便的。 那么怎么获取控件的resource id呢，使用uiautomatorviewer就可以了。具体方法如下图所示。 现在就以上图所示的android原生计算器程序为例，看一下每种语言是如何实现点击【9】这个按钮的。 目的点击计算器上的【9】这个按钮。该按钮的id是com.android.calculator2:id/digit6 。先甜后苦，从ruby开始。 本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途 Ruby篇12345require 'appium_lib'caps = &#123; caps:&#123; platformName: 'Android', appActivity: '.Calculator', appPackage: 'com.android.calculator2' &#125;, appium_lib: &#123; sauce_username: nil, sauce_access_key: nil, debug: true&#125; &#125;dr = Appium::Driver.new(caps).start_driverdr.find_element(id: 'com.android.calculator2:id/digit9').click Python篇12345678910111213141516#coding:utf-8from appium import webdriverfrom time import sleepdesired_caps = &#123;&#125;desired_caps['platformName'] = 'Android'desired_caps['platformVersion'] = '4.4'desired_caps['deviceName'] = 'Android Emulator'desired_caps['app'] = 'Calculator.apk'desired_caps['appPackage'] = 'com.android.calculator2'desired_caps['appActivity'] = '.Calculator'dr = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)sleep(3)dr.find_element_by_id('com.android.calculator2:id/digit9').click() Java篇123456789101112131415161718192021222324//新建一个FindById类位于info.itest.www package下面package info.itest.www;import io.appium.java_client.AppiumDriver;import java.net.MalformedURLException;import java.net.URL;import org.openqa.selenium.remote.CapabilityType;import org.openqa.selenium.remote.DesiredCapabilities;public class FindById &#123; public static void main(String args[]) throws MalformedURLException &#123; DesiredCapabilities cap = new DesiredCapabilities(); cap.setCapability(CapabilityType.BROWSER_NAME, \"\"); cap.setCapability(\"platformName\", \"Android\"); cap.setCapability(\"deviceName\", \"Android Emulator\"); cap.setCapability(\"platformVersion\", \"4.4\"); cap.setCapability(\"appPackage\", \"com.android.calculator2\"); cap.setCapability(\"appActivity\", \".Calculator\"); AppiumDriver dr = new AppiumDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), cap); dr.findElement(By.id(\"com.android.calculator2:id/digit9\")).click(); &#125;&#125; 如果读者对webdriver很熟悉的话，那么掌握这个方法是非常简单的。如果对webdriver不熟悉，那么可以参考乙醇的webdriver实用指南，先学习一下webdriver的基础知识。 这一节我们写了一些脚本去进行控件定位，在实际的项目中，这些没有任何断言的脚本是基本上无法完成测试用例的功能的。 先卖个关子，下下一节乙醇将会带大家写第一个appium的测试用例。 那么下一节我们将学习如何使用class name进行定位。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.yangyanxing.com/tags/自动化测试/"}]},{"title":"Android官方的uiautomator例子的实现","slug":"1264","date":"2014-12-28T17:04:49.000Z","updated":"2017-12-16T15:42:55.686Z","comments":true,"path":"article/1264.html","link":"","permalink":"https://www.yangyanxing.com/article/1264.html","excerpt":"Android的自动化测试有很多框架，其中uiautomator是google官方提供的黑盒UI相关的自动化测试工具，case使用java写，今天实践了一下官方文档中样例程序，其中还是有一些小问题需要总结一下的。前几天试着使用uiautoamtor在真实的项目中写了一个简单的测试使用Uiautomator做基于UI界面的测试 使用ADT创建一个java的项目在创建项目的时候要加上JUnit与你使用的Android platforms中对应的android.jar与uiautomator.jar","text":"Android的自动化测试有很多框架，其中uiautomator是google官方提供的黑盒UI相关的自动化测试工具，case使用java写，今天实践了一下官方文档中样例程序，其中还是有一些小问题需要总结一下的。前几天试着使用uiautoamtor在真实的项目中写了一个简单的测试使用Uiautomator做基于UI界面的测试 使用ADT创建一个java的项目在创建项目的时候要加上JUnit与你使用的Android platforms中对应的android.jar与uiautomator.jar 新建一个包(我这里就只叫com)再这个包下创建一个class输入以下java代码,代码全是官方文档上的代码，除了最上面的package 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiObjectNotFoundException;import com.android.uiautomator.core.UiScrollable;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.testrunner.UiAutomatorTestCase;public class Runer extends UiAutomatorTestCase &#123; public void testDemo() throws UiObjectNotFoundException &#123; // Simulate a short press on the HOME button. getUiDevice().pressHome(); // We’re now in the home screen. Next, we want to simulate // a user bringing up the All Apps screen. // If you use the uiautomatorviewer tool to capture a snapshot // of the Home screen, notice that the All Apps button’s // content-description property has the value “Apps”. We can // use this property to create a UiSelector to find the button. UiObject allAppsButton = new UiObject(new UiSelector() .description(\"Apps\")); // Simulate a click to bring up the All Apps screen. allAppsButton.clickAndWaitForNewWindow(); // In the All Apps screen, the Settings app is located in // the Apps tab. To simulate the user bringing up the Apps tab, // we create a UiSelector to find a tab with the text // label “Apps”. UiObject appsTab = new UiObject(new UiSelector() .text(\"Apps\")); // Simulate a click to enter the Apps tab. appsTab.click(); // Next, in the apps tabs, we can simulate a user swiping until // they come to the Settings app icon. Since the container view // is scrollable, we can use a UiScrollable object. UiScrollable appViews = new UiScrollable(new UiSelector() .scrollable(true)); // Set the swiping mode to horizontal (the default is vertical) appViews.setAsHorizontalList(); // Create a UiSelector to find the Settings app and simulate // a user click to launch the app. UiObject settingsApp = appViews.getChildByText(new UiSelector() .className(android.widget.TextView.class.getName()), \"Settings\"); settingsApp.clickAndWaitForNewWindow(); // Validate that the package name is the expected one UiObject settingsValidation = new UiObject(new UiSelector() .packageName(\"com.android.settings\")); assertTrue(\"Unable to detect Settings\", settingsValidation.exists()); UiObject reportBug = new UiObject(new UiSelector().text(\"Sound\")); reportBug.clickAndWaitForNewWindow(); UiObject soundValidation = new UiObject(new UiSelector() .text(\"Volumes\")); assertTrue(\"Unable to detect Sound\", soundValidation.exists()); getUiDevice().pressHome(); &#125; 使用ant工具生成build.xml我这里在使用ADT自已的ant插件时提示 Class not found: javac1.8 网上查了查，是插件与我java环境不符，下载最新的ant插件就可以了http://ant.apache.org/bindownload.cgi下载这个tar.gz包，解压，然后将apache-ant-1.9.4bin目录添加到环境变量PATH中然后cmd到android sdk的tools目录，使用andrlid list命令，记住你将要在模拟器中运行的(也是你刚刚导入android.jar与uiautomator.jar包时所在的platforms)在cmd下使用android create uitest-project -n -t -p -n 为生成的jar包名称，自已任意定义，-t 为上面查看到的值，我这里是1-p 为输出路径，这里就是刚才创建的java项目所在的路径android create uitest-project -n AutoRunner -t 1 -p D:myAndroidStudyandroidTest然后再cmd进入D:myAndroidStudyandroidTest，使用ant build命令生成AutoRunner.jar文件 将这个AutoRunner.jar文件push到模拟器中adb push AutoRunner.jar /data/local/tmp 使用adb shell uiautomator runtest AutoRunner.jar –c com.Runer 使Runer类运行我的代码里又在官方基础上多了一个点击”sound”的操作与点击Home键操作123456UiObject reportBug = new UiObject(new UiSelector().text(\"Sound\")); reportBug.clickAndWaitForNewWindow(); UiObject soundValidation = new UiObject(new UiSelector() .text(\"Volumes\")); assertTrue(\"Unable to detect Sound\", soundValidation.exists());","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[{"name":"android","slug":"android","permalink":"https://www.yangyanxing.com/tags/android/"}]},{"title":"C++获取系统信息与拷贝文件到windows目录下","slug":"1220","date":"2014-12-06T14:28:33.000Z","updated":"2017-12-16T15:43:44.756Z","comments":true,"path":"article/1220.html","link":"","permalink":"https://www.yangyanxing.com/article/1220.html","excerpt":"12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;void main()&#123;char szSelfName[MAX_PATH] = &#123;0&#125;;//定义存储文件的名字的变量char szWindowsPath[MAX_PATH] = &#123;0&#125;;//定义winsows路径的变量char szSystemPath[MAX_PATH] = &#123;0&#125;;//定义存储system的变量char szTmpPath[MAX_PATH] = &#123;0&#125;;GetModuleFileName(NULL,szSelfName,MAX_PATH);//得到文件的名字，NULL的时候是文件自身GetWindowsDirectory(szWindowsPath,MAX_PATH);//得到windows目录GetSystemDirectory(szSystemPath,MAX_PATH);//得到system目录cout&lt;&lt;szSelfName&lt;&lt;endl&lt;&lt;szWindowsPath&lt;&lt;endl&lt;&lt;szSystemPath&lt;&lt;endl;strcat(szWindowsPath,\"\\123.exe\");//定义拷贝后的名字cout&lt;&lt;szWindowsPath&lt;&lt;endl;cout&lt;&lt;CopyFile(szSelfName,szWindowsPath,FALSE);char szComputerName[MAXBYTE] = &#123;0&#125;;//定义存储computer的变量char szUserName[MAXBYTE] = &#123;0&#125;;//定义userName存储的变量unsigned long nSize = MAXBYTE;OSVERSIONINFO OsVer;//Before calling the GetVersionEx function, set the dwOSVersionInfoSize member of the OSVERSIONINFO data structure to sizeof(OSVERSIONINFO).OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);GetVersionEx(&amp;OsVer);//将得到的系统信息存储在OsVer中cout&lt;&lt;OsVer.dwMajorVersion&lt;&lt;\".\"&lt;&lt;OsVer.dwMinorVersion&lt;&lt;\" \"&lt;&lt;OsVer.dwPlatformId&lt;&lt;endl;if(OsVer.dwMajorVersion == 6 &amp;&amp; OsVer.dwMinorVersion == 1)&#123;cout&lt;&lt;\"你的系统是win7\"&lt;&lt;endl;&#125;else&#123;cout&lt;&lt;\"你的系统不是win7\"&lt;&lt;endl;&#125;GetComputerName(szComputerName,&amp;nSize);GetUserName(szUserName,&amp;nSize);cout&lt;&lt;szComputerName&lt;&lt;endl;cout&lt;&lt;szUserName&lt;&lt;endl;","text":"12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;void main()&#123;char szSelfName[MAX_PATH] = &#123;0&#125;;//定义存储文件的名字的变量char szWindowsPath[MAX_PATH] = &#123;0&#125;;//定义winsows路径的变量char szSystemPath[MAX_PATH] = &#123;0&#125;;//定义存储system的变量char szTmpPath[MAX_PATH] = &#123;0&#125;;GetModuleFileName(NULL,szSelfName,MAX_PATH);//得到文件的名字，NULL的时候是文件自身GetWindowsDirectory(szWindowsPath,MAX_PATH);//得到windows目录GetSystemDirectory(szSystemPath,MAX_PATH);//得到system目录cout&lt;&lt;szSelfName&lt;&lt;endl&lt;&lt;szWindowsPath&lt;&lt;endl&lt;&lt;szSystemPath&lt;&lt;endl;strcat(szWindowsPath,\"\\123.exe\");//定义拷贝后的名字cout&lt;&lt;szWindowsPath&lt;&lt;endl;cout&lt;&lt;CopyFile(szSelfName,szWindowsPath,FALSE);char szComputerName[MAXBYTE] = &#123;0&#125;;//定义存储computer的变量char szUserName[MAXBYTE] = &#123;0&#125;;//定义userName存储的变量unsigned long nSize = MAXBYTE;OSVERSIONINFO OsVer;//Before calling the GetVersionEx function, set the dwOSVersionInfoSize member of the OSVERSIONINFO data structure to sizeof(OSVERSIONINFO).OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);GetVersionEx(&amp;OsVer);//将得到的系统信息存储在OsVer中cout&lt;&lt;OsVer.dwMajorVersion&lt;&lt;\".\"&lt;&lt;OsVer.dwMinorVersion&lt;&lt;\" \"&lt;&lt;OsVer.dwPlatformId&lt;&lt;endl;if(OsVer.dwMajorVersion == 6 &amp;&amp; OsVer.dwMinorVersion == 1)&#123;cout&lt;&lt;\"你的系统是win7\"&lt;&lt;endl;&#125;else&#123;cout&lt;&lt;\"你的系统不是win7\"&lt;&lt;endl;&#125;GetComputerName(szComputerName,&amp;nSize);GetUserName(szUserName,&amp;nSize);cout&lt;&lt;szComputerName&lt;&lt;endl;cout&lt;&lt;szUserName&lt;&lt;endl;","categories":[{"name":"C++","slug":"C","permalink":"https://www.yangyanxing.com/categories/C/"}],"tags":[]},{"title":"C++中windows编程基础","slug":"1216","date":"2014-12-06T14:20:08.000Z","updated":"2017-12-16T15:44:49.292Z","comments":true,"path":"article/1216.html","link":"","permalink":"https://www.yangyanxing.com/article/1216.html","excerpt":"1234567891011一、宽字符与多字节字符#include \"tchar.h\"void main()&#123;TCHAR p[] = _T(\"IT学吧\");int l1 = sizeof(p);//I1 T1 学2 吧2 1int l2 = _tcslen(p);int l4 = wcslen(p);//int l3 = strlen(p);return;&#125; 在多字节字符集中，每个汉字占两个字节，英文字母占一个字节，sizeof(p) = 7 _tcslen(p)=6(字符串长度等于6，I1 T1 学2 吧2) 在宽字节（unicode）字符集中，所有有字符都是占两个字节 sizeof(p) = 10 _tcslen(p)=4(I1 T1 学1 吧1)","text":"1234567891011一、宽字符与多字节字符#include \"tchar.h\"void main()&#123;TCHAR p[] = _T(\"IT学吧\");int l1 = sizeof(p);//I1 T1 学2 吧2 1int l2 = _tcslen(p);int l4 = wcslen(p);//int l3 = strlen(p);return;&#125; 在多字节字符集中，每个汉字占两个字节，英文字母占一个字节，sizeof(p) = 7 _tcslen(p)=6(字符串长度等于6，I1 T1 学2 吧2) 在宽字节（unicode）字符集中，所有有字符都是占两个字节 sizeof(p) = 10 _tcslen(p)=4(I1 T1 学1 吧1)在_tcslen函数中 英文字母每一个都只占一个长度，多字节中，中文占两个，宽字节中，中文占一个 #define _tcslen&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wcslen&#160; （宽字节定义 unicode） #define _tcslen&#160;&#160;&#160;&#160; strlen （多字节定义） 总体来说 使用_tcslen可以兼容多字节与宽字节 一般由_t与_tcs开头的都是兼容的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ca02windows.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"ca02windows.h\"#include \"tchar.h\"#include &lt;Windows.h&gt;LRESULT CALLBACK WndProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123;switch (uMsg)&#123;case WM_CLOSE:::MessageBox(hwnd, _T(\"确认关闭吗？\"), _T(\"确认关闭吗？\"), MB_YESNO);::DestroyWindow(hwnd);break;case WM_DESTROY:::PostQuitMessage(0);break;default:break;&#125;return DefWindowProc(hwnd, uMsg, wParam, lParam);//不自已定义处理函数，使用系统自已的处理方法&#125;int WINAPI _tWinMain(IN HINSTANCE hInstance,IN HINSTANCE hPrevInstance,IN LPTSTR lpCmdLine,IN int nShowCmd)&#123;const TCHAR* pszClassName = _T(\"ITWnd\");WNDCLASSEX wcex;wcex.cbSize = sizeof(WNDCLASSEX);wcex.style = CS_HREDRAW | CS_VREDRAW;//水平与垂直变化重绘wcex.lpfnWndProc = WndProc;//回调函数wcex.cbClsExtra = 0;wcex.cbWndExtra = 0;wcex.hInstance = hInstance;//handlewcex.hIcon = (HICON)::LoadIcon(NULL, IDI_HAND);//大图标wcex.hIconSm = (HICON)::LoadIcon(NULL, IDI_APPLICATION);//小图标wcex.hbrBackground = (HBRUSH)::GetStockObject(WHITE_BRUSH);//背景wcex.hCursor = (HCURSOR)::LoadCursor(NULL, IDC_ARROW);//光标wcex.lpszMenuName = NULL;//是否有菜单wcex.lpszClassName = pszClassName;//注册的类名，不能重复的BOOL bRet = ::RegisterClassEx(&amp;wcex);//开始注册这个类if (!bRet)&#123;::MessageBox(NULL, _T(\"注册窗口失败\"), _T(\"注册窗口\"), MB_OK);return FALSE;&#125;HWND hwnd = ::CreateWindowEx(0, pszClassName, _T(\"杨彦星kevin\"), WS_VISIBLE | WS_OVERLAPPEDWINDOW,CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,NULL, NULL, hInstance, NULL); //开始创建窗口if (!hwnd)&#123;::MessageBox(NULL, _T(\"创建窗口失败\"), _T(\"创建窗口\"), MB_OK);return FALSE;&#125;::ShowWindow(hwnd, SW_NORMAL);//创建窗口 SW_NORMAL最大化::UpdateWindow(hwnd);//更新窗口//::DestroyWindow()MSG msg;while (::GetMessage(&amp;msg,NULL,NULL,NULL))&#123;::TranslateMessage(&amp;msg);//翻译消息::DispatchMessage(&amp;msg);//调试消息，将消息传给回调函数进行处理&#125;return TRUE;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://www.yangyanxing.com/categories/C/"}],"tags":[]},{"title":"c++语言基础(hello world,数据类型,构造方法,指针的常见错误,常量指针,指针与引用)","slug":"1212","date":"2014-12-06T14:13:08.000Z","updated":"2017-12-16T15:45:51.109Z","comments":true,"path":"article/1212.html","link":"","permalink":"https://www.yangyanxing.com/article/1212.html","excerpt":"123456789101112131415161718192021222324252627一、hello world#include&lt;iostream&gt; 这里可以用#include&lt;iostream.h&gt; 加载一个非标准的库，由于.h还没有名字空间的概念，所以之后也就没有使用std的操作using namespace std; 声明定义使用std 名字空间namespace a&#123; int b = 5;&#125;namespace c&#123; int b = 8;&#125;int main()&#123; std::cout&lt;&lt;\"我喜欢C++n\"; std::cout&lt;&lt;\"五年一班数学成绩n\"; std::cout&lt;&lt;\"第一名许凡的成绩t\"&lt;&lt;100; std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"第二名许凡的成绩t\"&lt;&lt;90+8; std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"第三名许凡的成绩t\"&lt;&lt;(float)5/8; std::cout&lt;&lt;std::endl; cout&lt;&lt;\"我是没有使用std的\"&lt;&lt;endl; int b = 10; cout&lt;&lt;b&lt;&lt;\" \"&lt;&lt;a::b&lt;&lt;\" \"&lt;&lt;c::b&lt;&lt;endl; return 0;&#125;","text":"123456789101112131415161718192021222324252627一、hello world#include&lt;iostream&gt; 这里可以用#include&lt;iostream.h&gt; 加载一个非标准的库，由于.h还没有名字空间的概念，所以之后也就没有使用std的操作using namespace std; 声明定义使用std 名字空间namespace a&#123; int b = 5;&#125;namespace c&#123; int b = 8;&#125;int main()&#123; std::cout&lt;&lt;\"我喜欢C++n\"; std::cout&lt;&lt;\"五年一班数学成绩n\"; std::cout&lt;&lt;\"第一名许凡的成绩t\"&lt;&lt;100; std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"第二名许凡的成绩t\"&lt;&lt;90+8; std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"第三名许凡的成绩t\"&lt;&lt;(float)5/8; std::cout&lt;&lt;std::endl; cout&lt;&lt;\"我是没有使用std的\"&lt;&lt;endl; int b = 10; cout&lt;&lt;b&lt;&lt;\" \"&lt;&lt;a::b&lt;&lt;\" \"&lt;&lt;c::b&lt;&lt;endl; return 0;&#125; 二、数据类型 1. 常量 使用const 关键字定义 const name = “yangyanxing”; 2. 枚举型常量 enum num{zero,one,two,three,four};12345678910111213 int main()&#123; enum day&#123;Sunday,Monday,Tuesday,Wednesday,Thurday,Friday,Saturday&#125;; day today; // 使用枚举类型day 创建一个today对象 today = Monday;// 相当于today=1 if (today == Sunday||today == Saturday)&#123; cout&lt;&lt;\"今天休息\"; &#125; else&#123; cout&lt;&lt;\"今天工作\"&lt;&lt;endl; &#125; return 0;&#125; 三、构造方法1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class rectangel&#123; public: //下面这个是构造函数，它没有返回值，也就不用反回值类型 rectangel(int l,int w)&#123;length = l;width = w;&#125; //构造函数可以有多个，以参数不同为区分 rectangel()&#123;cout&lt;&lt;\"这里调用无参的构造参数n\";&#125; //下面定义析构函数，析构函数也是没有返回值，且只能有一个没有参数的，使用~ 与构造函数进行区分 ~rectangel()&#123;cout&lt;&lt;\"对象使用完毕，该说bye-bye啦！n\";&#125; int area()&#123;return length*width;&#125; int getLength()&#123;return length;&#125; int getWitdth()&#123;return width;&#125; private: //私有成员属性不能直接访问，要通过一个公有(public)的方法来返回 int length; int width;&#125;;int main()&#123; rectangel a(3,4); cout&lt;&lt;\"这个长方形a的长为\"&lt;&lt;a.getLength()&lt;&lt;endl; cout&lt;&lt;\"这个长方形a的宽为\"&lt;&lt;a.getWitdth()&lt;&lt;endl; cout&lt;&lt;\"这个长方形a的面积为\"&lt;&lt;a.area()&lt;&lt;endl; //这里创建另外一个对象，以无参的形式创建 ,这时它的长和宽将不确定 rectangel b; cout&lt;&lt;\"这个长方形b的长为\"&lt;&lt;b.getLength()&lt;&lt;endl; cout&lt;&lt;\"这个长方形b的宽为\"&lt;&lt;b.getWitdth()&lt;&lt;endl; cout&lt;&lt;\"这个长方形b的面积为\"&lt;&lt;b.area()&lt;&lt;endl; return 0;&#125; 四、指针的常见错误1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int *p = new int; *p = 3; cout&lt;&lt;\"初始化p时所指向的内存地址为：\"&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;\"将3赋给p的地址后，指针p读取的值为：\"&lt;&lt;*p&lt;&lt;endl; delete p;//将p指针删除，但是并没有将其指向空。删除掉指针其实并没有删除掉该指针 //而是告诉编译器该指针所指向的这块内存区域我不用了，可以被别的变量所使用 //而此时该指针所保存的地址在没有指向空之前还是原来指向的地址 cout&lt;&lt;\"删除指针后p所保存的内存地址为：\"&lt;&lt;p&lt;&lt;endl; long *p1 =new long;//这里重新开辟一块新的内存区域，也就是刚才释放掉的内存区域&#125; 123456789101112131415161718将delete应用于指针时,它指向的内存将被释放,如果再一次对该指针使用delete,程序将崩溃,因为删除指针后要将其值设置为0或者NULL(即空指针),将delete用于空指针是安全的.#include &lt;iostream&gt;using namespace std;int main()&#123; int* p = 0;//初始化时应该将指针赋值为空指针 p = new int; *p = 9; cout&lt;&lt;\"*p = \"&lt;&lt;*p&lt;&lt;endl; delete p; p = 0;//or p = NULL; delete p;//delete p again,不会发生错误 int n;//为了不让屏幕一闪而消失 cin&gt;&gt;n; return 0;&#125; 如果delete p后未将p赋值为空指针的话,将会出现迷途指针,这个错误在C++中最难发现,最难解决的问题.迷途指针是指将delete用于指针p后,释放它所指向的内存,但是没有把指针赋值为空指针,这时候p所指向的内存可能供其他程序使用,一旦再一次调用p,因为p所指向的依然是那一块内存,那块内存又被其他程序已经用来,这个导致的结果不可预料,所以在C++中这个迷途指针才是麻烦. 就好比,我要订一个快餐,在手机上设置了快捷键2,按2就可以拨打400-517-517,快餐电话订快餐,但是后来这个电话号码有其他用途了,例如被设置为投诉电话,或者某人的家庭电话,又或者这个电话变成空号了,我按2快捷键的时候或者拨打到别人家里,别人公司,或者是空号,如果危险的话这个电话就被恐怖分子设置为启动炸弹的电话,一旦有电话打入,某地方的炸弹立刻爆炸,非常危险.所以在400-517-517这个号码变更好,我要把快捷键设置为空,等以后想用时再设置. 所以呢,delete p之后要将p赋值为空指针 五、常量指针12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class A &#123;public: int get()&#123;return this-&gt;i;&#125; void set(int x)&#123;this-&gt;i=x;&#125;private: int i;&#125;;int main()&#123; int a = 3; int *const p = &amp;a;//常量指针，指针所指向的内存地址不能改变，但是内存地址上的值可以改变,定义的时候必须要初始化 a = 4; A *const p1 = new A;//指向A对象的一个常量指针 //指针为常量，不可改变，但是指针所指的变量或者对象是可以改变的 //p1 = p1+1; p1-&gt;set(11); cout&lt;&lt;p1-&gt;get(); return 0;&#125; 六、指针与引用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;using namespace std;void swap(int &amp;m,int &amp;n)&#123; //这里的参数是地址 cout&lt;&lt;\"交换前m的值为\"&lt;&lt;m&lt;&lt;\" n的值为:\"&lt;&lt;n&lt;&lt;endl; int c; c=m; m=n; n=c; cout&lt;&lt;\"交换后m的值为\"&lt;&lt;m&lt;&lt;\" n的值为:\"&lt;&lt;n&lt;&lt;endl;&#125;int func(int a,float *b,int *c)&#123; if(a&gt;200||a&lt;=0)&#123; a=0; &#125;else&#123; *b = a*a*3.14; *c = a*a; a = 1; &#125; return a;&#125;//使用按址传递的方式int func2(int a,float &amp;b,int &amp;c)&#123; if(a&gt;200||a&lt;=0)&#123; a=0; &#125;else&#123; b = a*a*3.14; c = a*a; a = 1; &#125; return a;&#125;int main()&#123; int num = 0; int &amp;mum = num;//引用即别名，这里是将num取了另外一个名字叫mum num = 99; cout&lt;&lt;\"mum的值为：\"&lt;&lt;mum&lt;&lt;endl; mum = 100; cout&lt;&lt;\"num的值为:\"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;\"&amp;num:\"&lt;&lt;&amp;num&lt;&lt;endl; cout&lt;&lt;\"&amp;mum:\"&lt;&lt;&amp;mum&lt;&lt;endl;//它们的内存地址是一样的 cout&lt;&lt;\"###################n\"; int b = 999; mum = b; //其实只是将b的值赋给了mum与num cout&lt;&lt;\"将b赋给mun后的内存地址情况\"&lt;&lt;endl; cout&lt;&lt;\"&amp;num:\"&lt;&lt;&amp;num&lt;&lt;\":\"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;\"&amp;mum:\"&lt;&lt;&amp;mum&lt;&lt;\":\"&lt;&lt;mum&lt;&lt;endl; cout&lt;&lt;\"&amp;b :\"&lt;&lt;&amp;b&lt;&lt;\":\"&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;\"改变num的值后内存与值的情况\"&lt;&lt;endl; num = 10; cout&lt;&lt;\"&amp;num:\"&lt;&lt;&amp;num&lt;&lt;\":\"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;\"&amp;mum:\"&lt;&lt;&amp;mum&lt;&lt;\":\"&lt;&lt;mum&lt;&lt;endl; cout&lt;&lt;\"&amp;b :\"&lt;&lt;&amp;b&lt;&lt;\":\"&lt;&lt;b&lt;&lt;endl; //b的值是不受影响的 cout&lt;&lt;\"*******************n\"; int m = 3; int n = 4; cout&lt;&lt;\"主程序中m的值为：\"&lt;&lt;m&lt;&lt;\" n的值为：\"&lt;&lt;n&lt;&lt;endl; swap(m,n);//这里传的是m与n的地址 cout&lt;&lt;\"swap后m的值为：\"&lt;&lt;m&lt;&lt;\" n的值为：\"&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;\"*******************n\"; cout&lt;&lt;\"请输入一个数，将会求出圆的面积与正方形的面积n\"; int r,br; float cr; int check; cin&gt;&gt;r; check = func(r,&amp;cr,&amp;br);//这样可以通过一个函数来改变三个值 cr br a if(check)&#123; cout&lt;&lt;\"圆的面积为：\"&lt;&lt;cr&lt;&lt;\"正方形的面积为:\"&lt;&lt;br&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;\"您输入的数字有误n\"; cout&lt;&lt;r&lt;&lt;\" \"&lt;&lt;cr&lt;&lt;\" \"&lt;&lt;br&lt;&lt;endl; &#125; cout&lt;&lt;\"请再次输入一个数，将会求出圆的面积与正方形的面积n\"; int x,z; float y; cin&gt;&gt;x; check = func2(x,y,z);//按址传递 if(check)&#123; cout&lt;&lt;\"圆的面积为：\"&lt;&lt;y&lt;&lt;\"正方形的面积为:\"&lt;&lt;z&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;\"您输入的数字有误n\"; &#125; /* 总的来说，使用按址传递的方法代码上看起来再简洁一些，指针容易写错 */ return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://www.yangyanxing.com/categories/C/"}],"tags":[]},{"title":"dev c++安装使用","slug":"1208","date":"2014-12-06T14:08:03.000Z","updated":"2017-12-16T15:47:10.836Z","comments":true,"path":"article/1208.html","link":"","permalink":"https://www.yangyanxing.com/article/1208.html","excerpt":"最近开始接触C++，在练习基本的语法的时候，不想使用臃肿的VS，于是查了下，dev c++为个挺小巧，但麻雀虽小五脏具全，对于基本语法的学习使用已经足够了。 下载安装，下载还是挺麻烦的，我下载好了共享在360云盘上了，http://yunpan.cn/cAaf826jiSdie （提取码：7b0a）这个是有minGW的，安装的时候选择full 在翻译的时候输出debug，当然你不这样设置的话在以后要调试的时候也会提示你是否设置的 工具–翻译选项","text":"最近开始接触C++，在练习基本的语法的时候，不想使用臃肿的VS，于是查了下，dev c++为个挺小巧，但麻雀虽小五脏具全，对于基本语法的学习使用已经足够了。 下载安装，下载还是挺麻烦的，我下载好了共享在360云盘上了，http://yunpan.cn/cAaf826jiSdie （提取码：7b0a）这个是有minGW的，安装的时候选择full 在翻译的时候输出debug，当然你不这样设置的话在以后要调试的时候也会提示你是否设置的 工具–翻译选项 写一个简单的hello world吧 123456#include&lt;iostream&gt;using namespace std;int main()&#123;cout&lt;&lt;\"hello world\"&lt;&lt;endl;return 0;","categories":[{"name":"C++","slug":"C","permalink":"https://www.yangyanxing.com/categories/C/"}],"tags":[]},{"title":"被潜意识蒙蔽的理性","slug":"1199","date":"2014-10-27T16:20:02.000Z","updated":"2017-12-16T10:10:41.991Z","comments":true,"path":"article/1199.html","link":"","permalink":"https://www.yangyanxing.com/article/1199.html","excerpt":"最近在观察一些事情，发现很多时候我们的理性往往都被潜意识所蒙蔽。 公司内网中有段时间经常有人发表一些自已的东西被“偷”的帖子，于是在人们脑海中就有一个公司里有很多小偷的意识，自已的东西一旦找不到了，首先想到的就是被别人偷走了，甚至一些人还总发表一些放在冰箱里的食物饮料等被莫名的拿走的帖子，这些人无疑首先说的就是“偷”，遇到这样的事情首先想到的也是被别人拿走了，被别人吃掉了。","text":"最近在观察一些事情，发现很多时候我们的理性往往都被潜意识所蒙蔽。 公司内网中有段时间经常有人发表一些自已的东西被“偷”的帖子，于是在人们脑海中就有一个公司里有很多小偷的意识，自已的东西一旦找不到了，首先想到的就是被别人偷走了，甚至一些人还总发表一些放在冰箱里的食物饮料等被莫名的拿走的帖子，这些人无疑首先说的就是“偷”，遇到这样的事情首先想到的也是被别人拿走了，被别人吃掉了。后来有一天终于抓到了这个“小偷”，公司的保洁阿姨将冰箱里的看着长时间不吃的甚至变质的东西给仍了，这当中的误会也因此解除，之后也就很少有人再发些自已的吃的被“偷”的帖子。 另一件事是在公司十一放假前一天，有个人发了个帖子，那天是个周二，在我们公司那天下午是可以领办公用品的，当那个人去行政部领东西的时候，发现没有人，于是回来就在论坛里抱怨说“公司的行政部是不是已经提前放假了？”。 简单有两件小事，反映出我们在判断一件事的时候，总是先假定事情是一个什么的结果与原因，一旦表象所反映的内容达到某个状态，于是我们就更加确定脑海里的潜意识的判断，你到行政部没有看到人，那么你为什么不等一等，或者她只是去厕所了呢，或者只是出去接个电话了呢，为什么一定要认为她们提前下班了呢？ 生活中这样的例子也挺多，看到一个美女，潜意识里认为她一定得是一个高冷的人，当你想要和她接触她对你爱搭不理或者表现出讨厌的时候，你会不会到处去说她是个高攀不起的人。 两个相恋的人在一起，男的脑海里一直认为女方家里在未来一定要房子与车子，哪天真的分开了，男的未免在心里会认为一定是她家里看不起他这样的穷小子。 生活在一起的两个人，当一个人总是在潜意识里认识老公有外遇了，那么真有一天男的回来晚了或者一夜未归，第二天肯定免不了一通吵架。 工作中，你脑海里一开始认为另外一个同事总和你过不去，找你岔，哪天你可能真的因为你的错误，他说了你什么，你心里想的可能会是他怎么总和我过不去呢，我非得整他一次。 潜意识里官员就应该腐败，公务员就应该靠关系。 脑海中里的潜意识行为真是可怕，它蒙蔽了太多的真实，蒙蔽了太多的理性。 其实只要内心强大，你也可以拥有一双慧眼，透到现象看到事情的本质。","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"七牛cdn缓存导致ajax评论失效","slug":"1151","date":"2014-10-06T16:41:23.000Z","updated":"2017-12-16T15:47:50.565Z","comments":true,"path":"article/1151.html","link":"","permalink":"https://www.yangyanxing.com/article/1151.html","excerpt":"在使用了七牛的CDN后，发现在评论的时候会出现405错误 {“error”:”get from image source failed: E405”} 在网上查了查，这个问题出现的还挺多的，解决办法是改comments-ajax.js这个文件 1.在comments-ajax.js文件中下面这段程序的后面（参考cdn缓存导致ajax评论失效）： 12345var i = 0, got = -1, len = document.getElementsByTagName('script').length;while ( i &lt;= len &amp;&amp; got == -1)&#123; var js_url = document.getElementsByTagName('script')[i].src, got = js_url.indexOf('comments-ajax.js'); i++ ;&#125;","text":"在使用了七牛的CDN后，发现在评论的时候会出现405错误 {“error”:”get from image source failed: E405”} 在网上查了查，这个问题出现的还挺多的，解决办法是改comments-ajax.js这个文件 1.在comments-ajax.js文件中下面这段程序的后面（参考cdn缓存导致ajax评论失效）： 12345var i = 0, got = -1, len = document.getElementsByTagName('script').length;while ( i &lt;= len &amp;&amp; got == -1)&#123; var js_url = document.getElementsByTagName('script')[i].src, got = js_url.indexOf('comments-ajax.js'); i++ ;&#125; 添加一句话： js_url = js_url.replace(‘static.yangyanxing.com’,www.yangyanxing.com’); 其中，chengchunjie.qiniu.com换成自己的七牛云存储提供的二级域名，chengchunjie.com替换成自己的域名。 2.登陆七牛云存储，进入自己的网站静态存储的空间，打开内容，找到自己已经缓存的原来的comments-ajax.js文件，将修改过的comments-ajax.js上传上去。（这个最主要是解决，自己网站上comments-ajax.js更改，但七牛的CDN上并没有更改导致的一段时间评论还是无法提交成功的问题） 注意：上传的时候，在设置路径前缀处，一定要自定义前缀，wp-content/themes/你的主题名称/，否则上传无效。","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://www.yangyanxing.com/tags/wordpress/"}]},{"title":"mysql与mongodb命令对比","slug":"1128","date":"2014-09-28T17:01:51.000Z","updated":"2017-12-16T10:10:42.312Z","comments":true,"path":"article/1128.html","link":"","permalink":"https://www.yangyanxing.com/article/1128.html","excerpt":"","text":"之前一直在使用mysql,最近开始接触mongodb，觉得还是有一些相似的地方，只是相应的命令不大一样，这里做下记录，对比记应该相对简单一些,mongodb使用的是python的接口 连接：mysql: mysql -h localhost -u username -pmongodb:con = pymongo.Connection(‘localhost’,27017)显示数据库mysql:show databases;mongodb:con.database_names()使用某个数据库mysql:use database;mongodb:db = con[‘database’] or con.database 没有将会创建显示所有的表mysql:show tables;mongodb:db.collection_names()使用某个表(mongodb中称为colection)mysql: use table;mongodb:col = db.collection or db[‘collection’] 没有将会创建遍历表中的内容mysql: select * from table[where…]mongodb: for i in col.find():print ifor i in col.find_one({‘key’:’value’}):print i 返回值是字典向表中插入值mysql: insert into table valuses(……)mongodb:col.insert({‘key’:’value’,…})d = {‘key’:’value’}col.insert(d)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://www.yangyanxing.com/tags/sql/"}]},{"title":"修改Gwibber脚本成功添加新浪微博账户（解决一直正在认证的问题）","slug":"1115","date":"2014-09-21T15:38:38.000Z","updated":"2017-12-16T10:10:42.440Z","comments":true,"path":"article/1115.html","link":"","permalink":"https://www.yangyanxing.com/article/1115.html","excerpt":"Gwibber是linux下使用python基于 WebKit 和 GTK的客户端，其实本身功能大大陆基本上都用不了，只有一个新浪微博能用，但是里面的api认证还是用的几年前的oauth1,新浪早就将其停用了，现在 都采用的是oauth2认证，但是这个客户端还没有更新，在使用的时候会显示一直在认证页面。 其实本来也不想用它来发看微博，只是想完成认证，后面经过修改以后主界面报异常，不管了，这个客户端总之太挫了…… 使用官方推荐的由@廖雪峰 写的python SDK，https://github.com/michaelliao/sinaweibopy/wiki/OAuth2-HOWTO 将python SDK中的weibo.py放到init.py同级目录下","text":"Gwibber是linux下使用python基于 WebKit 和 GTK的客户端，其实本身功能大大陆基本上都用不了，只有一个新浪微博能用，但是里面的api认证还是用的几年前的oauth1,新浪早就将其停用了，现在 都采用的是oauth2认证，但是这个客户端还没有更新，在使用的时候会显示一直在认证页面。 其实本来也不想用它来发看微博，只是想完成认证，后面经过修改以后主界面报异常，不管了，这个客户端总之太挫了…… 使用官方推荐的由@廖雪峰 写的python SDK，https://github.com/michaelliao/sinaweibopy/wiki/OAuth2-HOWTO 将python SDK中的weibo.py放到init.py同级目录下 修改/usr/share/gwibber/plugins/sina/gtk/sina 下的init.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210from gi.repository.Gtk import Builderimport urllib, urllib2, json, urlparse, uuidfrom oauth import oauthfrom weibo import APIClientfrom gwibber.microblog.util import resourcesfrom gwibber.microblog.util.keyring import get_from_keyringimport gettextfrom gettext import gettext as _if hasattr(gettext, 'bind_textdomain_codeset'): gettext.bind_textdomain_codeset('gwibber','UTF-8')gettext.textdomain('gwibber-service-sina')import sina.utilsGdk.threads_init()sigmeth = oauth.OAuthSignatureMethod_HMAC_SHA1()class AccountWidget(Gtk.VBox): \"\"\"AccountWidget: A widget that provides a user interface for configuring sina accounts in Gwibber \"\"\" def __init__(self, account=None, dialog=None): \"\"\"Creates the account pane for configuring Sina accounts\"\"\" Gtk.VBox.__init__( self, False, 20 ) self.ui = Gtk.Builder() self.ui.set_translation_domain (\"gwibber\") self.ui.add_from_file (resources.get_ui_asset(\"gwibber-accounts-sina.ui\")) self.ui.connect_signals(self) self.vbox_settings = self.ui.get_object(\"vbox_settings\") self.pack_start(self.vbox_settings, False, False, 0) self.show_all() self.account = account or &#123;&#125; self.dialog = dialog self.window = dialog.dialog has_access_token = False has_secret_key = False if self.account.has_key(\"id\"): has_secret_key = get_from_keyring(self.account['id'], 'secret_token') is not None try: if self.account.has_key(\"access_token\") and self.account.has_key(\"secret_token\") and self.account.has_key(\"username\") and has_secret_key and not self.dialog.condition: self.ui.get_object(\"hbox_sina_auth\").hide() self.ui.get_object(\"sina_auth_done_label\").set_label(_(\"%s has been authorized by Sina\") % self.account[\"username\"]) self.ui.get_object(\"hbox_sina_auth_done\").show() else: self.ui.get_object(\"hbox_sina_auth_done\").hide() if self.dialog.ui: self.dialog.ui.get_object('vbox_create').hide() except: self.ui.get_object(\"hbox_sina_auth_done\").hide() if self.dialog.ui: self.dialog.ui.get_object(\"vbox_create\").hide() def on_sina_auth_clicked(self, widget, data=None): client = APIClient(app_key='1472971394',app_secret='49443ea72f7545486143f3f074b0b66e',redirect_uri=\"http://gwibber.com/0/auth.html\") url = client.get_authorize_url() self.winsize = self.window.get_size() web = WebKit.WebView() web.get_settings().set_property(\"enable-plugins\", False) web.get_settings().set_property(\"enable-developer-extras\", False) web.load_html_string(_(\"&lt;p&gt;Please wait...&lt;/p&gt;\"), \"file:///\") self.consumer = oauth.OAuthConsumer(*sina.utils.get_sina_keys()) request = oauth.OAuthRequest.from_consumer_and_token(self.consumer, http_method=\"POST\", callback=\"http://gwibber.com/0/auth.html\", http_url=\"http://api.t.sina.com.cn/oauth/request_token\") request.sign_request(sigmeth, self.consumer, token=None) tokendata = urllib2.urlopen(request.http_url, request.to_postdata()).read() self.token = oauth.OAuthToken.from_string(tokendata) # url = \"http://api.t.sina.com.cn/oauth/authorize?oauth_token=\" + self.token.key web.load_uri(url) web.set_size_request(550, 400) web.connect(\"title-changed\", self.on_sina_auth_title_change) self.scroll = Gtk.ScrolledWindow() self.scroll.add(web) self.scroll.set_size_request(550, 400) self.pack_start(self.scroll, True, True, 0) self.show_all() self.dialog.infobar.hide() self.ui.get_object(\"vbox1\").hide() self.ui.get_object(\"vbox_advanced\").hide() self.dialog.infobar.set_message_type(Gtk.MessageType.INFO) def on_sina_auth_title_change(self, web=None, title=None, data=None): saved = False if title.get_title() == \"Success\": if hasattr(self.dialog, \"infobar_content_area\"): for child in self.dialog.infobar_content_area.get_children(): child.destroy() self.dialog.infobar_content_area = self.dialog.infobar.get_content_area() self.dialog.infobar_content_area.show() self.dialog.infobar.show() message_label = Gtk.Label(_(\"Verifying\")) message_label.set_use_markup(True) message_label.set_ellipsize(Pango.EllipsizeMode.END) self.dialog.infobar_content_area.add(message_label) self.dialog.infobar.show_all() self.scroll.destroy() url = web.get_main_frame().get_uri() #use code for get token code = url.split('=')[1]#获得code值 client = APIClient(app_key='1472971394',app_secret='49443ea72f7545486143f3f074b0b66e',redirect_uri=\"http://gwibber.com/0/auth.html\") r = client.request_access_token(code) self.ui.get_object(\"vbox1\").show() self.ui.get_object(\"vbox_advanced\").show() self.access_token = r.access_token self.expires_in = r.expires_in client.set_access_token(self.access_token,self.expires_in) # verifier = data[\"oauth_verifier\"][0] # request = oauth.OAuthRequest.from_consumer_and_token( # self.consumer, self.token, http_method=\"POST\", # http_url=\"http://api.t.sina.com.cn/oauth/access_token\", # parameters=&#123;\"oauth_verifier\": str(verifier)&#125;) # request.sign_request(sigmeth, self.consumer, self.token) # tokendata = urllib2.urlopen(request.http_url, request.to_postdata()).read() # data = urlparse.parse_qs(tokendata) # atok = oauth.OAuthToken.from_string(tokendata) # self.account[\"access_token\"] = data[\"oauth_token\"][0] print \"11111111111111111111\" #这里打印一些信息来看看是否能正常获得token for k in r: print k, print '===============&gt;', print r[k] print \"11111111111111111111\" self.account[\"access_token\"] = r.access_token self.account[\"secret_token\"] = code#oauth2中的secret_token也就是code的值 # apireq = oauth.OAuthRequest.from_consumer_and_token( # self.consumer, atok, # http_method=\"GET\", # http_url=\"http://api.t.sina.com.cn/account/verify_credentials.json\", parameters=None) # apireq.sign_request(sigmeth, self.consumer, atok) # account_data = json.loads(urllib2.urlopen(apireq.to_url()).read()) # userinfo = client.users.show.get(access_token=access_token) useruid = client.account.get_uid.get() print useruid userinfo = client.users.show.get(uid=useruid['uid']) for k in userinfo: print k, print '=======&gt;', print userinfo[k] self.account[\"username\"] = userinfo[\"screen_name\"].encode(\"utf-8\") self.account[\"user_id\"] = userinfo[\"id\"] client.statuses.update.post(status='send from gwibber!')#这里试着发了一条微博，证明还是挺好用的！ if isinstance(userinfo, dict): if userinfo.has_key(\"id\"): saved = self.dialog.on_edit_account_save() else: print \"Failed\" self.dialog.infobar.set_message_type(Gtk.MessageType.ERROR) message_label.set_text(_(\"Authorization failed. Please try again.\")) else: print \"Failed\" self.dialog.infobar.set_message_type(Gtk.MessageType.ERROR) message_label.set_text(_(\"Authorization failed. Please try again.\")) if saved: message_label.set_text(_(\"Successful\")) self.dialog.infobar.set_message_type(Gtk.MessageType.INFO) self.dialog.infobar.hide() self.ui.get_object(\"hbox_sina_auth\").hide() self.ui.get_object(\"sina_auth_done_label\").set_label(_(\"%s has been authorized by Sina\") % str(self.account[\"username\"])) self.ui.get_object(\"hbox_sina_auth_done\").show() if self.dialog.ui and self.account.has_key(\"id\") and not saved: self.dialog.ui.get_object(\"vbox_save\").show() elif self.dialog.ui and not saved: self.dialog.ui.get_object(\"vbox_create\").show() self.window.resize(*self.winsize) if title.get_title() == \"Failure\": self.dialog.infobar.set_message_type(Gtk.MessageType.ERROR) message_label = Gtk.Label (_(\"Authorization failed. Please try again.\")) message_label.set_use_markup(True) message_label.set_ellipsize(Pango.EllipsizeMode.END) self.dialog.infobar_content_area.add(message_label) self.dialog.infobar.show_all() self.ui.get_object(\"vbox1\").show() self.ui.get_object(\"vbox_advanced\").show() self.scroll.destroy() self.window.resize(*self.winsize) self.dialog.select_account ()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"java中面向对象的一点学习总结","slug":"1108","date":"2014-08-24T15:33:40.000Z","updated":"2017-12-16T10:10:42.509Z","comments":true,"path":"article/1108.html","link":"","permalink":"https://www.yangyanxing.com/article/1108.html","excerpt":"最近开始看java的一些东西，感觉比python麻烦些，今天学习了面向对象的一些东西，觉得挺多挺复杂，这里做个知识总结 以一个简单的例子来说明java面向对象的三大特性，封装，继承，多态，有一个动物(Animal)基类，定义了run与eat方法，然后有一个猫(Cat)与狗(Dog)的子类继承了动物这个父类，子类重写(override)了父类的run与eat方法，同步又重载(overload)了run与eat方法，同时又定义了一个交配(Icopulation)的接口，让狗来implements交配接口，同时又创建一个Human类来专门implements交配接口 下面是具体的实现代码，没有什么实际的应用，只是作为学习用","text":"最近开始看java的一些东西，感觉比python麻烦些，今天学习了面向对象的一些东西，觉得挺多挺复杂，这里做个知识总结 以一个简单的例子来说明java面向对象的三大特性，封装，继承，多态，有一个动物(Animal)基类，定义了run与eat方法，然后有一个猫(Cat)与狗(Dog)的子类继承了动物这个父类，子类重写(override)了父类的run与eat方法，同步又重载(overload)了run与eat方法，同时又定义了一个交配(Icopulation)的接口，让狗来implements交配接口，同时又创建一个Human类来专门implements交配接口 下面是具体的实现代码，没有什么实际的应用，只是作为学习用Animal.java 这个是父类12345678910package com.yangyanxing.www;//这里是定义了一个Animal的基类public class Animal &#123;public void run()&#123;System.out.println(\"我是所有动物的跑\");&#125;public void eat()&#123;System.out.println(\"我是所有动物在吃\");&#125;&#125; Icopulation.java 交配的接口 12345package com.yangyanxing.www;//这里定义了一个接口类，动物应该都具有交配public interface Icopulation &#123;public void copulation();//这里是一个规范，要有交配方法，具体怎么实现要子类去实现&#125; &#160; Dog.java Dog的子类 1234567891011121314151617181920212223package com.yangyanxing.www;//这里定义了一个狗的类继承Animal基类public class Dog extends Animal implements Icopulation &#123;//对父类的方法进行重写(override) 方法的返回值类型与参数都不能变public void run()&#123;System.out.println(\"我是一条狗在跑\");&#125;//方法的重载(overload)只是参数的数量与类型不同，返回值与权限都要相同//这里由于父类里的run方法没有重载，所以使用多态创建的子类引用也不能使用带参数的run(5)public void run(int a)&#123;System.out.printf(\"我是只狗，已经跑了%d公里了n\",a);&#125;public void eat()&#123;System.out.println(\"我是一条狗是吃\");&#125;//这里是狗自已的方法，不是从基类继承的public void creame()&#123;System.out.println(\"这是一条狗在叫\");&#125;public void copulation()&#123;System.out.println(\"狗在交配\");&#125;&#125; &#160; Cat.java Cat子类 1234567891011121314151617package com.yangyanxing.www;public class Cat extends Animal &#123;public void run()&#123;System.out.println(\"我是一只猫在跑\");&#125;public void eat()&#123;System.out.println(\"我是一条猫是吃\");&#125;public void eat(String food)&#123;System.out.printf(\"我是只猫，我正在吃%sn\",food);&#125;//这里是猫自已的方法，不是从基类继承的public void creame()&#123;System.out.println(\"这是一条猫在叫\");&#125;&#125; &#160; Human.java 实现了交配的Human类 123456789101112package com.yangyanxing.www;public class Human implements Icopulation &#123;@Overridepublic void copulation() &#123;// TODO Auto-generated method stubSystem.out.println(\"人在交配\");&#125;&#125; Testoob.java 具体的测试代码 1234567891011121314151617181920212223242526272829303132package com.yangyanxing.www;//这里不用import 引用，在同一个包里public class Testoob &#123;public static void main(String[] args) &#123;// TODO Auto-generated method stubAnimal a = new Animal();Animal a1 = new Dog();//多态，使用父类创建子类的引用Animal a2 = new Cat();Dog dog = new Dog();Cat cat = new Cat();a.run();a.eat();a1.run();a1.eat();//a1.creame();//多态父类创建的子类不能使用子类自已的方法a2.run();a2.eat();dog.creame();//不是通过多态创建的子类可以使用自已的方法cat.creame();cat.eat(\"鱼\");dog.run(5);//a2.eat(\"fish\");//这里会出错，因为父类里没有定义带参数的eat()方法Icopulation idog = new Dog();idog.copulation();Icopulation ihuman = new Human();ihuman.copulation();&#125;&#125; 以下是程序运行的输出结果 我是所有动物的跑 我是所有动物在吃 我是一条狗在跑 我是一条狗是吃 我是一只猫在跑 我是一条猫是吃 这是一条狗在叫 这是一条猫在叫 我是只猫，我正在吃鱼 我是只狗，已经跑了5公里了 狗在交配 人在交配","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.yangyanxing.com/tags/java/"}]},{"title":"中国男人形象气质差配不上中国女人?","slug":"1106","date":"2014-08-20T15:34:21.000Z","updated":"2017-12-16T10:10:42.210Z","comments":true,"path":"article/1106.html","link":"","permalink":"https://www.yangyanxing.com/article/1106.html","excerpt":"前段时间网络上有人撰文说中国男人形象气质差配不上中国女人http://news.qq.com/a/20140723/062566.htm&#160; 其实很久之前我也有过同样的感受，中国女人，无论气质谈吐似乎都要比身边的男士要更加优雅，偶尔遇到一些炸毛女，但观其身边的男人也无非是一些洗剪吹之流，女人如果出口成脏的话她身边的男人也更是流毒之辈。 男人如果能在形象气质上达到某个层次以后，也会刻意的寻找一些使自已进步的，同样的，如果你只是一个洗剪吹，那么在你的生活里接触到的也无非是一个炸毛女。","text":"前段时间网络上有人撰文说中国男人形象气质差配不上中国女人http://news.qq.com/a/20140723/062566.htm&#160; 其实很久之前我也有过同样的感受，中国女人，无论气质谈吐似乎都要比身边的男士要更加优雅，偶尔遇到一些炸毛女，但观其身边的男人也无非是一些洗剪吹之流，女人如果出口成脏的话她身边的男人也更是流毒之辈。 男人如果能在形象气质上达到某个层次以后，也会刻意的寻找一些使自已进步的，同样的，如果你只是一个洗剪吹，那么在你的生活里接触到的也无非是一个炸毛女。 就我的工作环境而言，几乎不会接触到穿西装革履的男人，普遍还是以休闲运动为主，可能是程序员的生活比较随便，总体气质上不能说很高，但也不是很低，可是我身边能够看得到的女性形象上都要比男性要好一些。 如果真的要以外形来评判男性的话，大多数的男人在30以后身体开始发福，肚子开始变大，脸开始走形，会发现惭惭合不上的嘴，牙齿一天比一天黄，肤色开始变的暗淡，外形上越来越雷政富，但随着个人经历与财富已经有了一些积累，如果可以达到其欲望，那么他会在50，60甚至80还是要选择年轻貌美的，有时一个不成还要两个三个，这样就造成了一个恶果，男人形象上气质上要远远的差于身边的女性。 但是并不是所有的男性都有这样的本事，大多数的人还只是个普普通通的人，过着规律的每一天，但是生活是两个人的事，如果找了一个像李安夫人的女性为伴，肯在你什么都不成事的时候不抛弃你而是一直在鼓励你做事，相信你最终会有成功的那一天，可是事实并非如此，在一个急功近利的社会，在很多女性眼中，在你有年轻身体与容貌的时候，要求你要有这个有那个，她不关心你活的累不累，只关心她自已生活的好不好，你能给她带来什么，本来应是年少轻狂的年纪做事畏手畏脚，眼神中透露出胆小畏世的神情，想要让他有什么好气质？于是放弃了，开始身材走形的成熟大叔那种淡淡的忧郁，可是在外人看你，你们依然是那么的不般配，甚至更多的人认为是老黄牛吃嫩草。 但是有一个好的趋向，随着现代大都市的成熟女性越来越独立，她们也不再说依靠男人怎样怎样，自已有自已的独立经济来源，自已赚钱来装扮自已，买自已喜欢的东西，不再是嫁汉嫁汉，穿衣吃饭，有着自已的生活圈子，但是对于外貌气质的追求却从来不见减少，且会随着年龄增长要求会越来越高，这也使得她们看上去年纪越大气质越好的原因，年轻的时候谈貌美如花，年经大了谈高贵优雅，而男人似乎一直在想着赚钱养家或者基于动物本能的下身思考，无论你是什么政坛新星商界大佬，影视常春藤，都会想一个问题，找一个什么样的人渡过一生。 我们经常说的一个词叫“女神”，女人可能活的像神一样，而大多数的男人只能活的像条狗一样。 有时觉得女人的高冷与并非其所愿，身边的装逼男多了，你稍微对他好一点，多说一两句话，自我感觉良好的贱男就开始意淫“她是不是喜欢我？”，有时真想过去骂丫一句，就你那德形，想泡姑娘，还是先撒泡尿照照你自已吧！","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"python中的Queue与多进程（multiprocessing）","slug":"1103","date":"2014-07-29T16:59:27.000Z","updated":"2017-12-16T15:49:56.197Z","comments":true,"path":"article/1103.html","link":"","permalink":"https://www.yangyanxing.com/article/1103.html","excerpt":"最近接触一个项目，要在多个虚拟机中运行任务，参考别人之前项目的代码，采用了多进程来处理，于是上网查了查python中的多进程 一、先说说Queue（队列对象） Queue是python中的标准库，可以直接import 引用，之前学习的时候有听过著名的“先吃先拉”与“后吃先吐”，其实就是这里说的队列，队列的构造的时候可以定义它的容量，别吃撑了，吃多了，就会报错,构造的时候不写或者写个小于1的数则表示无限多 import Queue q = Queue.Queue(10) 向队列中放值(put) q.put(‘yang’) q.put(4) q.put([‘yan’,’xing’]) 在队列中取值get() 默认的队列是先进先出的","text":"最近接触一个项目，要在多个虚拟机中运行任务，参考别人之前项目的代码，采用了多进程来处理，于是上网查了查python中的多进程 一、先说说Queue（队列对象） Queue是python中的标准库，可以直接import 引用，之前学习的时候有听过著名的“先吃先拉”与“后吃先吐”，其实就是这里说的队列，队列的构造的时候可以定义它的容量，别吃撑了，吃多了，就会报错,构造的时候不写或者写个小于1的数则表示无限多 import Queue q = Queue.Queue(10) 向队列中放值(put) q.put(‘yang’) q.put(4) q.put([‘yan’,’xing’]) 在队列中取值get() 默认的队列是先进先出的1234567&gt;&gt;&gt; q.get()&apos;yang&apos;&gt;&gt;&gt; q.get()4&gt;&gt;&gt; q.get()[&apos;yan&apos;, &apos;xing&apos;]&gt;&gt;&gt; 当一个队列为空的时候如果再用get取则会堵塞，所以取队列的时候一般是用到 get_nowait()方法，这种方法在向一个空队列取值的时候会抛一个Empty异常 所以更常用的方法是先判断一个队列是否为空，如果不为空则取值 队列中常用的方法 Queue.qsize() 返回队列的大小Queue.empty() 如果队列为空，返回True,反之FalseQueue.full() 如果队列满了，返回True,反之FalseQueue.get([block[, timeout]]) 获取队列，timeout等待时间Queue.get_nowait() 相当Queue.get(False)非阻塞 Queue.put(item) 写入队列，timeout等待时间Queue.put_nowait(item) 相当Queue.put(item, False) 二、multiprocessing中使用子进程概念 from multiprocessing import Process 可以通过Process来构造一个子进程 p = Process(target=fun,args=(args)) 再通过p.start()来启动子进程 再通过p.join()方法来使得子进程运行结束后再执行父进程12345678910111213import os# 子进程要执行的代码def run_proc(name): print 'Run child process %s (%s)...' % (name, os.getpid())if __name__=='__main__': print 'Parent process %s.' % os.getpid() p = Process(target=run_proc, args=('test',)) print 'Process will start.' p.start() p.join() print 'Process end.'&lt;/pre&gt; 三、在multiprocessing中使用pool 如果需要多个子进程时可以考虑使用进程池(pool)来管理12345678910111213141516171819from multiprocessing import Poolimport os, timedef long_time_task(name): print 'Run task %s (%s)...' % (name, os.getpid()) start = time.time() time.sleep(3) end = time.time() print 'Task %s runs %0.2f seconds.' % (name, (end - start))if __name__=='__main__': print 'Parent process %s.' % os.getpid() p = Pool() for i in range(5): p.apply_async(long_time_task, args=(i,)) print 'Waiting for all subprocesses done...' p.close() p.join() print 'All subprocesses done.'&lt;/pre&gt; pool创建子进程的方法与Process不同，是通过 p.apply_async(func,args=(args))实现，一个池子里能同时运行的任务是取决你电脑的cpu数量，如我的电脑现在是有4个cpu，那会子进程task0,task1,task2,task3可以同时启动，task4则在之前的一个某个进程结束后才开始 上面的程序运行后的结果其实是按照上图中1，2，3分开进行的，先打印1，3秒后打印2，再3秒后打印3 代码中的p.close()是关掉进程池子，是不再向里面添加进程了，对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 当时也可以是实例pool的时候给它定义一个进程的多少 如果上面的代码中p=Pool(5)那么所有的子进程就可以同时进行 三、多个子进程间的通信 多个子进程间的通信就要采用第一步中说到的Queue，比如有以下的需求，一个子进程向队列中写数据，另外一个进程从队列中取数据，1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): for value in ['A', 'B', 'C']: print 'Put %s to queue...' % value q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): while True: if not q.empty(): value = q.get(True) print 'Get %s from queue.' % value time.sleep(random.random()) else: breakif __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 等待pw结束: pw.join() # 启动子进程pr，读取: pr.start() pr.join() # pr进程里是死循环，无法等待其结束，只能强行终止: print print '所有数据都写入并且读完'&lt;/pre&gt; 四、关于上面代码的几个有趣的问题12345678910# 父进程创建Queue，并传给各个子进程：q = Queue()p = Pool()pw = p.apply_async(write,args=(q,))pr = p.apply_async(read,args=(q,))p.close()p.join()printprint '所有数据都写入并且读完'&lt;/pre&gt; 如果main函数写成上面的样本，本来我想要的是将会得到一个队列，将其作为参数传入进程池子里的每个子进程，但是却得到 RuntimeError: Queue objects should only be shared between processes through inheritance 的错误，查了下，大意是队列对象不能在父进程与子进程间通信，这个如果想要使用进程池中使用队列则要使用multiprocess的Manager类123456789101112manager = multiprocessing.Manager()# 父进程创建Queue，并传给各个子进程：q = manager.Queue()p = Pool()pw = p.apply_async(write,args=(q,))time.sleep(0.5)pr = p.apply_async(read,args=(q,))p.close()p.join()printprint '所有数据都写入并且读完'&lt;/pre&gt; 这样这个队列对象就可以在父进程与子进程间通信，不用池则不需要Manager，以后再扩展multiprocess中的Manager类吧 关于锁的应用，在不同程序间如果有同时对同一个队列操作的时候，为了避免错误，可以在某个函数操作队列的时候给它加把锁，这样在同一个时间内则只能有一个子进程对队列进行操作，锁也要在manager对象中的锁1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Process,Queue,Poolimport multiprocessingimport os, time, random# 写数据进程执行的代码:def write(q,lock): lock.acquire() #加上锁 for value in ['A', 'B', 'C']: print 'Put %s to queue...' % value q.put(value) lock.release() #释放锁# 读数据进程执行的代码:def read(q): while True: if not q.empty(): value = q.get(False) print 'Get %s from queue.' % value time.sleep(random.random()) else: breakif __name__=='__main__': manager = multiprocessing.Manager() # 父进程创建Queue，并传给各个子进程： q = manager.Queue() lock = manager.Lock() #初始化一把锁 p = Pool() pw = p.apply_async(write,args=(q,lock)) pr = p.apply_async(read,args=(q,)) p.close() p.join() print print '所有数据都写入并且读完' 参考文章： python Queue模块 多进程","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python操作selenium的基本操作","slug":"1085","date":"2014-06-17T14:59:00.000Z","updated":"2017-12-16T10:10:42.107Z","comments":true,"path":"article/1085.html","link":"","permalink":"https://www.yangyanxing.com/article/1085.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#coding:utf-8from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChains #引入ActionChains鼠标操作类from selenium.webdriver.common.keys import Keys #引入keys类操作import timedef s(int): time.sleep(int)browser = webdriver.Chrome()browser.get('http://www.baidu.com')print '现在将浏览器最大化'browser.maximize_window()text = browser.find_element_by_name('tj_duty').textprint text #打印备案信息browser.find_element_by_id('kw1').send_keys(u'杨彦星')print browser.find_element_by_id('kw1').get_attribute('type')print browser.find_element_by_id('kw1').size #打印输入框的大小browser.find_element_by_id('su1').click()time.sleep(3)print '现在我将设置浏览器为宽480，高800显示'browser.set_window_size(480,800)browser.get('http://m.mail.10086.cn')time.sleep(3)print '现在我将回到刚才的页面'browser.maximize_window()browser.back()time.sleep(3)print '现在我将回到之前的页面'browser.forward()time.sleep(5)print '现在我将打开杨彦星的网站进行json搜索'browser.get('http://static.yangyanxing.com')browser.find_element_by_xpath(\".//*[@id='ls']\").send_keys(u'json')browser.find_element_by_xpath(\".//*[@id='header']/div[1]/div/form/input[2]\").click()time.sleep(5)browser.quit()browser = webdriver.Chrome()print '以下将以登录人人网来进行上面的综合应用'browser.get('http://www.renren.com/SysHome.do')browser.find_element_by_id('email').clear()#这个是以id选择元素browser.find_element_by_id('email').send_keys('email')browser.find_element_by_id('email').send_keys(Keys.BACK_SPACE)time.sleep(2)browser.find_element_by_id('email').send_keys('m')s(2)browser.find_element_by_id('email').send_keys(Keys.CONTROL,'a')s(2)browser.find_element_by_id('email').send_keys(Keys.CONTROL,'x')#剪切掉里面的内容s(2)browser.find_element_by_id('email').send_keys(Keys.CONTROL,'v') #重新输入进去s(2)browser.find_element_by_name('password').clear()#这个是以name选择元素browser.find_element_by_name('password').send_keys('password')#browser.find_element_by_xpath(\".//*[@id='login']\").click()#这个是以xpath选择元素browser.find_element_by_xpath(\".//*[@id='login']\").send_keys(Keys.ENTER) #这里通过点击Enter键来登录browser.maximize_window()article = browser.find_element_by_link_text(u'周碧华：社科院出现内鬼意味着什么？')ActionChains(browser).move_to_element(article).perform()#将鼠标移动到这里，但是这里不好用ActionChains(browser).context_click(article).perform()time.sleep(5)browser.quit() 开始接触selenium，其在web自动化上应用非常广，上面是一些最基本的操作，启动浏览器，打开网页，前进与后退，定位元素，键盘输入与鼠标点击操作，其中xpath可以在firefox下应用firepath插件来获取，但是局限性比较大，也会有一些兼容性的问题，像上面的代码在chrome下可以运行，但是在firefox下一些元素就找不到，很郁闷。。。继续再探索吧","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.yangyanxing.com/tags/自动化测试/"}]},{"title":"python的requests初步使用","slug":"1079","date":"2014-06-15T15:20:53.000Z","updated":"2017-12-16T10:10:42.076Z","comments":true,"path":"article/1079.html","link":"","permalink":"https://www.yangyanxing.com/article/1079.html","excerpt":"早就听说requests的库的强大，只是还没有接触，今天接触了一下，发现以前使用urllib，urllib2等方法真是太搓了…… 这里写些简单的使用初步作为一个记录","text":"早就听说requests的库的强大，只是还没有接触，今天接触了一下，发现以前使用urllib，urllib2等方法真是太搓了…… 这里写些简单的使用初步作为一个记录 安装http://cn.python-requests.org/en/latest/user/install.html#install 发送无参数的get请求12345678910111213141516171819202122232425r = requests.get('http://httpbin.org/get')print r.text'''&#123; \"args\": &#123;&#125;, \"headers\": &#123; \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Connection\": \"close\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.3.0 CPython/2.6.6 Windows/7\", \"X-Request-Id\": \"8a28bbea-55cd-460b-bda3-f3427d66b700\" &#125;, \"origin\": \"124.192.129.84\", \"url\": \"http://httpbin.org/get\"'''# 发送带参数的get请求,将key与value放入一个字典中，通过params参数来传递,其作用相当于urllib.urlencode``` python&gt;&gt;&gt; import requests&gt;&gt;&gt; pqyload = &#123;'q':'杨彦星'&#125;&gt;&gt;&gt; r = requests.get('http://www.so.com/s',params = pqyload)&gt;&gt;&gt; r.urlu'http://www.so.com/s?q=%E6%9D%A8%E5%BD%A6%E6%98%9F' 发送post请求，通过data参数来传递,123456789101112131415161718192021222324252627&gt;&gt;&gt; payload = &#123;'a':'杨','b':'hello'&#125;&gt;&gt;&gt; r = requests.post(\"http://httpbin.org/post\", data=payload)&gt;&gt;&gt; print r.text&#123; \"args\": &#123;&#125;, \"data\": \"\", \"files\": &#123;&#125;, \"form\": &#123; \"a\": \"u6768\", \"b\": \"hello\" &#125;, \"headers\": &#123; \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Connection\": \"close\", \"Content-Length\": \"19\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.3.0 CPython/2.6.6 Windows/7\", \"X-Request-Id\": \"c81cb937-04b8-4a2d-ba32-04b5c0b3ba98\" &#125;, \"json\": null, \"origin\": \"124.192.129.84\", \"url\": \"http://httpbin.org/post\"&#125;&gt;&gt;&gt; 可以看到，post参数已经传到了form里,data不光可以接受字典类型的数据，还可以接受json等格式1234&gt;&gt;&gt; payload = &#123;'a':'杨','b':'hello'&#125;&gt;&gt;&gt; import json&gt;&gt;&gt; r = requests.post('http://httpbin.org/post', data=json.dumps(payload)) 发送文件的post类型这个相当于向网站上传一张图片，文档等操作，这时要使用files参数1234&gt;&gt;&gt; url = 'http://httpbin.org/post'&gt;&gt;&gt; files = &#123;'file': open('touxiang.png', 'rb')&#125;&gt;&gt;&gt; r = requests.post(url, files=files) 定制headers，使用headers参数来传递1234567&gt;&gt;&gt; import json&gt;&gt;&gt; url = 'https://api.github.com/some/endpoint'&gt;&gt;&gt; payload = &#123;'some': 'data'&#125;&gt;&gt;&gt; headers = &#123;'content-type': 'application/json'&#125;&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload), headers=headers) 响应内容响应状态码r = requests.get(‘http://httpbin.org/get‘)print r.status_code 响应头123&gt;&gt;&gt; print r.headers&#123;'content-length': '519', 'server': 'gunicorn/18.0', 'connection': 'keep-alive', 'date': 'Sun, 15 Jun 2014 14:19:52 GMT', 'access-control-allow-origin': '*', 'content-type': 'application/json'&#125; 也可以取到这个个别的响应头用来做一些判断，这里的参数是不区分大小写的 r.headers[‘Content-Type’] r.headers.get(‘Content-Type’) 响应内容，前面已经在应用了r.text r.content 获取响应中的cookies1234&gt;&gt;&gt; r = requests.get('http://www.baidu.com')&gt;&gt;&gt; r.cookies['BAIDUID']'D5810267346AEFB0F25CB0D6D0E043E6:FG=1' 也可以自已定义请求的COOKIES123456789101112&gt;&gt;&gt; url = 'http://httpbin.org/cookies'&gt;&gt;&gt; cookies = &#123;'cookies_are':'working'&#125;&gt;&gt;&gt; r = requests.get(url,cookies = cookies)&gt;&gt;&gt;&gt;&gt;&gt; print r.text&#123; \"cookies\": &#123; \"cookies_are\": \"working\" &#125;&#125;&gt;&gt;&gt; cookies还有很多，因为目前我也还不是很多，以后再扩充吧 使用timeout参数设置超时时间12&gt;&gt;&gt; requests.get('http://github.com', timeout=1)&lt;Response [200]&gt; 如果将时间设置成非常小的数，如requests.get(‘http://github.com’, timeout=0.001)，那么如果在timeout的时间内没有连接，那么将会抛出一个Timeout的异常 访问中使用session先初始化一个session对象，s = requests.Session() 然后使用这个session对象来进行访问，r = s.post(url,data = user) 参考文章 http://blog.csdn.net/iloveyin/article/details/21444613 基本上都是从这扒的代码 以下通过访问人人网来获取首页中的最近来访问，然后再访问查看更多的来访来读取更多的最近来访 20151029更新，和美女刘巍进行讨论，由于很久没有登录人人网，它的登录页面与获得最近来访的页面都有所变动，登录时的url是http://www.renren.com/ajaxLogin/login 获取最近来访是http://www.renren.com/myfoot/whoSeenMe 更多的来访就是以带session的访问http://www.renren.com/myfoot/whoSeenMe123456789101112131415161718192021222324252627282930#coding:utf-8import requestsimport reurl = r'http://www.renren.com/ajaxLogin/login'user = &#123;'email':'email','password':'pass'&#125;s = requests.Session()r = s.post(url,data = user)html = r.textvisit = []first = re.compile(r'&lt;/span&gt;&lt;span class=\"time-tip first-tip\"&gt;&lt;span class=\"tip-content\"&gt;(.*?)&lt;/span&gt;')second = re.compile(r'&lt;/span&gt;&lt;span class=\"time-tip\"&gt;&lt;span class=\"tip-content\"&gt;(.*?)&lt;/span&gt;')third = re.compile(r'&lt;/span&gt;&lt;span class=\"time-tip last-second-tip\"&gt;&lt;span class=\"tip-content\"&gt;(.*?)&lt;/span&gt;')last = re.compile(r'&lt;/span&gt;&lt;span class=\"time-tip last-tip\"&gt;&lt;span class=\"tip-content\"&gt;(.*?)&lt;/span&gt;')visit.extend(first.findall(html))visit.extend(second.findall(html))visit.extend(third.findall(html))visit.extend(last.findall(html))for i in visit: print iprint '以下是更多的最近来访'vm = s.get('http://www.renren.com/myfoot/whoSeenMe')fm = re.compile(r'\"name\":\"(.*?)\"')visitmore = fm.findall(vm.text)for i in visitmore: print i","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"requests","slug":"requests","permalink":"https://www.yangyanxing.com/tags/requests/"}]},{"title":"与wordpress垃圾评论斗争到底","slug":"1069","date":"2014-06-09T15:05:11.000Z","updated":"2017-12-16T10:10:42.349Z","comments":true,"path":"article/1069.html","link":"","permalink":"https://www.yangyanxing.com/article/1069.html","excerpt":"由于本人个人博客小站的空间与mysql空间有限，共享服务器资源也有限，所以这些垃圾评论一定要拦截在写入数据库之外。 更可气的是看到空间的统计，很几千的IP访问，但基本上都是这个垃圾评论的IP，所以实在不能忍 网上找了一些方法，主要有三个，如果将这三个一块使用基本上就可以拦截绝大多数垃圾评论","text":"由于本人个人博客小站的空间与mysql空间有限，共享服务器资源也有限，所以这些垃圾评论一定要拦截在写入数据库之外。 更可气的是看到空间的统计，很几千的IP访问，但基本上都是这个垃圾评论的IP，所以实在不能忍 网上找了一些方法，主要有三个，如果将这三个一块使用基本上就可以拦截绝大多数垃圾评论 使用Akismet插件后台申请一个免费的key，可以拦截99%的垃圾评论，但是这个插件还是会将垃圾评论写入数据库的，一会几千条甚至上万条垃圾评论，虽说可以设置15天后自动删除，但是看着也别扭，于是加上第二种方法。 更改wp-comments-post.php名称这种方法是先将wp-comments-post.php改为随便的名字，然后在你主题文件的comments.php中将wp-comments-post.php改为你刚才改过的名字但是现在的spam机器人太强了，这种方法基本上没有任何作用，垃圾评论还是会进入到后台的垃圾评论里，于是采取第三种方法，过滤掉纯英语的垃圾评论，这种评论占了垃圾评论的很大一部分 过滤纯英文垃圾评论在你主题的functions.php中添加以下代码1234567 function refused_spam_comments( $comment_data ) &#123; $pattern = '/[一-龥]/u'; if(!preg_match($pattern,$comment_data['comment_content'])) &#123; wp_die('评论必须含中文！');&#125; return( $comment_data );&#125; 其中[一-龥]这个正则表达式代表所有中文，这时纯英文的垃圾评论算是过滤掉了，但是还有另外一种垃圾评论，日文的…… 日文的采用同样的方法，请几个常出现的日文假名写入到正则表达式中ッ、の、ン、優、業、グ、貿1234567 function fuckjp_comment_post( $incoming_comment ) &#123; $http = '/[&lt;|=|.|友|夜|KTV|ッ|の|ン|優|業|グ|貿|]/u'; if(preg_match($http, $incoming_comment['comment_content'])) &#123; wp_die( \"小日本滚蛋!\" ); &#125; return( $incoming_comment );&#125; 将这三点综合起来使用，终于清净多了…… 参考文章http://www.v7v3.com/wpjiaocheng/201308215.html http://www.pzboy.com/soft/php/english-comments/","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[]},{"title":"切换google的公共库缓解网站访问慢的问题","slug":"1052","date":"2014-06-07T14:58:32.000Z","updated":"2017-12-16T10:10:42.115Z","comments":true,"path":"article/1052.html","link":"","permalink":"https://www.yangyanxing.com/article/1052.html","excerpt":"近期谷(zheng)歌(fu)抽疯，很多google的公共库文件访问缓慢或者根本就是无法访问，很多网站前端以前都是直接引用google的地址，这会或多或少的影响网站打开速度。本人博客也“不幸”引入了一些google的公共库，换了几个服务器，无论是BAE还是SAE或者国外的服务器再或者是国内的服务器，都很慢，今天查了查，将其换为360网站卫士提供的公共库资源（http://libs.useso.com/），效果果然提高不少。 这个是由360网站卫士CDN驱动的常用前端公共库以及和谐使用Google公共库&amp;字体库的调用方法。 打开Chrome开发者工具(F12),打开网站，查看到一些引用都是error，其中一个是","text":"近期谷(zheng)歌(fu)抽疯，很多google的公共库文件访问缓慢或者根本就是无法访问，很多网站前端以前都是直接引用google的地址，这会或多或少的影响网站打开速度。本人博客也“不幸”引入了一些google的公共库，换了几个服务器，无论是BAE还是SAE或者国外的服务器再或者是国内的服务器，都很慢，今天查了查，将其换为360网站卫士提供的公共库资源（http://libs.useso.com/），效果果然提高不少。 这个是由360网站卫士CDN驱动的常用前端公共库以及和谐使用Google公共库&amp;字体库的调用方法。 打开Chrome开发者工具(F12),打开网站，查看到一些引用都是error，其中一个是 http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js&#160; 这个我检查了下，发现是我主题模板里的footer.php里的一句引用，于是替换成了以下。 http://ajax.useso.com/ajax/libs/jquery/1.4.3/jquery.min.js&#160; 之后还有一个fonts.googleapis.com/css?family=Open+Sans 没有找到，找这个文件可以费了点劲，我在主题模板里没有找到这句话，查找见面源代码根据位置也找不到，在用notepad++搜了几个wordpree的文件夹以后还是没有发现，无奈文件太多，没想到藏这么深，于自已写个脚本来搜索wordpress所有文件。。。1234567891011121314151617181920212223242526272829303132333435#coding:utf-8import os,sysdef listFile(path, isDeep=True): _list = [] if isDeep: try: for root, dirs, files in os.walk(path): for fl in files: _list.append('%s%s' % (root, fl)) except: pass else: for fn in glob.glob( path + os.sep + '*' ): if not os.path.isdir(fn): _list.append('%s' % path + os.sep + fn[fn.rfind('')+1:]) return _listpwd = os.getcwd()print pwdcut = listFile(pwd)flag = 1for i in cut: filename = os.path.split(i)[1] ext = os.path.splitext(i)[1] if ext == '.php' or ext == '.js': f = open(i) for j in f.readlines(): if 'fonts.googleapis.com' in j: print i print j flag = 0if flag: print 'TT' 将它放到wordpress目录下运行，不一会就找到了原来是wp-includes目录下的script-loader.php，而且只有这一个文件，大概在602行左右 $open_sans_font_url = “//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,300,400,600&amp;subset=$subsets”; 将其改为$open_sans_font_url = “//fonts.useso.com/css?family=Open+Sans:300italic,400italic,600italic,300,400,600&amp;subset=$subsets”; ``` 保存之后上传，这两个文件，再打开网站试下，果真比原来快了不少！希望对于有类似问题的朋友有帮助。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[]},{"title":"python中的中文编码问题","slug":"1050","date":"2014-06-01T16:25:02.000Z","updated":"2017-12-16T10:10:41.984Z","comments":true,"path":"article/1050.html","link":"","permalink":"https://www.yangyanxing.com/article/1050.html","excerpt":"在编程领域中，中文编码问题一向是个很头疼的问题，今天写点总结一下解决的方法 unicode与utf-8和gbk之间的转换，涉及到的函数有decode与encode 首先明确一下，python中的字符串都是以某种编码来存储的，就中文来说，以gbk与utf-8的，你虽然可以这样定义一个变量 s = u’杨彦星’,但是你可以用type(s) 来看一下它的类型，此时这个s 不是字符串，而是unicode类型，当你定义s = ‘杨彦星’的时候，这时type(s)才是str类型，但是当你直接定义s = ‘杨彦星’时会在不同的场景下出现不同的问题，windows下的cmd还好，换到一个utf-8的解析器里就是乱码，所以最好的方式是在定义有中文（或者说非英文的）字符串时以unicode来定义，然后再去解码输出。 将字符串decode成unicode s = ‘杨彦星’ s_uni = s.decode(‘gbk’) #将s转换成unicode，decode的时候就加上这个字符原来的编码类型 s_utf8 = s_uni.encode(‘utf-8’) s_gbk = s_uni.encode(‘gbk’)","text":"在编程领域中，中文编码问题一向是个很头疼的问题，今天写点总结一下解决的方法 unicode与utf-8和gbk之间的转换，涉及到的函数有decode与encode 首先明确一下，python中的字符串都是以某种编码来存储的，就中文来说，以gbk与utf-8的，你虽然可以这样定义一个变量 s = u’杨彦星’,但是你可以用type(s) 来看一下它的类型，此时这个s 不是字符串，而是unicode类型，当你定义s = ‘杨彦星’的时候，这时type(s)才是str类型，但是当你直接定义s = ‘杨彦星’时会在不同的场景下出现不同的问题，windows下的cmd还好，换到一个utf-8的解析器里就是乱码，所以最好的方式是在定义有中文（或者说非英文的）字符串时以unicode来定义，然后再去解码输出。 将字符串decode成unicode s = ‘杨彦星’ s_uni = s.decode(‘gbk’) #将s转换成unicode，decode的时候就加上这个字符原来的编码类型 s_utf8 = s_uni.encode(‘utf-8’) s_gbk = s_uni.encode(‘gbk’) decode() 函数需要字符本来的编码作为参数，encode()函数需要字符想要转换成的编码 当想要保存成特定编码的文件时，就需要使用codecs库 import codecs s =u ‘杨彦星’ f = codecs.open(‘test.txt’,’w’,’utf-8’) f.write(s) f.close() 这时可以打开test.txt查看文件的编码，这时就会是utf-8的，写入的中文要是unicode","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"Ubuntu从安装到设置的一点记录","slug":"1032","date":"2014-03-06T15:43:25.000Z","updated":"2017-12-16T10:10:42.185Z","comments":true,"path":"article/1032.html","link":"","permalink":"https://www.yangyanxing.com/article/1032.html","excerpt":"1.硬盘安装：http://www.linuxidc.com/Linux/2013-10/91565.htm 2.Nvidia显卡的安装，http://blog.csdn.net/wzcqr0501/article/details/8498659 曾尝试安装，但第一次失败且改不回来，于是不准备安装了，自带的Nvidia显卡已经很好了 3.修改hosts改变google的解析 sudo gedit /etc/hosts 4.默认启动ubuntu后自动挂载windows分区 http://www.linuxidc.com/Linux/2013-02/79679.htm 创建挂载目录 sudo mkdir /media/windows 等等 查看磁盘分区的UUID sudo blkid 记录UUID 编辑fstab sudo gedit /etc/fstab 写入如下内容 UUID=D06ABBA96ABB8AAC /media/windows ntfs default 0 0 5.解决中文乱码问题 sudo gedit /etc/profile","text":"1.硬盘安装：http://www.linuxidc.com/Linux/2013-10/91565.htm 2.Nvidia显卡的安装，http://blog.csdn.net/wzcqr0501/article/details/8498659 曾尝试安装，但第一次失败且改不回来，于是不准备安装了，自带的Nvidia显卡已经很好了 3.修改hosts改变google的解析 sudo gedit /etc/hosts 4.默认启动ubuntu后自动挂载windows分区 http://www.linuxidc.com/Linux/2013-02/79679.htm 创建挂载目录 sudo mkdir /media/windows 等等 查看磁盘分区的UUID sudo blkid 记录UUID 编辑fstab sudo gedit /etc/fstab 写入如下内容 UUID=D06ABBA96ABB8AAC /media/windows ntfs default 0 0 5.解决中文乱码问题 sudo gedit /etc/profile在最后添加： export PATH=$PATH GST_ID3_TAG_ENCODING=GBK:UTF-8:GB18030export PATH=$PATH GST_ID3V2_TAG_ENCODING=GBK:UTF-8:GB18030 6.导入windows字体 http://www.cnblogs.com/zhj5chengfeng/p/3251009.html sudo mkdir /usr/share/fonts/winfontssudo cp ~/WinFonts/ /usr/share/fonts/winfontscd /usr/share/fonts/winfontssudo chmod 744 sudo mkfontscalesudo mkfontdirsudo fc-cache -f -v 重启电脑 7.安装fcitx小企鹅输入法 http://www.cnblogs.com/yuemengke/archive/2013/04/09/3010207.html sudo apt-get install fcitx fcitx-config-gtk fcitx-sunpinyin fcitx-table-wbpy 8.安装qq http://www.ubuntusoft.com/thread-225-1-1.html","categories":[{"name":"Linux相关","slug":"Linux相关","permalink":"https://www.yangyanxing.com/categories/Linux相关/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.yangyanxing.com/tags/linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.yangyanxing.com/tags/Ubuntu/"}]},{"title":"javascript DOM初学(一)","slug":"994","date":"2014-02-22T18:18:25.000Z","updated":"2017-12-16T10:10:42.446Z","comments":true,"path":"article/994.html","link":"","permalink":"https://www.yangyanxing.com/article/994.html","excerpt":"开始学习javacript，这里做个总结","text":"开始学习javacript，这里做个总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#div1 &#123;width:200px;height:200px;background:#CCC;position:relative&#125;#div2 &#123;width:100px;height:100px;background:red;position:absolute;left:50px;top:50px;&#125;&lt;/style&gt;&lt;script&gt;window.onload=function()&#123; var oul = document.getElementById('ul1') //alert (oUL.childNodes.length) for(var i=0;i&lt;oul.childNodes.length;i++) //childNodes属性随着浏览器的不同而不同，高级点的回车换行等也算一个 &#123; if (oul.childNodes[i].nodeType == 1) //这里就解决了只选用元素属性节点，文本属性的节点就不算了，也就排除了回车换行等问题 &#123; oul.childNodes[i].style.background = 'red' &#125; &#125; for(var i=0;i&lt;oul.children.length;i++) &#123; oul.children[i].style.background = 'blue' //children属性直接只选取元素属性，不算文本元素 &#125; var oa = document.getElementsByTagName('a') for(var i = 0;i&lt;oa.length;i++) &#123; oa[i].onclick=function() //为某个元素添加某些方法 &#123; //获取父节点 this.parentNode.style.display='none' //使得父节点设置为隐藏 &#125; &#125; var od=document.getElementById('div2') od.onclick=function() &#123; alert(od.offsetParent)//获取该元素用于定位的元素 &#125; var oul3=document.getElementById(\"ul3\") //oul3.firstElementChild.style.background = 'red' if (oul3.firstElementChild)//处理兼容问题 &#123; oul3.firstElementChild.style.background = 'blue' &#125; else &#123; oul3.firstChild.style.background = 'red' &#125; var osub = document.getElementById('sub') var otext = document.getElementById('text') var ouser = document.getElementById(\"userType\") var yyx = document.getElementsByTagName('p')[0]//返回是列表，所以得取其中之一 osub.onclick = function() &#123; //1.otext.value = 'hahaha' //2.otext['value'] = 'hahaha' var text = ouser.getAttribute('value') var text2 = yyx.firstChild.nodeValue //获得该节点的值，也就是文本元素 otext.setAttribute('value',text2) &#125; function getClassName(parent,classname) &#123; classnamelist = [] var d = document.getElementById(parent) var c = d.getElementsByTagName('*') for (var i=0;i&lt;c.length;i++) &#123; if (c[i].className == classname) &#123; classnamelist.push(c[i]) &#125; &#125; return classnamelist &#125; var oul4 = document.getElementById(\"ul4\") var oli4 = oul4.getElementsByTagName('li') //var dli4 = document.getElementsByTagName('li') 会选取整个文档内的元素，并不是我们想要的，我们想要的是从某个父级元素下面选元素 needRed = getClassName('ul4','red') for(var i = 0;i&lt;needRed.length;i++) &#123; needRed[i].style.background = 'red' &#125; &#125;;&lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;ul id=\"ul1\"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;ul id=\"ul2\"&gt; &lt;li&gt;adfadf &lt;a href=\"#\"&gt;隐藏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;aadfaddf &lt;a href=\"#\"&gt;隐藏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;233df &lt;a href=\"#\"&gt;隐藏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;fafadf &lt;a href=\"#\"&gt;隐藏&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;br&gt; &lt;div id=\"div1\"&gt; &lt;div id=\"div2\"&gt;sdasdfafasd&lt;/div&gt;&lt;/div&gt; &lt;ul id=\"ul3\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;我是杨彦星&lt;/p&gt;&lt;input type=\"text\" id=\"userType\" value=\"adfadfadf\"/&gt;&lt;input type=\"text\" id=\"text\" /&gt;&lt;input type=\"submit\" id=\"sub\" value=\"点击\" /&gt; &lt;br /&gt; &lt;ul id=\"ul4\"&gt; &lt;li class=\"red\"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class=\"red\"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class=\"red\"&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"web","slug":"web","permalink":"https://www.yangyanxing.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yangyanxing.com/tags/javascript/"}]},{"title":"python中的logging模块应用","slug":"963","date":"2013-11-16T15:56:49.000Z","updated":"2017-12-16T10:10:42.068Z","comments":true,"path":"article/963.html","link":"","permalink":"https://www.yangyanxing.com/article/963.html","excerpt":"python中有系统自带的logging模块，使用起来非常方便，并且要在程序中经常要使用这个模块，这样出了问题可以通过日志很方便的查找在哪里出了问题，比直接找代码要方便些 我记录了一些经常用到的，不是很常用的可以到python文档中去查看 http://docs.python.org/2/library/logging.html","text":"python中有系统自带的logging模块，使用起来非常方便，并且要在程序中经常要使用这个模块，这样出了问题可以通过日志很方便的查找在哪里出了问题，比直接找代码要方便些 我记录了一些经常用到的，不是很常用的可以到python文档中去查看 http://docs.python.org/2/library/logging.html1. 初始化 logger = logging.getLogger(“endlesscode”)，getLogger()方法后面最好加上所要日志记录的模块名字，后面的日志格式中的%(name)s 对应的是这里的模块名字 2. 设置级别 logger.setLevel(logging.DEBUG),Logging中有NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL这几种级别，日志会记录设置级别以上的日志 3. Handler，常用的是StreamHandler和FileHandler，windows下你可以简单理解为一个是console和文件日志，一个打印在CMD窗口上，一个记录在一个文件上 4. formatter，定义了最终log信息的顺序,结构和内容，我喜欢用这样的格式 ‘[%(asctime)s] [%(levelname)s] %(message)s’, ‘%Y-%m-%d %H:%M:%S’， %(name)s Logger的名字 %(levelname)s 文本形式的日志级别 %(message)s 用户输出的消息 %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒 %(levelno)s 数字形式的日志级别 %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有 %(filename)s 调用日志输出函数的模块的文件名 %(module)s&#160; 调用日志输出函数的模块名 %(funcName)s 调用日志输出函数的函数名 %(lineno)d 调用日志输出函数的语句所在的代码行 %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数 %(thread)d 线程ID。可能没有 %(threadName)s 线程名。可能没有 %(process)d 进程ID。可能没有 5. 记录 使用object.debug(message)来记录日志 下面来写一个实例，在CMD窗口上只打出error以上级别的日志，但是在日志中打出debug以上的信息12345678910111213141516171819202122import logginglogger = logging.getLogger(\"simple_example\")logger.setLevel(logging.DEBUG)# 建立一个filehandler来把日志记录在文件里，级别为debug以上fh = logging.FileHandler(\"spam.log\")fh.setLevel(logging.DEBUG)# 建立一个streamhandler来把日志打在CMD窗口上，级别为error以上ch = logging.StreamHandler()ch.setLevel(logging.ERROR)# 设置日志格式formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")ch.setFormatter(formatter)fh.setFormatter(formatter)#将相应的handler添加在logger对象中logger.addHandler(ch)logger.addHandler(fh)# 开始打日志logger.debug(\"debug message\")logger.info(\"info message\")logger.warn(\"warn message\")logger.error(\"error message\")logger.critical(\"critical message\") 运行一下将会看到CMD窗口只记录两条，spam.log中记录了五条日志 &#160; 当一个项目比较大的时候，不同的文件中都要用到Log,可以考虑将其封装为一个类来使用1234567891011121314151617181920212223242526272829303132333435363738394041424344#! /usr/bin/env python#coding=gbkimport logging,osclass Logger: def __init__(self, path,clevel = logging.DEBUG,Flevel = logging.DEBUG): self.logger = logging.getLogger(path) self.logger.setLevel(logging.DEBUG) fmt = logging.Formatter('[%(asctime)s] [%(levelname)s] %(message)s', '%Y-%m-%d %H:%M:%S') #设置CMD日志 sh = logging.StreamHandler() sh.setFormatter(fmt) sh.setLevel(clevel) #设置文件日志 fh = logging.FileHandler(path) fh.setFormatter(fmt) fh.setLevel(Flevel) self.logger.addHandler(sh) self.logger.addHandler(fh) def debug(self,message): self.logger.debug(message) def info(self,message): self.logger.info(message) def war(self,message): self.logger.warn(message) def error(self,message): self.logger.error(message) def cri(self,message): self.logger.critical(message)if __name__ =='__main__': logyyx = Logger('yyx.log',logging.ERROR,logging.DEBUG) logyyx.debug('一个debug信息') logyyx.info('一个info信息') logyyx.war('一个warning信息') logyyx.error('一个error信息') logyyx.cri('一个致命critical信息') 这样每次使用的时候只要实例化一个对象就可以了 logobj = Logger(‘filename’,clevel,Flevel) 如果想在CMD窗口中对于error的日志标红，warning的日志标黄，那么可以使用ctypes模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#! /usr/bin/env python#coding=gbkimport logging,osimport ctypesFOREGROUND_WHITE = 0x0007FOREGROUND_BLUE = 0x01 # text color contains blue.FOREGROUND_GREEN= 0x02 # text color contains green.FOREGROUND_RED = 0x04 # text color contains red.FOREGROUND_YELLOW = FOREGROUND_RED | FOREGROUND_GREENSTD_OUTPUT_HANDLE= -11std_out_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)def set_color(color, handle=std_out_handle): bool = ctypes.windll.kernel32.SetConsoleTextAttribute(handle, color) return boolclass Logger: def __init__(self, path,clevel = logging.DEBUG,Flevel = logging.DEBUG): self.logger = logging.getLogger(path) self.logger.setLevel(logging.DEBUG) fmt = logging.Formatter('[%(asctime)s] [%(levelname)s] %(message)s', '%Y-%m-%d %H:%M:%S') #设置CMD日志 sh = logging.StreamHandler() sh.setFormatter(fmt) sh.setLevel(clevel) #设置文件日志 fh = logging.FileHandler(path) fh.setFormatter(fmt) fh.setLevel(Flevel) self.logger.addHandler(sh) self.logger.addHandler(fh) def debug(self,message): self.logger.debug(message) def info(self,message): self.logger.info(message) def war(self,message,color=FOREGROUND_YELLOW): set_color(color) self.logger.warn(message) set_color(FOREGROUND_WHITE) def error(self,message,color=FOREGROUND_RED): set_color(color) self.logger.error(message) set_color(FOREGROUND_WHITE) def cri(self,message): self.logger.critical(message)if __name__ =='__main__': logyyx = Logger('yyx.log',logging.WARNING,logging.DEBUG) logyyx.debug('一个debug信息') logyyx.info('一个info信息') logyyx.war('一个warning信息') logyyx.error('一个error信息') logyyx.cri('一个致命critical信息')","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"使用web.py在BAE建立自已的电影网站","slug":"953","date":"2013-10-31T16:06:43.000Z","updated":"2017-12-16T10:10:42.085Z","comments":true,"path":"article/953.html","link":"","permalink":"https://www.yangyanxing.com/article/953.html","excerpt":"最近在网上看了一篇文章使用web.py在BAE上建立电影网站，http://www.51bigfool.com/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8bae%E5%92%8Cweb-py%E6%89%93%E9%80%A0%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1top100%E7%9A%84.html 我自已也在此基础上做了一些改进，也在一点点的熟悉使用web.py这个框架，可以看一下我弄了一半的应用 http://movie.yangyanxing.com 准备 BAE web.py 在BAE上建立一个python的应用快速创建即可，选择Iframe","text":"最近在网上看了一篇文章使用web.py在BAE上建立电影网站，http://www.51bigfool.com/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8bae%E5%92%8Cweb-py%E6%89%93%E9%80%A0%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1top100%E7%9A%84.html 我自已也在此基础上做了一些改进，也在一点点的熟悉使用web.py这个框架，可以看一下我弄了一半的应用 http://movie.yangyanxing.com 准备 BAE web.py 在BAE上建立一个python的应用快速创建即可，选择Iframe 之后进入云引擎将环境类型设置为python 先简单看一下目录结构如下 │&#160; index.py│&#160; model.py│├─static│&#160; └─images│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; lg_movie_a12_2.png│└─templates&#160;&#160;&#160; │&#160; add.html&#160;&#160;&#160; │&#160; base.html&#160;&#160;&#160; │&#160; index.html&#160;&#160;&#160; │&#160; play.html&#160;&#160;&#160; │&#160; show.html&#160;&#160;&#160; │&#160; top250style.css 新建一个Mysql，进入phpmyadmin导入所需的表 &#160;123456CREATE TABLE DoubanTop250(id INT AUTO_INCREMENT ,moviename TEXT,score FLOAT,url TEXT,PRIMARY KEY ( id ) 我先按照原来的教程添加了相应的代码model.py123456789101112131415161718192021222324# _*_ coding:utf-8 _*_import webimport web.dbfrom bae.core import constdbname = \"数据库名字\"db = web.database( dbn='mysql', host=const.MYSQL_HOST, port=int(const.MYSQL_PORT), user=const.MYSQL_USER, passwd=const.MYSQL_PASS, db=dbname)def additem(name, rating, address): return db.insert('DoubanTop250', moviename=name, score=rating, url=address)def get_items(): return db.select('DoubanTop250', order='id')def get_item(id): return db.select('DoubanTop250', where='id=$id', vars=locals())[0] index.py 12345678910111213141516171819202122232425262728293031323334#_*_ coding:utf-8 _*_import webimport modelimport osimport reurls = ( \"/\", \"Index\", \"/play/(d+)\", \"Play\")t_globals = &#123; 'datestr': web.datestr&#125;app_root = os.path.dirname(__file__)template_root = os.path.join(app_root, 'templates/')render = web.template.render(template_root, base='base', globals=t_globals)class Index: def GET(self): items = model.get_items()# return render.test(items) return render.index(items)class Play: def POST(self, id): id = int(id) item = model.get_item(id) return render.play(item)app = web.application(urls, globals()).wsgifunc()from bae.core.wsgi import WSGIApplicationapplication = WSGIApplication(app) base.html123456789101112131415161718192021222324252627282930$def with (page)&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt; 杨彦星的自娱自乐&lt;/title&gt; &lt;link type=\"text/css\" rel=\"stylesheet\" href=\"/templates/top250style.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"header\"&gt; &lt;a target=\"_blank\" href=\"http://movie.douban.com/chart\" title=\"豆瓣电影排行旁\"&gt;&lt;img src=\"/static/images/lg_movie_a12_2.png\" &gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=\"main\"&gt; &lt;h1&gt; 这是瞎写的我会乱说吗|&lt;a target=\"_blank\" href = \"/addmovie/\"&gt;添加电影&lt;/a&gt;&lt;/h1&gt; $:page &lt;/div&gt; &lt;div id=\"footer\"&gt; &lt;div id=\"copyright\"&gt; &lt;p&gt;本站纯属自娱自乐与学习python之用，电影啥的全是网上收集&lt;/p&gt; &lt;a href = \"/\"&gt;返回首页&lt;/a&gt; &lt;p&gt;&lt;em&gt;Proudly powered by Web.py&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; index.html1234567891011121314151617181920$def with(items) &lt;table&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;影片名&lt;/th&gt; &lt;th&gt;得分&lt;/th&gt; &lt;th&gt;百度影音播放&lt;/th&gt; &lt;/tr&gt; $for item in items: &lt;tr&gt; &lt;td id=\"tdstyle\"&gt;$item.id&lt;/td&gt; &lt;td id=\"tdstyle\"&gt;$item.moviename&lt;/td&gt; &lt;td id=\"tdstyle\"&gt;$item.score&lt;/td&gt; &lt;td id=\"tdstyle\"&gt; &lt;form action=\"/play/$item.id\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"播放\" /&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; play.html12345678910$def with(item)&lt;h2&gt;$item.id $item.moviename&lt;/h2&gt;&lt;blockquote&gt; &lt;object classid=\"clsid:02E2D748-67F8-48B4-8AB4-0A085374BB99\" width=\"600\" height=\"400\" id=\"BaiduPlayer\" name=\"BaiduPlayer\" onError=if(window.confirm('请您先安装百度影音软件,然后刷新本页才可以正常播放.'))&#123;window.open('http://player.baidu.com')&#125;else&#123;self.location='http://player.baidu.com'&#125;&gt; &lt;PARAM NAME='URL' VALUE=$item.url&gt; &lt;PARAM NAME='Autoplay' VALUE='1'&gt; &lt;/object&gt;&lt;a title=\"返回首页\" href=\"http://kanimdb.duapp.com\"&gt; 返回首页 &lt;/a&gt;&lt;/blockquote&gt; top250style.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263body&#123; background-image: url(tw.jpg); background-position:right; background-color: #fff; margin-left:15%; margin-right:15%; border: 2px dotted gray; padding: 20px 20px 20px 20px; font-family: sans-serif;&#125;h1 &#123; font-family: sans-serif; font-weight: bolder;; color: green; border-bottom: 2px solid gray; text-align: center;&#125;table &#123; width: 500px; text-align: center; margin-top: 30px; margin-left: 20%; margin-right: 20%; border: thin solid black; border-collapse: collapse;&#125;th, #tdstyle &#123; border: thin dotted gray; padding: 5px; background-color: silver;&#125;th &#123; background-color: #fcba7a;&#125;#main &#123; padding-top: 20px; padding-bottom: 20px;&#125;#bdplaer &#123; padding-left: 10px; padding-right: 10px;&#125;#header &#123; text-align: center;&#125;#footer &#123; padding: 10px, 10px, 10px, 10px; text-align: center;&#125;#copyright &#123; padding: 10px, 10px, 10px, 10px; font-size: small;&#125; 修改app.conf12345678910111213handlers: - url : /static/images/(.*) script: /static/images/$1 - url : /templates/(.*) script: /templates/$1 - url : /(.*) script: index.py - expire : .jpg modify 10 years - expire : .swf modify 10 years - expire : .png modify 10 years - expire : .gif modify 10 years - expire : .JPG modify 10 years 好了，现在这个应用基本上就可以看了，不过现在请忘了以上的代码。因为我们要为其添加一些自已的想要的东西 首先我们要添加“添加影片”功能 修改urls配置1234567urls = ( \"/\",\"Index\", \"/play/(d+)\",\"Play\", \"/add/\",\"Add\", \"/addmovie/\",\"addmovie\") 这里的addmovie 其实只是想render到一个模板中 添加class addmovie实现 123class addmovie: def GET(self): return render.add() 添加add.html123456&lt;form action=\"/add/\" method=\"post\"&gt;电影名:&lt;input type=\"text\" name = \"name\"&gt;&lt;br&gt;得分:&lt;input type=\"text\" name = \"rating\"&gt;&lt;br&gt;播放地址:&lt;input type=\"text\" name = \"address\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"add\"&gt;&lt;/form&gt; 很简单的表单，我前端不会，只会写简单的html 这里name值可以随便写，有意义或者你自已认识即可，反正后面的python代码会做处理 这里将movie的信息post到/add/中 转为urls里已经配置了 “/add/“,”Add”, 下面来写class Add实现1234567891011class Add: def POST(self): movieinfo = web.data() #model.additem(movieinfo) #return render.show(movieinfo) postlist = movieinfo.split('&amp;') movie = [] for i in postlist: movie.append(i.split('=')[1]) model.additem(urllib.unquote(movie[0]),movie[1],urllib.unquote(movie[2])) web.seeother(\"/\") 这里的代码写的太ugly了，但是可以满足需要，如果有更好的实现可以和我说下 先将post来的数据使用&amp;分割，将会得到name=xxx,rating=xxx,address=xxx的列表 接着来获取相应的值，也就是再将列表中的各个项再用‘=’进行分割，然后将值append到一个新的列表中 然后将新的列表中的各个值进行unquote，要不你插入到数据库中的将不是中文等，而是quote过的数据 插件结束后跳转到首页 web.seeother(“/”) 好了，现在我们完成了添加电影的操作 完成后你现在就去找些电影和百度影音地址来添加看看但是我发现一个新的问题，百度影音在非IE浏览器上是不好用的，这还了得…… 在网上找方法，有一个通过 javacsript先判断浏览器的appname来决定使用哪个，http://pcbbs.baidu.com/thread-62871-1-1.html 这个是我试过了，可以实现在chrome与FF下调用百度影音，但是我要传的$item.url不能传入javascrip中，传入后就是$item.url，在网上查找说可以要写两个$，我也试过了，但是还是不能播放，于是我决定放弃IE用户，让所有播放都走非IE的方法中，爱咋地咋地。 百度这点做的就不如qvod，人家官方都出了在非IE浏览器上调用的方法，而百度还在使用IE，真是不思进取，我也决定在网页上调用qvod播放接口 那么新的问题又来了，程序怎么知道你是要用qvod还是百度来播放？其实很简单，你在添加播放地址的时候，qvod的地址是以qvod开始的，百度影音是以bdhd开始的，只要判断一下$item.url是以哪个开头的就可以了 但是网上更多的还是thunder,edk等协议的影视资源，这些无论是百度还是qvod都无法播放，于是我想到了现在很流行的云点播，迅雷的云点播可以播放，但是非白金会员只能播放一段时间，随便找了几个提供在线云点播的，有弹出式广告的占大多数，于是找了一个没有广告的，okdvd，其接口调用也挺简单的 1&lt;iframe scrolling=\"no\" frameborder=\"0\" name=\"win_vod\" id=\"win_vod\" border=\"0\" style=\"width: 950px; height: 550px\" src=\"http://www.okdvd.com/api.php#!url=后面加上播放地址\"&gt;&lt;/iframe&gt; 所以最终修改我的play.html为12345678910111213141516171819$def with(item)&lt;h2&gt;$item.id $item.moviename&lt;/h2&gt;&lt;blockquote&gt;&lt;div align = \"center\"&gt;$if item.url.startswith('qvod'): &lt;object classid=\"clsid:F3D0D36F-23F8-4682-A195-74C92B03D4AF\" width=\"860\" height=\"460\" id=\"QvodPlayer\" name=\"QvodPlayer\" onerror=\"document.getElementById('QvodPlayer').style.display='none';document.getElementById('iframe_down').style.display='';document.getElementById('iframe_down').src='http://error2.qvod.com/error4.htm';\"&gt; &lt;param name='Showcontrol' value='2'&gt; &lt;param name='URL' value=$item.url&gt; &lt;param name='Autoplay' value='1'&gt; &lt;embed id=\"QvodPlayer2\" name=\"QvodPlayer2\" width=\"860\" height=\"460\" URL=$item.url type='application/qvod-plugin' Autoplay='1' Showcontrol='1' &gt;&lt;/embed&gt; &lt;/object&gt;$elif item.url.startswith('bdhd'):&lt;object id=\"BaiduPlayer\" name=\"BaiduPlayer\" type=\"application/player-activex\" width=\"860\" height=\"460\" progid=\"Xbdyy.PlayCtrl.1\" param_URL=$item.url param_OnPlay=\"onPlay\" param_OnPause=\"onPause\" param_OnFirstBufferingStart=\"onFirstBufferingStart\" param_OnFirstBufferingEnd=\"onFirstBufferingEnd\" param_OnPlayBufferingStart=\"onPlayBufferingStart\" param_OnPlayBufferingEnd=\"onPlayBufferingEnd\" param_OnComplete=\"onComplete\" param_Autoplay=\"1\"&gt;&lt;/object&gt;$else:&lt;iframe scrolling=\"no\" frameborder=\"0\" name=\"win_vod\" id=\"win_vod\" border=\"0\" style=\"width: 860px; height: 460px\" src=\"http://www.okdvd.com/okapi.php#!url=$item.url\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/blockquote&gt; 这里有一个问题困扰了我很长时间，原来这里的模板如果有python代码的话也是要遵循其缩进原则的，如$if 下面的如果和$if同级，那么也会报错，BAE提供错误日志，可以很快的查看到哪里出错了 首页上播放按钮现在还都是“播放”字样我想让它显示是百度还是qvod播放，其实方法和上面一样，判断$item.url的startswith()方法，另外我又有了新的需求，因为网上有些电影的资源实在不好找到百度或者qvod与thunder或者edk资源，但是优酷或者土豆上有，那我可以让其跳转到相应的网址上播放 所以最终的index.html修改成这样123456789101112131415161718192021222324252627282930313233$def with(items) &lt;table&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;影片名&lt;/th&gt; &lt;th&gt;得分&lt;/th&gt; &lt;th&gt;播放&lt;/th&gt; &lt;/tr&gt; $for item in items: &lt;tr&gt; &lt;td id=\"tdstyle\"&gt;$item.id&lt;/td&gt; &lt;td id=\"tdstyle\"&gt;$item.moviename&lt;/td&gt; &lt;td id=\"tdstyle\"&gt;$item.score&lt;/td&gt; &lt;td id=\"tdstyle\"&gt; $if item.url.startswith(\"http\"): &lt;form action=\"$item.url\" method=\"get\" target=\"_blank\"&gt; &lt;input type=\"submit\" value=\"新页面播放\" /&gt; &lt;/form&gt; $elif item.url.startswith('bdhd'): &lt;form action=\"/play/$item.id\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"百度影音播放\" /&gt; &lt;/form&gt; $elif item.url.startswith('qvod'): &lt;form action=\"/play/$item.id\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"qvod播放\" /&gt; &lt;/form&gt; $else: &lt;form action=\"/play/$item.id\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"云点播播放\" /&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 而最终的index.py修改成这样1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#-*- coding:utf-8 -*-import webimport modelimport osimport reimport urlliburls = ( \"/\",\"Index\", \"/play/(d+)\",\"Play\", \"/add/\",\"Add\", \"/addmovie/\",\"addmovie\")t_globals = &#123; 'datestr': web.datestr&#125;app_root = os.path.dirname(__file__)template_root = os.path.join(app_root, 'templates/')render = web.template.render(template_root, base='base', globals=t_globals)class Index: def GET(self): items = model.get_items()# return render.test(items) return render.index(items)class Play: def POST(self, id): id = int(id) item = model.get_item(id) return render.play(item)class Add: def POST(self): movieinfo = web.data() #model.additem(movieinfo) #return render.show(movieinfo) postlist = movieinfo.split('&amp;') movie = [] for i in postlist: movie.append(i.split('=')[1]) model.additem(urllib.unquote(movie[0]),movie[1],urllib.unquote(movie[2])) web.seeother(\"/\")class addmovie: def GET(self): return render.add()app = web.application(urls, globals()).wsgifunc()from bae.core.wsgi import WSGIApplicationapplication = WSGIApplication(app) 遗留问题现在没有权限限制，谁都可以添加，也没有修改与删除选项，所以后面我将添加相应的权限管理，另外总不能自已都去手工添加电影，考虑使用爬虫来自动添加电影 献给热爱的电影的同胞们向亚伦·斯沃茨 致敬 &#160; 向汤唯致敬","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"webpy","slug":"webpy","permalink":"https://www.yangyanxing.com/tags/webpy/"}]},{"title":"web.py中关于url的总结","slug":"932","date":"2013-10-21T17:42:41.000Z","updated":"2017-12-16T10:10:41.904Z","comments":true,"path":"article/932.html","link":"","permalink":"https://www.yangyanxing.com/article/932.html","excerpt":"网页中的数据在传递的时候有GET和POST两种方式，GET是以网址的形式传参数，在web.py中有着很好的匹配，如果我们配置以下的urls123urls =( '/','index', '/weixin/(.*?)','WeixinInterface' 先不考虑/weixin/后面的东西，现在我们来写index的类123class index: def GET(self): i = web.input(name = 'kevinkelin',age = 100)","text":"网页中的数据在传递的时候有GET和POST两种方式，GET是以网址的形式传参数，在web.py中有着很好的匹配，如果我们配置以下的urls123urls =( '/','index', '/weixin/(.*?)','WeixinInterface' 先不考虑/weixin/后面的东西，现在我们来写index的类123class index: def GET(self): i = web.input(name = 'kevinkelin',age = 100) 随便写一个index.html模板文件123456$def with(name,age)$if name:I just want to say &lt;em&gt;hello&lt;/em&gt; to $name, he is $age years old$else:&lt;em&gt;hello&lt;/em&gt;,world! 当访问http://127.0.0.1:8080/ 此时没有传递name与age的值，由于我的GET函数里定义了默认的name与age的值，所以程序会将kevinkelin与26传递到模板中去得到以下的输出 I just want to say hello to kevinkelin, he is 100 years old 当访问http://127.0.0.1:8080/?name=yyx&amp;age=26 即向GET函数中传递name = yyx and age = 26的时候得到以下的输出 I just want to say hello to yyx, he is 26 years old &#160; 我们也可以不定义默认的的参数，即定义为空 i = web.input(name = None,age = None) 当访问http://127.0.0.1:8080/ 的时候将会得到 hello,world!的输出即模板中的else 但是如果你不定义name和age将会出错 i = web.input() 这是因为后面你将i.name与i.age分配到模板当中去，但是全局变量里又没有这两个变量，所以会报错 但有时我们想这样传递参数，不想加那个“？”这时我们得要更改urls规则123urls =( '/name=(.*)&amp;age=(.*)','index', '/weixin/(.*?)','WeixinInterface' 重新写class index12class index: def GET(self,name,age): 这里是将url的参数通过正则匹配然后传递到index类中的GET的参数中 当访问http://127.0.0.1:8080/name=yyx&amp;age=26 时将得到 I just want to say hello to yyx, he is 26 years old 第二种方法看似简单，但其实不好控制，要求写的正则工作量加大了 如果我想知道到底有多少参数通过GET方式传递过来，我可以直接return 来看一下到底有哪些传递过来了 &#160; 接下来看一下post来的数据 我们可以制作一个简单的表单或者直接使用fiddler来构造数据进行POST传值12def POST(self): data = web.data() &#160; 我想看一下得到的数据类型 return type(data) 得到的是，也就是说web.py已经将post的数据转换成了str类型 那么我来试一下传递xml12345678&lt;xml&gt;&lt;ToUserName&gt;yanxingyang&lt;/ToUserName&gt;&lt;FromUserName&gt;study_python&lt;/FromUserName&gt;&lt;CreateTime&gt;123456&lt;/CreateTime&gt;&lt;MsgType&gt;text&lt;/MsgType&gt;&lt;Content&gt;Just a test&lt;/Content&gt;&lt;/xml&gt; 其实这个微信的XML格式做了一些更改，我来试着使用lxml对它进行解析 from lxml import etree data = web.data() xml = etree.fromstring(data) content = xml.find(‘Content’).text return content 得到的结果很好 关于python解析XML以前也有总结过（http://my.oschina.net/yangyanxing/blog/159212），在我的脑子里总感觉解析XML是件头痛的事情…… 今天先总结到这，明天接着搞LXML进行解析xml操作。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"webpy","slug":"webpy","permalink":"https://www.yangyanxing.com/tags/webpy/"}]},{"title":"在中文windows下使用pywinauto进行窗口操作（一）","slug":"926","date":"2013-10-06T19:42:56.000Z","updated":"2017-12-16T10:10:42.482Z","comments":true,"path":"article/926.html","link":"","permalink":"https://www.yangyanxing.com/article/926.html","excerpt":"这两天开始接触pywinauto，听说百度的自动化QA也用这个模块，于是来了兴趣，但网上的教程很少，而且基本上都是拿官方的notepad来说，首先中文菜单的支持是问题，其次各种操作也没有写清楚，阅读官方的文档，发现这个东西使用起来还真是非常方便，下面我也以notepad为例来说明一下它的简单操作。 安装pywinauto; https://sourceforge.net/project/showfiles.php?group_id=157379 Sendkeyshttp://www.rutherfurd.net/python/sendkeys/index.html ctypes (如果你是python2.3或者2.4)检测你是否安装正确 from pywinauto import applicationapp = application.Application.start(“notepad.exe”)app.notepad.TypeKeys(“%FX”)","text":"这两天开始接触pywinauto，听说百度的自动化QA也用这个模块，于是来了兴趣，但网上的教程很少，而且基本上都是拿官方的notepad来说，首先中文菜单的支持是问题，其次各种操作也没有写清楚，阅读官方的文档，发现这个东西使用起来还真是非常方便，下面我也以notepad为例来说明一下它的简单操作。 安装pywinauto; https://sourceforge.net/project/showfiles.php?group_id=157379 Sendkeyshttp://www.rutherfurd.net/python/sendkeys/index.html ctypes (如果你是python2.3或者2.4)检测你是否安装正确 from pywinauto import applicationapp = application.Application.start(“notepad.exe”)app.notepad.TypeKeys(“%FX”) 都安装好了以后，我们来正式进入pywinauto的世界 启动程序12from pywinauto import applicationapp = application.Application.start('notepad.exe') start() 函数里也可以接路径+程序名 使用spy++lite查看notepad的信息 里面的窗口类名与标题文本相关重要，以后的查找窗口基本上都要用的到 现在我们来点击“帮助-&gt;关于记事本”操作1app.Notepad.MenuSelect('帮助-&gt;关于记事本'.decode('gb2312')) 这里的app是你刚才实例的对象，Notepad是类名，可以从spy++lite中看到,MenuSelect方法可以自动检索Notepad上的菜单选项， decode(‘gb2312’)方法是把中文强制转换为unicode编码，对于非英文的操作系统都是要转换的，后面还有更简单的方法 查找“关于记事本”的窗口还是使用spy++lite来查看“关于记事本”的信息 窗口类名：#32770 标题文字：关于“记事本” 官方法文档中有以下两个方法 1. 通过top_dlg = app.topwindow() 来获得最上面的window，但是官方并不推荐这种方式，目前来说这个“关于记事本”是最上面，但是也不能保证在测试的进程当中有什么意外的进程跑到了上面，一旦有新的进程，那么得到的就是一个错误的对象 2.通过finddlg = app.window(title_re = ‘’, class_name = ‘’) 方法获得，这也是为什么我上面说标题文本与窗口类名非常重要的原因，title_re和 class_name这两个可以单独使用也可以一块使用，因为有时没有标题文本，也有时一个窗口类名有多个对象，比如“Edit”有时当一个对话框中有多个输入框时会有多个Edit类名，对于“关于记事本”我们可以通过以下代码获得 中文要进行unicode编码，这里也可以通过decode(‘gb2312’)方法实现，但是不如输入一个U省事~ 呵呵 我们print一下得到的about_dlg 说明我们得到的是一个application.WindowSpecification对象 在”关于记事本”窗口上找到“确定”按钮(button)在pywinauto中，对话框下面的是controller，button,checkbox,textbox等都是controller 我们可以使用print_control_identifiers() 方法来打印出该窗口中所有的controller 会得到以下的输出123456789101112131415161718192021222324Control Identifiers:Static - '' (L312, T265, R738, B267)'' '0' '1' 'Static' 'Static0' 'Static1'Static - '' (L308, T280, R340, B313)'2' 'Static2'Static - 'Microsoft Windows' (L350, T280, R695, B295)'Microsoft Windows' 'Microsoft WindowsStatic' 'Static3'Static - 'u7248u672c 6.1 (u5185u90e8u7248u672c 7601: Service Pack 1)' (L350, T295, R748, B310)'Static4' 'u7248u672c 6.1 (u5185u90e8u7248u672c 7601: Service Pack 1)' 'u7248u672c 6.1 (u5185u90e8u7248u672c 7601: Service Pack 1)Static'Static - 'u7248u6743u6240u6709 xa9 2009 Microsoft Corporationu3002u4fddu7559u6240u6709u6743u5229u3002' (L350, T310, R710, B325)'Static5' 'u7248u6743u6240u6709 xa9 2009 Microsoft Corporationu3002u4fddu7559u6240u6709u6743u5229u3002' 'u7248u6743u6240u6709 xa9 2009 Microsoft Corporationu3002u4fddu7559u6240u6709u6743u5229u3002Static'Static - 'Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002' (L350, T325, R710, B385)'Static6' 'Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002' 'Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static' 'Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static0' 'Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static1'Static - '' (L350, T385, R665, B415)'Static7' 'Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static2'SysLink - 'u6839u636e &lt;A&gt;Microsoft u8f6fu4ef6u8bb8u53efu6761u6b3e&lt;/A&gt;uff0cu672cu4ea7u54c1u4f7fu7528u6743u5c5eu4e8e:' (L350, T415, R665, B445)'SysLink' 'u6839u636e &lt;A&gt;Microsoft u8f6fu4ef6u8bb8u53efu6761u6b3e&lt;/A&gt;uff0cu672cu4ea7u54c1u4f7fu7528u6743u5c5eu4e8e:' 'u6839u636e &lt;A&gt;Microsoft u8f6fu4ef6u8bb8u53efu6761u6b3e&lt;/A&gt;uff0cu672cu4ea7u54c1u4f7fu7528u6743u5c5eu4e8e:SysLink'Static - 'kevin' (L365, T445, R680, B460)'Static8' 'kevin' 'kevinStatic' 'kevinStatic0' 'kevinStatic1'Static - '' (L365, T460, R680, B475)'Static9' 'kevinStatic2'Button - 'u786eu5b9a' (L672, T503, R747, B524)'Button' 'u786eu5b9a' 'u786eu5b9aButton' static，SysLink,button等是它类型，后面接的是title，都是unicode的，这里面就有没有title的controller，再后面的（L,T,R,B）是这个控件的位置，分别对应着左上右下 在”关于记事本”窗口上找到“确定”按钮，可以通过app.window_()方法，传入的参数可以是title,也可以是class_name,所以我说这两个值相当重要，一直在用，这里的title支持正则表达式，非常方便 在app上先找到about_dlg,然后再about_dlg上找确定button app.window_(titlere = u’关于“记事本”’).window(title_re = u’确定’)，然后通过Click()方法来单击这个button 另外一种方法也是官方推荐的在非英文系统下的方法12OK = u'确定'about_dlg[OK].Click() 这个的意思就是在about_dlg下找到u’确定’，看起来比上面要简练好理解，理解了这种方式，接下来还有更简单的，都不用找about_dlg 直接 app[u’关于“记事本”’][u’确定’].Click() 在记事本里写点东西这个其实在校验pywinauto的时候已经做过了全用TypeKeys函数，但是这里如果要输入中文还是要u一下1app.notepad.TypeKeys(u\"杨彦星\") 一个比较恶心的问题在MenuSelect函数中不支持正则，完全是全文匹配，如我输入 dig = app.Notepad.MenuSelect(“编辑-&gt;替换”.decode(‘gb2312’)) 是找不到对象的 必须要 dig = app.Notepad.MenuSelect(“编辑(E)-&gt;替换(R)”.decode(‘gb2312’)) 这样才行，得把(R) (E)写上才行，但是奇怪的是上面的“帮助-&gt;关于记事本”就不用输入，所以说是一个挺恶心的问题，我也不知道这是为什么…… 最后把上面的函数合并一下，跑下来应该会很快123456789101112131415161718192021222324252627282930#! /usr/bin/env python#coding=gbkimport timefrom pywinauto import applicationapp = application.Application.start('notepad.exe')app.Notepad.MenuSelect('帮助-&gt;关于记事本'.decode('gb2312'))time.sleep(.5)#这里有两种方法可以进行定位“关于记事本”的对话框#top_dlg = app.top_window_() 不推荐这种方式，因为可能得到的并不是你想要的about_dlg = app.window_(title_re = u\"关于\", class_name = \"#32770\")#这里可以进行正则匹配title#about_dlg.print_control_identifiers()app.window_(title_re = u'关于“记事本”').window_(title_re = u'确定').Click()app.Notepad.MenuSelect('帮助-&gt;关于记事本'.decode('gb2312'))time.sleep(.5) #停0.5s 否则你都看不出来它是否弹出来了！ABOUT = u'关于“记事本”'OK = u'确定'#about_dlg[OK].Click()#app[ABOUT][OK].Click()app[u'关于“记事本”'][u'确定'].Click()app.Notepad.TypeKeys(u\"杨彦星\")dig = app.Notepad.MenuSelect(\"编辑(E)-&gt;替换(R)\".decode('gb2312'))Replace = u'替换'Cancle = u'取消'time.sleep(.5)app[Replace][Cancle].Click()dialogs = app.windows_() 先写这么多，以后再写点更多的应用~","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[]},{"title":"使用python进行windows自动化测试（1）","slug":"920","date":"2013-10-04T17:41:33.000Z","updated":"2017-12-16T10:10:42.368Z","comments":true,"path":"article/920.html","link":"","permalink":"https://www.yangyanxing.com/article/920.html","excerpt":"最近开始学习整理python在windows自动化测试中的使用，觉得挺有意思的 主要思路，在windows下，主要通过启进程，然后查找进程的句柄，然后再操作这个句柄，包括点击，填写文字，关闭，获取文字等操作 下面以一个简单的校验文件md5值的操作来介绍一个python的应用，当然python中有校验md5的函数，不用非要使用工具来校验，这里只是练习使用python来自动化操作 所用的工具有SpyLite，用于查看窗口ID，句柄等信息","text":"最近开始学习整理python在windows自动化测试中的使用，觉得挺有意思的 主要思路，在windows下，主要通过启进程，然后查找进程的句柄，然后再操作这个句柄，包括点击，填写文字，关闭，获取文字等操作 下面以一个简单的校验文件md5值的操作来介绍一个python的应用，当然python中有校验md5的函数，不用非要使用工具来校验，这里只是练习使用python来自动化操作 所用的工具有SpyLite，用于查看窗口ID，句柄等信息 工具下载 http://www.xiazaiba.com/html/358.html&#160; http://www.xiazaiba.com/html/5861.html 我们要达到的目的是通过md5校验工具将文件的md5值保存到一个log文档中 测试的目录结构 –automd5– &#160;&#160;&#160; –needCheck– &#160;&#160;&#160; checkmd5.py &#160;&#160;&#160; SpyLite24.exe &#160;&#160;&#160; Hash.exe needCheck目录放需要检查md5的文件 &#160; &#160; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286#! /usr/bin/env python#coding=gbkimport time,re,ctypesimport os,sys,subprocess,win32gui,win32con,win32apiimport glob,time#启进程函数def createProcess(cmd, wait = False): if wait: proc = tryExcept(subprocess.Popen, cmd, stdout = subprocess.PIPE, stderr = subprocess.PIPE) else: proc = tryExcept(subprocess.Popen, cmd) if isExcept(proc): return if not wait: return proc.pid proc.communicate()def tryExcept(func, *params, **paramMap): try: return func(*params, **paramMap) except Exception, e: return edef isExcept(e, eType = Exception): return isinstance(e, eType)class BaseWindow: @staticmethod def parseClickConfig(clkCfg): if clkCfg == None: return None, None, False, 0 if type(clkCfg) == bool: return None, None, clkCfg, 0 if type(clkCfg) == int: return None, None, False, clkCfg if len(clkCfg) == 2: if type(clkCfg[0]) == int and type(clkCfg[1]) == int: return clkCfg[0], clkCfg[1], False, 0 return None, None, clkCfg[0], clkCfg[1] if len(clkCfg) == 3: if type(clkCfg[2]) == bool: return clkCfg[0], clkCfg[1], clkCfg[2], 0 return clkCfg[0], clkCfg[1], False, clkCfg[2] return clkCfg#点击窗口#clkCfg:byDrv|mode|(x,y)|(byDrv,mode)|(x,y,byDrv)|(x,y,mode)|(x,y,byDrv,mode)def clickWindow(hwnd, clkCfg = None): if isRawWindow(hwnd): return topWindow(hwnd) rect = getWindowRect(hwnd) if not rect: return x, y, byDrv, mode = BaseWindow.parseClickConfig(clkCfg) if x == None: x = (rect[0] + rect[2]) / 2 elif x &lt; 0: x += rect[2] else: x += rect[0] if y == None: y = (rect[1] + rect[3]) / 2 elif y &lt; 0: y += rect[3] else: y += rect[1] clickMouse(x, y, byDrv, mode)#点击鼠标CLICK_MOUSE = 0CLICK_MOUSE_DOUBLE = 1CLICK_MOUSE_RIGHT = 2def clickMouse(x, y, byDrv = False, mode = CLICK_MOUSE): moveMouse(x, y, byDrv) downMsg, upMsg = win32con.MOUSEEVENTF_LEFTDOWN, win32con.MOUSEEVENTF_LEFTUP if mode == CLICK_MOUSE_RIGHT: downMsg, upMsg = win32con.MOUSEEVENTF_RIGHTDOWN, win32con.MOUSEEVENTF_RIGHTUP win32api.mouse_event(downMsg, 0, 0, 0, 0) win32api.mouse_event(upMsg, 0, 0, 0, 0) if mode == CLICK_MOUSE_DOUBLE: win32api.mouse_event(downMsg, 0, 0, 0, 0) win32api.mouse_event(upMsg, 0, 0, 0, 0)#移动鼠标def moveMouse(x, y, byDrv = False): w, h = win32api.GetSystemMetrics(0), win32api.GetSystemMetrics(1) x, y = int(float(x) / w * 65535), int(float(y) / h * 65535) win32api.mouse_event(win32con.MOUSEEVENTF_MOVE | win32con.MOUSEEVENTF_ABSOLUTE, x, y, 0, 0)#获得窗口尺寸def getWindowRect(hwnd): rect = tryExcept(win32gui.GetWindowRect, hwnd) if not isExcept(rect): return rect#置顶窗口def topWindow(hwnd): fgHwnd = win32gui.GetForegroundWindow() if fgHwnd == hwnd: return True rst = tryExcept(win32gui.SetForegroundWindow, hwnd) if not isExcept(rst): return True return getWindowClass(fgHwnd) == 'Progman' and getWindowText(fgHwnd) == 'Program Manager'##获取窗口文字def getWindowText(hwnd, buf = ctypes.c_buffer(1024)): size = ctypes.sizeof(buf) ctypes.memset(buf, 0, size) tryExcept(win32gui.SendMessageTimeout, hwnd, win32con.WM_GETTEXT, size, buf, win32con.SMTO_ABORTIFHUNG, 10) return buf.value.strip()#获取窗口类名def getWindowClass(hwnd, buf = ctypes.c_buffer(1024)): size = ctypes.sizeof(buf) ctypes.memset(buf, 0, size) ctypes.windll.user32.GetClassNameA(hwnd, ctypes.addressof(buf), size) return buf.value.strip()#查找第一个窗口#title:text,class,ctrlid#parentTitle:None,hwnd,text,classdef findWindow(title, parentTitle = None, isRaw = False): hwndList = findWindows(title, parentTitle, isRaw) if hwndList: return hwndList[0]def findRawWindows(title, parentTitle = None): return findWindows(title, parentTitle, True)#判断是否为非正常窗口def isRawWindow(hwnd): return not win32gui.IsWindowVisible(hwnd) or not win32gui.IsWindowEnabled(hwnd) or ctypes.windll.user32.IsHungAppWindow(hwnd)#查找窗口#title:text,class,ctrlid#parentTitle:None,hwnd,text,classdef findWindows(title, parentTitle = None, isRaw = False): def __enumWindowHandler__(hwnd, wndList): text = re.split('[r|n]+', getWindowText(hwnd))[0].strip() clazz = getWindowClass(hwnd).strip() ctrlId = win32gui.GetDlgCtrlID(hwnd) wndList.append((hwnd, text, clazz, ctrlId)) if not parentTitle: parentHwndList = [None] elif type(parentTitle) == int: parentHwndList = [parentTitle] else: parentHwndList = findRawWindows(parentTitle) hwndSet = set() for parentHwnd in parentHwndList: wndList = [] #EnumWindows if parentHwnd: tryExcept(win32gui.EnumChildWindows, parentHwnd, __enumWindowHandler__, wndList) else: win32gui.EnumWindows(__enumWindowHandler__, wndList) #FindWindowEx hwnd, foundHwndList = None, [] while True: hwnd = tryExcept(win32gui.FindWindowEx, parentHwnd, hwnd, None, None) if not hwnd or isExcept(hwnd) or hwnd in foundHwndList: break __enumWindowHandler__(hwnd, wndList) foundHwndList.append(hwnd) #GetWindow if parentHwnd: hwnd = tryExcept(win32gui.GetWindow, parentHwnd, win32con.GW_CHILD) else: hwnd = tryExcept(win32gui.GetWindow, win32gui.GetDesktopWindow(), win32con.GW_CHILD) while hwnd and not isExcept(hwnd): __enumWindowHandler__(hwnd, wndList) hwnd = tryExcept(win32gui.GetWindow, hwnd, win32con.GW_HWNDNEXT) #Combine for hwnd, text, clazz, ctrlId in set(wndList): if type(title) == int: if ctrlId == title: hwndSet.add(hwnd) elif text == title or re.match('^' + title + '$', text, re.S) or clazz == title or re.match('^' + title + '$', clazz, re.S): hwndSet.add(hwnd) if parentHwnd: hwndSet.update(findRawWindows(title, hwnd)) if isRaw: return list(hwndSet) hwndList = [] for hwnd in hwndSet: if not isRawWindow(hwnd): hwndList.append(hwnd) return hwndList#设置窗口文字def setWindowText(hwnd, text): rst = tryExcept(win32gui.SendMessageTimeout, hwnd, win32con.WM_SETTEXT, 0, text, win32con.SMTO_ABORTIFHUNG, 10) return not isExcept(rst)#杀掉指定name的进程def killProcessByName(pname, user = None): killProcessByNames([pname], user)def listFile(path, isDeep=True): _list = [] if isDeep: try: for root, dirs, files in os.walk(path): for fl in files: _list.append('%s%s' % (root, fl)) except: pass else: for fn in glob.glob( path + os.sep + '*' ): if not os.path.isdir(fn): _list.append('%s' % path + os.sep + fn[fn.rfind('')+1:]) return _list#杀掉指定name的进程列表def killProcessByNames(pnameList, user = None): cmd = 'taskkill /F /T' if user: cmd += ' /FI \"USERNAME eq %s\"' % user for pname in pnameList: cmd += ' /IM %s' % pname createProcess(cmd, True)#超时设置def handleTimeout(func, timeout, *params, **paramMap): interval = 0.8 if type(timeout) == tuple: timeout, interval = timeout while timeout &gt; 0: t = time.time() rst = func(*params, **paramMap) if rst and not isExcept(rst): break time.sleep(interval) timeout -= time.time() - t return rst#写文件def setFileData(filename, data, mode): f = open(filename, mode) f.write(data) f.close()if __name__ == '__main__': if os.path.isfile('md5.log'): os.system('del md5.log') parentHwnd = r'Hash.*?' #setWindowText(textblack,'123') filedir = os.path.join(os.getcwd(),'needCheck') filelist = listFile(filedir) #os.chdir(filedir) for file in filelist: #启进程 createProcess('Hash.exe') #查找浏览按钮 browse_button = findWindow(r'浏览.*?',parentHwnd) #点击浏览按钮 clickWindow(browse_button) textblack = findWindow(0x47C,'#32770') handleTimeout(setWindowText,10,textblack,file) open_hwnd = findWindow('打开.*?','#32770') #点击打开按钮 clickWindow(open_hwnd) #获取文件md5信息 #需要内容的行号 expect_content_id = [0,4] content_hwnd = findWindow(0x3EA,r'Hash.*?') content_text = handleTimeout(getWindowText,20,content_hwnd) content = content_text.split('rn') md5content = [i.split(': ')[1].strip() for ind, i in enumerate(content) if ind in expect_content_id] print md5content filename,md5value = md5content setFileData('md5.log','文件名:'+filename+'n'+'md5:'+ md5value+'nn','a') killProcessByName('Hash.exe') os.system('pause')","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.yangyanxing.com/tags/自动化测试/"}]},{"title":"通过hello world程序判断你的虚拟主机是否支持python","slug":"897","date":"2013-09-24T17:37:52.000Z","updated":"2017-12-16T10:10:41.998Z","comments":true,"path":"article/897.html","link":"","permalink":"https://www.yangyanxing.com/article/897.html","excerpt":"今天在RC上买了台虚拟主机玩玩，看它上面说支持python语言，于是试了下 写一个hello world的小程序12#!/usr/bin/pythonprint 'Content-Type: text/plainn' 以二进制方式上传到自已的空间上，访问 http://static.yangyanxing.com/test.py 居然一次性成功了，完美地显示hello world","text":"今天在RC上买了台虚拟主机玩玩，看它上面说支持python语言，于是试了下 写一个hello world的小程序12#!/usr/bin/pythonprint 'Content-Type: text/plainn' 以二进制方式上传到自已的空间上，访问 http://static.yangyanxing.com/test.py 居然一次性成功了，完美地显示hello world 可是在网上查了一下，发现大部分还是出现500服务器错误，主要是以下几个原因 RC的python路径为/usr/bin/python 所以要在python文件首行加上 有时还要改.htaccess，在上面添加对python的解析 AddHandler cgi-script .py 没有以二进制方式上传 上传后有时要改下这个文件的权限为755，我的是744也可以执行 还是500服务器错误，请检查代码写是否有问题，别少一个引号多加一个分号什么的","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[]},{"title":"Python中的urllib2库的使用","slug":"911","date":"2013-09-11T17:06:43.000Z","updated":"2017-12-16T10:10:42.494Z","comments":true,"path":"article/911.html","link":"","permalink":"https://www.yangyanxing.com/article/911.html","excerpt":"今天研究了下urllib2这个库的使用，才发现以前有很多不明白的东西，现在写下来也做个记录 最基础的应用123import urllib2url = r'http://www.baidu.com'html = urllib2.urlopen(url).read() 客户端与服务器端通过request与response来沟通，客户端先向服务端发送request，然后接收服务端返回的response urllib2提供了request的类，可以让用户在发送请求前先构造一个request的对象，然后通过urllib2.urlopen方法来发送请求1234import urllib2url = r'http://www.baidu.com'req = urllib2.Request(url)html = urllib2.urlopen(req).read()","text":"今天研究了下urllib2这个库的使用，才发现以前有很多不明白的东西，现在写下来也做个记录 最基础的应用123import urllib2url = r'http://www.baidu.com'html = urllib2.urlopen(url).read() 客户端与服务器端通过request与response来沟通，客户端先向服务端发送request，然后接收服务端返回的response urllib2提供了request的类，可以让用户在发送请求前先构造一个request的对象，然后通过urllib2.urlopen方法来发送请求1234import urllib2url = r'http://www.baidu.com'req = urllib2.Request(url)html = urllib2.urlopen(req).read() 上例中先使用req = urllib2.Request(url)实例化一个resquest对象，接下来使用urllib2.urlopen(req)来打开这个网页 我们注意到在实例化Request对象的时候，队了url是必须的，还有几个默认的参数 基中data与header也是使用的比较多的，一些需要登录的才能浏览的网站经常需要这两个参数123456789import urllibimport urllib2url = 'http://www.baidu.com/'values = &#123;'name' : 'Michael Foord', 'location' : 'Northampton','language' : 'Python' &#125;data = urllib.urlencode(values)req = urllib2.Request(url,data)response = urllib2.urlopen(req)the_page = response.read() 这个例子是向百度发送几个数据，这个例子是会返回一个错误页面，很正常，因为我们在访问百度的时候并不需要post什么信息，post了倒是会出错 百度是找不到相应的网页就会报错。 当然这个是POST数据，也可以用在GET方法，稍将上面的代码进行改造 百度是通过http://www.baidu.com/s?wd=XXX 来进行查询的，这样我们需要将{‘wd’:’xxx’}这个字典进行urlencode1234567891011#coding:utf-8import urllibimport urllib2url = 'http://www.baidu.com/s'values = &#123;'wd':'杨彦星'&#125;data = urllib.urlencode(values)print dataurl2 = url+'?'+dataresponse = urllib2.urlopen(url2)the_page = response.read() 以下以模拟登录人人网然后再显示首页内容为例来详细说明一下cookie的使用，以下是文档中给的例子，我们就通过改造这个例子来实现我们想要的功能1234import cookielib, urllib2cj = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))r = opener.open(\"http://example.com/\") &#160;123456789101112#coding:utf-8import urllib2,urllibimport cookieliburl = r'http://www.renren.com/ajaxLogin'#创建一个cj的cookie的容器cj = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))#将要POST出去的数据进行编码data = urllib.urlencode(&#123;\"email\":email,\"password\":pass&#125;)r = opener.open(url,data) 当你看到有cj的时候,说明你已经访问了登录页面,是否正常登录你现在还看不出来,可以通过访问http://www.renren.com/home 来查看 上面的代码有两点要说明,我也是看了很长时间才明白 r = opener.open(url,data) 这句,为什么要使用opener这个对象来open,而不是用utllib2,urlopen?不光是例子里这么写,我们才这么写,通过改造我们也可以使用urllib2.urlopen,其实是因为opener是urllib2.bulid_opener创造出来的, 但是你可以这样理解,他build出来后,自已却并没有安装使用它,也没有它的属性与方法,如果想使urllib2也具有opener的属性与方法,可以先使用urllib2.install_opener(opener)来”安装”这个opener,安装完以后就可以使用urllib2来操作了123456789101112131415#coding:utf-8import urllib2,urllibimport cookieliburl = r'http://www.renren.com/ajaxLogin'#创建一个cj的cookie的容器cj = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))urllib2.install_opener(opener)#将要POST出去的数据进行编码data = urllib.urlencode(&#123;\"email\":email,\"password\":pass&#125;)#r = opener.open(url,data)如果没有上面的urllib2.install_opener方法，就必须这样写了r = urllib2.urlopen(url,data)html = urllib2.urlopen('http://www.renren.com/home').read() 同样urllib2还有proxy相关的handle,基本的思路和这个差不多","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python处理网页中的cookie","slug":"908","date":"2013-09-10T03:16:49.000Z","updated":"2017-12-16T10:10:42.039Z","comments":true,"path":"article/908.html","link":"","permalink":"https://www.yangyanxing.com/article/908.html","excerpt":"最近想要搭建个小黄鸡的微信应用，但是一路来发现，现在很多的方法都已经不能用了，我在本地试过，也试用过requests获取session的方法也不行，但是这经过这次折腾，倒是对cookie有了更多的了解，以下以python登录人人网的例子来介绍cookie的使用。cookie的定义可以参考百度百科，http://baike.baidu.com/subview/835/5062332.htm 但是里面说的乱七八糟的，而且好多重复，使用firefox或者fiddler等工具来抓取cookie在firefox下使用httpFox插件来查到人人网的登录时需要POST的地址是http://www.renren.com/ajaxLogin&#160;","text":"最近想要搭建个小黄鸡的微信应用，但是一路来发现，现在很多的方法都已经不能用了，我在本地试过，也试用过requests获取session的方法也不行，但是这经过这次折腾，倒是对cookie有了更多的了解，以下以python登录人人网的例子来介绍cookie的使用。cookie的定义可以参考百度百科，http://baike.baidu.com/subview/835/5062332.htm 但是里面说的乱七八糟的，而且好多重复，使用firefox或者fiddler等工具来抓取cookie在firefox下使用httpFox插件来查到人人网的登录时需要POST的地址是http://www.renren.com/ajaxLogin&#160;而且查看到需要POST的DATA有email和password python通过cookielib来处理cookie，以下是简单的代码1234567891011121314151617181920212223242526&gt;&gt;&gt; import urllib&gt;&gt;&gt; import urllib2,cookielib&gt;&gt;&gt; login_page = \"http://www.renren.com/ajaxLogin\"&gt;&gt;&gt; cj = cookielib.CookieJar()&gt;&gt;&gt; opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))&gt;&gt;&gt; opener.add_handler = [('User-agent','Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)')]&gt;&gt;&gt; data = urllib.urlencode(&#123;\"email\":'username',\"password\":'password'&#125;)&gt;&gt;&gt; opener.open(login_page,data)&lt;addinfourl at 53653216 whose fp = &lt;socket._fileobject object at 0x03307B70&gt;&gt;&gt;&gt;&gt; if cj:... for index,cookie in enumerate(cj):... print index,':',cookie...0 : &lt;Cookie _de=90D533AE20EB964CA96710977F452897 for .renren.com/&gt;1 : &lt;Cookie anonymid=hlehtdzg-8359yw for .renren.com/&gt;2 : &lt;Cookie first_login_flag=1 for .renren.com/&gt;3 : &lt;Cookie id=224967207 for .renren.com/&gt;4 : &lt;Cookie loginfrom=null for .renren.com/&gt;5 : &lt;Cookie p=9beb60859c004bcaf0a32ff2c973473d7 for .renren.com/&gt;6 : &lt;Cookie societyguester=86b6a6006002ab6316f708521ab50bfc7 for .renren.com/&gt;7 : &lt;Cookie t=86b6a6006002ab6316f708521ab50bfc7 for .renren.com/&gt;8 : &lt;Cookie xnsid=fa53da51 for .renren.com/&gt;9 : &lt;Cookie t=30af9ffe774f4d6f242e92da1ccd6670 for .renren.com/xtalk/&gt;10 : &lt;Cookie feedType=224967207_hot for .www.renren.com/&gt;11 : &lt;Cookie JSESSIONID=abc3IP9kEhTExblxcRfeu for www.renren.com/&gt;&gt;&gt;&gt; 可以和firebug或者httpFox中得到的cookie进行对比，值可能不一致，但key基本上是一致的，你每次登录应该都不一致 &#160; 我也尝试过使用fidder模拟发送没有cookie的POST数据，但是没有得到想要的返回值 而加上cookie信息以后就可以正常的跳转到自己的主页了 好了，基本上了解了python中使用cookie来发送登录信息，现在我们来写一个小脚本来登录自己人人网。123456789101112131415161718#encoding=utf-8import urllib2import urllibimport cookielibdef renrenBrower(url,user,password): login_page = \"http://www.renren.com/ajaxLogin\" try: cj = cookielib.CookieJar() opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj)) opener.addheaders = [('User-agent','Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)')] data = urllib.urlencode(&#123;\"email\":'user',\"password\":'password'&#125;) opener.open(login_page,data) op=opener.open(url) data= op.read() return data except Exception,e: print str(e)print renrenBrower(\"http://www.renren.com/home\",\"用户名\",\"密码\") &#160; 这样就可以将自己首页的信息显示出来了，其实在登录完以后，还可以接着写脚本来获取自己想要的信息，如朋友的新鲜事， 这里重点是使用SGMLParser来解析html代码 以下代码参考http://www.oschina.net/code/snippet_148170_10661&#160;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from sgmllib import SGMLParserimport sys,urllib2,urllib,cookielibclass spider(SGMLParser): def __init__(self,email,password): SGMLParser.__init__(self) self.h3=False self.h3_is_ready=False self.div=False self.h3_and_div=False self.a=False self.depth=0 self.names=\"\" self.dic=&#123;&#125; self.email=email self.password=password self.domain='renren.com' try: cookie=cookielib.CookieJar() cookieProc=urllib2.HTTPCookieProcessor(cookie) except: raise else: opener=urllib2.build_opener(cookieProc) urllib2.install_opener(opener) def login(self): url='http://www.renren.com/PLogin.do' postdata=&#123; 'email':self.email, 'password':self.password, 'domain':self.domain &#125; req=urllib2.Request( url, urllib.urlencode(postdata) ) self.file=urllib2.urlopen(req).read() #print self.file def start_h3(self,attrs): self.h3 = True def end_h3(self): self.h3=False self.h3_is_ready=True def start_a(self,attrs): if self.h3 or self.div: self.a=True def end_a(self): self.a=False def start_div(self,attrs): if self.h3_is_ready == False: return if self.div==True: self.depth += 1 for k,v in attrs: if k == 'class' and v == 'content': self.div=True; self.h3_and_div=True #h3 and div is connected def end_div(self): if self.depth == 0: self.div=False self.h3_and_div=False self.h3_is_ready=False self.names=\"\" if self.div == True: self.depth-=1 def handle_data(self,text): #record the name if self.h3 and self.a: self.names+=text #record says if self.h3 and (self.a==False): if not text:pass else: self.dic.setdefault(self.names,[]).append(text) return if self.h3_and_div: self.dic.setdefault(self.names,[]).append(text) def show(self): type = sys.getfilesystemencoding() for key in self.dic: print ( (''.join(key)).replace(' ','')).decode('utf-8').encode(type), ( (''.join(self.dic[key])).replace(' ','')).decode('utf-8').encode(type)if __name__ =='__main__': renrenspider=spider('email','password') renrenspider.login() renrenspider.feed(renrenspider.file) renrenspider.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"使用python抓取360搜索联想词","slug":"877","date":"2013-09-03T17:09:19.000Z","updated":"2017-12-16T15:53:24.146Z","comments":true,"path":"article/877.html","link":"","permalink":"https://www.yangyanxing.com/article/877.html","excerpt":"几乎所有的搜索引擎都提供联想词提示，这个小脚本其实功能性不大，只当作使用urllib2发http请求和如何使用代理来访问 参考文章 http://video.sina.com.cn/v/b/113293169-1631501663.html","text":"几乎所有的搜索引擎都提供联想词提示，这个小脚本其实功能性不大，只当作使用urllib2发http请求和如何使用代理来访问 参考文章 http://video.sina.com.cn/v/b/113293169-1631501663.html http://obmem.info/?p=4712345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8import urllib,urllib2，cookielibimport re,timefrom random import choiceiplist = ['1.93.21.147:2222','42.96.129.66:80','59.57.15.71:80']#代理的列表，可以到网上搜，有好多wordlist = ['生活','杨','彦','星']#想要搜索的关键词列表for w in wordlist: ip = choice(iplist) word = urllib.quote(w)#使用urllib库中的quite方法将关键词进行编码 url = r'http://sug.so.360.cn/suggest/word?callback=suggest_so&amp;encodein=utf-8&amp;encodeout=utf-8&amp;word=%s'% word #用一个字典来存储header里的内容，这样做主要是为了不让360搜索来屏蔽机器人的采集 #可以使用firebug等工具来查看 header = &#123; 'GET':url, 'Host':'sug.so.360.cn', 'Referer':r'http://www.so.com/', 'User-Agent':'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36' &#125; #以下是采用代理方式来访问360搜索 proxy_support = urllib2.ProxyHandler(&#123;'http':'http://'+ip&#125;) opener = urllib2.build_opener(proxy_support,urllib2.HTTPHandler) urllib2.install_opener(opener)## cookie_support= urllib2.HTTPCookieProcessor(cookielib.CookieJar())## opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler)## urllib2.install_opener(opener)## 如果想要即要cookies又要代理，可以使用以下结构## opener = urllib2.build_opener(proxy_support, cookie_support, urllib2.HTTPHandler)#### content = urllib2.urlopen('url').read()req = urllib2.Request(url) #创建一个请求#把header元素加入到请求中for key in header:req.add_header(key,header[key])html = urllib2.urlopen(req).read()ss = re.findall(\"\"(.*?)\"\",html) #使用正则将联想词匹配出来for item in ss:print item time.sleep(3)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python解析json","slug":"874","date":"2013-08-27T17:23:05.000Z","updated":"2019-01-21T13:52:10.319Z","comments":true,"path":"article/874.html","link":"","permalink":"https://www.yangyanxing.com/article/874.html","excerpt":"相对于python解析XML来说，我还是比较喜欢json的格式返回，现在一般的api返回都会有json与XML格式的选择，json的解析起来个人觉得相对简单些 先看一个简单的豆瓣的图书查询的api返回","text":"相对于python解析XML来说，我还是比较喜欢json的格式返回，现在一般的api返回都会有json与XML格式的选择，json的解析起来个人觉得相对简单些 先看一个简单的豆瓣的图书查询的api返回 http://api.douban.com/v2/book/isbn/97872180873511&#123;\"rating\":&#123;\"max\":10,\"numRaters\":79,\"average\":\"9.1\",\"min\":0&#125;,\"subtitle\":\"\",\"author\":[\"野夫\"],\"pubdate\":\"2013-9\",\"tags\":[&#123;\"count\":313,\"name\":\"野夫\",\"title\":\"野夫\"&#125;,&#123;\"count\":151,\"name\":\"散文随笔\",\"title\":\"散文随笔\"&#125;,&#123;\"count\":83,\"name\":\"身边的江湖\",\"title\":\"身边的江湖\"&#125;,&#123;\"count\":82,\"name\":\"土家野夫\",\"title\":\"土家野夫\"&#125;,&#123;\"count\":70,\"name\":\"散文\",\"title\":\"散文\"&#125;,&#123;\"count\":44,\"name\":\"中国文学\",\"title\":\"中国文学\"&#125;,&#123;\"count\":43,\"name\":\"随笔\",\"title\":\"随笔\"&#125;,&#123;\"count\":38,\"name\":\"中国现当代文学\",\"title\":\"中国现当代文学\"&#125;],\"origin_title\":\"\",\"image\":\"http://img5.douban.com/mpic/s27008269.jpg\",\"binding\":\"\",\"translator\":[],\"catalog\":\"自序 让记忆抵抗n001 掌瓢黎爷n024 遗民老谭n039 乱世游击：表哥的故事n058 绑赴刑场的青春n076 风住尘香花已尽n083 “酷客”李斯n100 散材毛喻原n113 颓世华筵忆黄门n122 球球外传：n一个时代和一只小狗的际遇n141 童年的恐惧与仇恨n151 残忍教育n167 湖山一梦系平生n174 香格里拉散记n208 民国屐痕\",\"pages\":\"256\",\"images\":&#123;\"small\":\"http://img5.douban.com/spic/s27008269.jpg\",\"large\":\"http://img5.douban.com/lpic/s27008269.jpg\",\"medium\":\"http://img5.douban.com/mpic/s27008269.jpg\"&#125;,\"alt\":\"http://book.douban.com/subject/25639223/\",\"id\":\"25639223\",\"publisher\":\"广东人民出版社\",\"isbn10\":\"7218087353\",\"isbn13\":\"9787218087351\",\"title\":\"身边的江湖\",\"url\":\"http://api.douban.com/v2/book/25639223\",\"alt_title\":\"\",\"author_intro\":\"郑世平，笔名野夫，网名土家野夫。毕业于武汉大学，曾当过警察、囚徒、书商。曾出版历史小说《父亲的战争》、散文集《江上的母亲》（获台北2010国际书展非虚构类图书大奖，是该奖项第一个大陆得主）、散文集《乡关何处》（被新浪网、凤凰网、新华网分别评为2012年年度好书）。\",\"summary\":\"1.野夫书稿中被删减最少，最能体现作者观点、情感的作品。n2.文字凝练，具有极强的感染力。以一枝孤笔书写那些就在你我身边的大历史背景下普通人的生活变迁。n3\\. 柴静口中“一半像警察，一半像土匪”的野夫，以其特有的韵律表达世间的欢笑和悲苦。\",\"price\":\"32元\"&#125; 看起来别提多乱了，现在我们将其格式进行简单的整理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#123;rating: &#123;max: 10,numRaters: 79,average: \"9.1\",min: 0&#125;,subtitle: \"\",author: [\"野夫\"],pubdate: \"2013-9\",tags: [&#123;count: 313,name: \"野夫\",title: \"野夫\"&#125;,&#123;count: 151,name: \"散文随笔\",title: \"散文随笔\"&#125;,&#123;count: 83,name: \"身边的江湖\",title: \"身边的江湖\"&#125;,&#123;count: 82,name: \"土家野夫\",title: \"土家野夫\"&#125;,&#123;count: 70,name: \"散文\",title: \"散文\"&#125;,&#123;count: 44,name: \"中国文学\",title: \"中国文学\"&#125;,&#123;count: 43,name: \"随笔\",title: \"随笔\"&#125;,&#123;count: 38,name: \"中国现当代文学\",title: \"中国现当代文学\"&#125;],origin_title: \"\",image: \"http://img5.douban.com/mpic/s27008269.jpg\",binding: \"\",translator: [ ],catalog: \"自序 让记忆抵抗 001 掌瓢黎爷 024 遗民老谭 039 乱世游击：表哥的故事 058 绑赴刑场的青春 076 风住尘香花已尽 083 “酷客”李斯 100 散材毛喻原 113 颓世华筵忆黄门 122 球球外传： 一个时代和一只小狗的际遇 141 童年的恐惧与仇恨 151 残忍教育 167 湖山一梦系平生 174 香格里拉散记 208 民国屐痕\",pages: \"256\",images: &#123;small: \"http://img5.douban.com/spic/s27008269.jpg\",large: \"http://img5.douban.com/lpic/s27008269.jpg\",medium: \"http://img5.douban.com/mpic/s27008269.jpg\"&#125;,alt: \"http://book.douban.com/subject/25639223/\",id: \"25639223\",permalink: \"25639223\",publisher: \"广东人民出版社\",isbn10: \"7218087353\",isbn13: \"9787218087351\",title: \"身边的江湖\",url: \"http://api.douban.com/v2/book/25639223\",alt_title: \"\",author_intro: \"郑世平，笔名野夫，网名土家野夫。毕业于武汉大学，曾当过警察、囚徒、书商。曾出版历史小说《父亲的战争》、散文集《江上的母亲》（获台北2010国际书展非虚构类图书大奖，是该奖项第一个大陆得主）、散文集《乡关何处》（被新浪网、凤凰网、新华网分别评为2012年年度好书）。\",summary: \"1.野夫书稿中被删减最少，最能体现作者观点、情感的作品。 2.文字凝练，具有极强的感染力。以一枝孤笔书写那些就在你我身边的大历史背景下普通人的生活变迁。 3\\. 柴静口中“一半像警察，一半像土匪”的野夫，以其特有的韵律表达世间的欢笑和悲苦。\",price: \"32元\"&#125; 下面我们通过python来取出想要的信息，比如我们想要rating,images里的large和summary 1234567import urllib2import jsonhtml = urllib2.urlopen(r'http://api.douban.com/v2/book/isbn/9787218087351')hjson = json.loads(html.read())print hjson['rating']print hjson['images']['large']print hjson['summary'] 是不是很简单，其实只要把返回的json格式嵌套搞清楚，json还是比较简单的","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"Python解析XML文档","slug":"872","date":"2013-08-27T16:32:24.000Z","updated":"2017-12-16T10:10:42.294Z","comments":true,"path":"article/872.html","link":"","permalink":"https://www.yangyanxing.com/article/872.html","excerpt":"解析XML主要用到pytohn自带的XML库，其次还是lxml库 XML结构先以一个相对简单但功能比较全的XML文档为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'&gt; &lt;title&gt;dive into mark&lt;/title&gt; &lt;subtitle&gt;currently between addictions&lt;/subtitle&gt; &lt;id&gt;tag:diveintomark.org,2001-07-29:/&lt;/id&gt; &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/'/&gt; &lt;entry&gt; &lt;author&gt; &lt;name&gt;Mark&lt;/name&gt; &lt;uri&gt;http://diveintomark.org/&lt;/uri&gt; &lt;/author&gt; &lt;title&gt;Dive into history, 2009 edition&lt;/title&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/&gt; &lt;id&gt;tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id&gt; &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt; &lt;published&gt;2009-03-27T17:20:42Z&lt;/published&gt; &lt;category scheme='http://diveintomark.org' term='diveintopython'/&gt; &lt;category scheme='http://diveintomark.org' term='docbook'/&gt; &lt;category scheme='http://diveintomark.org' term='html'/&gt; &lt;summary type='html'&gt;Putting an entire chapter on one page sounds bloated, but consider this &amp;mdash; my longest chapter so far would be 75 printed pages, and it loads in under 5 seconds&amp;hellip; On dialup.&lt;/summary&gt; &lt;/entry&gt; &lt;entry&gt; &lt;author&gt; &lt;name&gt;Mark&lt;/name&gt; &lt;uri&gt;http://diveintomark.org/&lt;/uri&gt; &lt;/author&gt; &lt;title&gt;Accessibility is a harsh mistress&lt;/title&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'/&gt; &lt;id&gt;tag:diveintomark.org,2009-03-21:/archives/20090321200928&lt;/id&gt; &lt;updated&gt;2009-03-22T01:05:37Z&lt;/updated&gt; &lt;published&gt;2009-03-21T20:09:28Z&lt;/published&gt; &lt;category scheme='http://diveintomark.org' term='accessibility'/&gt; &lt;summary type='html'&gt;The accessibility orthodoxy does not permit people to question the value of features that are rarely useful and rarely used.&lt;/summary&gt; &lt;/entry&gt; &lt;entry&gt; &lt;author&gt; &lt;name&gt;Mark&lt;/name&gt; &lt;/author&gt; &lt;title&gt;A gentle introduction to video encoding, part 1: container formats&lt;/title&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'/&gt; &lt;id&gt;tag:diveintomark.org,2008-12-18:/archives/20081218155422&lt;/id&gt; &lt;updated&gt;2009-01-11T19:39:22Z&lt;/updated&gt; &lt;published&gt;2008-12-18T15:54:22Z&lt;/published&gt; &lt;category scheme='http://diveintomark.org' term='asf'/&gt; &lt;category scheme='http://diveintomark.org' term='avi'/&gt; &lt;category scheme='http://diveintomark.org' term='encoding'/&gt; &lt;category scheme='http://diveintomark.org' term='flv'/&gt; &lt;category scheme='http://diveintomark.org' term='GIVE'/&gt; &lt;category scheme='http://diveintomark.org' term='mp4'/&gt; &lt;category scheme='http://diveintomark.org' term='ogg'/&gt; &lt;category scheme='http://diveintomark.org' term='video'/&gt; &lt;summary type='html'&gt;These notes will eventually become part of a tech talk on video encoding.&lt;/summary&gt; &lt;/entry&gt;&lt;/feed&gt; 先简单的看一下这个XML的结构","text":"解析XML主要用到pytohn自带的XML库，其次还是lxml库 XML结构先以一个相对简单但功能比较全的XML文档为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'&gt; &lt;title&gt;dive into mark&lt;/title&gt; &lt;subtitle&gt;currently between addictions&lt;/subtitle&gt; &lt;id&gt;tag:diveintomark.org,2001-07-29:/&lt;/id&gt; &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/'/&gt; &lt;entry&gt; &lt;author&gt; &lt;name&gt;Mark&lt;/name&gt; &lt;uri&gt;http://diveintomark.org/&lt;/uri&gt; &lt;/author&gt; &lt;title&gt;Dive into history, 2009 edition&lt;/title&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/&gt; &lt;id&gt;tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id&gt; &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt; &lt;published&gt;2009-03-27T17:20:42Z&lt;/published&gt; &lt;category scheme='http://diveintomark.org' term='diveintopython'/&gt; &lt;category scheme='http://diveintomark.org' term='docbook'/&gt; &lt;category scheme='http://diveintomark.org' term='html'/&gt; &lt;summary type='html'&gt;Putting an entire chapter on one page sounds bloated, but consider this &amp;mdash; my longest chapter so far would be 75 printed pages, and it loads in under 5 seconds&amp;hellip; On dialup.&lt;/summary&gt; &lt;/entry&gt; &lt;entry&gt; &lt;author&gt; &lt;name&gt;Mark&lt;/name&gt; &lt;uri&gt;http://diveintomark.org/&lt;/uri&gt; &lt;/author&gt; &lt;title&gt;Accessibility is a harsh mistress&lt;/title&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'/&gt; &lt;id&gt;tag:diveintomark.org,2009-03-21:/archives/20090321200928&lt;/id&gt; &lt;updated&gt;2009-03-22T01:05:37Z&lt;/updated&gt; &lt;published&gt;2009-03-21T20:09:28Z&lt;/published&gt; &lt;category scheme='http://diveintomark.org' term='accessibility'/&gt; &lt;summary type='html'&gt;The accessibility orthodoxy does not permit people to question the value of features that are rarely useful and rarely used.&lt;/summary&gt; &lt;/entry&gt; &lt;entry&gt; &lt;author&gt; &lt;name&gt;Mark&lt;/name&gt; &lt;/author&gt; &lt;title&gt;A gentle introduction to video encoding, part 1: container formats&lt;/title&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'/&gt; &lt;id&gt;tag:diveintomark.org,2008-12-18:/archives/20081218155422&lt;/id&gt; &lt;updated&gt;2009-01-11T19:39:22Z&lt;/updated&gt; &lt;published&gt;2008-12-18T15:54:22Z&lt;/published&gt; &lt;category scheme='http://diveintomark.org' term='asf'/&gt; &lt;category scheme='http://diveintomark.org' term='avi'/&gt; &lt;category scheme='http://diveintomark.org' term='encoding'/&gt; &lt;category scheme='http://diveintomark.org' term='flv'/&gt; &lt;category scheme='http://diveintomark.org' term='GIVE'/&gt; &lt;category scheme='http://diveintomark.org' term='mp4'/&gt; &lt;category scheme='http://diveintomark.org' term='ogg'/&gt; &lt;category scheme='http://diveintomark.org' term='video'/&gt; &lt;summary type='html'&gt;These notes will eventually become part of a tech talk on video encoding.&lt;/summary&gt; &lt;/entry&gt;&lt;/feed&gt; 先简单的看一下这个XML的结构123456789101112131415161718192021&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'&gt; #这里定义了命名空间(namespace) http://www.w3.org/2005/Atom &lt;title&gt;&lt;/title&gt; &lt;subtitle&gt;&lt;/subtitle&gt; &lt;id&gt;&lt;/id&gt; &lt;updated&gt;&lt;/updated&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/'/&gt; #这里的&lt;link&gt;没有text，但是里面有相应的属性 &lt;entry&gt; &lt;author&gt; &lt;name&gt;&lt;/name&gt; &lt;uri&gt;&lt;/uri&gt; &lt;/author&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/&gt; &lt;id&gt;&lt;/id&gt; &lt;updated&gt;&lt;/updated&gt; &lt;published&gt;&lt;/published&gt; &lt;category scheme='http://diveintomark.org' term='diveintopython'/&gt; &lt;summary type='html'&gt;&lt;/summary&gt; &lt;/entry&gt;&lt;/feed&gt; 首先有一个全局的根元素 在根元素下面有title,subtitle,id,update,link,entry子元素 在entry元素下面还有author,title,link,id,updated,published,category,summary子元素 （姑且称为孙元素） 在author元素下面还有name,uri子元素（这该称为曾孙元素了吧~ 哈哈） 结构还是挺清晰的 下面我们用python的方法来一步步的取出在元素&lt;&gt;&lt;/&gt;这间的content以为元素内的属性 使用的方法主要有 tree = etree.parse() 解析XML root = tree.getroot() 得到根元素 root.tag 根元素名称 root.attrib 显示元素的属性 root.findall() 查找元素 下面请看代码，都已经将注释与结果写在里面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import xml.etree.ElementTree as etree #将xml.etree.ElementTree引入tree = etree.parse('feed.xml') #解析XMLroot = tree.getroot()print root# &lt;Element &#123;http://www.w3.org/2005/Atom&#125;feed at cd1eb0&gt;#元素即列表print root.tag#&#123;http://www.w3.org/2005/Atom&#125;feed# ElementTree使用&#123;namespace&#125;localname来表达xml元素for child in root: print child # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;title at e2b5d0&gt; # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;subtitle at e2b4e0&gt; # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;id at e2b6c0&gt; # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;updated at e2b6f0&gt; # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;link at e2b4b0&gt; # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;entry at e2b720&gt; # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;entry at e2b510&gt; # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;entry at e2b750&gt; # 这里只显示一级子元素，而子元素的子元素将不会被遍历#属性即字典print root.attrib#&#123;'&#123;http://www.w3.org/XML/1998/namespace&#125;lang': 'en'&#125;#我们注意到feed下面的link这个元素有属性print root[4].attrib#&#123;'href': 'http://diveintomark.org/', 'type': 'text/html', 'rel': 'alternate'&#125;print root[3].attrib#&#123;&#125; 将会得到一个空字典，因为updated元素内没有属性值#查找元素entrylist = root.findall('&#123;http://www.w3.org/2005/Atom&#125;entry')print entrylist# [&lt;Element &#123;http://www.w3.org/2005/Atom&#125;entry at 18423a0&gt;, &lt;Element &#123;http://www.w# 3.org/2005/Atom&#125;entry at 18425d0&gt;, &lt;Element &#123;http://www.w3.org/2005/Atom&#125;entry a# t 1842968&gt;]print root.findall('&#123;http://www.w3.org/2005/Atom&#125;author')# 这里将得到一个空列表，因为author不是feed的直接子元素#查找子元素entries = tree.findall('&#123;http://www.w3.org/2005/Atom&#125;entry') #先找到entry元素·title = entries[0].find('&#123;http://www.w3.org/2005/Atom&#125;title')#接着再找title元素print title.text#'Dive into history, 2009 edition'all_links = tree.findall('//&#123;http://www.w3.org/2005/Atom&#125;link') #在元素前面加'//' 则可以在所有元素里查找包括子元素和孙元素# [&lt;Element &#123;http://www.w3.org/2005/Atom&#125;link at e181b0&gt;, # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;link at e2b570&gt;, # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;link at e2b480&gt;, # &lt;Element &#123;http://www.w3.org/2005/Atom&#125;link at e2b5a0&gt;]print all_links[0].attrib #将会得到这个Link的属性字典 # &#123;'href': 'http://diveintomark.org/', # 'type': 'text/html', # 'rel': 'alternate'&#125; 关于XML库解析与查找XML文档基本的方法就这些了，现在通过一个实例来学以至用下 还是回到微信的XML解析上微信将用户的信息POST到你的服务器上，基本形式如下12345678&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt; 现在我们来通过上面介绍的方法来获得元素中的‘this is a test’字段12345678910111213import xml.etree.ElementTree as etreeweixinxml = etree.parse('weixinpost.xml')wroot = weixinxml.getroot()print wroot.tagfor child in wroot: print child.tagif wroot.find('Content') is not None: print wroot.find('Content').textelse: print 'Nothing found' 这样简单几步就可以把想要的内容取出来了 参考文章 http://woodpecker.org.cn/diveintopython3/xml.html","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"},{"name":"xml","slug":"xml","permalink":"https://www.yangyanxing.com/tags/xml/"}]},{"title":"使用python一步一步搭建微信公众平台（一）","slug":"871","date":"2013-08-24T11:03:05.000Z","updated":"2017-12-16T15:55:19.459Z","comments":true,"path":"article/871.html","link":"","permalink":"https://www.yangyanxing.com/article/871.html","excerpt":"最近无聊，想玩玩微信的公众平台，后来发现乐趣无穷啊~ 使用的工具，python 新浪SAE平台，微信的公众平台 你需要先在微信的公众平台与新浪SAE平台上各种注册，微信平台注册的时候需要你拍张手持身份证的照片，还有几天的审核期 微信公众平台：http://mp.weixin.qq.com","text":"最近无聊，想玩玩微信的公众平台，后来发现乐趣无穷啊~ 使用的工具，python 新浪SAE平台，微信的公众平台 你需要先在微信的公众平台与新浪SAE平台上各种注册，微信平台注册的时候需要你拍张手持身份证的照片，还有几天的审核期 微信公众平台：http://mp.weixin.qq.com 新浪SAE：http://sae.sina.com.cn/ 等待微信公众审核通过后，登录公众平台后，点击高级功能。将会看到需要提供一个接入信息： 微信接口配置[/caption] 那么我们需要一个网址作为接口（这时就需要SAE上搭建Python的一个应用），Token呢，就是相当于我们和微信之间约定的“密码”，这里可以随便填写英文或者数字，但实测输入纯数字有时会有问题，所以还是字符串比较靠谱。 第一步，在SAE上搭建python的应用在下图的应用里选择python应用。 填好二级域名和应用名称等，选择好语言。这里我们使用Python开发选择web应用。创建好应用之后，在代码管理中创建一个新的版本。而后我们可以选择编辑代码。能够实现在线编辑，根本用不着配置本地环境，SVN等等。当然像这种轻量级的应用在线编辑器就可以了，SVN的话还不如在线编辑好用 第二步，编写index.wsgi因为我们使用的是web.py框架，因为其良好的xml解析，想了解web.py的童鞋可以移步 http://webpy.org/docs/0.3/tutorial.zh-cn 首先编写config.yaml123456789name: yangyanxingversion: 1libraries:- name: webpy version: \"0.36\"- name: lxml version: \"2.3.4\" 注意严格的缩进，差一个空格你就废了！而且调试的时候很不好发现问题。。。 接着我们继续编写index.wgsi123456789101112131415161718# coding: UTF-8import osimport saeimport webfrom weixinInterface import WeixinInterfaceurls = ('/weixin','WeixinInterface')app_root = os.path.dirname(__file__)templates_root = os.path.join(app_root, 'templates')render = web.template.render(templates_root)app = web.application(urls, globals()).wsgifunc()application = sae.create_wsgi_app(app)&lt;/pre&gt; 简单解释一下， from weixinInterface import WeixinInterface这里我们需要再创建一个weixinIterface的py文件，你也可以将这个类写在index.wgsi文件中，只是这样看起来会乱乱的 新建一个weixinIterface.py文件，注意大小写，写入以下代码123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import hashlibimport webimport lxmlimport timeimport osimport urllib2,jsonfrom lxml import etreeclass WeixinInterface: def __init__(self): self.app_root = os.path.dirname(__file__) self.templates_root = os.path.join(self.app_root, 'templates') self.render = web.template.render(self.templates_root) def GET(self): #获取输入参数 data = web.input() signature=data.signature timestamp=data.timestamp nonce=data.nonce echostr=data.echostr #自己的token token=\"yangyanxing\" #这里改写你在微信公众平台里输入的token #字典序排序 list=[token,timestamp,nonce] list.sort() sha1=hashlib.sha1() map(sha1.update,list) hashcode=sha1.hexdigest() #sha1加密算法 #如果是来自微信的请求，则回复echostr if hashcode == signature: return echostr 这里定义了一个GET方法，是根据微信公众平台的要求，进行的token验证，因为这里我们定义了templates_root为根目录下的templates，所以还要在根目录下创建一个目录teplatest的目录开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，否则接入失败。 signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 加密/校验流程：1. 将token、timestamp、nonce三个参数进行字典序排序2. 将三个参数字符串拼接成一个字符串进行sha1加密3. 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信因为微信是将验证信息GET发出去的，所以这里使用了GET方法来取得值并且返回相应用值 保存全部，现在回到微信的公众平台高级管理界面 在url里面填写你在新浪SAE里应用名称并且加上/weixin，如：http://XXXX.sinaapp.com/weixin token随便输入，只要注意更改weixinInterface.py中的token就行了，输入好了以后点击提交，如果没有什么问题的话就会通过验证！ 第三步，新建一个简单的自动回复的方法鹦鹉学舌，就是用户说什么，它也回复什么，没什么用，只是随便玩玩！ 在weixinInterface.py里继续添加代码12345678def POST(self): str_xml = web.data() #获得post来的数据 xml = etree.fromstring(str_xml)#进行XML解析 content=xml.find(\"Content\").text#获得用户所输入的内容 msgType=xml.find(\"MsgType\").text fromUser=xml.find(\"FromUserName\").text toUser=xml.find(\"ToUserName\").text return self.render.reply_text(fromUser,toUser,int(time.time()),u\"我现在还在开发中，还没有什么功能，您刚才说的是：\"+content) 这个def 是和上一个GET同级的，注意缩进 接着我们在templates目录下创建reply_text.xml模板文件，写入以下代码12345678$def with (toUser,fromUser,createTime,content)&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[$toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[$fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;$createTime&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[$content]]&gt;&lt;/Content&gt;&lt;/xml&gt; 注意这里的toUser与fromUser是刚才post的是相反的，因为这里的toUser也就是POST函数里的fromUser，这里的fromUser也就是POST函数里的toUser,msgType是text 全部保存，现在就在用你的个人微信关注一下你创建的公众微信号，然后随便输入些内容，如果没有什么问题，你将会收到一条鹦鹉学舌的回复内容！ 参考文章：http://www.nilday.com/%E5%88%A9%E7%94%A8sae%E6%90%AD%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89web-py%E5%AE%9E%E7%8E%B0%E7%9A%84sae-hello-world/","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python发邮件是件很简单的事情","slug":"870","date":"2013-08-07T16:09:33.000Z","updated":"2017-12-16T10:10:42.402Z","comments":true,"path":"article/870.html","link":"","permalink":"https://www.yangyanxing.com/article/870.html","excerpt":"","text":"利用python的smtplib，发邮件将是一件非常简单的事情，下文以用163邮箱来发邮件为例，说明smtplib的应用12345678910111213141516171819202122232425262728#coding:utf-8import smtplibdef sendMail(mail_to): mail_server = 'smtp.163.com' mail_port = '25' username = 'soar_1987@163.com' password = 'XXXXXXXX' mail_title = 'python Test' mail_content = 'This is a test from python for sending email' if type(mail_to) == str:#之所以要有这样的判断是为了收件人是多个人或者传入的的收件人列表是以list的方式 mail_list = mail_to.split(';') #将str类型的数据转换为list elif type(mail_to) == list: mail_list = mail_to else: print \"你输入的收件人格式有误\" try: handle = smtplib.SMTP(mail_server,mail_port) handle.login(username,password) msg = \"From:%srn To:%srnContent-Type: text/html;charset=gb2312rnSubject:%srnrn %s\"%(\"杨彦星\",\";\".join(mail_list),mail_title,mail_content) #这里的msg其实就是一种固定的格式，From:To:Subject handle.sendmail(username,mail_list,msg) print \"Send email sucess\" except Exception,e: print \"Send email failed because %s\" % eif __name__ ==\"__main__\": sendMail('yanxingyang@gmail.com')","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"可爱的python中的一个与递归相关的小问题","slug":"821","date":"2013-06-22T17:41:21.000Z","updated":"2017-12-16T10:10:42.319Z","comments":true,"path":"article/821.html","link":"","permalink":"https://www.yangyanxing.com/article/821.html","excerpt":"可爱的python一书中有一个练习题，是在一个目录中查找特定扩展名的文件，并且读取里面的内容，然后用户输入一个关键词，在这些文件中进行搜索，如果找到后就把这一行内容打印出来，他提出的问题是如果里面还有目录，目录里面还有更深的目录，解决这个问题，我想到的只能是递归。。。1234567891011121314151617181920212223242526#coding:utf-8import os,sysdef cdGrep(keyword,filepath): filelist = os.listdir(filepath) for cdc in filelist: if os.path.isdir(cdc): filepath2 = os.path.join(filepath,cdc) cdGrep(keyword,filepath2) elif '.txt' in cdc:# print filepath+cdc f = open(filepath+''+ cdc) for line in f.readlines(): linelower = line.lower() if keyword in linelower: print '您查找的关键词在%s中找到'% (filepath+''+cdc) print line f.close()if __name__ == '__main__': keword = raw_input('请输入想要查询的关键字') pw = os.getcwd() cdGrep(keword,pw)","text":"可爱的python一书中有一个练习题，是在一个目录中查找特定扩展名的文件，并且读取里面的内容，然后用户输入一个关键词，在这些文件中进行搜索，如果找到后就把这一行内容打印出来，他提出的问题是如果里面还有目录，目录里面还有更深的目录，解决这个问题，我想到的只能是递归。。。1234567891011121314151617181920212223242526#coding:utf-8import os,sysdef cdGrep(keyword,filepath): filelist = os.listdir(filepath) for cdc in filelist: if os.path.isdir(cdc): filepath2 = os.path.join(filepath,cdc) cdGrep(keyword,filepath2) elif '.txt' in cdc:# print filepath+cdc f = open(filepath+''+ cdc) for line in f.readlines(): linelower = line.lower() if keyword in linelower: print '您查找的关键词在%s中找到'% (filepath+''+cdc) print line f.close()if __name__ == '__main__': keword = raw_input('请输入想要查询的关键字') pw = os.getcwd() cdGrep(keword,pw) 但是这里出现一个问题，就是目录只能进行底下一层，再深的目录就不进行遍历了，很是郁闷，于是在德问网上问了下，很快就有人指出了我的错误出在哪了 if os.path.isdir(cdc):这里不应该写成cdc，如果是cdc的话如果他是一个目录的话，再到下一层系统是不能再识别的，应该是if os.path.isdir(os.path.join(filepath,cdc)):将cdc与之前的目录进行结合，这样系统才能正常的识别目录 这样，程序就可以很好的遍历目录了","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[]},{"title":"通过一个python小脚本来下载最新的360杀毒安装程序","slug":"817","date":"2013-06-03T11:21:12.000Z","updated":"2017-12-16T10:10:41.839Z","comments":true,"path":"article/817.html","link":"","permalink":"https://www.yangyanxing.com/article/817.html","excerpt":"","text":"小脚本很简单，主要是练习一下正则匹配，与简单的urllib库的应用 1234567891011121314151617181920212223242526#coding: utf8import urllib,reimport osdef getLastinstall(): page = urllib.urlopen(r'http://sd.360.cn/download_center.html') html = page.read() page.close() rematch = r'http://down.360.cn/360sd/360sd_se_(.*?)exe' replusmatch = r'http://down.360.cn/360sd/360sd_plus_(.*?)exe' stdname = '360sd_'+(str(re.compile(rematch).findall(html)[0]))+'exe' downurlstd = r'http://down.360.cn/360sd/360sd_'+(str(re.compile(rematch).findall(html)[0]))+'exe' powname = '360sd_plus_'+(str(re.compile(replusmatch).findall(html)[0]))+'exe' downurlpow = r'http://down.360.cn/360sd/360sd_plus_'+(str(re.compile(replusmatch).findall(html)[0]))+'exe' localpath = os.getcwd()+r'/installpack' if not (os.path.isfile(stdname) and os.path.isfile(powname)): if not os.path.isdir('installpack'): os.makedirs('installpack') urllib.urlretrieve(downurlstd,localpath+'/'+stdname) urllib.urlretrieve(downurlpow,localpath+'/'+powname) else: print '目录中已经是线上最新版杀毒安装程序'if __name__ =='__main__': getLastinstall()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"python中的OOP","slug":"813","date":"2013-06-01T14:17:55.000Z","updated":"2017-12-16T10:10:42.222Z","comments":true,"path":"article/813.html","link":"","permalink":"https://www.yangyanxing.com/article/813.html","excerpt":"","text":"直接上代码，已经在后面有注释了1234567891011121314151617181920212223242526272829303132333435363738#coding:utf8name = 'yangyanxing'class Test(): class kevin(): var1 = '我是内部类' name = 'kvein' gae = '26' def fun1(self): print self.name print '我是公共方法' self.__fun2() #可以通过公有就去来调用私有方法，在调用的过程中可以进行更改 def __fun2(self): print '我是私有方法' @classmethod def fun3(self): #可以不通过实例来访问这个类方法 print '#'*40 print self.name print '我是类方法' @staticmethod #静态方法，也是可以不通过实例对象就可以访问的方法但是在定义的时候不用加self def fun4(): print Test.name print name #这里的name是全局变量 Test.fun3() print '我是静态方法'print Test.name #公有属性可以直接方法，不用实例化对象yang = Test() #实例化一个类interyang = Test.kevin() #实例化一个内部类yang.fun1() #方法类里面的公共属性print interyang.var1 # 访问内部类里的属性Test.fun3()#访问类方法Test.fun4() 12345678910111213141516171819#coding:utf8class Test(): var1 = '类的公有属性' __var2 = '类的私有属性' def fun(self): self.var2 = '对象的公有属性' # 这里定义了一个对象的公有属性 self.__var3 = '对象的私有属性'# 这里定义了一个对象的私有属性 var4 = '函数的局部变量' #这里定义了一个函数的局部变量，这里面的var4只有在函数内部使用kevin = Test() #实例了一个对象yang = Test() #又实例了另外一个对象print kevin.var1##print kevin.__var2 #这里将无法访问kevin.fun()print kevin.var2 #在没有调用fun函数之前是没有var2的##print kevin.__var3 对象的私有属性是无法调用的##print yang.var2 #这里因为没有调用yang的fun方法，所以还是无法访问yang里的var2","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"一个python的小脚本登录人人并抓取新鲜事","slug":"806","date":"2013-05-28T16:30:48.000Z","updated":"2017-12-16T10:10:42.024Z","comments":true,"path":"article/806.html","link":"","permalink":"https://www.yangyanxing.com/article/806.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from sgmllib import SGMLParserimport sys,urllib2,urllib,cookielibclass spider(SGMLParser): def __init__(self,email,password): SGMLParser.__init__(self) self.h3=False self.h3_is_ready=False self.div=False self.h3_and_div=False self.a=False self.depth=0 self.names=\"\" self.dic=&#123;&#125; self.email=email self.password=password self.domain='renren.com' try: cookie=cookielib.CookieJar() cookieProc=urllib2.HTTPCookieProcessor(cookie) except: raise else: opener=urllib2.build_opener(cookieProc) urllib2.install_opener(opener) def login(self): url='http://www.renren.com/PLogin.do' postdata=&#123; 'email':self.email, 'password':self.password, 'domain':self.domain &#125; req=urllib2.Request( url, urllib.urlencode(postdata) ) self.file=urllib2.urlopen(req).read() #print self.file def start_h3(self,attrs): self.h3 = True def end_h3(self): self.h3=False self.h3_is_ready=True def start_a(self,attrs): if self.h3 or self.div: self.a=True def end_a(self): self.a=False def start_div(self,attrs): if self.h3_is_ready == False: return if self.div==True: self.depth += 1 for k,v in attrs: if k == 'class' and v == 'content': self.div=True; self.h3_and_div=True #h3 and div is connected def end_div(self): if self.depth == 0: self.div=False self.h3_and_div=False self.h3_is_ready=False self.names=\"\" if self.div == True: self.depth-=1 def handle_data(self,text): #record the name if self.h3 and self.a: self.names+=text #record says if self.h3 and (self.a==False): if not text:pass else: self.dic.setdefault(self.names,[]).append(text) return if self.h3_and_div: self.dic.setdefault(self.names,[]).append(text) def show(self): type = sys.getfilesystemencoding() for key in self.dic: print ( (''.join(key)).replace(' ','')).decode('utf-8').encode(type), ( (''.join(self.dic[key])).replace(' ','')).decode('utf-8').encode(type)if __name__ =='__main__': renrenspider=spider('email','password') renrenspider.login() renrenspider.feed(renrenspider.file) renrenspider.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"(转)抛砖引玉 正则表达式完成电话号码的匹配","slug":"779","date":"2013-03-18T15:24:26.000Z","updated":"2017-12-16T16:00:10.301Z","comments":true,"path":"article/779.html","link":"","permalink":"https://www.yangyanxing.com/article/779.html","excerpt":"原来地址：http://www.diveintopython.net/regular_expressions/phone_numbers.html 迄今为止，你主要是匹配整个模式，不论是匹配上，还是没有匹配上。但是正则表达式还有比这更为强大的功能。当一个模式确实 匹配上时，你可以获取模式中特定的片断，你可以发现具体匹配的位置。 这个例子来源于我遇到的另一个现实世界的问题，也是在以前的工作中遇到的。问题是：解析一个美国电话号码。客户要能 (在一个单一的区域中) 输入任何数字，然后存储区号、干线号、电话号和一个可选的独立的分机号到公司数据库里。为此，我通过网络找了很多正则表达式的例子，但是没有一个能够完全满足我的要求。 这里列举了我必须能够接受的电话号码： 800-555-1212 800 555 1212 800.555.1212 (800) 555-1212 1-800-555-1212 800-555-1212-1234 800-555-1212x1234 800-555-1212 ext. 1234 work 1-(800) 555.1212 #1234格式可真够多的！我需要知道区号是 800，干线号是 555，电话号的其他数字为 1212。对于那些有分机号的，我需要知道分机号为 1234。 让我们完成电话号码解析这个工作，这个例子展示第一步。例 7.10. 发现数字 phonePattern = re.compile(r’^(d{3})-(d{3})-(d{4})$’) (1)phonePattern.search(‘800-555-1212’).groups() (2)","text":"原来地址：http://www.diveintopython.net/regular_expressions/phone_numbers.html 迄今为止，你主要是匹配整个模式，不论是匹配上，还是没有匹配上。但是正则表达式还有比这更为强大的功能。当一个模式确实 匹配上时，你可以获取模式中特定的片断，你可以发现具体匹配的位置。 这个例子来源于我遇到的另一个现实世界的问题，也是在以前的工作中遇到的。问题是：解析一个美国电话号码。客户要能 (在一个单一的区域中) 输入任何数字，然后存储区号、干线号、电话号和一个可选的独立的分机号到公司数据库里。为此，我通过网络找了很多正则表达式的例子，但是没有一个能够完全满足我的要求。 这里列举了我必须能够接受的电话号码： 800-555-1212 800 555 1212 800.555.1212 (800) 555-1212 1-800-555-1212 800-555-1212-1234 800-555-1212x1234 800-555-1212 ext. 1234 work 1-(800) 555.1212 #1234格式可真够多的！我需要知道区号是 800，干线号是 555，电话号的其他数字为 1212。对于那些有分机号的，我需要知道分机号为 1234。 让我们完成电话号码解析这个工作，这个例子展示第一步。例 7.10. 发现数字 phonePattern = re.compile(r’^(d{3})-(d{3})-(d{4})$’) (1)phonePattern.search(‘800-555-1212’).groups() (2) (‘800’, ‘555’, ‘1212’) phonePattern.search(‘800-555-1212-1234’) (3) &gt;(1)我们通常从左到右阅读正则表达式。这个正则表达式匹配字符串的开始，接着匹配 (d{3})。d{3} 是什么呢？好吧，{3} 的含义是“精确匹配三个数字”；这是曾在前面见到过的 {n,m} 语法的一种变形。d 的含义是 “任何一个数字” (0 到 9)。把它们放大括号中意味着要“精确匹配三个数字位，接着把它们作为一个组保存下来，以便后面的调用”。接着匹配一个连字符，接着是另外一个精确匹配三个数字位的组，接着另外一个连字符，接着另外一个精确匹配四个数字为的组，接着匹配字符串的结尾。(2)为了访问正则表达式解析过程中记忆下来的多个组，我们使用 search 函数返回对象的 groups() 函数。这个函数将返回一个元组，元组中的元素就是正则表达式中定义的组。在这个例子中，定义了三个组，第一个组有三个数字位，第二个组有三个数字位，第三个组有四个数字位。(3)这个正则表达式不是最终的答案，因为它不能处理在电话号码结尾有分机号的情况，为此，我们需要扩展这个正则表达式。例 7.11. 发现分机号 phonePattern = re.compile(r’^(d{3})-(d{3})-(d{4})-(d+)$’) (1) phonePattern.search(‘800-555-1212-1234’).groups() (2) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘800 555 1212 1234’) (3) phonePattern.search(‘800-555-1212’) (4) (1)这个正则表达式和上一个几乎相同，正像前面的那样，匹配字符串的开始，接着匹配一个有三个数字位的组并记忆下来，接着是一个连字符，接着是一个有三个数字位的组并记忆下来，接着是一个连字符，接着是一个有四个数字位的组并记忆下来。不同的地方是你接着又匹配了另一个连字符，然后是一个有一个或者多个数字位的组并记忆下来，最后是字符串的结尾。(2)函数 groups() 现在返回一个有四个元素的元组，由于正则表达式中定义了四个记忆的组。(3)不幸的是，这个正则表达式也不是最终的答案，因为它假设电话号码的不同部分是由连字符分割的。如果一个电话号码是由空格符、逗号或者点号分割呢？你需要一个更一般的解决方案来匹配几种不同的分割类型。(4)啊呀！这个正则表达式不仅不能解决你想要的任何问题，反而性能更弱了，因为现在你甚至不能解析一个没有分机号的电话号码了。这根本不是你想要的，如果有分机号，你要知道分机号是什么，如果没有分机号，你仍然想要知道主电话号码的其他部分是什么。下一个例子展示正则表达式处理一个电话号码内部，采用不同分隔符的情况。例 7.12. 处理不同分隔符 phonePattern = re.compile(r’^(d{3})D+(d{3})D+(d{4})D+(d+)$’) (1)phonePattern.search(‘800 555 1212 1234’).groups() (2) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘800-555-1212-1234’).groups() (3) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘80055512121234’) (4)phonePattern.search(‘800-555-1212’) (5) (1)当心啦！你首先匹配字符串的开始，接着是一个三个数字位的组，接着是 D+，这是个什么东西？好吧，D 匹配任意字符，除了 数字位，+ 表示“1 个或者多个”，因此 D+ 匹配一个或者多个不是数字位的字符。这就是你替换连字符为了匹配不同分隔符所用的方法。(2)使用 D+ 代替 - 意味着现在你可以匹配中间是空格符分割的电话号码了。(3)当然，用连字符分割的电话号码也能够被识别。(4)不幸的是，这个正则表达式仍然不是最终答案，因为它假设电话号码一定有分隔符。如果电话号码中间没有空格符或者连字符的情况会怎样哪？(4)我的天！这个正则表达式也没有达到我们对于分机号识别的要求。现在你共有两个问题，但是你可以利用相同的技术来解决它们。下一个例子展示正则表达式处理没有 分隔符的电话号码的情况。例 7.13. 处理没有分隔符的数字 phonePattern = re.compile(r’^(d{3})D(d{3})D(d{4})D(d)$’) (1)phonePattern.search(‘80055512121234’).groups() (2) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘800.555.1212 x1234’).groups() (3) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘800-555-1212’).groups() (4) (‘800’, ‘555’, ‘1212’, ‘’) phonePattern.search(‘(800)5551212 x1234’) (5) (1)和上一步相比，你所做的唯一变化就是把所有的 + 变成 。在电话号码的不同部分之间不再匹配 D+，而是匹配 D 了。还记得 + 的含义是“1 或者多个”吗? 好的，* 的含义是“0 或者多个”。因此，现在你应该能够解析没有分隔符的电话号码了。(2)你瞧，它真的可以胜任。为什么？首先匹配字符串的开始，接着是一个有三个数字位 (800) 的组，接着是 0 个非数字字符，接着是一个有三个数字位 (555) 的组，接着是 0 个非数字字符，接着是一个有四个数字位 (1212) 的组，接着是 0 个非数字字符，接着是一个有任意数字位 (1234) 的组，最后是字符串的结尾。(3)对于其他的变化也能够匹配：比如点号分隔符，在分机号前面既有空格符又有 x 符号的情况也能够匹配。(4)最后，你已经解决了长期存在的一个问题：现在分机号是可选的了。如果没有发现分机号，groups() 函数仍然返回一个有四个元素的元组，但是第四个元素只是一个空字符串。(5)我不喜欢做一个坏消息的传递人，此时你还没有完全结束这个问题。还有什么问题呢？当在区号前面还有一个额外的字符时，而正则表达式假设区号是一个字符串的开始，因此不能匹配。这个不是问题，你可以利用相同的技术“0或者多个非数字字符”来跳过区号前面的字符。下一个例子展示如何解决电话号码前面有其他字符的情况。例 7.14. 处理开始字符 phonePattern = re.compile(r’^D(d{3})D(d{3})D(d{4})D(d*)$’) (1)phonePattern.search(‘(800)5551212 ext. 1234’).groups() (2) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘800-555-1212’).groups() (3) (‘800’, ‘555’, ‘1212’, ‘’) phonePattern.search(‘work 1-(800) 555.1212 #1234’) (4) (1)这个正则表达式和前面的几乎相同，但它在第一个记忆组 (区号) 前面匹配 D，0 或者多个非数字字符。注意，此处你没有记忆这些非数字字符 (它们没有被括号括起来)。如果你发现它们，只是跳过它们，接着只要匹配上就开始记忆区号。(2)你可以成功地解析电话号码，即使在区号前面有一个左括号。(在区号后面的右括号也已经被处理，它被看成非数字字符分隔符，由第一个记忆组后面的 D 匹配。)(3)进行仔细的检查，保证你没有破坏前面能够匹配的任何情况。由于首字符是完全可选的，这个模式匹配字符串的开始，接着是 0 个非数字字符，接着是一个有三个数字字符的记忆组 (800)，接着是 1 个非数字字符 (连字符)，接着是一个有三个数字字符的记忆组 (555)，接着是 1 个非数字字符 (连字符)，接着是一个有四个数字字符的记忆组 (1212)，接着是 0 个非数字字符，接着是一个有 0 个数字位的记忆组，最后是字符串的结尾。(4)此处是正则表达式让我产生了找一个硬东西挖出自己的眼睛的冲动。为什么这个电话号码没有匹配上？因为在它的区号前面有一个 1，但是你认为在区号前面的所有字符都是非数字字符 (D*)。唉！让我们往回看一下。迄今为止，正则表达式总是从一个字符串的开始匹配。但是现在你看到了，有很多不确定的情况需要你忽略。与其尽力全部匹配它们，还不如全部跳过它们，让我们采用一个不同的方法：根本不显式地匹配字符串的开始。下面的这个例子展示这个方法。例 7.15. 电话号码，无论何时我都要找到它 phonePattern = re.compile(r’(d{3})D(d{3})D(d{4})D(d)$’) (1)phonePattern.search(‘work 1-(800) 555.1212 #1234’).groups() (2) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘800-555-1212’) (3) (‘800’, ‘555’, ‘1212’, ‘’) phonePattern.search(‘80055512121234’) (4) (‘800’, ‘555’, ‘1212’, ‘1234’)(1)注意，在这个正则表达式的开始少了一个 ^ 字符。你不再匹配字符串的开始了，也就是说，你需要用你的正则表达式匹配整个输入字符串，除此之外没有别的意思了。正则表达式引擎将要努力计算出开始匹配输入字符串的位置，并且从这个位置开始匹配。(2)现在你可以成功解析一个电话号码了，无论这个电话号码的首字符是不是数字，无论在电话号码各部分之间有多少任意类型的分隔符。(3)仔细检查，这个正则表达式仍然工作的很好。(4)还是能够工作。看看一个正则表达式能够失控得多快？回头看看前面的例子，你还能区别它们么？ 当你还能够理解这个最终答案的时候 (这个正则表达式就是最终答案，即使你发现一种它不能处理的情况，我也真的不想知道它了)，在你忘记为什么你这么选择之前，让我们把它写成松散正则表达式的形式。例 7.16. 解析电话号码 (最终版本) phonePattern = re.compile(r’’’ # don’t match beginning of string, number can start anywhere ( d{3}) # area code is 3 digits (e.g. ‘800’) D* # optional separator is any number of non-digits (d{3}) # trunk is 3 digits (e.g. ‘555’) D* # optional separator(d{4}) # rest of number is 4 digits (e.g. ‘1212’) D* # optional separator (d*) # extension is optional and can be any number of digits $ # end of string ‘’’ , re.VERBOSE) phonePattern.search(‘work 1-(800) 555.1212 #1234’).groups() (1) (‘800’, ‘555’, ‘1212’, ‘1234’) phonePattern.search(‘800-555-1212’) (2) (‘800’, ‘555’, ‘1212’, ‘’)(1)除了被分成多行，这个正则表达式和最后一步的那个完全相同，因此它能够解析相同的输入一点也不奇怪。(2)进行最后的仔细检查。很好，仍然工作。你终于完成了这件任务。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[]},{"title":"(转)Python 参数知识（变量前加星号的意义）","slug":"775","date":"2013-03-16T12:24:01.000Z","updated":"2017-12-16T10:10:42.046Z","comments":true,"path":"article/775.html","link":"","permalink":"https://www.yangyanxing.com/article/775.html","excerpt":"原文地址：http://blog.csdn.net/qinyilang/article/details/5484415 **过量的参数 **在运行时知道一个函数有什么参数，通常是不可能的。另一个情况是一个函数能操作很多对象。更有甚者，调用自身的函数变成一种api提供给可用的应用。 对于这些情况，python提供了两种特别的方法来定义函数的参数，允许函数接受过量的参数，不用显式声明参数。这些“额外”的参数下一步再解释。 注意args和kwargs只是python的约定。任何函数参数，你可以自己喜欢的方式命名，但是最好和python标准的惯用法一致，以便你的代码，其他的程序员也能轻松读懂。位置参数 在参数名之前使用一个星号，就是让函数接受任意多的位置参数。 12345678910&gt;&gt;&gt; def multiply(*args):... total = 1... for arg in args:... total *= arg... return total...&gt;&gt;&gt; multiply(2, 3)6&gt;&gt;&gt; multiply(2, 3, 4, 5, 6)720","text":"原文地址：http://blog.csdn.net/qinyilang/article/details/5484415 **过量的参数 **在运行时知道一个函数有什么参数，通常是不可能的。另一个情况是一个函数能操作很多对象。更有甚者，调用自身的函数变成一种api提供给可用的应用。 对于这些情况，python提供了两种特别的方法来定义函数的参数，允许函数接受过量的参数，不用显式声明参数。这些“额外”的参数下一步再解释。 注意args和kwargs只是python的约定。任何函数参数，你可以自己喜欢的方式命名，但是最好和python标准的惯用法一致，以便你的代码，其他的程序员也能轻松读懂。位置参数 在参数名之前使用一个星号，就是让函数接受任意多的位置参数。 12345678910&gt;&gt;&gt; def multiply(*args):... total = 1... for arg in args:... total *= arg... return total...&gt;&gt;&gt; multiply(2, 3)6&gt;&gt;&gt; multiply(2, 3, 4, 5, 6)720 python把参数收集到一个元组中，作为变量args。显式声明的参数之外如果没有位置参数，这个参数就作为一个空元组。 **关键字参数 **python在参数名之前使用2个星号来支持任意多的关键字参数。 1234567&gt;&gt;&gt; def accept(**kwargs):... for keyword, value in kwargs.items():... print &quot;%s =&gt; %r&quot; % (keyword, value)...&gt;&gt;&gt; accept(foo=&apos;bar&apos;, spam=&apos;eggs&apos;)foo =&gt; &apos;bar&apos;spam =&gt; &apos;eggs&apos; 注意：kwargs是一个正常的python字典类型，包含参数名和值。如果没有更多的关键字参数，kwargs就是一个空字典。 混合参数类型 任意的位置参数和关键字参数可以和其他标准的参数声明一起使用。混合使用时要加些小心，因为python中他们的次序是重要的。参数归为4类，不是所有的类别都需要。他们必须按下面的次序定义，不用的可以跳过。 1）必须的参数2）可选的参数3）过量的位置参数4）过量的关键字参数 def complex_function(a, b=None, c, *d): 这个次序是必须的，因为args和*kwargs只接受那些没有放进来的其他任何参数。没有这个次序，当你调用一个带有位置参数的函数，python就不知道哪个值是已声明参数想要的，也不知道哪个被作为过量参数对待。 也要注意的是，当函数能接受许多必须的参数和可选的参数，那它只要定义一个过量的参数类型即可。 传递参数集合 除了函数能接受任意参数集合，python代码也可以调用带有任意多数量的函数，像前面说过的用星号。这种方式传递的参数由python扩展成为参数列表。以便被调用的函数不需要为了这样调用而去使用过量参数。python中任何可调用的，都能用这种技法来调用。并且用相同的次序规则和标准参数一起使用。123456789101112131415161718192021&gt;&gt;&gt; def add(a, b, c):... return a + b + c...&gt;&gt;&gt; add(1, 2, 3)6&gt;&gt;&gt; add(a=4, b=5, c=6)15&gt;&gt;&gt; args = (2, 3)&gt;&gt;&gt; add(1, *args)6&gt;&gt;&gt; kwargs=&#123;&apos;b&apos;: 8, &apos;c&apos;: 9&#125;&gt;&gt;&gt; add(a=7, **kwargs)24&gt;&gt;&gt; add(a=7, *args)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: add() got multiple values for keyword argument &apos;a&apos;&gt;&gt;&gt; add(1, 2, a=7)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: add() got multiple values for keyword argument &apos;a&apos;","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"迟暮之年，感慨之春","slug":"760","date":"2013-03-08T18:04:37.000Z","updated":"2017-12-16T10:10:42.520Z","comments":true,"path":"article/760.html","link":"","permalink":"https://www.yangyanxing.com/article/760.html","excerpt":"早上匆匆忙忙的上了拥挤的公交，其实后面还有更拥挤的地铁，麻木的内心其实早已习惯这种乱哄哄的狭小空间，打开手机，习惯性的打开阅读软件，浏览着早已下载好的离线新闻，公交每到一站，任凭司机撕心裂肺的倡导，能动则随着人流动，不能动就当什么都没有听到，当有乘客在拥挤的车厢内挤来挤去，有意无意的一些身体接触摩擦过后，一股想骂人的冲动只因为在转头都困难的环境下就忍了吧。 怎知每天这时都会有很多老年人来凑热闹，我有时真是由衷的佩服他们，满头白发，却还做着有些年轻人都不想做但不得不做的事情，挤来挤去的，也有不开眼的在座位上的乘客，依然玩着自己的手机或者补着晚上还没有做完的梦，于是老年人在还可以移动的情况下会继续寻找属于自己的“专座”。 而今天我放下了手机，不再看那些用数据堆起来的专题。只因两位特别的老人。","text":"早上匆匆忙忙的上了拥挤的公交，其实后面还有更拥挤的地铁，麻木的内心其实早已习惯这种乱哄哄的狭小空间，打开手机，习惯性的打开阅读软件，浏览着早已下载好的离线新闻，公交每到一站，任凭司机撕心裂肺的倡导，能动则随着人流动，不能动就当什么都没有听到，当有乘客在拥挤的车厢内挤来挤去，有意无意的一些身体接触摩擦过后，一股想骂人的冲动只因为在转头都困难的环境下就忍了吧。 怎知每天这时都会有很多老年人来凑热闹，我有时真是由衷的佩服他们，满头白发，却还做着有些年轻人都不想做但不得不做的事情，挤来挤去的，也有不开眼的在座位上的乘客，依然玩着自己的手机或者补着晚上还没有做完的梦，于是老年人在还可以移动的情况下会继续寻找属于自己的“专座”。 而今天我放下了手机，不再看那些用数据堆起来的专题。只因两位特别的老人。 嘈杂的车厢内，看着一位老妪步履蹒跚的上了车，目测有70多岁吧，可能是由于身材矮小的原因吧，再加上乱七八糟的环境，很少有人注意到她，即使她从我后边挤过去，我也没有更多的注意。 这时另一位坐在专座上的老人，目测60多岁吧，突然喊了一句“阿姨，您坐这里吧” 于是老妪挪动着不灵巧的身体说了声谢谢后，坐了下来。 写到这里，不要以为我是想说什么社会道德，这些东西还不足以让我停下手中的手机还静静的注意她们。之后她们开始了交谈，而内容却是我深深的思考中。 两们老人看到公车外面有人溜狗，于是找到了一个两个人都喜欢的话题，年长的说，我家也有一条小狗，10多年了，前段时间刚没的。 另一个说，那可够可惜的 “可不是嘛，我都不敢再养了，那条小狗有次我不想要了，想把它送出去，送了一个亲戚家，结果没几天它居然自己跑回来了，我听到大晚上的外面有挠门声，打开门一看，这小玩意居然自己跑回来了，当时我这眼泪啊，从此以后我就再不想把它送出去了” “可不是嘛，狗这东西通人性，也认路” 我清楚的看到老人摘下自己的老花镜，擦了擦红润的眼睛。 老人接着说，“我这小狗啊，养了10多年，最后那段日子，见了生人也不叫了，有点打蔫，再后来就不怎么吃食了，到最后眼睛都瞎了，我每天用针管给它喂水喂食” “那您可对它真是细心” “最后看着太难受了，送医院了，打了针安乐，就这么送走了。。。” 我注意到周围的乘客很多都在听她讲她和她的小狗的故事。 那个老妪接着说 “我的一个邻居家的小狗，死了后还给它立了个碑！还提了字” 听到这里，我心里是觉得很好笑的。 但笑过之后会开始思考，迟暮的老人，在这么大的岁数下，还要挤公交，想必其儿女是未尽足够的孝道，抑或儿女在远方没有能力，又或者儿女早已不在世上，老人将自己的感情寄托在身边的小生命上，一条小狗的逝去也能让其伤心欲绝。 当今社会，年轻人都在想着怎么生存，怎么成功，而忽略了在家独处的父母，但父母们的愿望很简单，只希望在晚年多陪陪他们，一家人团团圆圆的，但他们却又不能妨碍翅膀硬了的我们，我们想要振翅高飞，想要干出一番事业，而大多忽略了至亲的亲情，在外面累了，受委屈了，这时才想到家里还有两个一直宠你爱你包容你的人。 迟暮之年，难免想到死亡，看着身边的小生命逝去，心里想必是和年轻人所不一样的。 感慨之春，在风赶雾霾，沙逼北京的春天，承载着多少人的成功梦，却也承载着多少年迈的父母对子女的思念。","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"Python中用print方法向文件中写入内容","slug":"749","date":"2013-02-02T15:40:21.000Z","updated":"2017-12-16T10:10:42.142Z","comments":true,"path":"article/749.html","link":"","permalink":"https://www.yangyanxing.com/article/749.html","excerpt":"一个小功能，我就是想用print功能实现，不想用write123456import osos.chdir(\"/usr/tem\")char=\"my name is yangyanxing\"f = open(\"test.txt\",\"w\")print &gt;&gt;f,char 但是Python3中还可以用以下的方式123456import osos.chdir(\"/usr/tem\")char=\"my name is yangyanxing\"f = open(\"test.txt\",\"w\")print(char,file=f)","text":"一个小功能，我就是想用print功能实现，不想用write123456import osos.chdir(\"/usr/tem\")char=\"my name is yangyanxing\"f = open(\"test.txt\",\"w\")print &gt;&gt;f,char 但是Python3中还可以用以下的方式123456import osos.chdir(\"/usr/tem\")char=\"my name is yangyanxing\"f = open(\"test.txt\",\"w\")print(char,file=f) 也可以考虑用with as结构，会简单与周全些12345try: with(\"man.txt\",\"w\") as data: print &gt;&gt;data,charexcept IOError as err: print(\"Write error\"+ str(err)) 这种可以不用考虑finally情况 不同版本真是麻烦。。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"利用新浪SAE storage服务做图床","slug":"460","date":"2012-12-10T15:37:16.000Z","updated":"2017-12-16T10:10:42.526Z","comments":true,"path":"article/460.html","link":"","permalink":"https://www.yangyanxing.com/article/460.html","excerpt":"新浪SAE 为用户提供storage服务，来永久性存储文件，这很好的为用户提供图片等文件存储服务，以下通过方法来建立一个自己的图床 需求：上传一张照片，返回这张照片的地址 实现 http://kevinkelin.sinaapp.com/fileupload.php 首先在SAE上建立一个storage 的domain首先在SAE上建立一个storage 的domain,(其实再之前你需要有一个应用，这里不写了)","text":"新浪SAE 为用户提供storage服务，来永久性存储文件，这很好的为用户提供图片等文件存储服务，以下通过方法来建立一个自己的图床 需求：上传一张照片，返回这张照片的地址 实现 http://kevinkelin.sinaapp.com/fileupload.php 首先在SAE上建立一个storage 的domain首先在SAE上建立一个storage 的domain,(其实再之前你需要有一个应用，这里不写了) 新建一个fileupload.php文件代码如下1234567891011121314151617181920212223242526272829&lt;?phpsession_start();include_once('saestorage.class.php');?&gt;&lt;html&gt;&lt;body&gt;&lt;form action=\"fileupload.php\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;input type = \"file\" name=\"myfile\" size=\"100\" /&gt;&lt;br&gt;&lt;input type = \"submit\" value= \"upload\" / &gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$domain=\"imagefile\";$file_name = $_FILES[\"myfile\"][\"name\"];$temp_arr = explode(\".\", $file_name);$file_ext = array_pop($temp_arr);$file_ext = trim($file_ext);$file_ext = strtolower($file_ext);$new_file_name = date(\"YmdHis\") . '_' . rand(10000, 99999).'.'.$file_ext;$s = new SaeStorage();//$s-&gt;upload( 'imagefile',$_FILES[\"myfile\"][\"name\"],$_FILES[\"myfile\"][\"name\"]);echo $aimage=$s-&gt;upload( 'imagefile',$new_file_name,$_FILES[\"myfile\"][\"tmp_name\"]);?&gt; 得到了图片的地址，你就可以随意的使用了，前提是你在建立domain的时候不要防盗链，新浪SAE也是有限制的运行在SAE上的应用(App)将会消耗平台资源，为保证各App不互相 影响，我们引入了分钟配额的概念，即：在每分钟内每个应用的各个服务所消耗的 资源的速度。当Storage服务超过分钟配额，我们将会立即禁掉该应用的Storage 服务，禁用五分钟后，恢复会自动恢复，避免影响到SAE平台的稳定性。服务因为超过“分钟配额”而被禁用时，会在“服务状态”看到该服务被禁用的原因是：OverMinuteQuota 服务请求数cpu时间流入带宽流出带宽Storage5,000NA80MB400MB今天又将这个页面改了改，实现可以遍历指定domain下所有图片以及下载地址，并且实现后上传先显示，只是实现功能，所以页面太糙了。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpsession_start();include_once( 'config.php' );include_once( 'saetv2.ex.class.php' );include_once('saestorage.class.php');?&gt;&lt;html&gt;&lt;body&gt;&lt;form action=\"fileupload.php\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;input type = \"file\" name=\"myfile\" size=\"100\" /&gt;&lt;br&gt;&lt;input type = \"submit\" value= \"upload\" / &gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$domain=\"imagefile\";$file_name = $_FILES[\"myfile\"][\"name\"];$temp_arr = explode(\".\", $file_name);$file_ext = array_pop($temp_arr);$file_ext = trim($file_ext);$file_ext = strtolower($file_ext);$new_file_name = date(\"YmdHis\") . '_' . rand(10000, 99999).'.'.$file_ext;$s = new SaeStorage();//$s-&gt;upload( 'imagefile',$_FILES[\"myfile\"][\"name\"],$_FILES[\"myfile\"][\"name\"]);echo $aimage=$s-&gt;upload( 'imagefile',$new_file_name,$_FILES[\"myfile\"][\"tmp_name\"]);$files = $s-&gt;getList($domain,\"\",100);echo \"&lt;pre&gt;\";print_r($files);echo \"&lt;/pre&gt;\";foreach($files as $name)&#123;echo $s-&gt;getUrl($domain,$name).\"&lt;br&gt;\";&#125;echo \"&lt;br&gt;\";foreach($files as $name)&#123; //echo \"&lt;img src=\".$s-&gt;getUrl($domain,$name).\" width='50%'. height='100%'.&gt;\"; echo \"&lt;table border='5' align='center'&gt;\"; echo \"&lt;tr&gt;\"; echo \"&lt;td align='right'&gt;\"; echo \"&lt;a target='_blank' href=\".$s-&gt;getUrl($domain,$name). \"&gt;&lt;img src=\".$s-&gt;getUrl($domain,$name).\" width='30%' height='30%'\".\"&gt;&lt;/a&gt;\"; echo \"&lt;br&gt;&lt;br&gt;\"; echo $s-&gt;getUrl($domain,$name).\"&lt;br&gt;\"; echo \"&lt;/td&gt;\"; echo \"&lt;/tr&gt;\"; echo \"&lt;/table&gt;\";&#125;?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[]},{"title":"解决wordpress后台写日志时编辑器加载慢","slug":"444","date":"2012-12-07T16:05:04.000Z","updated":"2017-12-16T10:10:42.361Z","comments":true,"path":"article/444.html","link":"","permalink":"https://www.yangyanxing.com/article/444.html","excerpt":"空间放在国外的人基本都有一个感受，有时加载很慢，我最近用wordpress写文章的时候，默认的编辑器加载很慢有时都无法写博客下图中红框圈出来的位置加载太慢，后来网上查了查相应的资料，原来是有一个.js文件导致的，那个文件有200多K所以有时对于主机放在国外的朋友很慢，其实这里只要把这个js文件放到国内服务器，加载速度就能提高很快 到你的wordpress目录 wp-includes/js/tinymce取出tiny_mce.js文件，然后将其放到国内一个访问快的服务器，别说你没有啊，实在没有的话用新浪的SAE。然后找到打开wp-includes/class-wp-editor.php 这个文件，找到大概540行左右","text":"空间放在国外的人基本都有一个感受，有时加载很慢，我最近用wordpress写文章的时候，默认的编辑器加载很慢有时都无法写博客下图中红框圈出来的位置加载太慢，后来网上查了查相应的资料，原来是有一个.js文件导致的，那个文件有200多K所以有时对于主机放在国外的朋友很慢，其实这里只要把这个js文件放到国内服务器，加载速度就能提高很快 到你的wordpress目录 wp-includes/js/tinymce取出tiny_mce.js文件，然后将其放到国内一个访问快的服务器，别说你没有啊，实在没有的话用新浪的SAE。然后找到打开wp-includes/class-wp-editor.php 这个文件，找到大概540行左右改为1234567891011if ( $tmce_on ) &#123;if ( $compressed )echo \"&lt;script type='text/javascript' src='&#123;$baseurl&#125;/wp-tinymce.php?c=1&amp;$version'&gt;&lt;/script&gt;n\";elseecho \"&lt;script type='text/javascript' src='http://kevinkelin.sinaapp.com/tiny_mce.js'&gt;&lt;/script&gt;n\";if ( 'en' != self::$mce_locale &amp;&amp; isset($lang) )echo \"&lt;script type='text/javascript'&gt;n$langn&lt;/script&gt;n\";elseecho \"&lt;script type='text/javascript' src='&#123;$baseurl&#125;/langs/wp-langs-en.js?$version'&gt;&lt;/script&gt;n\";&#125; 其中http://kevinkelin.sinaapp.com/tiny_mce.js 是我将这个js文件放到新浪SAE的地址，如果你的版本也是3.4.2的话，你想用也可以引用，前提是你认为我不会对这个js文件做手脚。。。。 好了，改好后再在后台写篇文章看一下吧，速度是不是有很大的提高呢？","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[]},{"title":"（转）Python装饰器与面向切面编程","slug":"416","date":"2012-12-05T15:18:05.000Z","updated":"2017-12-16T16:07:40.668Z","comments":true,"path":"article/416.html","link":"","permalink":"https://www.yangyanxing.com/article/416.html","excerpt":"","text":"本文用了一个很通俗的例子还一步步的让读者理解Python中的装饰器的概念 原文地址：http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html 今天来讨论一下装饰器。装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 装饰器入门需求是怎么来的？装饰器的定义很是抽象，我们来看一个小例子。 1234def foo(): print 'in foo()' foo() 这是一个很无聊的函数没错。但是突然有一个更无聊的人，我们称呼他为B君，说我想看看执行这个函数用了多长时间，好吧，那么我们可以这样做： 12345678import timedef foo(): start = time.clock() print 'in foo()' end = time.clock() print 'used:', end - start foo() 很好，功能看起来无懈可击。可是蛋疼的B君此刻突然不想看这个函数了，他对另一个叫foo2的函数产生了更浓厚的兴趣。 怎么办呢？如果把以上新增加的代码复制到foo2里，这就犯了大忌了~复制什么的难道不是最讨厌了么！而且，如果B君继续看了其他的函数呢？ 1.2. 以不变应万变，是变也 还记得吗，函数在Python中是一等公民，那么我们可以考虑重新定义一个函数timeit，将foo的引用传递给他，然后在timeit中调用foo并进行计时，这样，我们就达到了不改动foo定义的目的，而且，不论B君看了多少个函数，我们都不用去修改函数定义了！123456789101112import time def foo(): print 'in foo()' def timeit(func): start = time.clock() func() end =time.clock() print 'used:', end - start timeit(foo) 看起来逻辑上并没有问题，一切都很美好并且运作正常！……等等，我们似乎修改了调用部分的代码。原本我们是这样调用的：foo()，修改以后变成了：timeit(foo)。这样的话，如果foo在N处都被调用了，你就不得不去修改这N处的代码。或者更极端的，考虑其中某处调用的代码无法修改这个情况，比如：这个函数是你交给别人使用的。 1.3. 最大限度地少改动！ 既然如此，我们就来想想办法不修改调用的代码；如果不修改调用代码，也就意味着调用foo()需要产生调用timeit(foo)的效果。我们可以想到将timeit赋值给foo，但是timeit似乎带有一个参数……想办法把参数统一吧！如果timeit(foo)不是直接产生调用效果，而是返回一个与foo参数列表一致的函数的话……就很好办了，将timeit(foo)的返回值赋值给foo，然后，调用foo()的代码完全不用修改！123456789101112131415161718192021#-*- coding: UTF-8 -*-import time def foo(): print 'in foo()' # 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法def timeit(func): # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装 def wrapper(): start = time.clock() func() end =time.clock() print 'used:', end - start # 将包装后的函数返回 return wrapper foo = timeit(foo)foo() 这样，一个简易的计时器就做好了！我们只需要在定义foo以后调用foo之前，加上foo = timeit(foo)，就可以达到计时的目的，这也就是装饰器的概念，看起来像是foo被timeit装饰了。在在这个例子中，函数进入和退出时需要计时，这被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。与传统编程习惯的从上往下执行方式相比较而言，像是在函数执行的流程中横向地插入了一段逻辑。在特定的业务领域里，能减少大量重复代码。面向切面编程还有相当多的术语，这里就不多做介绍，感兴趣的话可以去找找相关的资料。 这个例子仅用于演示，并没有考虑foo带有参数和有返回值的情况，完善它的重任就交给你了 ：） Python的额外支持2.1. 语法糖 上面这段代码看起来似乎已经不能再精简了，Python于是提供了一个语法糖来降低字符输入量。123456789101112131415import time def timeit(func): def wrapper(): start = time.clock() func() end =time.clock() print 'used:', end - start return wrapper @timeitdef foo(): print 'in foo()' foo() 重点关注第11行的@timeit，在定义上加上这一行与另外写foo = timeit(foo)完全等价，千万不要以为@有另外的魔力。除了字符输入少了一些，还有一个额外的好处：这样看上去更有装饰器的感觉。 2.2. 内置的装饰器 内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。由于模块里可以定义函数，所以静态方法和类方法的用处并不是太多，除非你想要完全的面向对象编程。而属性也不是不可或缺的，Java没有属性也一样活得很滋润。从我个人的Python经验来看，我没有使用过property，使用staticmethod和classmethod的频率也非常低。123456789101112131415161718192021class Rabbit(object): def __init__(self, name): self._name = name @staticmethod def newRabbit(name): return Rabbit(name) @classmethod def newRabbit2(cls): return Rabbit('') @property def name(self): return self._name这里定义的属性是一个只读属性，如果需要可写，则需要再定义一个setter：@name.setterdef name(self, name): self._name = name functools模块提供了两个装饰器。这个模块是Python 2.5后新增的，一般来说大家用的应该都高于这个版本。但我平时的工作环境是2.4 T-T 2.3.1. wraps(wrapped[, assigned][, updated]):这是一个很有用的装饰器。看过前一篇反射的朋友应该知道，函数是有几个特殊属性比如函数名，在被装饰后，上例中的函数名foo会变成包装函数的名字wrapper，如果你希望使用反射，可能会导致意外的结果。这个装饰器可以解决这个问题，它能将装饰过的函数的特殊属性保留。123456789101112131415161718import timeimport functools def timeit(func): @functools.wraps(func) def wrapper(): start = time.clock() func() end =time.clock() print 'used:', end - start return wrapper @timeitdef foo(): print 'in foo()' foo()print foo.__name__ 首先注意第5行，如果注释这一行，foo.name将是’wrapper’。另外相信你也注意到了，这个装饰器竟然带有一个参数。实际上，他还有另外两个可选的参数，assigned中的属性名将使用赋值的方式替换，而updated中的属性名将使用update的方式合并，你可以通过查看functools的源代码获得它们的默认值。对于这个装饰器，相当于wrapper = functools.wraps(func)(wrapper)。 2.3.2. total_ordering(cls):这个装饰器在特定的场合有一定用处，但是它是在Python 2.7后新增的。它的作用是为实现了至少lt、le、gt、ge其中一个的类加上其他的比较方法，这是一个类装饰器。如果觉得不好理解，不妨仔细看看这个装饰器的源代码：1234567891011121314151617181920212223242526def total_ordering(cls): \"\"\"Class decorator that fills in missing ordering methods\"\"\" convert = &#123; '__lt__': [('__gt__', lambda self, other: other &lt; self), ('__le__', lambda self, other: not other &lt; self), ('__ge__', lambda self, other: not self &lt; other)], '__le__': [('__ge__', lambda self, other: other &lt;= self), ('__lt__', lambda self, other: not other &lt;= self), ('__gt__', lambda self, other: not self &lt;= other)], '__gt__': [('__lt__', lambda self, other: other &gt; self), ('__ge__', lambda self, other: not other &gt; self), ('__le__', lambda self, other: not self &gt; other)], '__ge__': [('__le__', lambda self, other: other &gt;= self), ('__gt__', lambda self, other: not other &gt;= self), ('__lt__', lambda self, other: not self &gt;= other)] &#125; roots = set(dir(cls)) &amp; set(convert) if not roots: raise ValueError('must define at least one ordering operation: &lt; &gt; &lt;= &gt;=') root = max(roots) # prefer __lt__ to __le__ to __gt__ to __ge__ for opname, opfunc in convert[root]: if opname not in roots: opfunc.__name__ = opname opfunc.__doc__ = getattr(int, opname).__doc__ setattr(cls, opname, opfunc) return cls","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"北京工业大学内两个网卡分别访问内网与外网的方法","slug":"413","date":"2012-11-30T13:50:34.000Z","updated":"2017-12-16T10:10:42.538Z","comments":true,"path":"article/413.html","link":"","permalink":"https://www.yangyanxing.com/article/413.html","excerpt":"相信很多在北京工业大学的童鞋都知道内网有很多资源，但是由于学校内的网络是按流量收费的，所以对于外网拥有的更多好资源有时只能另想办法，于是很多宿舍开始办理201宽带，但是最快的网速也不及内网10M/s下载爽，于是我在网上找了一些方法，结合北工大的网络环境，写了一个批处理文件来解决同时访问内网与外网的方法 1.网络现状：有线接内网，无线接ADSL宽带。 2.首先查看自己内网与ADSL的IP与网关 内网 IP 172.27.28.96 网关 172.27.28.254 ADSL IP 192.168.1.105 网关 192.168.1.1 3. 再建一个txt文档，输入以下信息，重新保存为.bat文件，","text":"相信很多在北京工业大学的童鞋都知道内网有很多资源，但是由于学校内的网络是按流量收费的，所以对于外网拥有的更多好资源有时只能另想办法，于是很多宿舍开始办理201宽带，但是最快的网速也不及内网10M/s下载爽，于是我在网上找了一些方法，结合北工大的网络环境，写了一个批处理文件来解决同时访问内网与外网的方法 1.网络现状：有线接内网，无线接ADSL宽带。 2.首先查看自己内网与ADSL的IP与网关 内网 IP 172.27.28.96 网关 172.27.28.254 ADSL IP 192.168.1.105 网关 192.168.1.1 3. 再建一个txt文档，输入以下信息，重新保存为.bat文件， 123route delete 0.0.0.0route add 0.0.0.0 mask 0.0.0.0 192.168.1.1route add 172.27.0.0 mask 255.0.0.0 172.27.28.254 简单解释一下，第一行为删除所以的网关，第二条为所以外网建立新的网关，也就是你的ADSL路由网关，第三条为你的内网建立网关，这里的网关就是你上面内网查到的网关，注意第三条加的时候一定要和你上面查到的网关对应，第二位和上面的相同，如我这里面的172.27 .0.0 而不能是172.0.0.0 好了保存一下，然后双击运行这个bat文件，此时你就可以既可能访问内网同时也可以访问外网了~ 注意到北工大内网可以访问IPV6的google以及相关的服务，这时你可以修改你的hosts文件，可以把所有的google服务指身向 2404:6800:4008:c01::69 速度还是不错的，但偶尔也会有阻断,大家上网愉快~","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[]},{"title":"解决新浪开放平台应用（oauth2）网站无法认证的问题","slug":"407","date":"2012-11-29T15:10:50.000Z","updated":"2017-12-16T10:10:42.416Z","comments":true,"path":"article/407.html","link":"","permalink":"https://www.yangyanxing.com/article/407.html","excerpt":"前些天一直在倒腾新浪微博的开放平台，一开始用的oauth1，利用官方的PHP SDK写了一个简单发微博的应用，但是很遗憾，没有成功，这里简单的写一下12345678910111213141516171819202122&lt;?phpsession_start();include_once( 'config.php' );include_once( 'weibooauth.php' );$c = new WeiboClient( WB_AKEY , WB_SKEY , $_SESSION['last_key']['oauth_token'] , $_SESSION['last_key']['oauth_token_secret'] );?&gt;&lt;form action=\"\" method=\"post\"&gt;&lt;input type=\"text\" name=\"text\" id=\"1\"&gt;&lt;input type=\"submit\" name=\"submit\" value=\"发表微博\"&gt;&lt;/form&gt;&lt;?phpif(isset($_POST['text']))&#123;$rr=$c-&gt;update($_POST['text']);echo \"发表成功\";&#125;?&gt;","text":"前些天一直在倒腾新浪微博的开放平台，一开始用的oauth1，利用官方的PHP SDK写了一个简单发微博的应用，但是很遗憾，没有成功，这里简单的写一下12345678910111213141516171819202122&lt;?phpsession_start();include_once( 'config.php' );include_once( 'weibooauth.php' );$c = new WeiboClient( WB_AKEY , WB_SKEY , $_SESSION['last_key']['oauth_token'] , $_SESSION['last_key']['oauth_token_secret'] );?&gt;&lt;form action=\"\" method=\"post\"&gt;&lt;input type=\"text\" name=\"text\" id=\"1\"&gt;&lt;input type=\"submit\" name=\"submit\" value=\"发表微博\"&gt;&lt;/form&gt;&lt;?phpif(isset($_POST['text']))&#123;$rr=$c-&gt;update($_POST['text']);echo \"发表成功\";&#125;?&gt; 认证页面我就不写了，就是用的官方的SDK，输入几个字以后，点击发表微，虽然显示 “发表成功”，但我的微博根本没有发表，于是我将$rr显示出来1234567if(isset($_POST['text']))&#123;$rr=$c-&gt;update($_POST['text']); echo \"&lt;pre&gt;\";print_r($rr); echo \"&lt;/pre&gt;\";&#125; 结果发现了问题 Array( [request] =&gt; /statuses/update.json [error_code] =&gt; 401 [error] =&gt; 40109:consumer_key_refused!)查看官方文档 “24、OAuth1.0授权方式能否继续使用？ 目前未授权的应用已经禁止使用OAuth1.0授权及V1接口，2012年9月左右将禁止所有应用使用OAuth1.0授权及V1接口。我们推荐更安全、稳定的OAuth2.0授权方式， OAuth1.0授权方式不久后将全面禁止使用。“ 也就是说oauth1的接口新的应用是不能用的。。。汗，使用oauth2的接口吧 结果却有新的错误 再继续查看官方文档关于redirect_url_mismatch的解释 “获取用户授权是出现 error ：redirect_uri_mismatch 怎么解决？ 这是由于回调地址填写错误造成的，解决办法： A、站内应用：redirect_uri等于应用信息中的“站内应用地址”而非“应用实际地址”； B、其他应用：redirect_uri需与http://open.weibo.com/apps/30871*/info/advanced （30871*替换成你应用的AppKey）应用高级信息中的“应用回调页”完全匹配或在绑定的域名下。 注意：修改应用回调页或绑定域名后需要约半小时左右时间生效。” 由于我新建的是其他应用，于是去修改应用高级设置里的回调页 一开始这个回调信息应该是没有的，需要手工输入才可以，于是输入完这个地址后，再来调用此应用，经过受权页面后，一切就OK了~","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[]},{"title":"通过小程序练习Python中关于os模块的方法","slug":"397","date":"2012-11-15T17:14:18.000Z","updated":"2017-12-16T16:10:07.607Z","comments":true,"path":"article/397.html","link":"","permalink":"https://www.yangyanxing.com/article/397.html","excerpt":"通过一个小程序来熟悉一下os模块中的方法，OS模块在以后会经常的使用，操作目录与文件等","text":"通过一个小程序来熟悉一下os模块中的方法，OS模块在以后会经常的使用，操作目录与文件等 123456789101112131415161718192021222324252627282930313233343536373839404142import osprint os.getcwd()for tmpdir in ('/tmp',r'c:temp',r'd:temp'): if os.path.isdir(tmpdir): ##判断上面元组中的元素是否存在并且为一个目录 breakelse: print 'No temp dir available' tmpdir = '' os.chdir('d:') ##我这里直接转到d分区了 os.makedirs('temp1') ##建立temp1文件夹 print os.getcwd() ## 获得当前目录路径if tmpdir: os.chdir(tmpdir) ##切换文件夹 cwd = os.getcwd() print 'Current temp dir is %s ' % cwd print 'Now it will create an dir...' dirname = os.listdir(cwd) ##显示当前目录下的文件，放到一个列表中 print dirname os.makedirs('example1') ##建立一个新的文件夹，example os.chdir('example1') cwd = os.getcwd() print 'Now the current dir is %s ' % cwd print 'The original dir listing is:' print os.listdir(cwd) print 'Now it will create a test file' fobj = file('test.txt','w') fobj.write('foon') fobj.write('barn') fobj.close() print 'Now after create a test file the listing is :' print os.listdir(cwd) ##这里会创建一个文件，里面有foo bar 这两行字符 print 'Now it will change the test.tex to test.ini' os.rename('test.txt','test.ini') ##rename print os.listdir(cwd) path = os.path.join(cwd,os.listdir(cwd)[0]) ##path 此时为 d:tempexample1test.ini print 'The full file pathname is %s' % path print os.path.split(path) ## ['d:tempexample1', 'test.ini'] split() 函数返回 dirname(目录名) 与 basename(文件名+扩展名)的一个元组 print os.path.splitext(os.path.basename(path)) ##('test', '.ini') splittext() 函数返回filename(文件名)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"一个Python的小例子来理解字典与while循环","slug":"393","date":"2012-11-11T17:23:59.000Z","updated":"2017-12-16T10:10:42.433Z","comments":true,"path":"article/393.html","link":"","permalink":"https://www.yangyanxing.com/article/393.html","excerpt":"现在要实现一个需求，弹出一个界面，可以让用户选择是新建用户还是登录已有账户，或者直接退出，在登录账户的时候，密码输入错误不能超过三次，超过三次要回到主界面，用户名输入‘q’的时候也可以退出并回到主界面","text":"现在要实现一个需求，弹出一个界面，可以让用户选择是新建用户还是登录已有账户，或者直接退出，在登录账户的时候，密码输入错误不能超过三次，超过三次要回到主界面，用户名输入‘q’的时候也可以退出并回到主界面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#-*-coding:utf-8-*-db = &#123;&#125; #通过使用字典来建立一个以用户名与密码的映射关系def newuser(): prompt = 'login desired:' while True: #开始第一层循环，一直是True，除非有break name = raw_input(prompt) if db.has_key(name): #判断所输入的用户名是否在已经存在的字典中，也就是字典中的key，如果存在则弹出一个提示 prompt = 'name has already please change another' continue else: break #这里的意思是所输入的用户名不在字典的key里，则循环break掉 pwd = raw_input('password: ') db[name] = pwd #将所输入的密码赋值给用户名所对应的valuedef olduser(): #这里定义一个老用户登录的函数 us = False #这里定义一个us=False的目的是为了进行检查用户名是否存在的 while not us: username = raw_input('username(q for quit): ') if username in db: #这处是检查用户名（key）是否是所定义的字典中，如果在的话us = True，则此处循环结束，不再提示输入用户名 us = True pwded = db.get(username) #取出用户名的密码 Ntime = 3 #定义最多只能错误输入三次密码 while Ntime != 0: password = raw_input('password: ') if password != pwded: print 'You password is not correct you have %d times to try again' % Ntime Ntime-=1 #次数减1 if Ntime == 0: print 'You have tried too much time without right password!' break #循环结束，同时也意味着olduser()函数的结束，程序向下走，程序将调用__main__入口，从而showmenu()函数被调用 elif password == pwded: #密码正确 print 'welcome back!' break elif username == 'q': #当用户名输入q 的时候手工定义pwded and password，为了后面的判断 pwded = None password = 123 break else: print 'No such user!!! please try again' #当输入一个不存在的key的时候输入此句 if password == 123: print 'You choice is q so it will back to main menu!' #这里是前面的当输入为q的用户名时的输出def showmenu(): prompt = ''' (N)ew user sign (O)ld user login (Q)uit Enter your choice:''' done = False while not done: chosen = False while not chosen: try: choice = raw_input(prompt).strip()[0].lower() #取用户所输入字符串第一个字符并将其小写去空格 except (EOFError,KeyboardInterrupt): choice = 'q' print 'nYou picked is [%s]'% choice if choice not in 'noq': #判断是否在这三个字母当中 print 'choice is invaild,try again' else: chosen = True if choice == 'q':done =True #done = True 则程序主循环不执行，程序结束 if choice == 'o':olduser() if choice == 'n':newuser()if __name__ == '__main__': showmenu()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.yangyanxing.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.yangyanxing.com/tags/python/"}]},{"title":"利用Chrome或者极速浏览器屏蔽烦人的广告","slug":"375","date":"2012-09-21T15:52:03.000Z","updated":"2017-12-16T10:10:42.031Z","comments":true,"path":"article/375.html","link":"","permalink":"https://www.yangyanxing.com/article/375.html","excerpt":"首先得声明，广告做为互联网中一个不可或缺元素，也是网站的主要收益来源，但频繁的广告会使人烦死，如一些垃圾网站的鼠标点击弹出色情游戏广告，有时还不止一个，还有优酷有广告，动辄就45S，实在受不了，基于此，寻找各路大仙 浏览器，Chrome或者基于Chrome核的浏览器，像360极速浏览器，在Chrome商店中（https://chrome.google.com/webstore/）搜索Adblock Plus (https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb) 最新版的Chrome要必须从Chrome商店中安装应用，如果是极速浏览器的话可以直接点击 http://adblockplus.org/devbuilds/adblockpluschrome/00latest.crx 这个好处是直接就集成了ChinaList+EasyList ，当中有中国大多数网站中的广告元素，新装的时候会有一段时间的数据下载过程，取决于你的网速，数据请看 https://easylist-downloads.adblockplus.org/chinalist+easylist.txt 接下来你就可以轻松的访问各种网站了，注意现在访问的时候在浏览器的地址栏最右边会出现一个红色的ABP标识，因为即使在那个ChianList里面，也不是能把中国所以的网站广告都屏蔽了，有时还需要自己手工的添加，用鼠标点击那个红色标识，接着再点击“轻松建立过滤规则”，接下来把鼠标放到你想屏蔽广告的地方，那个地方会就成半透明的黄色，点击一下即可，在弹出来的对话框点击确定 当然也有想看网站广告的时候，","text":"首先得声明，广告做为互联网中一个不可或缺元素，也是网站的主要收益来源，但频繁的广告会使人烦死，如一些垃圾网站的鼠标点击弹出色情游戏广告，有时还不止一个，还有优酷有广告，动辄就45S，实在受不了，基于此，寻找各路大仙 浏览器，Chrome或者基于Chrome核的浏览器，像360极速浏览器，在Chrome商店中（https://chrome.google.com/webstore/）搜索Adblock Plus (https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb) 最新版的Chrome要必须从Chrome商店中安装应用，如果是极速浏览器的话可以直接点击 http://adblockplus.org/devbuilds/adblockpluschrome/00latest.crx 这个好处是直接就集成了ChinaList+EasyList ，当中有中国大多数网站中的广告元素，新装的时候会有一段时间的数据下载过程，取决于你的网速，数据请看 https://easylist-downloads.adblockplus.org/chinalist+easylist.txt 接下来你就可以轻松的访问各种网站了，注意现在访问的时候在浏览器的地址栏最右边会出现一个红色的ABP标识，因为即使在那个ChianList里面，也不是能把中国所以的网站广告都屏蔽了，有时还需要自己手工的添加，用鼠标点击那个红色标识，接着再点击“轻松建立过滤规则”，接下来把鼠标放到你想屏蔽广告的地方，那个地方会就成半透明的黄色，点击一下即可，在弹出来的对话框点击确定 当然也有想看网站广告的时候， 这时候可以这样做，点击红色的ABP标识，把“对该网站启用过滤”前面的沟去掉。 接下来说优酷，当你使用这个屏蔽插件的时候，这个孙子开始向你卖萌 接下来我们使用神器，OpenGG.Clean.Player 点击下载 替换本身的播放器，目前这种方法还可以用，不过指不定哪天就不能用了，先用着吧~","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[]},{"title":"ThinkPHP之简单的用户增删改查","slug":"702","date":"2012-08-19T16:05:15.000Z","updated":"2017-12-16T10:10:42.053Z","comments":true,"path":"article/702.html","link":"","permalink":"https://www.yangyanxing.com/article/702.html","excerpt":"此篇文章简单的应用了之前所介绍的CURD 在IndexAction.class.php中写入以下代码","text":"此篇文章简单的应用了之前所介绍的CURD 在IndexAction.class.php中写入以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpclass IndexAction extends Action&#123; /*主页显示*/ public function index()&#123; $user=M('user'); $list=$user-&gt;field(array('id','username','createip'))-&gt;select();//查出id username,createip这三个字段 $this-&gt;assign('title','操作练习');//将操作练习分配给title $this-&gt;assign('alist',$list); //将上面所得到的$list分配给alist $this-&gt;display(); //这里需要在TPL中创建一个index.html的页面 &#125; /*删除用户操作*/ function del()&#123; $user=M('user'); if ($user-&gt;delete($_GET['id']))&#123;//这里采用的是GET传值 $this-&gt;success('删除用户成功'); &#125;else&#123; $this-&gt;error('删除用户失败'); &#125; &#125; /*添加用户操作*/ function add()&#123; Load('extend');//这里是为了要应用get_client_ip()方法 if ($_POST['password']!=$_POST['repassword'])&#123; $this-&gt;error('两次输入的密码不一致'); &#125; $user=D('user');//使用D方法实例化模型则要在model中创建相应的UserModel.class.php，里面可以什么方法都不写 if ($vo=$user-&gt;create())&#123; $user-&gt;createtime=time(); $user-&gt;createip=get_client_ip(); $user-&gt;password=md5($user-&gt;password);//将数据压入到$user变量中 if ($user-&gt;add())&#123; $this-&gt;success('用户注册成功'); &#125;else &#123; $this-&gt;error('用户注册失败'); &#125; &#125;else &#123; $this-&gt;error($user-getError()); &#125; &#125; /*显示用户修改页面，这里不是修改方法*/ function edit()&#123; $id=$_GET['id']; $user=M('user'); $list=$user-&gt;where(\"id=$id\")-&gt;find(); $this-&gt;assign(title,'用户编辑页面'); $this-&gt;assign('list',$list); $this-&gt;display();//这在后面还要建立一个edit.html的模板文件 &#125; /*这里是将用户的数据更新到数据库中* 更新的方法是save而不是update*/ function update()&#123; $user=D('user'); if ($user-&gt;create())&#123; $user-&gt;password=md5($user-&gt;password); if ($user-&gt;save())&#123; $this-&gt;success('用户更新成功，此次更新的ID为'.$user-&gt;id); &#125;else&#123; $this-&gt;error($user-&gt;getError()); &#125; &#125;else &#123; $this-&gt;error($user-getError()); &#125; &#125;&#125;?&gt; 还要建立两个模板文件index.html和edit.html文件 index.html123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;title&gt;&#123;$title&#125;&lt;/title&gt; &lt;!-- 这里是收到的标题变量 --&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"__URL__/add\" method=\"post\" &gt;用户名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;密 码：&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt;重复密码：&lt;input type=\"password\" name=\"repassword\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt;&lt;volist name='alist' id='vo'&gt;&lt;li&gt;&lt;span&gt;ID&#123;$vo['id']&#125;&lt;/span&gt; &lt;span&gt;用户名&#123;$vo['username']&#125;&lt;/span&gt; &lt;span&gt;注册IP&#123;$vo['createip']&#125;&lt;/span&gt; &lt;a href='__URL__/del/id/&#123;$vo['id']&#125;'&gt;删除&lt;/a&gt; &lt;a href='__URL__/edit/id/&#123;$vo['id']&#125;'&gt;编辑&lt;/a&gt;&lt;/li&gt;&lt;/volist&gt;&lt;/body&gt;&lt;/html&gt; edit.html12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;title&gt; &#123;$title&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"__URL__/update\" method=\"post\"&gt;用户名：&lt;input type=\"text\" name=\"username\" value=\"&#123;$list['username']&#125;\"&gt;&lt;br&gt;密 码：&lt;input type=\"text\" name=\"password\" value=\"&#123;$list['password']&#125;\"&gt;&lt;br&gt;注册时间：&lt;input type=\"text\" name=\"createtime\" value=\"&#123;$list['createtime']&#125;\"&gt;&lt;br&gt;注册IP：&lt;input type=\"text\" name=\"createip\" value=\"&#123;$list['createip']&#125;\"&gt;&lt;br&gt;&lt;input type=\"hidden\" value=\"&#123;$list['id']&#125;\" name='id'&gt; &lt;!--这里是一个隐藏表单，用于传递修改的是哪个ID --&gt;&lt;input type=\"submit\" value=\"修改\"&gt;&lt;a href=\"__URL__\"&gt;返回&lt;/a&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://www.yangyanxing.com/tags/ThinkPHP/"}]},{"title":"ThinkPHP中的CURD之C","slug":"373","date":"2012-08-09T17:53:09.000Z","updated":"2017-12-16T10:10:41.864Z","comments":true,"path":"article/373.html","link":"","permalink":"https://www.yangyanxing.com/article/373.html","excerpt":"CURD 增 删 改 查 C create方法 每当实例化一个数据对象后，当需要接收post来值的时候，要用create方法来创建一个对象，根据表单提交的POST数据创建数据对象，并保存在内存中，可以通过dump($user)查看，返回值是一个数组12345$user=M('user');$vo=$user-&gt;create();dupm($vo); //这时会遍历出得到的（post）值","text":"CURD 增 删 改 查 C create方法 每当实例化一个数据对象后，当需要接收post来值的时候，要用create方法来创建一个对象，根据表单提交的POST数据创建数据对象，并保存在内存中，可以通过dump($user)查看，返回值是一个数组12345$user=M('user');$vo=$user-&gt;create();dupm($vo); //这时会遍历出得到的（post）值 array(2) { [\"username\"] => string(4) \"root\" [\"password\"] => string(11) \"12345678\" } 写一个add方法，加上一个表单 在tpl里面建立一个表单123456789101112&lt;html&gt;&lt;body&gt;&lt;form action=\"__URL__/add\" method=\"post\"&gt;用户名&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;密 码&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在user的控制器里面写上一个方法，这时也可以不写create方法，但是就是单独写上一个对象的赋值方法，create的时候其实就是在接收post而来的数据12345678910111213141516171819function add()&#123;$user=M('user');//$user-&gt;create(); 如果不用create方法，也可以用下面的方法$user-&gt;username=$_POST['username'];$user-&gt;password=md5($_POST[password]);//将post来的密码进行md5加密 /* 如果用create方法可以用这面的方法写 $user-&gt;create(); $user-&gt;password=md5($user-&gt;password); */ //add为thinkphp中向数据库中添加数据的方法if ($user-&gt;add()) &#123;$this-&gt;success('添加用户成功');&#125;else &#123;$this-&gt;error('添加用户失败');&#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[]},{"title":"ThinkPHP四种实例化模型的方法","slug":"372","date":"2012-08-06T17:00:18.000Z","updated":"2017-12-16T10:10:42.460Z","comments":true,"path":"article/372.html","link":"","permalink":"https://www.yangyanxing.com/article/372.html","excerpt":"假设数据库中有一个think_user的数据表 普通方式12345678910111213$user=new Model('user');$user=M('user');/*user的U可以大写，也可以小写，当库中还有一个think_user_message等表的时候，可以使用new Model('userMessage') 或者new Model(user_message)，也就是说大写的首字母相当于带下划线的单词此方法也可以用快捷方法，M方法*/","text":"假设数据库中有一个think_user的数据表 普通方式12345678910111213$user=new Model('user');$user=M('user');/*user的U可以大写，也可以小写，当库中还有一个think_user_message等表的时候，可以使用new Model('userMessage') 或者new Model(user_message)，也就是说大写的首字母相当于带下划线的单词此方法也可以用快捷方法，M方法*/ 当需要继承多个模型的时候，可以用M(‘ ‘,’ ‘)方法123456789101112$user=M('user','Common');$user=new Common('user');/*此方法说明$user中既有user中的方法，也可以从自定义的模型中继承方法，比如在Common中写一个常用的方法（公共方法），这种方法比较便捷的实现了一个变量实例化多个模型，也大大的简便了代码的书写,此方法还可以写成$user=new Common('user');*/ D方法12345$user=new UserModel();$user=D('user');/*此种方法可以方便实现用户自定义数据库操作类与方法，用户可以在UserModel.class.php中封装自己定义的方法*/ 通过空模型来实例化这种方式是通过自定义数据库查询语句来实现查询功能12$user=new Model();$list=$user-&gt;query('select * from think_user') 总的来说，如果没有继承第三方的类，D与M方法实例出来的是一样的 $user=M(‘user’); $user=D(‘user’); 而M方法则可以比较方便的继承第三方类（公共类啊等等）","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://www.yangyanxing.com/tags/ThinkPHP/"}]},{"title":"通过新浪SAE搭建自己的个人博客","slug":"371","date":"2012-04-22T17:02:55.000Z","updated":"2017-12-16T10:10:42.545Z","comments":true,"path":"article/371.html","link":"","permalink":"https://www.yangyanxing.com/article/371.html","excerpt":"新浪SAE是个好东西，对于学习PHP的同学是一个不错的练习空间，（现在已经推出了java了，不过需要邀请码）不用在四处寻找廉价的主机，而且 平台上已经集成了很多现成的应用，博客空间有wordpress，emlog等，PHP框架有thinkPHP,cakephp等，而且还是 ecshop，最土等电子商务系统，更方便的应用于用户，感兴趣的同学可以体验一下，现在我将写一篇关于搭建wordpress博客应用和自己创建一个新 浪微博的简单应用来抛砖引玉，让更多的同学朋友了解SAE。 SAE地址 http://sae.sina.com.cn/ 需要准备：新浪微博账号（必须），自己注册的域名（可选），SAE提供二级域名的访问，xxx.sinaapp.com 也可以绑定自己的域名，注意这里的域名可以不用备案哦~ 搭建wordpress博客应用具体步骤","text":"新浪SAE是个好东西，对于学习PHP的同学是一个不错的练习空间，（现在已经推出了java了，不过需要邀请码）不用在四处寻找廉价的主机，而且 平台上已经集成了很多现成的应用，博客空间有wordpress，emlog等，PHP框架有thinkPHP,cakephp等，而且还是 ecshop，最土等电子商务系统，更方便的应用于用户，感兴趣的同学可以体验一下，现在我将写一篇关于搭建wordpress博客应用和自己创建一个新 浪微博的简单应用来抛砖引玉，让更多的同学朋友了解SAE。 SAE地址 http://sae.sina.com.cn/ 需要准备：新浪微博账号（必须），自己注册的域名（可选），SAE提供二级域名的访问，xxx.sinaapp.com 也可以绑定自己的域名，注意这里的域名可以不用备案哦~ 搭建wordpress博客应用具体步骤 用新浪微博账号授权打开SAE地址 http://sae.sina.com.cn/ 点击“用新浪微博账号”登录，用新浪微博账号登录后点击导航条上的“应用仓库”，选择下面的wordpress 点击安装些应点击安装些应，选择基于URL安装，并且在填写二级域名处填写一个独一无二的域名，接着点击“安装到以上位置” 设置站点信息稍等一会，程序会自动安装的，安装完毕后点击提示中的”点击此处进入初始化页面”进行个人博客的初始化，站点名字，管理员及密码等，设置好了以后，点击下面的“安装wordpress”，一切OK了，个人博客搭建完毕。简单吧。 绑定自己的域名绑定自己的域名，在自己的应用列表下选择刚才你创建的应用名字，不是后面的二级域名啊，切换到“应用设置”里面，在独立域名设置那添加一个你自己的域名，这里添加的时候是把自己的域名添加一个CNAME解析，再添加一个A解析，具体是什么，会有提示告诉你的~ wordpress 的模板添加与修改wordpress 的模板添加与修改，这里比用自己的虚拟主机有点麻烦，因为新浪SAE不允许wordpress后台更新模板，所以与下载插件，所以更改模板的时候有两种方 法，SVN或者用SAE的代码编辑器来编辑，推荐使用SVN，比SAE更改要简单方便 SVN的使用方法参见http://sae.sina.com.cn/?m=devcenter&amp;catId=212 这里就不重复了。添加插件也用同样的方法。 简单的调用新浪微博API来更新自己的微博准备工作，新浪微博账号并且开通新浪微博开发者平台，注册地址 http://open.weibo.com/ 具体步骤 打开新浪微博开放平台 http://open.weibo.com/ 点击下面的“我是开发者” http://open.weibo.com/development 进入开发者页面，点击创建应用—&gt;选择第一个“站内应用” 填写应用名字，应用介绍等信息（随便写的），域名绑定选择默认的“否”，点击“创建” OK 转到刚才你创建的应用的详细页面，其实这里的信息只有两个有用，一个是APP Keys，一个是App Secret,记录好这两个值，以后的应用都要用这两个值 由于新浪SAE已经集合了最新的PHP版的SDK，可以不用下载，直接用，但有兴趣的同学可以下载来看看人家的方法是怎么实现的，对于学习者来说还是挺有用的~ 在本地新建三个php文件，名字随便起，我这里起的是getRequestToken.php（用于请求request token），请求request token（用于获得的request token和token secret来初始化SaeTOAuth对象），config.php（可选，主要用于初始化常量，推荐使用） 在config.php中写入以下代码 12345header('Content-Type: text/html; charset=UTF-8');define( \"WB_AKEY\" , '你自己的APP Keys' );define( \"WB_SKEY\" , '你自己的App Secret' );define( \"WB_CALLBACK_URL\" , 'http://kevinweibo.sinaapp.com/getAccess.php' );//稍后介绍这里怎么填写 在getRequestToken.php中写入以下代码 123456789101112131415&lt;?phpsession_start();include ('config.php');//我这里是将WB_AKEY和WB_SKEY写入到了一个config.php文件中include ('saet.ex.class.php');$auth=new SaeTOAuth(WB_AKEY,WB_SKEY);//your app key and app secret//这一步是去sina服务器请求request token$token=$auth-&gt;getRequestToken();//这一步是用request token拼装认证的url,第三个参数是获得用户认证许可后跳转到的url。就是我们在SAE注册应用的二级域名$url=$auth-&gt;getAuthorizeURL($token,true,\"http://kevinweibo.sinaapp.com/getAccessToken.php\");$_SESSION['token']=$token['oauth_token'];//记录下来备用$_SESSION['token_secret']=$token['oauth_token_secret'];//最后将$url当成一个链接输出到页面中,用户点击了这个链接就会跳转到认证页面echo \"&lt;a href=$url&gt;欢迎光临，请使用微博账号受权登录!&lt;/a&gt;\";?&gt; 5.3 在getAccessToken.php中写入以下代码1234567891011121314151617&lt;?phpsession_start();include ('config.php');include ('saet.ex.class.php');//利用第一步获得的request token和token secret来初始化SaeTOAuth对象$auth=new SaeTOAuth(WB_AKEY,WB_SKEY,$_SESSION['token'],$_SESSION['token_secret']);//去换取真正有用的access token$accessToken=$auth-&gt;getAccessToken($_REQUEST['oauth_verifier'],$_REQUEST['oauth_token']);//print_r($accessToken);//存储起来,后面每次请求都要带上这两个值$_SESSION['token']=$accessToken['oauth_token'];$_SESSION['token_secret']=$accessToken['oauth_token_secret'];//接下来你就可以跳转到你的应用页面开始微博之旅了,例如输出一句js,window.location.href=\"send.php\"//echo \"token:\".$_SESSION['token'];//echo \"&lt;br/&gt;token_secret:\".$_SESSION['token_secret'].\"&lt;br/&gt;\";echo \"&lt;script&gt;window.location.href='send.php'&lt;/script&gt;\"?&gt; 5.4 注意最后一句说的是打开一个send.php页面，所以这里还要新建一个send.php文件，在里面打入以下代码123456789101112131415161718192021&lt;?phpsession_start();include ('config.php');//include ('saetv2.ex.class.php');include ('saet.ex.class.php');$auth = new SaeTClient(WB_AKEY,WB_SKEY, $_SESSION['token'], $_SESSION['token_secret']);$mes = $_POST[msg];$auth-&gt;update($mes);// 这句话是关键，其实发新浪微博的方法就这个，非常简单~?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"POST\"&gt;要发送的微博：&lt;input type=\"text\" name=\"msg\"&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;a href=\"weibolist.php\"&gt;进入你的微博列表页面&lt;/a&gt;&lt;br /&gt; //这个不用写，写了后有更好玩的~&lt;/body&gt;&lt;/html&gt; 把这四个文件打包成一个zip文件，到新浪SAE里面创建一个应用，这时在创建应用的时候就不要选择基于URL安装了，选择下面的“选择文件“，把刚才那压缩的zip文件，点击”安装到以上位置“ 刚才config.php代码里面的define( “WB_CALLBACK_URL” , ‘http://kevinweibo.sinaapp.com/getAccess.php‘ ); 这里面红字应该知道填写什么了吧？你应用的地址加上getaccess.php 好了，大功告成，可以爽一爽了，进入你刚才创建的应用 http://kevinweibo.sinaapp.com/getRequestToken.php 点击上面的受权链接，并将自己的微博账号受权，接着会进入到send.php页面，随便写句话，点击”提交“，看看微博发出去没，哈哈~ 更多要玩点更好玩的，可以下载微博SDK，查看里面的API方法，或者在线的查看 http://open.weibo.com/wiki/API%E6%96%87%E6%A1%A3_V2 我这里创建了个weibolist.php文件，来简单的调用了几个12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpsession_start();include ('config.php');//include ('saetv2.ex.class.php');include ('saet.ex.class.php');$auth = new SaeTClient(WB_AKEY,WB_SKEY, $_SESSION['token'], $_SESSION['token_secret']);$publicmsg=$auth-&gt;followers();//调用followers方法来显示当前用户的粉丝列表 //用foreach方法来遍历数组foreach ($publicmsg as $key=&gt;$value)&#123;echo \"$key =&gt; $value\".\"&lt;br&gt;\";foreach($value as $key1=&gt;$value1)&#123;echo \"$key1 =&gt; $value1\".\"&lt;br&gt;\";&#125;echo \"&lt;br&gt;\";&#125;//这里是旧版的SDK的例子$mes = $_POST[msg];$auth-&gt;update($mes);?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"POST\"&gt;要发送的微博：&lt;input type=\"text\" name=\"msg\"&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;br&gt;&lt;h2&gt;第二种种发送新微博&lt;/h2&gt;&lt;form action=\"weibolist.php\" method=\"POST\"&gt;&lt;input type=\"text\" name=\"msg\" style=\"width:300px\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;h2&gt;发送图片微博&lt;/h2&gt;&lt;form action=\"weibolist.php\" &gt;&lt;input type=\"text\" name=\"msg\" style=\"width:300px\" value=\"文字内容\" /&gt;&lt;input type=\"text\" name=\"pic\" style=\"width:300px\" value=\"图片url\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;?phpif( isset($_REQUEST['pic']) )&#123;$rr = $auth -&gt;upload( $_REQUEST['msg'] , $_REQUEST['pic'] );echo \"&lt;p&gt;发送完成&lt;/p&gt;\" ;&#125;?&gt; 先到这吧，更有意思的东西等待更新的发现~","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[]},{"title":"在SUSE中用Pidgin整合QQ与新浪微博","slug":"227","date":"2012-01-13T17:57:08.000Z","updated":"2017-12-16T10:10:42.532Z","comments":true,"path":"article/227.html","link":"","permalink":"https://www.yangyanxing.com/article/227.html","excerpt":"TX官方出的qq for linux实在是太恶心了，好友不全也就罢了，关键是还总崩溃，忍不了了，一开始我还总是用WEB qq还将就下，可以感觉这个实在是不方便，在网上找了些方法 ， lumqq很久之前就不更新也，不不支持现在的qq登录了，于是找到了传说中的Pidgin，下载了一个最新的2.10.0 软件源，默认的光盘里就有这个软件 下载安装，其实这个软件可以兼容MSN Gtalk facebook,我还额外的下载了一个新浪微博的插件 pidgin-microblog-sina http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/ 软件源但这个插件表现一般，比官方的air客户端差好多，当时只是好奇第一次启动的时候会弹出添加账号窗口，这里选择新浪微博填写好后点击添加会弹出与新浪微博的授权页面，授权后会得到一串数字，填写到弹出的对话框中即可添加QQ有点困难首先下载libqq,","text":"TX官方出的qq for linux实在是太恶心了，好友不全也就罢了，关键是还总崩溃，忍不了了，一开始我还总是用WEB qq还将就下，可以感觉这个实在是不方便，在网上找了些方法 ， lumqq很久之前就不更新也，不不支持现在的qq登录了，于是找到了传说中的Pidgin，下载了一个最新的2.10.0 软件源，默认的光盘里就有这个软件 下载安装，其实这个软件可以兼容MSN Gtalk facebook,我还额外的下载了一个新浪微博的插件 pidgin-microblog-sina http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/ 软件源但这个插件表现一般，比官方的air客户端差好多，当时只是好奇第一次启动的时候会弹出添加账号窗口，这里选择新浪微博填写好后点击添加会弹出与新浪微博的授权页面，授权后会得到一串数字，填写到弹出的对话框中即可添加QQ有点困难首先下载libqq, http://code.google.com/p/libqq-pidgin/downloads/list 下载后用7za 解压，当时我的系统中还没有安装7za，于是用 zypper install p7zip 命令安装 接着解压 7za x libqq.so_0.71_i386.7z e是解压到当前路径 x是解压到压缩包命名的目录下 把解压出来的libqq.so复制到/usr/lib/purple-2 文件夹下 重启Pidgin，这时在添加账号里就有了QQ选项了 添加后界面虽说有点简单，但基本的功能都已经包括了，别奢望太多，毕竟不是100多M的QQ……","categories":[{"name":"Linux相关","slug":"Linux相关","permalink":"https://www.yangyanxing.com/categories/Linux相关/"}],"tags":[]},{"title":"美化opensuse中的字体","slug":"221","date":"2012-01-10T15:37:57.000Z","updated":"2017-12-16T10:10:42.515Z","comments":true,"path":"article/221.html","link":"","permalink":"https://www.yangyanxing.com/article/221.html","excerpt":"原文地址 http://forums.opensuse.org/ae-ae-chinese/aes-aeoe-e-e-ae-zae-aeoe/c-ae-zae-aeoe/470464-opensuse-c-aeoe-oec-zcs-ae-ae-az-e-c-i-oec-ae-mactype.html openSUSE 目前最完美的中文字型设置，类似 Mactype","text":"原文地址 http://forums.opensuse.org/ae-ae-chinese/aes-aeoe-e-e-ae-zae-aeoe/c-ae-zae-aeoe/470464-opensuse-c-aeoe-oec-zcs-ae-ae-az-e-c-i-oec-ae-mactype.html openSUSE 目前最完美的中文字型设置，类似 Mactype1.添加linuxsir中文官方源 http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/ 安装里面的freetype2 安装，然后 Konsole 输入 infctl settyle 「styles」，默认的 style 有 infinality / linux / osx / osx2 / win7 / win98 / winxp 建议大家用 osx。 这个命令我不知道我使用的对不对，我是这么输入的，infctl settyle osx 结果就是字体变了，还挺好看的","categories":[{"name":"Linux相关","slug":"Linux相关","permalink":"https://www.yangyanxing.com/categories/Linux相关/"}],"tags":[]},{"title":"关于Audacious中字体乱码的解决办法","slug":"216","date":"2012-01-10T15:30:03.000Z","updated":"2017-12-16T10:10:42.240Z","comments":true,"path":"article/216.html","link":"","permalink":"https://www.yangyanxing.com/article/216.html","excerpt":"安装完Audatious可以正常播放后，可以播放列表里确是惨不忍睹…… 原因不说了，因为在windows下使用的不同标准的字体","text":"安装完Audatious可以正常播放后，可以播放列表里确是惨不忍睹…… 原因不说了，因为在windows下使用的不同标准的字体 更改设置 文件-首选项- playlist 在Custom string 上输入 %f 在上面的Fallback character encodings里输入 GBK 关闭 - 点击 播放列表- 刷新 OK 一切正常了～","categories":[{"name":"Linux相关","slug":"Linux相关","permalink":"https://www.yangyanxing.com/categories/Linux相关/"}],"tags":[]},{"title":"opensuse12.1从安装到使用的一些札记","slug":"210","date":"2012-01-10T15:11:27.000Z","updated":"2017-12-16T10:10:42.300Z","comments":true,"path":"article/210.html","link":"","permalink":"https://www.yangyanxing.com/article/210.html","excerpt":"opensuse也玩了很久了，但我还是觉得自己是一个初学者，写这篇文章主要是想记录一下自己使用中的问题，以后如果再次安装好做一个记录 本文主要参考网张上的文章 http://cn.opensuse.org 中文wiki http://hi.baidu.com/winland0704/home winland的百度空间 http://lug.ustc.edu.cn/sites/opensuse-guide/ Unofficial guide","text":"opensuse也玩了很久了，但我还是觉得自己是一个初学者，写这篇文章主要是想记录一下自己使用中的问题，以后如果再次安装好做一个记录 本文主要参考网张上的文章 http://cn.opensuse.org 中文wiki http://hi.baidu.com/winland0704/home winland的百度空间 http://lug.ustc.edu.cn/sites/opensuse-guide/ Unofficial guide一、安装 如果有条件还是选择光盘安装，如果没有条件或者想搞些新鲜的玩意，选择硬盘安装，我使用的是用Burg4DOS硬盘安装openSUSE 安装教程请到http://www.vdisk.cn/down/index/9152371A9887 这里下载，这个教程很简单，也很好用，根着教程操作，但是到了分区这一步要小心，这里面如果出现什么磁盘空间不足之类的提示，在这个界面把 create LVM based proposal选项选中 硬盘安装之后有一个遗留问题，就是镜像所在的磁盘不能开机自动挂载上，要挂载的话还要输入一次ROOT密码，这个我找了半天也没有找到方法，但是这样却有一个好处，就是以后在安装这个镜像里的软件时，可以直接安装，我感觉这个可能就是问题所在 2、安装这后我认为最先要解决的是各种多媒体的codec 可以用一键安装 KDE GNOME我安装的KDE桌面，还是推荐使用KDE桌面 主要的codec有 libxine1-codecs（多媒体播放引擎，支持MPEG-4等） k3b-codecs（K3b的MP3支持） ffmpeg（有名的音视频编解码器，支持众多格式） lame（MP3格式支持） gstreamer-0_10-plugins-bad gstreamer-0_10-plugins-ugly gstreamer-0_10-ffmpeg（这三个是GStreamer多媒体播放支持） libdvdcss2（如果您不播放DVD可以跳过这条 注意：在刚刚安装完系统的时候，会有一个系统进程一直在用的软件，这时候你既不能安装软件，也不能做软件源的操作，等会吧， 做了一次更新检查后就好了。 在安装软件的时候，有时候会默认添加很多软件源，而且这些软件源默认也是做自动刷新的，所以注意如果不用的话要取消添加这些源， 即使添加了也要把自动刷新取消，可以定期做一次更新，要不然每次做软件的操作会有很长的等待时间，很烦人。 3.添加一些常用的软件源 parkman: 这个几乎是每一个linux用户必须添加的，很多多媒体的软件等都需要它，unofficial guide上推荐的台湾源我是怎么也添加不上去 所以我就不用那个源了，我用的是 http://packman.inode.at/suse/12.1/ 这个源 或者你可以找到很多别的好用的packman源， 软件源里一定要有的，OSS开源 non-oss非开源 update更新,我添加了国内的163镜像源， 使用帮助http://mirrors.163.com/.help/opensuse.html 还有一些源都是些牛人建立的，也不错，里面有一些国人常用的软件 http://download.opensuse.org/repositories/home:/hillwood/openSUSE_12.1/ http://download.opensuse.org/repositories/home:/swyear/openSUSE_12.1/ http://download.opensuse.org/repositories/home:/stecue/openSUSE_12.1/ http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/自己选择一些就可以了，以后你会增加很多的。 添加完软件源后要做的当然是安装软件了，其实常用的软件在安装opensuse的时候已经自动安装上了，但这里就安装的是自己喜欢 别的软件 如 Audaciou Smplayer 等 打开 yast 点击安装软件 搜索 MPlayer、SMPlayer、Audacious，AMSN安装，会自动提示安装必要的库 其他的常用的软件 Chrome 这个是我必须安装的 https://www.google.com/chrome?platform=linux Skype: http://skype.tom.com/download/linux/skype-2.2.0.25-suse.i586.rpm Fcitx: 这个是我后来才发现的非常好用的输入法，因为我使用的是五笔输入法，在linux上以前一直在ibus下使用万能五笔，但是不 知道12.1的怎么回事，还是按照原来的方法添加了万能五笔后，既没有添加成功，默认安装的输入法也丢失了，无奈之下，上网上搜索了下都说Fcitx这个输入法中的五笔相当好用，于是将系统中原来的ibus和ibus-table remove掉了，安装了Fcitx，这个输入法太惊艳了，我一下子就喜欢上了，爱不释手啊～～","categories":[{"name":"Linux相关","slug":"Linux相关","permalink":"https://www.yangyanxing.com/categories/Linux相关/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.yangyanxing.com/tags/linux/"}]},{"title":"关于PHP面向对象的一点网摘(继承性与访问类型)","slug":"205","date":"2011-12-18T09:32:20.000Z","updated":"2017-12-16T10:10:42.093Z","comments":true,"path":"article/205.html","link":"","permalink":"https://www.yangyanxing.com/article/205.html","excerpt":"类的继承继承作为面向对象的三个重要特性的一个方面，在面向对象的领域有着极其重要的作用，好像没听说哪个面向对象的语言不支持继承。继承是PHP5 面向对象程序设计的重要特性之 一，它是指建立一个新的派生类，从一个或多个先前定义的类中继承数据和函数，而且可以 重新定义或加进新数据和函数，从而建立了类的层次或等级。说的简单点就是，继承性是子类自动共享父类的数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的 时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为 自己的内容，并加入若干新的内容。比如你现在已经有一个“人”这个类了，这个类里面有 两个成员属性“姓名和年龄”以及还有两个成员方法“说话的方法和走路的方法”，如果现在 程序需要一个学生的类，因为学生的也是人，所以学生也有成员属性“姓名和年龄”以及成 员方法“说话的方法和走路的方法”，这个时候你就可以让学生类来继承人这个类，继承之后， 学生类就会把人类里面的所有的属性都继承过来，就不用你再去重新声明一遍这些成员属性 和方法了，因为学生类里面还有所在学校的属性和学习的方法，所以在你做的学生类里面有 继承自人类里面的属性和方法之外在加上学生特有的“所在学校属性”和“学习的方法”, 这样一个学生类就声明完成了，继承我们也可以叫做“扩展”，从上面我们就可以看出，学生 类对人类进行了扩展，在人类里原有两个属性和两个方法的基础上加上一个属性和一个方法 扩展出来一个新的学生类。 通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型 不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基 类，又称为父类以及超类。由已存在的类派生出的新类称为派生类，又称为子类。 在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分 类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重性。采用继承性， 提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。在C++语言中，一个派生类可以从一个基类派生，也可以从多个基类派生。从一个基类派生的继承称为单继承；从多个基类派生的继承称为多继承。但是在PHP 和Java 语言里面没有多继承，只有单继承，也就是说，一个类只能直接从 一个类中继承数据，这就是我们所说的单继承。 也就是说一个子类只能有一个父类，但一个父类可以有多个子类例如：下面是“人”类的抽象","text":"类的继承继承作为面向对象的三个重要特性的一个方面，在面向对象的领域有着极其重要的作用，好像没听说哪个面向对象的语言不支持继承。继承是PHP5 面向对象程序设计的重要特性之 一，它是指建立一个新的派生类，从一个或多个先前定义的类中继承数据和函数，而且可以 重新定义或加进新数据和函数，从而建立了类的层次或等级。说的简单点就是，继承性是子类自动共享父类的数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的 时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为 自己的内容，并加入若干新的内容。比如你现在已经有一个“人”这个类了，这个类里面有 两个成员属性“姓名和年龄”以及还有两个成员方法“说话的方法和走路的方法”，如果现在 程序需要一个学生的类，因为学生的也是人，所以学生也有成员属性“姓名和年龄”以及成 员方法“说话的方法和走路的方法”，这个时候你就可以让学生类来继承人这个类，继承之后， 学生类就会把人类里面的所有的属性都继承过来，就不用你再去重新声明一遍这些成员属性 和方法了，因为学生类里面还有所在学校的属性和学习的方法，所以在你做的学生类里面有 继承自人类里面的属性和方法之外在加上学生特有的“所在学校属性”和“学习的方法”, 这样一个学生类就声明完成了，继承我们也可以叫做“扩展”，从上面我们就可以看出，学生 类对人类进行了扩展，在人类里原有两个属性和两个方法的基础上加上一个属性和一个方法 扩展出来一个新的学生类。 通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型 不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基 类，又称为父类以及超类。由已存在的类派生出的新类称为派生类，又称为子类。 在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分 类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重性。采用继承性， 提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。在C++语言中，一个派生类可以从一个基类派生，也可以从多个基类派生。从一个基类派生的继承称为单继承；从多个基类派生的继承称为多继承。但是在PHP 和Java 语言里面没有多继承，只有单继承，也就是说，一个类只能直接从 一个类中继承数据，这就是我们所说的单继承。 也就是说一个子类只能有一个父类，但一个父类可以有多个子类例如：下面是“人”类的抽象 代码片段12345678910111213141516class Person&#123; //定义一个“人”类作为父类//下面是人的成员属性var $name;var $sex;var $age;//定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值function __construct($name, $sex, $age)&#123;$this-&gt;name=$name;$this-&gt;sex=$sex;$this-&gt;age=$age;&#125;//这个人可以说话的方法, 说出自己的属性function say() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 性别：\".$this-&gt;sex.\" 我的年龄是：\".$this-&gt;age.\"&lt;br&gt;\";&#125;&#125; 下面我们做一个“学生类”，如果不是用继承如下：代码片段 123456789101112131415161718192021222324252627282930class Student&#123; //定义一个“人”类做为父类//下面是人的成员属性var $name;var $sex;var $age;var $school; //新添加的学生所在学校的属性//定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值function __construct($name=””, $sex=””, $age=””, $school=””)&#123;$this-&gt;name=$name;$this-&gt;sex=$sex;$this-&gt;age=$age;$this-&gt;school=$school;&#125;//这个人可以说话的方法, 说出自己的属性function say() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 性别：\".$this-&gt;sex.\" 我的年龄是：\".$this-&gt;age.\"&lt;br&gt;\";&#125;//这个学生学习的方法function study() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 我正在”.$this-&gt;school.”学习&lt;br&gt;\";&#125;&#125;//定义一个子类“学生类“使用”extends”关键字来继承”人”类class Student extends Person&#123;var $school; //学生所在学校的属性 只是新添加上去//这个学生学习的方法function study() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 我正在”.$this-&gt;school.”学习&lt;br&gt;\";&#125;&#125; 通过上面“Student”类的定义，Student 类通过使用“extends”这个关键字把Person 类里的所有成员属性和成员方法都继承过来了，并扩展了一个所在学校成员属性“school”，和一个学习方法“study()”。现在子类“Student”里面和使用这个类实例出来的对象都具有如下的属性和方法：学生类“Student”里面的成员属性有：姓名：name;年龄：age;性别：sex;学校：school;学生类“Student”里面的成员方法有：说话方法：say();学习方法：study();通过上面类继承的使用简化了对象、类的创建工作量，增加了代码的可重性。但是从上面这一个例子上中“可重用性”以及其它的继承性所带来的影响，我们看的还不是特别的明显，你扩展的去想一下，人有无数个岗位，比如上面的学生还有老师、工程师、医生、工人 等，很多很多，如果每个类都定义“人”都共同具有的属性和方法，想一想会有很大的工作 量，这些属性和方法都可以从“Person”人类里面继承过来。 重载新的方法 (只是在子类里重新定义父类中的函数)在学习PHP 这种语言中你会发现，PHP 中的方法是不能重载的，所谓的方法重载就是定义相同的方法名，通过“参数的个数”不同或“参数的类型”不同,来访问我们的相同方法 名的不同方法。但是因为PHP 是弱类型的语言，所以在方法的参数中本身就可以接收不同类 型的数据，又因为PHP 的方法可以接收不定个数的参数，所以通过传递不同个数的参数调用不相同方法名的不同方法也是不成立的。所以在PHP 里面没有方法重载。不能重载也就是在 你的项目中不能定义相同方法名的方法。另外，因为PHP 没有名子空间的概念，在同一个页 面和被包含的页面中不能定义相同名称的方法，也不能定义和PHP 给我提供的方法重名，当然在同一个类中也不能定义相同名称的方法。我们这里所指的重载新的方法所指的是什么呢？其实我们所说的重载新的方法就是子类覆盖父类的已有的方法，那为什么要这么做呢？父类的方法不是可以继承过来直接用吗？但 有一些情况是我们必须要覆盖的，比如说我们前面提到过的例子里面，“Person”这个人类里 面有一个“说话”的方法，所有继承“Person”类的子类都是可以“说话”的，我们“Student” 类就是“Person”类的子类，所以“Student”的实例就可以“说话”了，但是人类里面“说 话”的方法里面说出的是“Person”类里面的属性，而“Student”类对“Person”类进行了扩 展，又扩展出了几个新的属性，如果使用继承过来的“say()”说话方法的话，只能说出从 “Person”类继承过来的那些属性，那么新扩展的那些属性使用这个继承过来的“say()”的 方法就说不出来了，那有的人就问了，我在“Student”这个子类中再定义一个新的方法用于 说话，说出子类里面所有的属性不就行了吗？一定不要这么做，从抽象的角度来讲，一个“学 生”不能有两种“说话”的方法，就算你定义了两个不同的说话的方法，可以实现你想要的 功能，被继承过来的那个“说话“方法可能没有机会用到了，而且是继承过来的你也删不掉。 这个时候我们就要用到覆盖了。虽然说在PHP 里面不能定义同名的方法，但是在父子关系的两个类中，我们可以在子类 中定义和父类同名的方法，这样就把父类中继承过来的方法覆盖掉了。 代码片段123456789101112131415161718192021222324252627282930&lt;?class Person&#123; //定义一个“人”类做为父类//下面是人的成员属性var $name;var $sex;var $age;//定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值function __construct($name, $sex, $age)&#123;$this-&gt;name=$name;$this-&gt;sex=$sex;$this-&gt;age=$age;&#125;function say() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 性别：\".$this-&gt;sex.\" 我的年龄是：\".$this-&gt;age.\"&lt;br&gt;\";&#125;&#125;class Student extends Person&#123;var $school;function study() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 我正在”.$this-&gt;school.”学习&lt;br&gt;\";&#125;//这个学性可以说话的方法, 说出自己所有的属性，覆盖了父类的同名方法function say() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 性别：\".$this-&gt;sex.\" 我的年龄是：\".$this-&gt;age.\"我在\".$this-&gt;school.\"上学.&lt;br&gt;\";&#125;&#125;?&gt; 上面的例子，我们就在“Student”子类里覆盖了继承父类里面的“say()”的方法，通过覆盖我们就实现了对“方法”扩展。 但是，像这样做虽然解决了我们上面说的问题，但是在实际开发中，一个方法不可能就一条代码或是几条代码，比如说“Person”类里面“say()”方法有里面有100 条代码，如果我们想对这个方法覆盖保留原有的功能外加上一点点功能，就要把原有的100 条代码重写 一次，再加上扩展的几条代码，这还算是好的，而有的情况，父类中的方法是看不见原代码 的，这个时候你怎么去重写原有的代码呢？我们也有解决的办法，就是在子类这个方法中可 以调用到父类中被覆盖的方法，也就是把被覆盖的方法原有的功能拿过来再加上自己的一点 功能，可以通过两种方法实现在子类的方法中调用父类被覆盖的方法：一种是使用父类的“类名：：“来调用父类中被覆盖的方法；一种是使用“parent：：”的方试来调用父类中被覆盖的方法； 123456789101112131415class Student extends Person&#123;var $school;function study() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 我正在”.$this-&gt;school.”学习&lt;br&gt;\";&#125;//这个学性可以说话的方法, 说出自己所有的属性，覆盖了父类的同名方法function say() &#123;//使用父类的“类名::“来调用父类中被覆盖的方法；// Person::say();//或者使用“parent：：”的方试来调用父类中被覆盖的方法；这种方法没法加上了类的函数parent::say();//加上一点自己的功能echo “我的年龄是：\".$this-&gt;age.\"我在\".$this-&gt;school.\"上学.&lt;br&gt;\";&#125;&#125; 现在用两种方式都可以访问到父类中被覆盖的方法，我们选那种方式最好呢？用户可能会发现自己写的代码访问了父类的变量和函数。如果子类非常精炼或者父类非常专业化的时候尤其是这样。不要用代码中父类文字上的名字，应该用特殊的名字parent，它指的就是子类在extends 声明中所指的父类的名字。这样做可以避免在多个地方使用父类的名字。如果继承树在实现的过程中要修改，只要简单地修改类中extends 声明的部分。同样，构造方法在子类中如果没有声明的话，也可以使用父类中的构造方法，如果子类中重新定义了一个构造方法也会覆盖掉父类中的构造方法，如果想使用新的构造方法为所有属性赋值也可以用同样的方式。代码片段 12345678910111213141516class Student extends Person&#123;var $school; //学生所在学校的属性function __construct($name, $sex, $age, $school)&#123;//使用父类中的方法为原有的属性赋值parent::__construct($name, $sex, $age);$this-&gt;school=$school;&#125;//这个学生学习的方法function study() &#123;echo \"我的名子叫：\".$this-&gt;name.\" 我正在”.$this-&gt;school.”学习&lt;br&gt;\";&#125;//这个人可以说话的方法, 说出自己的属性function say() &#123;parent::say();//加上一点自己的功能echo “我的年龄是：\".$this-&gt;age.\"我在\".$this-&gt;school.\"上学.&lt;br&gt;\"; 访问类型类型的访问修饰符允许开发人员对类成员的访问进行限制，这是PHP5 的新特性，但却是OOP 语言的一个好的特性。而且大多数OOP 语言都已支持此特性。PHP5 支持如下3 种访问修饰符public (公有的、默认的)，private (私有的)和protected (受保护的)三种。 public 公有修饰符，类中的成员将没有访问限制，所有的外部成员都可以访问（读和写）这个类成员（包括成员属性和成员方法），在PHP5 之前的所有版本中，PHP 中类的成员都是public 的，而且在PHP5 中如果类的成员没有指定成员访问修饰符，将被视为public。 例：public $name; public function say(){};private 私有修改符，被定义为private 的成员，对于同一个类里的所有成员是可见的，即是没有访问限制；但对于该类的外部代码是不允许改变甚至读操作，对于该类的子类，也不能访问private 修饰的成员。例：private $var1 = ‘A’; //属性private function getValue(){} //函数protected 保护成员修饰符，被修饰为protected 的成员不能被该类的外部代码访问。但是对于该类的子类有访问权限，可以进行属性、方法的读及写操作,该子类的外部代码包括其的子类都不具有访问其属性和方法的权限。例：protected $name;protected function say(){}; private protected public同一个类中 √ √ √类的子类中 √ √所有的外部成员 √代码片段12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php/*** Define MyClass*/class MyClass&#123;// Contructors must be publicpublic function __construct() &#123; &#125;// Declare a public methodpublic function MyPublic() &#123; &#125;// Declare a protected methodprotected function MyProtected() &#123; &#125;// Declare a private methodprivate function MyPrivate() &#123; &#125;// This is publicfunction Foo() &#123;$this-&gt;MyPublic();$this-&gt;MyProtected();$this-&gt;MyPrivate();&#125;&#125;$myclass = new MyClass;$myclass-&gt;MyPublic(); //Works$myclass-&gt;MyProtected(); // Fatal Error$myclass-&gt;MyPrivate(); // Fatal Error$myclass-&gt;Foo(); // Public, Protected and Private work/*** Define MyClass2*/class MyClass2 extends MyClass&#123;// This is publicfunction Foo2()&#123;$this-&gt;MyPublic();$this-&gt;MyProtected();$this-&gt;MyPrivate(); // Fatal Error&#125;&#125;$myclass2 = new MyClass2;$myclass2-&gt;MyPublic(); // Works$myclass2-&gt;Foo2(); // Public and Protected work, not Private?&gt; 另外在子类覆盖父类的方法时也要注意一点，子类中方法的访问权限一定不能低于父类被覆盖方法的访问权限，也就是一定要高于或等于父类方法的访问权限。 例如，如果父类方法的访问权限是protected 那么子类中要覆盖的权限就要是protected和public，如果父类的方法是public 那么子类中要覆盖的方法只能也是public，总之子类中的方法总是要高于或等于父类被覆盖方法的访问权限.","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[]},{"title":"关于PHP面向对象的一点网摘(基本概念与封装性)","slug":"199","date":"2011-12-15T16:50:04.000Z","updated":"2017-12-16T10:10:42.454Z","comments":true,"path":"article/199.html","link":"","permalink":"https://www.yangyanxing.com/article/199.html","excerpt":"本文大部门摘自网络，作为我学习的一点总结也还不错 PHP面向对象技术 本部分一共包括以下一些技术点：1.面向对象的概念2.什么是类，什么是对象，类和对象这间的关系3.什么是面向对象编程呢？4.如何抽象出一个类？5.如何实例化对象？6.如何去使用对象中的成员？7.特殊的引用“$this”的使用8.构造方法与析构方法9.封装性","text":"本文大部门摘自网络，作为我学习的一点总结也还不错 PHP面向对象技术 本部分一共包括以下一些技术点：1.面向对象的概念2.什么是类，什么是对象，类和对象这间的关系3.什么是面向对象编程呢？4.如何抽象出一个类？5.如何实例化对象？6.如何去使用对象中的成员？7.特殊的引用“$this”的使用8.构造方法与析构方法9.封装性 10.set()、 get()、 isset()、 unset()四个方法的应用11.类的继承12.多态的应用13.重载新的方法14.访问类型15.静态成员的使用16.final关键字的应用17.toString()方法18.克隆对象19.call处理调用错误20.自动加载类21.把对象串行化22.抽象方法和抽象类23.php5接口技术 1.面向对象的概念面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种计算机编程架构，OOP的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成，OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。面向对象一直是软件开发领域内比较热门的话题，首先，面向对象符合人类看待事物的一般规律。其次，采用面向对象方法可以使系统各部分各司其职、各尽所能。为编程人员敞开了一扇大门，使其编程的代码更简洁、更易于维护，并且具有更强的可重用性。有人说PHP不是一个真正的面向对象的语言，这是事实。PHP 是一个混合型语言，你可以使用OOP，也可以使用传统的过程化编程。然而，对于大型项目，你可能需要在PHP 中使用纯的OOP去声明类，而且在你的项目里只用对象和类。这个概念我先不多说了，因为有很多朋友远离面向对象编程的主要原因就是一接触面向对象概念的时候就理解不上去，所以就不想去学下去了。等读者看完整体内容后再去把概念搞明白吧。 2.什么是类，什么是对象，类和对象这间的关系类的概念：类是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和服务两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性说明和服务说明两个主要部分。 对象的概念：对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。从更抽象的角度来说，对象是问题域或实现域中某些事物的一个抽象，它反映该事物在系统中需要保存的信息和发挥的作用；它是一组属性和有权对这些属性进行操作的一组服务的封装体。客观世界是由对象和对象之间的联系组成的。类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。类描述了一组有相同特性（属性）和相同行为（方法）的对象。 3.什么是面向对象编程呢？就不说他的概念，如果你想建立一个电脑教室，首先要有一个房间，房间里面要有N台电脑，有N张桌子， N把椅子，白板，投影机等等，这些是什么，刚才咱们说了，这就是对象，能看到的一个个的实体，可以说这个电脑教室的单位就是这一个个的实体对象，它们共同组成了这个电脑教室，那么我们是做程序，这和面向对象有什么关系呢？开发一个系统程序和建一个电脑教室类似，你把每个独立的功能模块抽象成类，形成对象，由多个对象组成这个系统，这些对象之间都能够接收信息、处理数据和向其它对象发送信息等等相互作用。就构成了面向对象的程序。 4.如何抽象出一个类？上面已经介绍过了，面向对象程序的单位就是对象，但对象又是通过类的实例化出来的，所以我们首先要做的就是如何来声明类，做出来一个类很容易，只要掌握基本的程序语法定义规则就可以做的出来，那么难点在那里呢？一个项目要用到多少个类，用多少个对象，在那要定义类，定义一个什么样的类，这个类实例化出多少个对象，类里面有多少个属性，有多少个方法等等,这就需要读者通过在实际的开发中就实际问题分析设计和总结了。类的定义：class 类名{} 使用一个关键字class和后面加上一个你想要的类名以及加上一对大括号， 这样一个类的结构就定义出来了，只要在里面写代码就可以了，但是里面写什么？ 能写什么？怎样写才是一个完整的类呢？上面讲过来，使用类是为了让它实例出对象来给我们用，这就要知道你想要的是什么样的对象了，像上面我们讲的一个装机配置单上写什么，你装出来的机子就有什么。比如说，一个人就是一个对象，你怎么把一个你看好的人推荐给你们领导呢？当然是越详细越好了：首先，你会介绍这个人姓名、性别、年龄、身高、体重、电话、家庭住址等等。然后，你要介绍这个人能做什么，可以开车，会说英语，可以使用电脑等等。只要你介绍多一点，别人对这个人就多一点了解，这就是我们对一个人的描述， 现在我们总结一下，所有的对象我们用类去描述都是类似的，从上面人的描述可以看到， 做出一个类来，从定义的角度分两部分，第一是从静态上描述，第二是从动态上描述，静态上的描述就是我们所说的 属性，像上面我们看到的，人的姓名、性别、年龄、身高、体重、电话、家庭住址等等。动态上也就是人的这个对象的功能，比如这个人可以开车，会说英语，可以使用电脑等等，抽象成程序时，我们把动态的写成函数或者说是方法，函数和方法是一样的。所以，所有类都是从属性和方法这两方面去写，属性又叫做这个类的成员属性，方法叫做这个类的成员方法。class 人{成员属性：姓名、性别、年龄、身高、体重、电话、家庭住址成员方法：可以开车， 会说英语， 可以使用电脑}属性：通过在类定义中使用关键字” var “（如果没有别的关键词修饰，则用var来修饰）来声明变量，即创建了类的属性,虽然在声明成员属性的时候可以给定初始值， 但是在声明类的时候给成员属性初使值是没有必要的，比如说要是把人的姓名赋上“张三”,那么用这个类实例出几十个人，这几十个人都叫张三了，所以没有必要， 我们在实例出对象后给成员属性初始值就可以了。如： var $somevar;方法(成员函数)：通过在类定义中声明函数，即创建了类的方法。如： function somefun(参数列表){ … … } 上面就是一个类的声明，从属性和方法上声明出来的一个类，但是成员属性最好在声明的时候不要给初始的值，因为我们做的人这个类是一个描述信息，将来用它实例化对象，比如实例化出来10个人对象，那么这10个人， 每一个人的名子，性别， 年龄都是不一样的，所以最好不要在这个地方给成员属性赋初值，而是对每个对象分别赋值的。用同样的办法可以做出你想要的类了， 只要你能用属性和方法能描述出来的实体都可以定义成类，去实例化对象。为了加强你对类的理解，我们再做一个类，做一个形状的类，形状的范围广了点， 我们就做个矩形吧，先分析一下，想一想从两方面分析，矩形的属性都有什么？矩形的功能都有什么？class 矩形{//矩形的属性矩形的长；矩形的宽； //矩形的方法矩形的周长；矩形的面积；} 如果用这个类来创建出多个矩形对象，每个矩形对象都有自己的长和宽， 都可以求出自己的周长和面积了。 面向对象的三大特性一、封装性 封装性是面向对象编程中的三大特性之一，封装性就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义:1.把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位（即对象）。2.信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界〔或者说形成一道屏障〕，只保留有限的对外接口使之与外部发生联系。 封装的原则在软件上的反映是：要求使对象以外的部分不能随意存取对象的内部数据（属性），从而有效的避免了外部错误对它的”交叉感染”，使软件错误能够局部化，大大减少查错和排错的难度。 用个实例来说明吧，假如某个人的对象中有年龄和工资等属性，像这样个人隐私的属性是不想让其它人随意就能获得到的，如果你不使用封装，那么别人想知道就能得到，但是如果你封装上之后别人就没有办法获得封装的属性，除非你自己把它说出去，否则别人没有办法得到。再比如说，个人电脑都有一个密码，不想让其它人随意的登陆，在你的电脑里面拷贝和粘贴。还有就是像人这个对象，身高和年龄的属性，只能是自己来增涨，不可以让别人随意的赋值等等。使用private这个关键字来对属性和方法进行封装：原来的成员:var $name; //声明人的姓名var $sex; //声明人的性别var $age; //声明人的年龄function run(){…….}改成封装的形式：private $name; //把人的姓名使用private关键字进行封装private $sex; //把人的性别使用private关键字进行封装private $age; //把人的年龄使用private关键字进行封装private function run(){……} //把人的走路方法使用private关键字进行封装注意：只要是成员属性前面有其它的关键字就要去掉原有的关键字“var”。通过private就可以把人的成员（成员属性和成员方法）封装上了。封装上的成员就不能被类外面直接访问了，只有对象内部自己可以访问；下面的代码会产生错误：class Person { //下面是人的成员属性 private $name; //人的名子，被private封装上了 private $sex; //人的性别, 被private封装上了 private $age; //人的年龄, 被private封装上了 //这个人可以说话的方法 function say() { echo “我的名子叫：”.$this-&gt;name.” 性别：”.$this-&gt;sex.” 我的年龄是：”.$this-&gt;age.”“; } //这个人可以走路的方法, 被private封装上了 private function run() { echo “这个人在走路”; } } //实例化一个人的实例对象 $p1=new Person(); //试图去给私有的属性赋值， 结果会发生错误 $p1-&gt;name=”张三”; $p1-&gt;sex=”男”; $p1-&gt;age=20; //试图去打印私有的属性， 结果会发生错误 echo $p1-&gt;name.””; echo $p1-&gt;sex.””; echo $p1-&gt;age.”” //试图去打印私有的成员方法， 结果会发生错误 $p1-&gt;run(); ?&gt;输出结果为：Fatal error: Cannot access private property Person::$nameFatal error: Cannot access private property Person::$sexFatal error: Cannot access private property Person::$ageFatal error: Cannot access private property Person::$nameFatal error: Call to private method Person::run() from context ‘’从上面的实例可以看到，私有的成员是不能被外部访问的，因为私有成员只能在本对象内部自己访问，比如，$p1这个对象自己想把他的私有属性说出去，在say()这个方法里面访问了私有属性，这样是可以。（没有加任何访问控制，默认的是public的，任何地方都可以访问）//这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法function say(){ echo “我的名子叫：”.$this-&gt;name.” 性别：”.$this-&gt;sex.” 我的年龄是：”.$this-&gt;age.”“; //在这里也可以访问私有方法 //$this-&gt;run(); }因为成员方法say()是公有的，所以我们在类的外部调用say()方法是可以的，改变上面的代码；class Person { //下面是人的成员属性 private $name; //人的名子，被private封装上了 private $sex; //人的性别, 被private封装上了 private $age; //人的年龄, 被private封装上了 //定义一个构造方法参数为私有的属性姓名$name、性别$sex和年龄$age进行赋值 function construct($name, $sex, $age) //此处如果不给予初始值，则实例化对象时new Person() 里要赋值，否则会有警告 { //通过构造方法传进来的$name给私有成员属性$this-&gt;name赋初使值 $this-&gt;name=$name; //通过构造方法传进来的$sex给私有成员属性$this-&gt;sex赋初使值 $this-&gt;sex=$sex; //通过构造方法传进来的$age给私有成员属性$this-&gt;age赋初使值 $this-&gt;age=$age; } //这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法 function say() { echo “我的名子叫：”.$this-&gt;name.” 性别：”.$this-&gt;sex.” 我的年龄是：”.$this-&gt;age.”“; } } //通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄 $p1=new Person(“张三”，”男”, 20); $p2=new Person(“李四”，”女”, 30); $p3=new Person(“王五”，”男”, 40); //下面访问$p1对象中的说话方法 $p1-&gt;say(); //下面访问$p2对象中的说话方法 $p2-&gt;say(); //下面访问$p3对象中的说话方法 $p3-&gt;say();输出结果为：我的名子叫：张三性别：男我的年龄是：20我的名子叫：李四性别：女我的年龄是：30我的名子叫：王五性别：男我的年龄是：40因为构造方法是默认的公有方法（构造方法不要设置成私有的），所以在类的外面可以访问到，这样就可以使用构造方法创建对象，另外构造方法也是类里面的函数，所以可以用构造方法给私有的属性赋初值。Say()的方法是默认公有的，所以在外面也可以访问的到，说出他自己的私有属性。从上面的例子中我们可以看到，私有的成员只能在类的内部使用，不能被类外部直接来存取，但是在类的内部是有权限访问的，所以有时候我们需要在类的外面给私有属性赋值和读取出来，也就是给类的外部提供一些可以存取的接口，上例中构造方法就是一种赋值的形式，但是构造方法只是在创建对象的时候赋值，如果我们已经有一个存在的对象了，想对这个存在的对象赋值，这个时候，如果你还使用构造方法传值的形式传值，那么就创建了一个新的对象，并不是这个已存在的对象了。所以我们要对私有的属性做一些可以被外部存取的接口，目的就是可以在对象存在的情况下，改变和存取属性的值，但要注意，只有需要让外部改变的属性才这样做，不想让外面访问的属性是不做这样的接口的，这样就能达到封装的目的，所有的功能都是对象自己来完成，给外面提供尽量少的操作。如果给类外部提供接口，可以为私有属性在类外部提供设置方法和获取方法，来操作私有属性.例如： private $age; //私有的属性年龄 function setAge($age) //为外部提供一个公有设置年龄的方法 { if($age130) //在给属性赋值的时候，为了避免非法值设置给属性 return; $this-&gt;age=$age; } function getAge() //为外部提供一个公有获取年龄的方法 { return($this-&gt;age); } 上面的方法是为一个成员属性设置和获取值，当然你也可以为每个属性用同样的方法对其进行赋值和取值的操作，完成在类外部的存取工作。**set() get() isset() unset()四个方法的应用**一般来说，总是把类的属性定义为private，这更符合现实的逻辑。但是，对属性的读取和赋值操作是非常频繁的，因此在PHP5中，预定义了两个函数“get()”和“set()”来获取和赋值其属性,以及检查属性的“isset()”和删除属性的方法“unset()”。上一节中，我们为每个属性做了设置和获取的方法，在PHP5中给我们提供了专门为属性设置值和获取值的方法，“set()”和“get()”这两个方法，这两个方法不是默认存在的，而是我们手工添加到类里面去的，像构造方法(construct())一样, 类里面添加了才会存在，可以按下面的方式来添加这两个方法，当然也可以按个人的风格来添加：//get()方法用来获取私有属性 private function get($property_name) { if(isset($this-&gt;$property_name)) { return($this-&gt;$property_name); }else { return(NULL); } } //set()方法用来设置私有属性 private function set($property_name, $value) { $this-&gt;$property_name = $value; }get()方法：这个方法用来获取私有成员属性值的,有一个参数，参数传入你要获取的成员属性的名称，返回获取的属性值，这个方法不用我们手工的去调用，因为我们也可以把这个方法做成私有的方法，是在直接获取私有属性的时候对象自动调用的。因为私有属性已经被封装上了，是不能直接获取值的（比如：“echo $p1-&gt;name”这样直接获取是错误的），但是如果你在类里面加上了这个方法，在使用“echo $p1-&gt;name”这样的语句直接获取值的时候就会自动调用get($property_name)方法，将属性name传给参数$property_name，通过这个方法的内部执行，返回我们传入的私有属性的值。如果成员属性不封装成私有的，对象本身就不会去自动调用这个方法。set()方法：这个方法用来为私有成员属性设置值的，有两个参数，第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。这个方法同样不用我们手工去调用，它也可以做成私有的，是在直接设置私有属性值的时候自动调用的，同样属性私有的已经被封装上了，如果没有set()这个方法，是不允许的，比如：$this-&gt;name=‘zhangsan’, 这样会出错，但是如果你在类里面加上了set($property_name, $value)这个方法，在直接给私有属性赋值的时候，就会自动调用它，把属性比如name传给$property_name, 把要赋的值“zhangsan”传给$value，通过这个方法的执行，达到赋值的目的。如果成员属性不封装成私有的，对象本身就不会去自动调用这个方法。为了不传入非法的值，还可以在这个方法给做一下判断。代码如下：&lt;?php class Person { //下面是人的成员属性， 都是封装的私有成员 private $name; //人的名子 private $sex; //人的性别 private $age; //人的年龄 //get()方法用来获取私有属性 private function get($property_name) { echo “在直接获取私有属性值的时候，自动调用了这个get()方法“; if(isset($this-&gt;$property_name)) { return($this-&gt;$property_name); } else { return(NULL); } } //set()方法用来设置私有属性 private function set($property_name, $value) { echo “在直接设置私有属性值的时候，自动调用了这个set()方法为私有属性赋值“; $this-&gt;$property_name = $value; } } $p1=new Person(); //直接为私有属性赋值的操作， 会自动调用set()方法进行赋值 $p1-&gt;name=”张三”; $p1-&gt;sex=”男”; $p1-&gt;age=20; //直接获取私有属性的值， 会自动调用get()方法，返回成员属性的值 echo “姓名：”.$p1-&gt;name.”“; echo “性别：”.$p1-&gt;sex.”“; echo “年龄：”.$p1-&gt;age.”“; ?&gt;程序执行结果：在直接设置私有属性值的时候，自动调用了这个set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个set()方法为私有属性赋值在直接设置私有属性值的时候，自动调用了这个set()方法为私有属性赋值在直接获取私有属性值的时候，自动调用了这个get()方法姓名：张三在直接获取私有属性值的时候，自动调用了这个get()方法性别：男在直接获取私有属性值的时候，自动调用了这个get()方法年龄：20以上代码如果不加上get()和set()方法，程序就会出错，因为不能在类的外部操作私有成员，而上面的代码是通过自动调用get()和set()方法来帮助我们直接存取封装的私有成员的。isset() 方法：在看这个方法之前我们看一下“isset()”函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。那么如果在一个对象外面使用“isset()”这个函数去测定对象里面的成员是否被设定可不可以用它呢？分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用“isset()”函数来测定私有成员属性是否被设定了呢？可以，你只要在类里面加上一个“isset()”方法就可以了，当在类外部使用”isset()”函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的“isset()”方法了帮我们完成这样的操作，“isset()”方法也可以做成私有的。你可以在类里面加上下面这样的代码就可以了：private function isset($nm) { echo “当在类外部使用isset()函数测定私有成员$nm时，自动调用“; return isset($this-&gt;$nm); }unset()方法：看这个方法之前呢，我们也先来看一下“unset()”这个函数，“unset()”这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。那么如果在一个对象外部去删除对象内部的成员属性用“unset()”函数可不可以呢，也是分两种情况，如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性，如果对象的成员属性是私有的，我使用这个函数就没有权限去删除，但同样如果你在一个对象里面加上“unset()”这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了“unset()”这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，自动调用“unset()”函数来帮我们删除对象内部的私有成员属性，这个方法也可以在类的内部定义成私有的。在对象里面加上下面的代码就可以了：private function unset($nm) { echo “当在类外部使用unset()函数来删除私有成员时自动调用的“; unset($this-&gt;$nm); }我们来看一个完整的实例：&lt;?php class Person { //下面是人的成员属性 private $name; //人的名子 private $sex; //人的性别 private $age; //人的年龄 //get()方法用来获取私有属性 private function get($property_name) { if(isset($this-&gt;$property_name)) { return($this-&gt;$property_name); }else { return(NULL); } } //set()方法用来设置私有属性 private function set($property_name, $value) { $this-&gt;$property_name = $value; //这里的$this-&gt;$property_name 中$property_name 中要有$的，没有的话将赋不了值 } //isset()方法 private function isset($nm) { echo “isset()函数测定私有成员时，自动调用“; return isset($this-&gt;$nm); } //unset()方法 private function unset($nm) { echo “当在类外部使用unset()函数来删除私有成员时自动调用的“; unset($this-&gt;$nm); } } $p1=new Person(); $p1-&gt;name=”this is a person name”; //在使用isset()函数测定私有成员时，自动调用isset()方法帮我们完成，返回结果为true echo var_dump(isset($p1-&gt;name)).”“; echo $p1-&gt;name.”“; //在使用unset()函数删除私有成员时，自动调用unset()方法帮我们完成，删除name私有属性 unset($p1-&gt;name); //已经被删除了， 所这行不会有输出 echo $p1-&gt;name; ?&gt;输出结果为：isset()函数测定私有成员时，自动调用bool(true)this is a person name当在类外部使用unset()函数来删除私有成员时自动调用的set()、get()、isset()、__unset() 这四个方法都是我们添加到对象里面的，在需要时自动调用的，来完成在对象外部对对象内部私有属性的操作","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.yangyanxing.com/categories/PHP/"}],"tags":[]},{"title":"说说大学里的打工赚钱","slug":"131","date":"2011-11-13T16:02:04.000Z","updated":"2017-12-16T10:10:42.408Z","comments":true,"path":"article/131.html","link":"","permalink":"https://www.yangyanxing.com/article/131.html","excerpt":"今天在收拾屋子的时候发现了多年前办的一张农业银行的信用卡，虽然那张卡我始终没有激活，但是却让我开始想起大学里的关于打工挣钱的话题。那张卡是我当时一个不认识的同学打了份零工，就是替银行办理信用卡，办理一张有多少钱给他，我是在我一个同学要求下，不得已而办的，因为我知道不激活那张卡也没有用，自己也没有什么损失。可是没有想到这个农业银行要是从不舍弃放弃，给我发个快四年的短信…… 直到我换了手机号…… endless…… 于是我就在想一个问题，我这不是为了一个我从来不认识的人而给自己造成这么多年的麻烦吗？","text":"今天在收拾屋子的时候发现了多年前办的一张农业银行的信用卡，虽然那张卡我始终没有激活，但是却让我开始想起大学里的关于打工挣钱的话题。那张卡是我当时一个不认识的同学打了份零工，就是替银行办理信用卡，办理一张有多少钱给他，我是在我一个同学要求下，不得已而办的，因为我知道不激活那张卡也没有用，自己也没有什么损失。可是没有想到这个农业银行要是从不舍弃放弃，给我发个快四年的短信…… 直到我换了手机号…… endless…… 于是我就在想一个问题，我这不是为了一个我从来不认识的人而给自己造成这么多年的麻烦吗？ 上了大学，似乎很多人都有一种长大了的感觉，觉得再花父母的钱多多少少有种罪恶感，于是有的同学可始想着方法去赚钱，于是有的人选择了倒卖东西，有人当家教，有的人选择了成立社团，有的人学了点技术，开始以技术来服务别人来赚钱， 有的人开起了自己的淘宝店，或者开了自己的网站，总之各种吧。 但是在我看来其实他们还是没有找到自己究竟想要一个什么样的大学，自己究竟想要什么，如果真的只是想赚钱，那么上大学真是亏了，学业没有什么成就，钱真的赚不了多少。如果想积累下自己的社会经验，体验下挣钱的不容易，那么还可以理解。 但是像那种办卡的业务，说实在的，赚的钱真的不是什么好钱，首先，你利用的是你的朋友关系，那么作为朋友，无论自己有无需要，在面子上总是要给的，既然你开口了，对于我来说也不是多大点事，办也就办了，无所谓，但是你有没有想过，通过你的这份打工，你除了得到了钱你还得到了什么？你不会体验到赚钱是件很困难的事情，因为你有朋友，你的人脉也不会有多大扩展，甚至还会因为这张卡而影响你在你朋友圈中的地位，换句话说，以后别人找你做一件你不喜欢的事情，那么你有什么理由拒绝别人？更何况还有很多你都没有见过面的人因为你而受到银行无休止的短信骚扰，这么人你怎么处理？而你手拿着轻而易举得来的钱你又用在了什么地方？吃喝？还是继续做更大的生意？ 我在大学里也打过工，赚的钱加起来也不足1000，但其实我自己也不想做，很多时候也是出于朋友上的关系，一份是在高校资讯会的时候兜售一个高考的复习资料，当时做的时候学校管，还要躲着保卫处的人，感觉自己在做什么见不得人的事，状态非常不好。另一份是向大一新生推销英语报纸，这个工作似乎是各大报纸商每年都要做的，因为也只有大一小孩才会订，但其实当时做这份推销工作的同时我也是想在向大一新生推销我的网站，只是顺便，虽然感觉这次推销效果比高考那个好一点，但还是会觉得有一种违反校规的感觉，因为还是要躲着宿管大妈。 两次经历给我最大的收获就是让我知道我真的不适合做销售…… 因为我不能克服自己的心理障碍，而且投入的时间也最后的所得不能达到我的预期。 我觉得大学里如果想要赚钱，还是想有个自己的规划吧，或者说有个更明确的目的，叫君子爱财，取之有道，如果这些问题还没有想清楚，那么继续想，实在想不出来就去好好学习，不想好好学习就去谈恋爱，没有恋爱去谈那么就多交朋友，如果朋友也不想交，那么就多学点技能，如果技能也不想学，那么就健身，踢球，打篮球，运动也不想干那么就去当志愿者，或者在社会上当义工，大学里有很多事情可以去做，而赚钱的话你以后会发现你虽然得到了点金钱，但却错过了更多美好的大学时光。","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"说说微博与RSS","slug":"129","date":"2011-11-06T14:04:18.000Z","updated":"2017-12-16T16:12:03.575Z","comments":true,"path":"article/129.html","link":"","permalink":"https://www.yangyanxing.com/article/129.html","excerpt":"已经把人人网注销了一段时间了，因为在微博出现之后，我觉得人人网的信息量太少了，而且翻来覆去就那点东西，不是爱就是情，不是星座就是愤青，信息更新太慢了，而且我惭惭觉得SNS在影响着人们正常的沟通方式，看上去在网上大家聊的挺欢，但在现实生活中我们却很少和对方打声招呼。 微博出现以后其实强大的信息量很吸引我，到目前为止我关注了397人，基本上可以分为朋友，互联网信息，企业高管，名星，普通网友，每当我刷新的时候总会有很多信息出现，起初我还是因为微博上好玩的图片多而喜欢上微博，但后来当我快习惯了微博后，开始搜索一些与文化，生活，购物等的微博来关注，可以说微博是我主要获得信息的渠道，以前我总会用一个例子来说明，给你一分钟，你可以阅读多少条微博？但如果在SNS你可以阅读多少篇日志？或者说是多少条无病呻吟的状态？在微博的世界里，你不必关注有多少人回复你，而在SNS里，你却很在乎有多少朋友在关心你，在回复你，因为微博是一个信息获取的渠道，你在乎的是我在这段时间里又获得了多少信息。","text":"已经把人人网注销了一段时间了，因为在微博出现之后，我觉得人人网的信息量太少了，而且翻来覆去就那点东西，不是爱就是情，不是星座就是愤青，信息更新太慢了，而且我惭惭觉得SNS在影响着人们正常的沟通方式，看上去在网上大家聊的挺欢，但在现实生活中我们却很少和对方打声招呼。 微博出现以后其实强大的信息量很吸引我，到目前为止我关注了397人，基本上可以分为朋友，互联网信息，企业高管，名星，普通网友，每当我刷新的时候总会有很多信息出现，起初我还是因为微博上好玩的图片多而喜欢上微博，但后来当我快习惯了微博后，开始搜索一些与文化，生活，购物等的微博来关注，可以说微博是我主要获得信息的渠道，以前我总会用一个例子来说明，给你一分钟，你可以阅读多少条微博？但如果在SNS你可以阅读多少篇日志？或者说是多少条无病呻吟的状态？在微博的世界里，你不必关注有多少人回复你，而在SNS里，你却很在乎有多少朋友在关心你，在回复你，因为微博是一个信息获取的渠道，你在乎的是我在这段时间里又获得了多少信息。于是我最近在想一个问题，微博的定位到底是自媒体还是社交网络？我现在觉得微博社交的成分要少一些，更多的是一个媒体的发布渠道，可能也因人而义吧，如果就从个人来讲，我开微博，加的关注中大部门都是我的朋友，那么平时我在发微博的时候有很多时候是@我的朋友的，那么对于其他的陌生人来说，你发布的信息对他来说意义不是很大，那么这类人是主要将微博用来社交，但微博作为社交网络的工具来说劣势大于优势，首先信息的交互不是即时的，你在微博上，很有可能你@的人不在，@他或者私信他很长时间他才回复，很有可能你会选择发个短信或者打个电话，或者看他QQ在线就QQ联系了，其次范围很小，只能是以微博主为中心，他的朋友建立的关系网，就是这么一个小的范围，因为你的社交信息对于其它人来说是无用信息。作为自媒体，现在有很多网站企业都有自己的认证微博，一来用于发布自己商品相关的信息，二来转播一些其它有意思的微博来充实自己的信息，如果一个购物网站如团800一直在发布团购的商品，那么作为他的听众，也是会觉得很烦的，所以团800基本上很少发布关于商品的信息，更多的是生活常识，有意思的图片或者励志的微博，这点很符合听众的心思。 关于这点，其实可以说是微博的另一个劣势，以前某段时间我对汽车有兴趣，然后我以汽车为关键词搜索相应的人并且是认证的，结果出来的大多某些汽车俱乐部的人，当我对他们加了关注后，发现他们平时说的东西很少和车相关，更多的是到哪玩，去哪吃，或者就是一般的对话，感觉和普通人没有什么区别，后来我也就惭惭的取消了对他们的关注，而更多的是关注一些企业微博，也就是新浪微博里加蓝色认证的微博主，因为他们看上去会更专注一些。 但什么东西也不是完美的，微博信息量大的优势，但有时也是劣势，因为有时有些信息我会看不到，这时我开始接触RSS，其实这个东西以前就接触过，但当时没有发现他的好处，用的阅读器也不怎么样–foxmail，但这也不完全怪foxmail，因为当时我在用它的时候还没有微博也SNS，而且很多默认的订阅很多，一会就会有好几千的新文章，有点看的目不暇接…… 最近开始用google reader，使用其最大的原因是它可能很方便的将信息分享到SNS与微博上，当我看到篇有价值的文章后，可能通过send to功能快速的发到我和微博中，让更多的人看到，当然如果用RSS订阅大型门户网站中的新闻绝对不是一个明智的选择，如果那样的话就会陷入微博信息量大而杂的困境中，RSS适用于订阅些你平时很少访问但偶尔又会关注一下，或者说是某些领域中比较权威的网站，比如我的订阅中有互联网科技，时尚创意，娱乐，豆瓣文化，还有一些小众网站，虽然不是很有名，但是其中的信息还有挺不错的。 由于Google reader在国内访问有时会出问题，所以如果你会翻墙的话尽量翻墙访问，不会的话也没有关系，国内也有相应的网站提供RSS订阅服务，做的比较好的有鲜果，腾讯等，但个人感觉都没有Google好，qq reader其界面比Google强好多，更人性化，感觉是在休闲中阅读一本杂志，但它的分享功能太狭小了，只是腾讯里的那点产品，不过它可能直接转载到个人的QQ空间还是不错的，鲜果弄的也不错，但鸡肋也是分享功能，没法自定义分享，或者通过别的方式也可以，但是很麻烦。 当微博与RSS结合后可以说是互相弥补对方劣势的组合，在这个信息量巨大的时代下，能够快速准确的找到自己想要的信息可以说是很关键的。","categories":[{"name":"IT关注","slug":"IT关注","permalink":"https://www.yangyanxing.com/categories/IT关注/"}],"tags":[]},{"title":"是否还能保持一种学习的态度","slug":"124","date":"2011-08-21T15:26:08.000Z","updated":"2017-12-16T10:10:42.017Z","comments":true,"path":"article/124.html","link":"","permalink":"https://www.yangyanxing.com/article/124.html","excerpt":"记得很小的时候，听大人们说到了他们的年龄就没有学习的心思了 现在也开始明白了 那天突然很羡慕那些还在校园里的同学，因为你们还有寒暑假，因为你们能够在校园里学习自己喜欢的知识 想我在学校里的时候 也不是爱学习本专业的知识，经常和教务处的老师打交道 但还好的是我不玩游戏，我把时间放在了计算机上","text":"记得很小的时候，听大人们说到了他们的年龄就没有学习的心思了 现在也开始明白了 那天突然很羡慕那些还在校园里的同学，因为你们还有寒暑假，因为你们能够在校园里学习自己喜欢的知识 想我在学校里的时候 也不是爱学习本专业的知识，经常和教务处的老师打交道 但还好的是我不玩游戏，我把时间放在了计算机上但现在意识到，自己并不是计算机专业的，很多知识体系不完整，逻辑思考能力不是那么严谨 想学一些东西比较吃力，再加上工作一段时间了，开始为新的问题而愁，工作，工资，人际，柴米油盐…… 发现能够静下心来学习一种技能很是困难，有时加班，回来很累，什么也看不下去 其实可能就是一种坚持的问题吧，或者还没有一种踏实的心 眼前的迷惑很多，同学聚会聊天的话题已经惭惭的从游戏变成了工作，婚姻 回家的时候老妈也开始问我是否有对象的问题，而我总会以我哥还没有呢我着什么急啊来回应 学习，对于现在的我来说已经变成了一个越来越远的词汇 或许改变的只是一种学习的方式与内容吧，谁不是在学习呢，但我总觉得我在大学里就没有打下一个好的基础，真的毕业了，想的是一边工作一边学习，可是现实真的不一样，工作后要处理更多问题，在学校里，看人不爽了，我可以去骂他，打他，而在工作中，必须要换一种方式，或者更多的接受 现在我必须每个月看两本书，必须在这方面投入相应的精力，如果实在没有时间，我宁可不上网了，发现现在经常在网上其实也一直在做些无聊的事情，本来很无聊，还要和别人着无聊，时间很快的就过去了 上次我让一个朋友帮我从学校借两本书，当时我开玩笑地说，这个不是书，而是金钱！ 可不是吗，我一直相信，光靠一个好嘴巴是不能立于世的，而必须要有一技在身，即使用好的嘴巴使自己过的不错，但扪心自问，我的心是否空虚？生活是否充实？","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]},{"title":"用猫抓老鼠的实例理解java中面向对象的编程与类和对象以及方法的概念","slug":"121","date":"2011-06-02T18:16:17.000Z","updated":"2017-12-16T10:10:41.879Z","comments":true,"path":"article/121.html","link":"","permalink":"https://www.yangyanxing.com/article/121.html","excerpt":"今天看到马士兵讲的关于面向对象编程的思路，用了一个猫抓老鼠的例子，我觉得这个例子非常形象，于是写在这里，方便学习理解和以后查看","text":"今天看到马士兵讲的关于面向对象编程的思路，用了一个猫抓老鼠的例子，我觉得这个例子非常形象，于是写在这里，方便学习理解和以后查看 class cat{ //声明一个类–“猫” int furcolor; // 定义猫的一个属性（成员变量）“毛的颜色” float heght; // 定义猫的一个属性“身高” float weight;// 定义猫的一个属性“体重” static void catchmouse(mouse m){ //声明一个方法—-“抓老鼠” //how to catch a mouse //方法里面的关于怎么抓老鼠 //m.scream(); } public static void main(String[] args){// 主函数 cat C = new cat(); //构造一个猫这个类里的一个新“对象”—-“C” mouse M = new mouse();// 构造老鼠里面的一个新“对象”—–“M” C.catchmouse(M);// 猫的一个方法“抓老鼠”（具体到抓M那只老鼠） } } class mouse{ //定义老鼠这个类 void scream(){ //定义老鼠这个类的一个方法scream System.out.println(“mouse”); } } 此程序形象的说明了面向对象中的各种概念，类，对象，方法等","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[]},{"title":"大学就这么过了（4）","slug":"105","date":"2010-12-26T15:14:08.000Z","updated":"2017-12-16T10:10:42.061Z","comments":true,"path":"article/105.html","link":"","permalink":"https://www.yangyanxing.com/article/105.html","excerpt":"在第一周的某个晚上，又传来了陌生人的敲门声 你们好，我们是材料学院科协的，我们现在在招新，我是主席王东辰” 科协？这个是做什么的？” 我们这个组织是在学院管理下，从事一些实验工作，在我们这里你可以提前进入实验室，见到学科的带头负责人，如果做的好的话对你们有很大帮助的” 我心想这个不错啊，进入大学了就是想要锻炼一下自己的各种能力的，加入个组织也不错哦！ 于是我就报名了，可谁又曾想到，我的真正大学生活由此开始了，以至于以后发生的各种各种，我现在一直认为，加入科协，是我第一个转折点，这个转折点并不是我在科协里学到了什么，办成了什么事情，而是我认识了一个人，他叫姜晓希！ 他和我一样，加入了科协和我分一个部门，那次好像是为全学院的新生做一个讲座，主讲我们实验室的构成，我们学院的分支可以简称为“三室三所”，那天来了很多长老级别的人物，可是当时我们都不知道他们有多么牛逼。 这个暂时不提了，总之讲的东西当时听不懂，现在也听不懂！","text":"在第一周的某个晚上，又传来了陌生人的敲门声 你们好，我们是材料学院科协的，我们现在在招新，我是主席王东辰” 科协？这个是做什么的？” 我们这个组织是在学院管理下，从事一些实验工作，在我们这里你可以提前进入实验室，见到学科的带头负责人，如果做的好的话对你们有很大帮助的” 我心想这个不错啊，进入大学了就是想要锻炼一下自己的各种能力的，加入个组织也不错哦！ 于是我就报名了，可谁又曾想到，我的真正大学生活由此开始了，以至于以后发生的各种各种，我现在一直认为，加入科协，是我第一个转折点，这个转折点并不是我在科协里学到了什么，办成了什么事情，而是我认识了一个人，他叫姜晓希！ 他和我一样，加入了科协和我分一个部门，那次好像是为全学院的新生做一个讲座，主讲我们实验室的构成，我们学院的分支可以简称为“三室三所”，那天来了很多长老级别的人物，可是当时我们都不知道他们有多么牛逼。 这个暂时不提了，总之讲的东西当时听不懂，现在也听不懂！ 之后我们的部长说请客，说实话，以前我还没有怎么去过餐厅吃饭，这次应该是第一次吧！我们到的是学校的第一餐厅，据说现在改名叫天天餐厅了！ 至于点餐，我很愁，看着菜单上的图片都很漂亮，也不知道哪个好，随便点了个东西，之后就有了喝酒这个环节，我在高的时候喝过一点点，高考结束后，和同学一起吃饭也喝过一些，但是真的是一点点，自己还不喜欢酒的味道！ 那次我们喝的是啤酒，我以前最多就喝过两瓶，这次我也不知道能喝多少，喝多了后会是什么样子的，总之我不会让自己晕晕的，可是一瓶下去后，我虽说还很清醒，但是却有点晕了 但是姜晓希一开始却怎么也不肯喝酒，一直说自己不会喝，但是一瓶啤酒下了肚子后自己却死活也不放第二瓶酒了，而且他的笑让我们不知道他是真的喝多了还是装的，不过我现在觉得他是真的，因为之后的举动证明了他是真的不清醒了，可能是他酒量真的不行，一瓶啤酒就醉了…… 我将他抬回到宿舍后，心里很是害怕，也不知道他还行不行，他一直在闹，而且谁也劝不了，让他躺床上睡觉他不听，一直在笑，笑的让人害怕！最后他拿着脸盆说要去洗澡，我们都担心他会进了女浴室…… 我其实也不行了，头晕的不行了，只是我没有表现出来而已，而且大家都在关注姜晓希，即使我有点异常也不会关注的…… 在这之后，姜晓希喝酒的样子似乎成为了我们的笑话，没有别的意思，只是现在回想起来觉得挺逗的！ 而为什么说姜晓希的出现是我大学生活的转折呢，我们在经过这次喝酒后，感情似乎有了些加深，以后我们也有过很多的喜与怒！但是经过这次事件后，忘记是元旦还是中秋了，由材料、人文、生命三个学院共同举办一场迎新晚会，每个学院要出个节目…… 而大多数的人是没有什么才华的，唱歌跳舞已经不是简单的歌颂社会主义了，这种事情最令学生会头痛了，上面下了指令，学生会必须出几个节目，其实这也从另一方面说明大学生个性的东西太少了，多年的教育让一个本来才华横溢的孩子变成了一个书呆子，只会读死书！ 我当时也是学生会的成员，说来惭愧，居然还是学习部的，其实更惭愧的是后来大二的时候居然还当上了学习部的部长，这个以后再说明吧，这其实是我一个笑柄！ 我们宿舍里还有一个同学就是头发花白的，他叫于凡，由于长的比较胖，所以日后我们都叫他小胖儿。 由于姜晓希同学那次喝酒事件，弄的我们全班都当笑话，我和于凡又都是喜欢相声的人，所以我们决定说段相声，其实就是演一遍当年侯宝林说的《醉酒》，想以此来说笑下姜晓希同学。 他为了这段相声还特意将这个相声的原文写了一遍让我背捧哏的，他说逗哏的，但是当时我觉得说相声这种东西即兴发挥就可以了，没有必要都按照原文的说下来。 初审我们演的很糟糕，但是最后竟然录用了…… 那天上台表演的时候我到是不怎么紧张，反正我是捧哏的，只是简单的应和下就行了，主要还是看逗哏的 那天表演的时候他有段还是忘词了，我做为一个捧哏的，为了打圆场就拿主持人姜晓希开了涮…… 虽然效果一般吧，可是在我们下台后有一个人拦住了我们，这个人的出现是我大学里的又一个转折！ 此人名叫朱淑君，听起来像个女生的名字，可是他是一个男的，而且很帅很黑！他也是大一的新生，广告学院的。 他说“打扰一下，请问你们也是大一的吗？” 我说“是啊” 你好，我也是大一的，我们现在正在准备成立一个相声社，我看你们表演的不错，有没有兴趣加入我们社团啊？” 说过加入社团，这似乎是每一个大一新生在他没有进入大学的时候别人经常给他说的，在大学里要加入几个社团，并努力找到机会成为里面的骨干，锻炼一下自己的组织能力。现在想来这些都是扯谈的东西，要想锻炼你做什么都是一种锻炼，只要你认真的去想去思考去总结，没有必要刻意的做一些事情，就像四年以后的我在面试之前都要接受一些所谓的面试经，这些在我看来纯粹是装B的东西，自己是什么样的人没有必要去隐藏，做事情不能太急功近利！顺其自然才是正道！ 其实在开学的2、3周左右学校社团统一做了招新，这次盛宴似乎是每个新生来到大学后参加的第一个火热的活动，我们学校里的社团各类还挺多的，不过当时的大一新生似乎对吃喝玩乐比较关注，记得当时动漫社的cosplay和ID时尚舞社的劲舞都非常吸引人，而众多的社团中英语协会实力是最大的，因为他们背后有个很有实力的公司在支持，后来才知道，做社团的几乎都有一个叫“外联部”的部门，专门在外面找赞助，如果活动做的好，成员间还能有笔灰色收入，虽然我不喜欢这种行为，但是我认为比起串宿舍卖些小东西，做社团无论是投入还是收获，都要比它强，而做社团的目的已经不是单纯的兴趣爱好相投想一起做些事情了，而掺和了更多的商业，总觉得已不再是那样纯粹了，不过也难怪，在中国这样的伪社会主义中，拜金主义充斥着人们的头脑，当今社会没有钱没有势力好像做什么事情都会很难！而一句“我爸是李刚”却能抵消掉一个平民的“贱命”！ 说远了，回到社团的招新来，我当初很有激情了加入了英语协会，宏文学社，当时我也是个文艺青年，喜欢看些文化的东西，可是后来发现我被这些名字欺骗了！ 现在有个“相声社”的社团要成立，其实最开始的想法是不想参与了，我是个嫌麻烦的人！我问朱淑君，我们加入后能做什么？他说你们来说相声吧！ 我心想，就我们这样的还说相声呢？呵呵，你可真是没有见过会说相声的吧…… 我只是简单的应付着，最后留下了联系方式，心里反应我也不想去，随便吧！于凡也留了他的联系方式！ 可能由于于凡是逗哏的吧，社长先是联系他的，他们怎么联系经的我不大清楚，反正于凡回到宿舍后就和我说，社长是一个坐轮椅的同学，他还说他们社团里有还有一个美女！ 我一听美女，本来不想参加的，顿时来的精神，问于凡，你看到了吗？ 他说没有啊，反正我对美女不感兴趣，我才不参加这个社团呢！ 没过一会，社长就给我打来电话，说想和我聊聊，我说好啊 于是我到了他的宿舍，刚进去后见到了这个传说中的社长，心中顿时起了敬佩之情，他由于先天原因不得不坐在轮椅上生活，生活起居很不方便，在常人眼里，他应该是一个悲观的人，可是正是这个悲观的人，却正在做一件传播快乐的事情，他见我来了后马上召集的隔壁宿舍的两个同学，一个叫马金，一个叫郑小龙，那天我们基本上除了一开始聊些社团的事情，其余的时间都在扯谈聊闲天，天南地北的砍几个人的关系马上就亲近了。 我问他们，咱们社团现在有多少人啊？ 社长王一（这个名字非常简单，好记，我们以后经常拿他这个名字开玩笑，问他的八弟叫什么？呵呵）说目前还没有成立，主要的成员有7个 我其实是关心那个美女是谁，喜欢相声的女生似乎不多，但是又不好意思明说，我问他，听说还有个女生？ 王一说“嗯，这你都知道啊？消息够灵通的！” 呵呵 嗯，她确实是个大美女啊”，我现在一直不明白他当初为什么不说后半句，“其实她有男朋友” 难道说是想用色诱之术？呵呵 然而我和他们说，“我是社管委的成员” 其实当初加入社管委（社团管理委员会）也算是个巧合，社管委是在学校团委领导下组建的管理学校里社团活动的官方组织，社团在召新后必须将所得的会费上交到这个组织，以后活动的时候必须得到社管团的批准后才能得到资金。 我到现在仍然觉得我们大学里社团得不到很好的发展主要原因是由于这个组织的出现，学校一方面鼓励社团活动，但一方面又在限制社团的活动，官方的口气都是说为了学生的生命财产安全，或许也有这方面原因吧，但是我觉得有这么个组织存在，本身就限制了社团的发展，而在社管委工作的人，由于手中有了那么点小权力，似乎不显摆一下难以向他人证明自己的存在，而社管委的人是一年一换的，之前受过压迫的，在其持政后便更会是变本加利的获取这种心里上的虚荣！一个恶性循环开始了！一个小的官僚主义就开始形成了！这也是为这些以后工作在政府中或者行政单位的同学提供一个很好的实习机会！ 我加入这个组织是由陈坛介绍的，我没有走一般的应聘流程，当初进入这个组织目的很单纯，多认识点人。 因为陈坛在里面表现的不错，已经做了个不错的位置，我也就相应的得到了一个不错的位置！算是个走后门的人吧，呵呵 当我和王一说到我是社管委的人时，我感觉出来他们已经不想再让我当什么演员了，其实马金也是里面的成员，只是其个性太突出了，一直只是个小部员。 我经过那天的聊天后，决定不为了别的，只为王一（一哥）也全力帮助相声社！","categories":[{"name":"我的大学","slug":"我的大学","permalink":"https://www.yangyanxing.com/categories/我的大学/"}],"tags":[]},{"title":"大学就这么过了（3）","slug":"104","date":"2010-12-26T13:51:46.000Z","updated":"2017-12-16T10:10:42.203Z","comments":true,"path":"article/104.html","link":"","permalink":"https://www.yangyanxing.com/article/104.html","excerpt":"上文说到我正迷茫于为什么而学习这个问题上，由于找不到很好的理由，在上大学之前也曾经为自己设定过很多的目标，很多的想法，大学要这样过，那样走，可是总是有心插花花不成！ 应该是在我还没有正式上课的某个晚上，突然有人来敲门，我们也很客气的说“请进” 来的人我们并不认识，他是一个形态略胖的一个矮个子男生，带着一个眼镜，手中拿着很多东西，到我们屋来后也很客气的和我们说 “你们好，我是大二电控学院的崔澜波，你们是新大一吧？” “嗯”，我们说是的 “你们知道现在在大学里最重要的是什么么？”—-“英语！！！！” “哦”","text":"上文说到我正迷茫于为什么而学习这个问题上，由于找不到很好的理由，在上大学之前也曾经为自己设定过很多的目标，很多的想法，大学要这样过，那样走，可是总是有心插花花不成！ 应该是在我还没有正式上课的某个晚上，突然有人来敲门，我们也很客气的说“请进” 来的人我们并不认识，他是一个形态略胖的一个矮个子男生，带着一个眼镜，手中拿着很多东西，到我们屋来后也很客气的和我们说 “你们好，我是大二电控学院的崔澜波，你们是新大一吧？” “嗯”，我们说是的 “你们知道现在在大学里最重要的是什么么？”—-“英语！！！！” “哦”“我给你们推荐一本报纸吧，《英语周报》，里面有最新的文章，最热的影评，现在订购还赠送一本词典” 我们当时心想这位好心的师哥还不错呢， 当时我问他们，你们要吗？ “要不就来一份吧，一年的” “一份够看吗？咱们五个人呢？” 崔澜波说“那就订两份呗，谁想看都行” 由于高中的时候我们班是人手一份英语报纸，我忘了叫什么了，总之当时是当做练习册来做的，上面的很多的题，都是专门针对高考而出的，心想英语确实很重要啊，如果一个人别的本事都没有，光有一个很好的英语水平那也足以让他有一份好的工作！ 于是我们一个宿舍5个人就订了两份报纸！他承诺每期都送到宿舍。 那个英语四级词典好像是随着第一份报纸送到宿舍而送到的，当时我还根本不知道这个小东西的价值有多少？也不知道什么所谓的商业行为，觉得自己订一份报纸认真看看，对于自己的英语肯定有帮助！ 现在毕业后，有一天我回去找我一个大四的朋友，当我走到他宿舍的时候，我下意识的敲了下门，没有人理我，再敲了一下，传来一句不耐烦的声音，“门又没锁，你不会自己进来啊？” 当我进去的时候，我问他“那个XXX在宿舍吗？” 他看到我后不好意思的说“他不在” 现在想想，可能在大一的时候经常被这种敲门的声音而烦恼，起初我们还是热情的接受，甚至去买他们的东西，后来我们变的不热情，再后来我们变得不耐烦，再后来我们就直接说“不要，走吧”，敲门这个动作在我们大学里似乎只有在两种情况下才发生，一种是对方宿舍锁着门，我们想进来，于是我们敲门，第二种就是推销商品，发传单！而如果是同班或者同系的同学到别的宿舍串门，是根本不要敲门这个多余动作的！所以到了大二以后，一般对于敲门都很反感！这也就难怪那个同学对我没有好气的说话了！ 而现在大学里销售的东西真是一点新意都没有，我曾经见过卖耳机的，贴画的，各种小商品，现在想想看你们真的没有发掘学生他们真正想要的是什么？学生这块消费市场与其真正的消费能力有多少？ 在学校里无聊的生活暂且告一段落，终于该上新了，心中还挺期待的，哦，我忘了，在上课之前的某一天里，全学校的新生在操场上举行了盛大的迎新活动，我们全体在操场上按照班级院系站的很整齐，估计这是四年里站的最齐的一次了！ 总之就是那一套中国特色的演讲，而且有幸看到了老校长左铁镛院士，他上台的时候居然还有人来搀着，这让我更加佩服这位老学者，而那个名义上的校长“范伯元”我四年里也未曾见过其庐山真面目，但是我从百度图片中搜索过他！ 最后有一个环节是放飞心愿气球，我忘记我当时写了什么了，总之很飘渺，以至于我现在根本想不起来是什么了！ 不过还好，领导们在似乎感觉到了我们很累的样子，于是这个盛大的迎新会议并没有持续很长时间，结束后我们在张忻老师的带领下到了材料楼的某个教室，开了个班级小会，我们宿舍的同学还挺积极，坐到了第一排，说起来这个会议我们也都是很期待的，因为这个是第一次全班同学在开会，我也想看看别的同学都是什么样子的！ 我们有31个人，其中有9个女生，上大学之前就听说过理工科的女生如何如何，那天真是百闻不如一见！当时我有了一种怀念高中生活的感觉了！ 其实我觉得女生可能也是这么想的吧，我怎么来到了侏罗纪了？ 也不知道是为什么，大学里男生似乎对于男女关系看得很敏感，是不是觉得自己终于可以名目言顺的谈恋爱了？压抑了很久的感情终于要爆发了！ 其实男生嘴里谈论最多的女生要么她很好看，要么她太难看了！对于这两种女生男生口中谈论的大多是“啊，XXX，你和她很配啊！”而这两种唯一不同的就是对于好看的女生他说她和别的男生好的的时候其实他是伪心的，说难看女生的时候其实他是真心的！ 现在回想起来，当时自己真是太肤浅了，没想到以后的时光里会和她们发生那么多的事情！如果以貌取人的话那么我将错失多么美好的东西！ 回到刚刚说过的准备去上课，第一节好像是高数，早上我起的很早，来到第四食堂吃饭，当时是7点半，呵呵，看来和我一样积极的人还不在少数，排了很长的队才买到吃的！ 来到教室本来想早到占个好位置的，可是最后居然只能在后几排找个座位！看来大家在开学的时候都很积极嘛！ 8点铃声响起，老师上来讲课，他先做了个自我介绍，他叫胡京兴，后来得知也是数理学院有名的老师！其他的我记不清了，但是有一句话我记得比较清楚，他供应商“你们现在还可以很早的来到教室，以后就会有很多同学拿着早点到教室或者就不来了” 我心想这怎么可能？ 事实证明我真是太天真了！ 讲什么不记得了，总之第一节课讲的和高中差不多，基本的微分东西，不听也罢，我还辛勤的记了很多笔记，就差把老师的板书抄不遍了！ 上课是一方面，其实在第一节课还有更有趣的事情，就是观察姑娘。哈哈 和我们一起上课的还有数理学院的某个系，这不知道是不是人的一种普遍心理呢？总觉得别人的东西比自己的好呢？怎么人家学院的女生都那么漂亮呢？ 其实后来和数理学院的同学聊天的时候他们也特别羡慕我们材料学院的男生！ 看来这种心理是真的！ 接下来有很多课，记不清楚了！总之我们第一周都很积极！","categories":[{"name":"我的大学","slug":"我的大学","permalink":"https://www.yangyanxing.com/categories/我的大学/"}],"tags":[]},{"title":"大学就这么过了（2）","slug":"103","date":"2010-12-24T05:15:39.000Z","updated":"2017-12-16T10:10:42.136Z","comments":true,"path":"article/103.html","link":"","permalink":"https://www.yangyanxing.com/article/103.html","excerpt":"书接上文，上文写到我老爸去了我姑家，以后的事情我就不知道了 我一个人在学校里随便溜达，突然想起我的一个高中同学上行已经先到学校报道了，他叫张路，是和我在高中时候三个人一个宿舍的好兄弟，还有另外一个兄弟叫邓爱光，当时我们三个人一个大宿舍，回想起来真是爽啊，我们平时也是无话不说，还想起高考前的那个晚上，我们聊了很长时间的天，也不知道几点睡觉的，当时我们聊自己心中的大学，自己要在大学里怎么怎么样，不过现在看来好像都没有按照自己所设想的那样，爱光同学还号称自己要在20岁时破处，不过好像现在还是个处男，呵呵！ 张路说他在5号楼，于是我就去打听哪里是5号楼，结果来到了一个非常幽静的地方，当时我也不知道是哪里，可是看到楼牌号上明明写着5号楼，但是这里根本没有新生入学的气氛，我小心翼翼地走到大厅，看到一个阿姨，我就问，这里是5号楼吗？她说是，我说这里有新本科生吗？她很是诧异的看着我，这里是研究生宿舍！没有本科生！ 晕死！！！ 我又给张路打电话，问他是哪呢，他说他在1号楼5层…… 唉","text":"书接上文，上文写到我老爸去了我姑家，以后的事情我就不知道了 我一个人在学校里随便溜达，突然想起我的一个高中同学上行已经先到学校报道了，他叫张路，是和我在高中时候三个人一个宿舍的好兄弟，还有另外一个兄弟叫邓爱光，当时我们三个人一个大宿舍，回想起来真是爽啊，我们平时也是无话不说，还想起高考前的那个晚上，我们聊了很长时间的天，也不知道几点睡觉的，当时我们聊自己心中的大学，自己要在大学里怎么怎么样，不过现在看来好像都没有按照自己所设想的那样，爱光同学还号称自己要在20岁时破处，不过好像现在还是个处男，呵呵！ 张路说他在5号楼，于是我就去打听哪里是5号楼，结果来到了一个非常幽静的地方，当时我也不知道是哪里，可是看到楼牌号上明明写着5号楼，但是这里根本没有新生入学的气氛，我小心翼翼地走到大厅，看到一个阿姨，我就问，这里是5号楼吗？她说是，我说这里有新本科生吗？她很是诧异的看着我，这里是研究生宿舍！没有本科生！ 晕死！！！ 我又给张路打电话，问他是哪呢，他说他在1号楼5层…… 唉 我这个迷失方向的人于是就是学校里乱走，终于看到有一个像有新生气象的楼了，我于是大踏步的走了进去！ 可是迎面来面的是很多漂亮的女生，当然也不是很多了，但是像我这种刚刚进入大学校园，在我的脑海里女生还都是衣着校服的样子，突然有这么多衣着个性着实也让我感叹了一把，原来大学里女生自己打扮起来也都挺好看的，可是走着走着我的步伐就有些放缓，我有点不好意思走进去了，心想“我不会走错宿舍了吧？难道这里是女生宿舍？”心里是这么想的，眼睛就不是这么想的，有些不好意思了，突然一个“衣衫褴褛”的女生从楼上走了下来，身边还有很多和她一样的女生，这让我更加不好意思，我定下步子，只站在了宿舍大厅里，看到有很多的家长在帮孩子拿行李，这里也有男生，所以我不敢确定这个楼到底是男生还是女生，于是我就问那个宿管阿姨这楼是1号楼吗？她恶狠狠的说，这里是2号楼，1号楼在对面！而且这里是女生楼！！！ 噢，当时有点羞，一下子跑了出来！现在回想起来，这次无知的闯入却是我4年大学生活里仅有的2次到女生楼里！第二次也是最后一次却是我4年以后的毕业时帮人收拾行李！ 走出去后，我来到了1号楼，到了五层，找到了张路，呵呵，他还是老样子，瘦瘦的，他在和宿舍里的一个四川同学聊天，记得好像在聊06年四川的大旱，同时还有一个我另外一个高中同学，徐大江，呵呵，高中的时候这个孩子就一直很搞笑，上课时候特别积极，学习特别勤奋，所以他是我们高中班里考到北京工业大学里分最高的，而我是分最底的！不过一想想都无所谓了，现在又在一个起跑线上了！ 我们虽说在假期里一起聚过会，可是现在在一起了却不知道要聊些什么，我问张路是学什么专业的，他说是通信工程，我心想不错啊，我是学习材料科学与工程的，这个名字对于我来说却是个不知所云的东西，后来我才知道，我是被调剂到这个专业的，这个学院在就只有这么一个专业，三个班90多个人，而且是全学校里分数最低的，但是后来我又得知，这个学院实力是相当牛逼的，前任校长就是这个学院的，叫左铁镛，还是中科院的院士，学校能够建设两个奥运场馆也靠这个人的帮助！不过06年却看不到什么奥运场馆，虽说录取通知书上印着它的样子！ 聊天中得知徐大江被认命为他们班的班长！唉，入学分数高就是强啊，想想我们班的班长叫王宇清，曾经是清华附中的高材生，现在也沦为和我们一样了…… 唉，一想想心中也为这个不得志的人而感到遗憾，不过还有一个更遗憾的同学，就是我们班学号为1的同学，她叫尹吉吉，分数足足比我高了100多分，曾经是北京四中的高材生，也就是和我们这些凡夫俗子一个班了！ 我忘了我吃的第一顿饭是和谁一起吃的了，不过我清楚的记得是在第三食堂吃的，当时不知道，感觉第三食堂还不错，宫爆里有这么多肉，但是这就和我那次误进入女生宿舍楼一样，可能是我大学四年里仅有的几个去三食吃饭！ 第一天晚上我清楚的记得我们宿舍里就只有四个人，我们也不知道从哪里聊开了天，也不知道从哪里说到了分数，一提到分数似乎浙江的那个同学特别兴奋，他叫郑辰，这个人在我的大学四年生活里有过太多的喜与怒！湖南的那个同学叫陈坛，这个同学后来成为了我的好兄弟，也是个影响我人生观与价值观我兄弟，还有一个同学叫王云峤，我当时一看到他穿着那身黄背心就想起了白天那个由于档案袋坏了而在老师面前解释的同学，可是我没敢确定，不知道是不是他，于是就这样聊着天，我得知，原来北工大在外地的录取分数是那样的高啊，甚至比北理工都要高，心想你们都被骗了…… 那天晚上我提议咱们在校园里走走吧，临出门的时候我还拿上了白天有人发给我学校地图…… 也不知从哪里走的，总之走了很远，我还是一直没有转过方向来，中途经过了后来才知道的三教，当时觉得这个楼可真新啊！能够在这里学习真是幸福！ 回来后又随便聊了会天，忘了几点了，睡了！我这个人有个毛病，换个地方很不容易睡着觉，那天也照样，很久才入睡…… 第二天我早早的就醒了，我居然起来去操场锻炼身体了！好像是6点多，现在回想起来真是佩服我自己。 早上的空气很好，操场上也有很多人在锻炼身体！ 回到宿舍后发现宿舍里多了一个人？他在整理自己的床铺，我这才明白，他昨天没有来宿舍住，原来我们宿舍有5个人 我向他笑了笑，说“刚来啊” 他说“嗯，刚来” 我也不知道为什么没有问他叫什么名字，看到他满脑子的白头发心想就有点不舒服的感觉。 吃了早点，据说今天要开什么迎新会，于是我们就等待这个时间，到了知新园进去后发现里面还真气派，地方很大，那天主持会议的据说都是我们学院里响当当的人物，后来有的人还给我上过课。不过这里面有一个人给我印象最深，他叫“聂祚仁”，他是我们学院现在任的院长，给我印象深刻的是他的严谨的态度，他明明知道我们都不知道这个学院里有谁在负责什么项目，可是在说的时候有一点含糊就问身边的人“是不是那谁谁谁啊？”，感觉这可能是长期严谨的态度养成的习惯吧！ 总之他们在台上说了很多话，我也不知道说什么，就是给我的感觉材料学院很牛逼，你们不要看你们入学的分数可能比那些热门专业如计算机，机械的低，但是只要努力，以后有很大的发展！ 我当时还是个热爱学习的学生，可能大多数都和我一样吧，还想在大学里好好学习一吧，可是现在想想，努力学习又是为了什么呢？初中的时候是为了考上个好高中，我办到了，高中的时候努力学习是为了考个好大学，这个我不知道算不算办到了，可是在大学里好好学习又是为了什么呢？考上研究生？我当时还不知道什么叫考研，似乎本科毕业就可以了！研究生对于我是一个很模糊的概念，根本不知道它是啥样子，不过当时想的就是要好好学习，在不知道自己怎么走的时候先好好学习，没有目的的学习！像那些老师院士一样，有着渊博的知识！","categories":[{"name":"我的大学","slug":"我的大学","permalink":"https://www.yangyanxing.com/categories/我的大学/"}],"tags":[]},{"title":"大学就这么过了（1）","slug":"102","date":"2010-12-23T06:33:03.000Z","updated":"2017-12-16T10:10:42.216Z","comments":true,"path":"article/102.html","link":"","permalink":"https://www.yangyanxing.com/article/102.html","excerpt":"今天是2010年12月23日，距离我工作已经有很长时间了，目前我从事的一份生产性行业，最近工作是在车间查看炉子，工作很轻松，于是有了很多胡思乱想的时间，最近我一直在思考一个问题，我现在一直在回想我的大学有多少个转折点？我是怎样走到我现在的路的？我是怎么认识那么多朋友的？于是由此所引导，回想起我大学这四年的时光，真的有很多值得回忆，值得思考，认识很多朋友，经历很多事情，足以让我回味一生。 我也不知道从哪里说起，还是从我上学来报道那天说吧。 那天是我老爸陪我一起来报道的，我们从家里在坐公交来到这个学校，那天我是从学校西门进来的，第一眼看到让我有点失望，呵呵，其实我一直在想，如果那天我是从学校南门进来的，可能会让我对这个学校第一印象会好些，不过后来我听说有人是从学校北门进来的，这样一想我还是比较庆幸，北门是一个连车都不来的门！ 其实到现在我还是对于北京工业大学里面转着向，一直认为西门是南门，也许我天生的方向感就不是很强，做在车里左转右转就不知道哪是哪了！ 我和老爸拿着大包小包在学校里拿着转单走来走去，我担心我老爸跟着我转来转去累，于是我对他说您先在这歇会吧，我先自己去办里各种证件吧，老爸说好，注意身上的钱。我清楚的记得我在找我的班级时候，足足排了有半个多小时的队，中途还遇到了我一个高中同学，他叫卢国轩，我们以前都是运河中学的，他在8班，我在9班，平时见面的时候只是打个招呼，没想到现在竟然成了一个学院的同学了，我问他是哪个宿舍的，他说他在4号楼203，我一看我在4号楼225，唉，怎么离这么远啊？ 我还清楚的记得，","text":"今天是2010年12月23日，距离我工作已经有很长时间了，目前我从事的一份生产性行业，最近工作是在车间查看炉子，工作很轻松，于是有了很多胡思乱想的时间，最近我一直在思考一个问题，我现在一直在回想我的大学有多少个转折点？我是怎样走到我现在的路的？我是怎么认识那么多朋友的？于是由此所引导，回想起我大学这四年的时光，真的有很多值得回忆，值得思考，认识很多朋友，经历很多事情，足以让我回味一生。 我也不知道从哪里说起，还是从我上学来报道那天说吧。 那天是我老爸陪我一起来报道的，我们从家里在坐公交来到这个学校，那天我是从学校西门进来的，第一眼看到让我有点失望，呵呵，其实我一直在想，如果那天我是从学校南门进来的，可能会让我对这个学校第一印象会好些，不过后来我听说有人是从学校北门进来的，这样一想我还是比较庆幸，北门是一个连车都不来的门！ 其实到现在我还是对于北京工业大学里面转着向，一直认为西门是南门，也许我天生的方向感就不是很强，做在车里左转右转就不知道哪是哪了！ 我和老爸拿着大包小包在学校里拿着转单走来走去，我担心我老爸跟着我转来转去累，于是我对他说您先在这歇会吧，我先自己去办里各种证件吧，老爸说好，注意身上的钱。我清楚的记得我在找我的班级时候，足足排了有半个多小时的队，中途还遇到了我一个高中同学，他叫卢国轩，我们以前都是运河中学的，他在8班，我在9班，平时见面的时候只是打个招呼，没想到现在竟然成了一个学院的同学了，我问他是哪个宿舍的，他说他在4号楼203，我一看我在4号楼225，唉，怎么离这么远啊？ 我还清楚的记得，我在和所谓的班主任见面的时候，旁边有一个穿黄色背心的男生，一个身材高大，带着眼镜，他的档案袋坏了，有一些开口，他还一直在解释“这个不是我弄的，我没有看里的东西”，我心里想这个同学可真是的，这么重要的东西怎么说弄坏就弄坏呢！也太不注意了！ 在和班主任做了简单的交流后，我看到班主任的名字叫“张忻”，我对于第二个字不大确定叫什么， 所以只叫了他张老师，之后我去交了学杂费与住宿费，领了一张饭卡，内含100元的饭费，再基本上把所有的钱交过之后我回去找我老爸，在新图北广场上看到了他，他坐在地上，行李就放在旁边，我当时看到心里就有点酸酸的，让我老爸在这么热的天气下等了我这么长的时间，也找个阴凉的地方，不过我找到我老爸的时候，看到他脸上还是洋溢的幸福的表情，当时我心里就想要好好学习，让老爸的光荣感一直延续下去！ 可是后来我让他失望了！这个是以后的事情了。 在托着行李来到4号楼225的时候，宿舍里已经有一个同学到了，看来我还是来的比较早的，他在他爸妈（其实后来知道不是他妈妈）帮助下在弄被了，他选了一个离窗户的下铺，其实我还是比较喜欢下铺的，我就选了靠门的下铺，老爸和他们聊天时候知道他是来自湖南的，呵呵，这时突然从门外跑进来一个同学，他们问他是哪里人，他说是“浙江”的，在此之前，我还没有怎么接触到外地生，心想，呵呵，这下要和他们一起生活4年，心里在还真是有点打鼓，我看了一下，这个宿舍里有6张床，也就是说还有3个人没有来！ 之后我就去了楼下办理什么住宿证了，这个比较恶心，说让我交几照片，可是我的照片之前已经交的差不多了，手上没有了，他们让我现在马上去照，我就打听这哪有照相的地方，他们这里所谓的志愿者给我说来说去，有如轻车熟路，靠，我一个新来的，怎么知道啊？于是我走出门后接着打听，最后好像是一个志愿者带着我到学校里的一个照相馆，靠，这里人还真多，情况和我差不多，都是照片没有带够，后来才知道，这个宿舍照片那天不交也可以，以后再交也行！呵呵！ 回来后看到老爸已经把我的被子弄好了，还给我买了两把小锁，弄的差不多了，老爸说要走了，我说您知道怎么回去吗？他说知道，放心吧。那天他去了我姑家，估计应该是高兴吧！ (该上班了，回来接着写)","categories":[{"name":"我的大学","slug":"我的大学","permalink":"https://www.yangyanxing.com/categories/我的大学/"}],"tags":[]},{"title":"Twitter常用术语和名词解析","slug":"83","date":"2010-07-13T02:08:08.000Z","updated":"2017-12-16T16:13:14.369Z","comments":true,"path":"article/83.html","link":"","permalink":"https://www.yangyanxing.com/article/83.html","excerpt":"网上看到的一个关于Twitter的基础的东西，我想很多人都知道Twitter，但并不是很会用~ 不会的来看看吧~ 如果你是早期的twitter用户并一直使用 ，那对twitter的相关术语和名词肯定是比较熟悉的。而如果是新手用户，对一堆的twitter术语尤其是各种涎生的twitter合成词会找不着北。 常用的twitter术语 1、@reply 表示你想对其他 Twitter 用户发表公开的信息，例如回复别人或者提及别人。在使用的时候需要把 reply 换成某个 Twitter 用户名。顺便说一句，Reply 也是一个 Twitter 用户名，不过它不发表任何信息，也不 Follower 任何人，但是居然有 400 多个 Followers!","text":"网上看到的一个关于Twitter的基础的东西，我想很多人都知道Twitter，但并不是很会用~ 不会的来看看吧~ 如果你是早期的twitter用户并一直使用 ，那对twitter的相关术语和名词肯定是比较熟悉的。而如果是新手用户，对一堆的twitter术语尤其是各种涎生的twitter合成词会找不着北。 常用的twitter术语 1、@reply 表示你想对其他 Twitter 用户发表公开的信息，例如回复别人或者提及别人。在使用的时候需要把 reply 换成某个 Twitter 用户名。顺便说一句，Reply 也是一个 Twitter 用户名，不过它不发表任何信息，也不 Follower 任何人，但是居然有 400 多个 Followers!2、DM DM 的全称是 Direct Message(s)，是指给某个 Twitter 朋友发私信。所谓的朋友，就是你 Follow 我，我也 Follow 你的那种；所谓的私信，就是除了我和你，其他的人都看不到的私信&mdash;&mdash;不过我认为 Twitter 的管理员能够看到。如果你要给某人发私信，可以使用以下格式： DM(不分大小写)+空格+Twitter 用户名+空格+私信内容，例如： 3、RT ReTweet 的缩写，也有人用 ReTweeting 的，只是前者是动词，后者是动名词，指把别人的 Tweets 重新发到 Twitter 上。例如： RT @caozenghui 微型博客Twitter周五宣布，已成功获得3500万美元投资，这笔资金将主要用于产品开发。&mdash;-好消息，希望twitter借此能避免资金压力，继续做大。 不过，也有人使用 ReTw 的，例如： hexybaby: ReTw @dingyong: 网店卖“草泥马”玩偶 每只售价50元(组图) http://twurl.nl/ac66eq #放办公桌上，同事问：什么玩偶啊？好可爱啊！答：草泥马。 当然，如果您使用 TweetDeck 之类的桌面软件，那么 RT 别人的 Tweets 就会更加方便。 4、Hashtag Hashtag 就和 Flickr 上的标签一样，如果你就某个标签发表信息，那么订阅这个标签的人就会看到你的信息。举例说明： webleon: #Blog 企业Blog的价值何在？: Forrester最近的一份数据报告显示，只有16%的在线消费者信任企业Blog（企业博客）。这难免让人产生了疑惑：企业开设Blog究竟有多大价值？这份报告的题目就叫做：Ti.. http://tinyurl.com/5hw9zu 上面这个 Tweet 中，Blog 就是一个 Hashtag，但是，只有在Blog前面加上#的时候，上面的这句话才会出现在 Hashtags.com 网站，也才可以被订阅 Blog 这个 hashtag 的朋友看见。 Hashtag.com 目前经常宕机，出现503错误，并且无法识别中文的 Tag，例如，#Blog 可以被收录，但是 #博客就不行了。 twitter千奇百怪的合成名词 要把下面这些名词和它们的意义都记住，恐怕需要先去学倒背圆周率之类的记忆方法。 twacklist 由 Twitter + blacklist 组成，指 Twitter 上的黑名单。 twacklog 由 Twitter + Backlog 合成，指待处理的 tweets。 twammer 由 Twitter + spammer 组成，指 Twitter 上的垃圾制造者。 twandle 由 Twitter + handle 组成，指 Twitter 用户名。 twat 由 Twitter + acct 组成，意思同 Twammer，也是指 Twitter 上的垃圾制造者。 twait 由 Twitter + Wait 组成，指计划在未来某个时间发送的 twitter 信息。 twaitter 指按时发表 Twitter 信息的人。 twarmy 由 Twitter + Army 组成，指 Twitter 上的大军。 twavatar 由 Twitter + Avatar 组成，指 Twitter 用户的头像。 twawkward 由 Twitter + awkward 组成，指在 Twitter 上感到尴尬。 tweaten 由 Twitter + Eaten 组成，指某个 Tweet 被 Twitter 或者某客户端应用程序吃掉了，有和谐的意思吧。 twedia 由 Twitter + Media 组成，指 Twitter 上的媒体，例如 @nytimes、@bbcnews、等等。 tweeotches 由 Twitter + biotches 组成，指 Twitter 上的狗娘养。 tweeps 由 Twitter + peeps 组成，指 Twitter 上的朋友。 tweetheart 由 Twitter + Sweetheart 合成，直译为 Twitter 情人。 tweetspeak 由 Tweet + Speak 组成，指强迫性发表不超过140个字的 Twitter 信息。 tweetup 由 Twitter + meetup 组成，指 Twitter 用户之间的聚会。 tweme 由 Twitter + Meme 组成，指 Twitter 上的 Meme( 文化的基本单位&mdash;&mdash;有点玄）。 tweople/tweeple 由 Twitter + people 组成，指 Twitter 用户。 twequilibrium 指你的 Following 数量刚好等于 Followers 数量。 twerd 由 twitter + nerd 组成，指 Twitter 上的专家。 twerminology 由 Twitter + terminology 组成，指对 Twitter 术语的研究。 twerp 指在 Twitter 上表现不好的用户。 Twestival 由 Twitter + Festival 组成，指 Twitter 节，也叫推特节，日期为每年2月12号，活动的筹款全部用于慈善活动。 Twesting 由 Twitter + Test 组成，指在 Twitter 上做测试。 Twitterers 由 Twitter 用户组成的群体。 twetin 由 Twitter + cretin 组成，指白痴的 Twitter 用户. twewbie 由 Twitter + Newbie 组成，指一个牛逼的 Twitter 用户。 twhater 认为 Twitter 是愚蠢的人。 twiend 由 Twitter + friend 合成，即互相 Follow 的 Twitter 用户（推友）。 twiller 由 Twitter + Thriller 组成，指令人毛骨悚然的 Twitter 信息。 twinsight 由 Twitter + Insight 组成，指通过 Twitter 认识的新观点，也指两个人在同一时间发表同样的 Tweets。 twinterview 由 Twitter + Interview 组成，指通过 Twitter 展开或者促进面试。 twintro 由 Twitter + Introduce 组成，指通过 Twitter 介绍两个人相互认识。 twiplomacy 由 Twitter + diplomacy 组成，指把 Twitter 作为一种公共交际工具。 twirt 由 Twitter + Flirt 组成，指通过 Twitter 公然调情或者公然调情者。 twissues 由 Twitter + Issues 组成，指 Twitter 应用存在的问题。 twater 由 twitter + hater 组成，指憎恨 Twitter 的人。 twistory 由 Twitter + history 组成，有两种意思： 一是指某 Twitter 用户的 Tweets 和 @ 的历史；而是指在 Twitter 上发生的重大事件或者里程碑。 twitaddict 100% 的 Twitter 瘾君子，通常一个小时不玩 Twitter 就受不了。 twitaddict 同时也是一个 Twitter 用户。 twittarr 涉及海盗的 Twitter 信息。 twitcrush 由 Twitter + Crush 组成，指宣称自己暗恋某个 Twitter 用户。你可以通过 twitcrush.com 宣称自己暗恋了谁。 twitter squatter 明显，这不是合成词而是一个词组，指持有某个 Twitter 用户名并想获得好处的人。比如，brianclark 可以看作是一个 twitter squatter，因为其明显是抢注了著名博客兼推客 Copyblogger 作者的名字，不过这种行为是合法合理的，因为其并没有说自己就是 Copyblogger 的作者。 twitebate 由 Twitter + Debate 组成，指 Twitter 上的辩论，通常指政治辩论。 twiterature 由 Twitter + Literature 组成，指 twitter 上的文学著作。 twitery 由 Twitter + poetry 组成，指 Twitter 上的诗歌。twitery.wordpress.com 是一个以发表 twitery 为主的博客。 twitfluencer 由 Twitter + Influencer 组成，指有影响力的 Twitter 用户。 twitterati 由 Twitter + literati 组成，指 Twitter 上的文人，这个词在 Twitter 上常见。 twittercane 由 Twitter + hurricane 组成，就是 Tweet 旋风。 twitterdipity 指突然发现或者发送一些对自己或其他 Twitter 用户有用的链接或其他信息。 twitterfam 对 follower 的亲切称呼。 twitterholic 指沉迷于 Twitter 的用户，也指 twitterholic.com 网站（提供 Twitter 排名服务）。 twitterluia 由 Twitter + halleluia 组成，用来描述当奇迹发生时，Twitter 用户看见并发表到 Twitter 上。 twittermentia 记不住最后在 Twitter 上发表的信息。 twitterminology 由 Twitter + terminology 组成，指 Twitter 术语，意思同 twitterspeak。 twitterpreneur 由 Twitter + enterpreneur 组成，指 Twitter 企业家, 包括玩 Twitter 的企业家和企业是建立在 Twitter 基础上的企业家。 twitterpuff 由 Twitter + Puff 组成，表示在 Twitter 上自夸的人。 twitterrhea 大声令人讨厌混乱的 Twitter 信息。 twittiquette 由 Twitter + Ettiquette 组成，指 Twitter 上不成文的相关规则。 twittersation 由 Twitter + Conversation组成，指在Twitter 上的交流。 twitterscuse 由 Twitter + Excuse 组成，指 Twitter 不能正常运作的借口。 twitterspeak 由 Twitter + Speak ?成，指专门用于 Twitter 的语言。 twitterverse Twitter 空间，类似于博客空间（blogosphere） twitty 同 witty，是“诙谐的”意思。 twollower 由 Twitter + Follower 组成，指那些 Follower 你的 Twitter 用户。 twonanism 指在 Twitter 上自我夸奖。 tw00b 一个牛逼的 Twitter 用户。 twoosh 指刚好 140 个字的 Tweet。 twoutage Twitter 某种功能的失败。 twunch 由 Lunch + Twitter 合成，意为推友之间自由的午餐聚会。 twunch 同时也是有一个 Twitter 用户，并且拥有一个 twunch.be（荷兰语），推友们可以通过 @twunch 进行公开约会。 twunken 酒后玩 Twitter 或者沉醉于玩 Twitter。 twurze 由 Twitter + The Wurzels 合成，通常指牛逼的 Twitter 用户，意思同 tw00b 和 Twewbie。 twypo 由 Twitter + Typo 合成，指 Twitter 上的错别字。twypos.com 是一个专门收集 twypo 的网站。 tweehab 由 Twitter + Rehab 合成，指离开 Twitter 做一个恢复性的休息。 twerrorism 由 Twitter + Terrorism 合成，指 Twitter 黑客行动。 twincidence 两个不相关的 Twitter 用户讲述同一件事。 twoff 长期不在 Twitter 上。 twescapade 各抒己见的线下聚会。 twingup 由 twitter + wings+ meetup 组成，指有计划的线下吃鸡翅聚会","categories":[{"name":"计算机相关","slug":"计算机相关","permalink":"https://www.yangyanxing.com/categories/计算机相关/"}],"tags":[]},{"title":"小鸭子","slug":"850","date":"2009-12-05T01:09:39.000Z","updated":"2017-12-16T10:10:42.191Z","comments":true,"path":"article/850.html","link":"","permalink":"https://www.yangyanxing.com/article/850.html","excerpt":"今天读一本书，读着读着读到了一个关于小鸭子的故事 于是我联想到了很多我小时候的事情…… 小时候家里养过100多只鸭子，从它们刚出壳没几天身上只有一点点绒毛的时候，到最近养的肥肥大大的","text":"今天读一本书，读着读着读到了一个关于小鸭子的故事 于是我联想到了很多我小时候的事情…… 小时候家里养过100多只鸭子，从它们刚出壳没几天身上只有一点点绒毛的时候，到最近养的肥肥大大的它们来的时候我一是很开心的，天天去看它们，小时也会抓起来一只玩 但它们一点点的长大，而我却一点都看不出来…… 有天，我带着它们放，这一群啊…… 像一片乌云，但它们遇到了一个水坑，就像找到了自己的天堂，所有的鸭子都撒起了欢~ 有的小鸭子还潜入水中~ 玩的好开心啊…… 这时我也想起了那时的我，一个脏兮兮的小孩儿，赶着那么多小鸭子，自己也乐在其中~ 对于现在的我，什么才是我的小鸭子呢？","categories":[{"name":"生活记录","slug":"生活记录","permalink":"https://www.yangyanxing.com/categories/生活记录/"}],"tags":[]}]}