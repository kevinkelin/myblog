<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>python中关于map,lambda,高阶函数与装饰器的使用</title>
      <link href="/article/higher-order-function.html"/>
      <url>/article/higher-order-function.html</url>
      <content type="html"><![CDATA[<p>有一点python基础的朋友在看到一些老鸟写的一些函数的时候，他们会有意的写出一些高阶函数，要么带个map啊，要么带个lambda呀，再高一点的带个@装饰器啊，其它这些也没有什么难的，用法上高级一些，如果能捋顺它的逻辑，准确的在实际应用中使用，还是会给程序效率上带来一定的提高，至于可读性，当你习惯了这些用法时你就会觉得它的可读性也很好，之所以你不习惯，主要还是由于你不懂它的用法，说到可读性，这是另外的话题，以后再详细的聊聊，今天要说的主要是高阶函数与装饰器的使用。希望看完此篇文章的朋友有所收获。</p><a id="more"></a><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数的定义：一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>常规函数的参数一般是个变量或者是个对象，比如定义一个求和函数</p><pre><code class="python"># coding:utf-8def sum(x,y):    return x + yif __name__ == &#39;__main__&#39;:    print sum(3,4)</code></pre><p>这里传入的参数，x,y 都是整数，返回的是它们的和。<br>变量可否是一个函数呢？</p><pre><code class="python">&gt;&gt;&gt; s = sum&gt;&gt;&gt; s&lt;function sum at 0x01F96B70&gt;&gt;&gt;&gt; s.__name__&#39;sum&#39;&gt;&gt;&gt; s(6,7)13</code></pre><p>把sum()函数 赋给变量s，s现在为一个函数，s的<strong>name</strong>为’sum’,<br>可以调用s(6,7) 返回的就是sum(6,7)。</p><p>上面很简单，再来看一下高阶函数的定义，<code class="text">一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</code>,<br>既然函数也可以作为另外的一个函数的参数，那么我们再来定义另外一个函数</p><pre><code class="python"># coding:utf-8def sum(x,y):    return x + ydef sum2(func,x,y):    return func(x,y)if __name__ == &#39;__main__&#39;:    print sum2(sum,5,6)</code></pre><p>这里定义一个sum2函数，它的返回值是func(x,y)。</p><h1 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h1><p>函数可以作为参数，也可以作为返回值</p><pre><code class="python">def sum3(x,y):    def sum4():        return x+y    return sum4f3 =  sum3(1,2)print f3print f3()</code></pre><p><code class="text">sum3</code> 函数的返回值是<code class="text">sum4</code>,但直接打印f3时显示的是<code class="text">&lt;function sum4 at 0x02142DB0&gt;</code>,要执行这个函数需要调用执行一个f3函数<code class="text">f3()</code></p><h1 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h1><p>上面的代码似乎没有什么具体的应用，只要为了说明，函数也可以作为参数传入另外的函数中，下面来看一下map函数<br>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br>最简单的应用，给一个列表，返回该列表中每个元素的平方。</p><pre><code class="python">def f(x):    return x*xl = range(1,10)l2 = map(f,l)print type(l2)print l2</code></pre><p>在python2中map返回的是一个list,在python3中返回的是一个map对象，如果要得到新的列表，需要执行list(l2)操作，以下代码都是在python2环境下操作。</p><h1 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h1><p>说叫函数，其实它是一种没有名字的函数，一次性使用，适用于那种简单的表达式可以不用定义一个函数，上面的求和与求立方。</p><pre><code class="python">l3 = map(lambda x:x*x,[1,2,3,4])print l3l4 = map(lambda x,y:x+y,[1,2,3,4],[5,6,7,8])print l4fl =  lambda x:x*3print fl(10)</code></pre><p>注意到lambda用在map函数中时，如果它的参数需要两个或者更多，那么在map的参数里也要传入相应个数的列表，且它的计算是列表中对应位置的表达式，比如求和，它是将列表1中的第一个元素和列表中第一个元素求和放到返回列表中的第一荐，列表的长度要一致，不能第一个列表有4个元素，第二个列表有3个或者5个，第二个列表也只能是4个。</p><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>有了上面的一些基础，接下来咱们看看本文的重点—-装饰器<br>首先看一个简单函数的定义，打印当时日期时间</p><pre><code class="python">from datetime import datetimedef showTime():    print datetime.now()showTime()</code></pre><p>现在，假设我们要增强<code class="text">showTime</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code class="text">showTime</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><p>定义一个函数</p><pre><code class="python">def log(func):    def wrapper(*args, **kw):        print &#39;call %s():&#39; % func.__name__        return func(*args, **kw)    return wrapper</code></pre><p>观察这个log函数，它的参数是一个函数，要执行传入参数的函数时，将其包了一层，做了一些别的事情，然后又将函数返回，<code class="text">return wrapper</code> 所以本质上这个log就是一个返回函数的高阶函数。<br>参考上面定义sum2函数,再来回看一下上面说明的函数作为返回值，其实这里它已经执行了func函数，对于上面的代码就是<code class="text">print datetime.now()</code><br>装饰器的使用是在函数的定义处上面加上@符</p><pre><code class="python">def log(func):    def wrapper(*args, **kw):        print &#39;call %s():&#39; % func.__name__        return func(*args, **kw)    return wrapper@logdef showTime(a,b):    print a    print datetime.now()    print bshowTime(&#39;yang&#39;,&#39;fan&#39;)</code></pre><p>加了装饰器以后，我们把调用showTime函数分解一下，它实际上是执行了<code class="text">log(showTime(&quot;yang&quot;,&quot;fan&quot;))</code></p><p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p><pre><code class="python">def log2(text):    def decorator(func):        def wrapper(*args, **kw):            print(&#39;%s %s():&#39; % (text, func.__name__))            return func(*args, **kw)        return wrapper    return decorator@log2(&quot;yyx&quot;)def showTime(a,b):    print a    print datetime.now()    print bshowTime(&#39;yang&#39;,&#39;fan&#39;)</code></pre><p>上面的执行是这样的：<br>首先执行<code class="text">log2(&#39;yyx&#39;)</code>返回的是decorator函数，再调用返回的函数(decorator)，参数是showTime函数，返回值最终是wrapper函数,而wrapper函数将会执行showTime函数,所以在经过了log2装饰以后的调用分解开来应该是log2(“yyx”)(showTime(“yang”,”fan”))。</p><p>所以在写一个装饰器的时候，要区别装饰器本身是否需要有参数，如果没有，包一层即可，有参数的话需要包两层。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317848428125ae6aa24068b4c50a7e71501ab275d52000" target="_blank" rel="noopener">廖雪峰-函数式编程</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的list排序问题以及sort,sorted的使用</title>
      <link href="/article/python-list-sort.html"/>
      <url>/article/python-list-sort.html</url>
      <content type="html"><![CDATA[<p>列表list排序是一种非常常见的操作，里面有很多的方法也有很多的坑，这里简单的记录一下。</p><a id="more"></a><ol><li>sorted 方法</li></ol><pre><code class="python">&gt;&gt;&gt; l = [&#39;1&#39;,&#39;2&#39;,&#39;A&#39;,&#39;z&#39;,&#39;a&#39;,1,2]&gt;&gt;&gt; sorted(l)[1, 2, &#39;1&#39;, &#39;2&#39;, &#39;A&#39;, &#39;a&#39;, &#39;z&#39;]&gt;&gt;&gt; l[&#39;1&#39;, &#39;2&#39;, &#39;A&#39;, &#39;z&#39;, &#39;a&#39;, 1, 2]&gt;&gt;&gt; l2 = sorted(l)&gt;&gt;&gt; l2[1, 2, &#39;1&#39;, &#39;2&#39;, &#39;A&#39;, &#39;a&#39;, &#39;z&#39;]&gt;&gt;&gt; id(l2)38967136&gt;&gt;&gt; id(l)38985520</code></pre><p>sorted 方法传入一个列表，返回一个新的列表，并不影响原来列表的顺序，从上面的结果来看，数字排在了字符串之前，其实它是按照字符的ASCII的顺序排列的，那如果列表里是字符串呢？ </p><pre><code class="python">&gt;&gt;&gt; l = [&quot;yang&quot;,&quot;yan&quot;,&quot;xing&quot;,&quot;is&quot;,&quot;a&quot;,&quot;boy&quot;]&gt;&gt;&gt; sorted(l)[&#39;a&#39;, &#39;boy&#39;, &#39;is&#39;, &#39;xing&#39;, &#39;yan&#39;, &#39;yang&#39;]</code></pre><p>明显它是按照第一个字符来排，第一个字符相同再按第二个排。</p><p>sorted() 方法还有另外一个参数，reverse，当它为True的时候，将会倒序排列。</p><pre><code>&gt;&gt;&gt; sorted(l,reverse=True)[&#39;yang&#39;, &#39;yan&#39;, &#39;xing&#39;, &#39;is&#39;, &#39;boy&#39;, &#39;a&#39;]</code></pre><p>可否直接改变原list的结构，而不是生成一个新的list呢？ 当然可以</p><ol><li>sort方法<pre><code>&gt;&gt;&gt; l[&#39;yang&#39;, &#39;yan&#39;, &#39;xing&#39;, &#39;is&#39;, &#39;a&#39;, &#39;boy&#39;]&gt;&gt;&gt; l.sort()&gt;&gt;&gt; l[&#39;a&#39;, &#39;boy&#39;, &#39;is&#39;, &#39;xing&#39;, &#39;yan&#39;, &#39;yang&#39;]&gt;&gt;&gt;</code></pre>此时原列表l的结构已经变了，且该函数没有返回值，所以如果写成<code class="text">newL = l.sorr()</code> 并不能得到一个新的列表，newL为空，所以不要用错了</li></ol><p>这种排序也太简单了，我可否按照我自已的方法来排序呢？当然可以</p><ol><li>自定义排序<br>需要提供一个排序的方法，该方法要有三种返回值，假如有两个值a1和a2，通过某种计算，如果返回大于0(True)的值，则a1排在后面，如果小于0(False)，a1排在前面，如果等于0，则a1和a2顺序不变，看代码  </li></ol><pre><code class="python">#coding:gbka = [    {&#39;name&#39;:&#39;jk&#39;, &#39;score&#39;:100, &#39;first&#39;:50, &#39;second&#39;:50, &#39;third&#39;:0},     {&#39;name&#39;:&#39;zz&#39;, &#39;score&#39;:90, &#39;first&#39;:50, &#39;second&#39;:30, &#39;third&#39;: 10},     {&#39;name&#39;: &#39;yyx&#39;, &#39;score&#39;:90, &#39;first&#39;:40, &#39;second&#39;:30, &#39;third&#39;:20},    {&#39;name&#39;: &#39;zs&#39;, &#39;score&#39;:90, &#39;first&#39;:40, &#39;second&#39;:30, &#39;third&#39;:20},]def cmp(a1, a2):    if a1[&#39;score&#39;] != a2[&#39;score&#39;]:        return a1[&#39;score&#39;] - a2[&#39;score&#39;]    elif a1[&#39;first&#39;] != a2[&#39;first&#39;]:        return a1[&#39;first&#39;] - a2[&#39;first&#39;]    elif a1[&#39;second&#39;] != a2[&#39;second&#39;]:        return a1[&#39;second&#39;] - a2[&#39;second&#39;]    else:        return a1[&#39;third&#39;] - a2[&#39;third&#39;]a.sort(cmp)for i in a:    print i</code></pre><p>这里引出另外一个问题，字典是无序的，想要排字典，其实是排一组字典<br>这里希望将上述的list排序，按照每条记录中的’score’排序。如果’score’字段的值相等，则按照’first’的值排序。如果’first’依旧相等，则按照’second’排序。如果’second’相等，则按照’third’字段的值来排序。<br>该排序的结果为</p><blockquote><p>{‘second’: 50, ‘score’: 100, ‘name’: ‘jk’, ‘third’: 0, ‘first’: 50}<br>{‘second’: 30, ‘score’: 90, ‘name’: ‘zz’, ‘third’: 10, ‘first’: 50}<br>{‘second’: 30, ‘score’: 90, ‘name’: ‘yyx’, ‘third’: 20, ‘first’: 40}<br>{‘second’: 30, ‘score’: 90, ‘name’: ‘zs’, ‘third’: 20, ‘first’: 40}</p></blockquote><p>还可以用sorted方法</p><pre><code class="python">&gt;&gt;&gt; student_tuples = [(&#39;john&#39;, &#39;A&#39;, 15),(&#39;jane&#39;, &#39;B&#39;, 12),(&#39;dave&#39;, &#39;B&#39;, 10)]# sort by age&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2])[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]</code></pre><p>参考文章<br><a href="https://blog.csdn.net/nisxiya/article/details/49305857" target="_blank" rel="noopener">python list 自定义排序</a><br><a href="https://www.jianshu.com/p/7be04a3f30cd" target="_blank" rel="noopener">Python之排序函数sort() 和 sorted()</a><br><a href="https://blog.csdn.net/qq_15714857/article/details/50545265" target="_blank" rel="noopener">Python的排序：关于sort()与sorted()</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的日志按天保存单独的文件</title>
      <link href="/article/python-logging-day-file.html"/>
      <url>/article/python-logging-day-file.html</url>
      <content type="html"><![CDATA[<p>在运行web的python程序时,日志最好是使用按天的保存,这样查看起来会很方便,也不至于日志文件太大不好打开<br>python 自带的logging模块有着非常强大的作用</p><a id="more"></a><pre><code class="python">import loggingimport time,sysfrom logging.handlers import TimedRotatingFileHandlerlog = logging.getLogger(&#39;yyx&#39;)log.setLevel(logging.DEBUG)formatter = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)log_file_handler = TimedRotatingFileHandler(filename=&quot;log&quot;, when=&quot;S&quot;, interval=2)log_file_handler.setFormatter(formatter)log_file_handler.setLevel(logging.DEBUG)log.addHandler(log_file_handler)stream_handler = logging.StreamHandler(sys.stdout)stream_handler.setFormatter(formatter)log.addHandler(stream_handler)log.debug(&#39;111&#39;)log.error(&#39;11error&#39;)log.info(&#39;11info&#39;)time.sleep(2)log.error(&#39;222&#39;)time.sleep(2)log.info(&#39;333&#39;)</code></pre><p>TimedRotatingFileHandler类的参数意义如下:</p><ul><li>filename：日志文件名的prefix；</li><li>when：是一个字符串，用于描述滚动周期的基本单位，字符串的值及意义如下：<br>&nbsp;“S”: Seconds<br>&nbsp;“M”: Minutes<br>&nbsp;“H”: Hours<br>&nbsp;“D”: Days<br>&nbsp;“W”: Week day (0=Monday)<br>&nbsp;“midnight”: Roll over at midnight</li><li>interval: 滚动周期，单位有when指定，比如：when=’D’,interval=1，表示每天产生一个日志文件；</li><li>backupCount: 表示日志文件的保留个数； 不写则全保存</li></ul><p>除了上述参数之外，TimedRotatingFileHandler还有两个比较重要的成员变量，它们分别是suffix和extMatch。suffix是指日志文件名的后缀,suffix中通常带有格式化的时间字符串，filename和suffix由“.”连接构成文件名（例如：filename=“runtime”， suffix=“%Y-%m-%d.log”,生成的文件名为runtime.2015-07-06.log）</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用logging模块轻松地进行Python日志记录(转)</title>
      <link href="/article/use-logging-in-python.html"/>
      <url>/article/use-logging-in-python.html</url>
      <content type="html"><![CDATA[<p>在开发过程中，如果程序运行出现了问题，我们是可以使用我们自己的 Debug 工具来检测到到底是哪一步出现了问题，如果出现了问题的话，是很容易排查的。但程序开发完成之后，我们会将它部署到生产环境中去，这时候代码相当于是在一个黑盒环境下运行的，我们只能看到其运行的效果，是不能直接看到代码运行过程中每一步的状态的。在这个环境下，运行过程中难免会在某个地方出现问题，甚至这个问题可能是我们开发过程中未曾遇到的问题，碰到这种情况应该怎么办？<br>如果我们现在只能得知当前问题的现象，而没有其他任何信息的话，如果我们想要解决掉这个问题的话，那么只能根据问题的现象来试图复现一下，然后再一步步去调试，这恐怕是很难的，很大的概率上我们是无法精准地复现这个问题的，而且 Debug 的过程也会耗费巨多的时间，这样一旦生产环境上出现了问题，修复就会变得非常棘手。但这如果我们当时有做日志记录的话，不论是正常运行还是出现报错，都有相关的时间记录，状态记录，错误记录等，那么这样我们就可以方便地追踪到在当时的运行过程中出现了怎样的状况，从而可以快速排查问题。<br>因此，日志记录是非常有必要的，任何一款软件如果没有标准的日志记录，都不能算作一个合格的软件。作为开发者，我们需要重视并做好日志记录过程。</p><a id="more"></a><h1 id="日志记录的流程框架"><a href="#日志记录的流程框架" class="headerlink" title="日志记录的流程框架"></a>日志记录的流程框架</h1><p>那么在 Python 中，怎样才能算作一个比较标准的日志记录过程呢？或许很多人会使用 print 语句输出一些运行信息，然后再在控制台观察，运行的时候再将输出重定向到文件输出流保存到文件中，这样其实是非常不规范的，在 Python 中有一个标准的 logging 模块，我们可以使用它来进行标注的日志记录，利用它我们可以更方便地进行日志记录，同时还可以做更方便的级别区分以及一些额外日志信息的记录，如时间、运行模块信息等。<br>接下来我们先了解一下日志记录流程的整体框架。<br>整个日志记录的框架可以分为这么几个部分：</p><ul><li>Logger：即 Logger Main Class，是我们进行日志记录时创建的对象，我们可以调用它的方法传入日志模板和信息，来生成一条条日志记录，称作 Log Record。</li><li>Log Record：就代指生成的一条条日志记录。</li><li>Handler：即用来处理日志记录的类，它可以将 Log Record 输出到我们指定的日志位置和存储形式等，如我们可以指定将日志通过 FTP 协议记录到远程的服务器上，Handler 就会帮我们完成这些事情。</li><li>Formatter：实际上生成的 Log Record 也是一个个对象，那么我们想要把它们保存成一条条我们想要的日志文本的话，就需要有一个格式化的过程，那么这个过程就由 Formatter 来完成，返回的就是日志字符串，然后传回给 Handler 来处理。</li><li>Filter：另外保存日志的时候我们可能不需要全部保存，我们可能只需要保存我们想要的部分就可以了，所以保存前还需要进行一下过滤，留下我们想要的日志，如只保存某个级别的日志，或只保存包含某个关键字的日志等，那么这个过滤过程就交给 Filter 来完成。</li><li>Parent Handler：Handler 之间可以存在分层关系，以使得不同 Handler 之间共享相同功能的代码。</li></ul><p>以上就是整个 logging 模块的基本架构和对象功能，了解了之后我们详细来了解一下 logging 模块的用法。</p><h1 id="日志记录的相关用法"><a href="#日志记录的相关用法" class="headerlink" title="日志记录的相关用法"></a>日志记录的相关用法</h1><p>总的来说 logging 模块相比 print 有这么几个优点：</p><ul><li>可以在 logging 模块中设置日志等级，在不同的版本（如开发环境、生产环境）上通过设置不同的输出等级来记录对应的日志，非常灵活。</li><li>print 的输出信息都会输出到标准输出流中，而 logging 模块就更加灵活，可以设置输出到任意位置，如写入文件、写入远程服务器等。</li><li>logging 模块具有灵活的配置和格式化功能，如配置输出当前模块信息、运行时间等，相比 print 的字符串格式化更加方便易用。</li></ul><p>下面我们初步来了解下 logging 模块的基本用法，先用一个实例来感受一下：</p><pre><code class="python">import logginglogging.basicConfig(level=logging.INFO, format=&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)logger = logging.getLogger(__name__)logger.info(&#39;This is a log info&#39;)logger.debug(&#39;Debugging&#39;)logger.warning(&#39;Warning exists&#39;)logger.info(&#39;Finish&#39;)</code></pre><p>在这里我们首先引入了 logging 模块，然后进行了一下基本的配置，这里通过 basicConfig 配置了 level 信息和 format 信息，这里 level 配置为 INFO 信息，即只输出 INFO 级别的信息，另外这里指定了 format 格式的字符串，包括 asctime、name、levelname、message 四个内容，分别代表运行时间、模块名称、日志级别、日志内容，这样输出内容便是这四者组合而成的内容了，这就是 logging 的全局配置。<br>接下来声明了一个 Logger 对象，它就是日志输出的主类，调用对象的 info() 方法就可以输出 INFO 级别的日志信息，调用 debug() 方法就可以输出 DEBUG 级别的日志信息，非常方便。在初始化的时候我们传入了模块的名称，这里直接使用 <strong>name</strong> 来代替了，就是模块的名称，如果直接运行这个脚本的话就是 <strong>main</strong>，如果是 import 的模块的话就是被引入模块的名称，这个变量在不同的模块中的名字是不同的，所以一般使用 <strong>name</strong> 来表示就好了，再接下来输出了四条日志信息，其中有两条 INFO、一条 WARNING、一条 DEBUG 信息，我们看下输出结果：</p><blockquote><p>2018-06-03 13:42:43,526 - <strong>main</strong> - INFO - This is a log info<br>2018-06-03 13:42:43,526 - <strong>main</strong> - WARNING - Warning exists<br>2018-06-03 13:42:43,526 - <strong>main</strong> - INFO - Finish</p></blockquote><p>可以看到输出结果一共有三条日志信息，每条日志都是对应了指定的格式化内容，另外我们发现 DEBUG 的信息是没有输出的，这是因为我们在全局配置的时候设置了输出为 INFO 级别，所以 DEBUG 级别的信息就被过滤掉了。<br>这时如果我们将输出的日志级别设置为 DEBUG，就可以看到 DEBUG 级别的日志输出了：<br>logging.basicConfig(level=logging.DEBUG, format=’%(asctime)s - %(name)s - %(levelname)s - %(message)s’)<br>输出结果：</p><blockquote><p>2018-06-03 13:49:22,770 - <strong>main</strong> - INFO - This is a log info<br>2018-06-03 13:49:22,770 - <strong>main</strong> - DEBUG - Debugging<br>2018-06-03 13:49:22,770 - <strong>main</strong> - WARNING - Warning exists<br>2018-06-03 13:49:22,770 - <strong>main</strong> - INFO - Finish</p></blockquote><p>由此可见，相比 print 来说，通过刚才的代码，我们既可以输出时间、模块名称，又可以输出不同级别的日志信息作区分并加以过滤，是不是灵活多了？<br>当然这只是 logging 模块的一小部分功能，接下来我们首先来全面了解一下 basicConfig 的参数都有哪些：</p><ul><li>filename：即日志输出的文件名，如果指定了这个信息之后，实际上会启用 FileHandler，而不再是 StreamHandler，这样日志信息便会输出到文件中了。</li><li>filemode：这个是指定日志文件的写入方式，有两种形式，一种是 w，一种是 a，分别代表清除后写入和追加写入。</li><li>format：指定日志信息的输出格式，即上文示例所示的参数，详细参数可以参考：docs.python.org/3/library/l…，部分参数如下所示：</li></ul><blockquote><p>%(levelno)s：打印日志级别的数值。<br>%(levelname)s：打印日志级别的名称。<br>%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]。<br>%(filename)s：打印当前执行程序名。<br>%(funcName)s：打印日志的当前函数。<br>%(lineno)d：打印日志的当前行号。<br>%(asctime)s：打印日志的时间。<br>%(thread)d：打印线程ID。<br>%(threadName)s：打印线程名称。<br>%(process)d：打印进程ID。<br>%(processName)s：打印线程名称。<br>%(module)s：打印模块名称。<br>%(message)s：打印日志信息。</p></blockquote><ul><li>datefmt：指定时间的输出格式。</li><li>style：如果 format 参数指定了，这个参数就可以指定格式化时的占位符风格，如 %、{、$ 等。</li><li>level：指定日志输出的类别，程序会输出大于等于此级别的信息。</li><li>stream：在没有指定 filename 的时候会默认使用 StreamHandler，这时 stream 可以指定初始化的文件流。</li><li>handlers：可以指定日志处理时所使用的 Handlers，必须是可迭代的。</li></ul><p>下面我们再用一个实例来感受一下：</p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG,                    filename=&#39;output.log&#39;,                    datefmt=&#39;%Y/%m/%d %H:%M:%S&#39;,                    format=&#39;%(asctime)s - %(name)s - %(levelname)s - %(lineno)d - %(module)s - %(message)s&#39;)logger = logging.getLogger(__name__)logger.info(&#39;This is a log info&#39;)logger.debug(&#39;Debugging&#39;)logger.warning(&#39;Warning exists&#39;)logger.info(&#39;Finish&#39;)</code></pre><p>这里我们指定了输出文件的名称为 output.log，另外指定了日期的输出格式，其中年月日的格式变成了 %Y/%m/%d，另外输出的 format 格式增加了 lineno、module 这两个信息，运行之后便会生成一个 output.log 的文件，内容如下：</p><blockquote><p>2018/06/03 14:43:26 - <strong>main</strong> - INFO - 9 - demo3 - This is a log info<br>2018/06/03 14:43:26 - <strong>main</strong> - DEBUG - 10 - demo3 - Debugging<br>2018/06/03 14:43:26 - <strong>main</strong> - WARNING - 11 - demo3 - Warning exists<br>2018/06/03 14:43:26 - <strong>main</strong> - INFO - 12 - demo3 - Finish</p></blockquote><p>可以看到日志便会输出到文件中，同时输出了行号、模块名称等信息。</p><p>以上我们通过 basicConfig 来进行了一些全局的配置，我们同样可以使用 Formatter、Handler 进行更灵活的处理，下面我们来了解一下。</p><h2 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h2><p>首先我们来了解一下输出日志的等级信息，logging 模块共提供了如下等级，每个等级其实都对应了一个数值，列表如下：</p><table><thead><tr><th>等级</th><th>数值</th></tr></thead><tbody><tr><td>CRITICAL</td><td>50</td></tr><tr><td>FATAL</td><td>50</td></tr><tr><td>ERROR</td><td>40</td></tr><tr><td>WARNING</td><td>30</td></tr><tr><td>WARN</td><td>30</td></tr><tr><td>INFO</td><td>20</td></tr><tr><td>DEBUG</td><td>10</td></tr><tr><td>NOTSET</td><td>0</td></tr></tbody></table><p>这里最高的等级是 CRITICAL 和 FATAL，两个对应的数值都是 50，另外对于 WARNING 还提供了简写形式 WARN，两个对应的数值都是 30。<br>我们设置了输出 level，系统便只会输出 level 数值大于或等于该 level 的的日志结果，例如我们设置了输出日志 level 为 INFO，那么输出级别大于等于 INFO 的日志，如 WARNING、ERROR 等，DEBUG 和 NOSET 级别的不会输出。</p><pre><code class="python">import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.WARN)# Loglogger.debug(&#39;Debugging&#39;)logger.critical(&#39;Critical Something&#39;)logger.error(&#39;Error Occurred&#39;)logger.warning(&#39;Warning exists&#39;)logger.info(&#39;Finished&#39;)</code></pre><p>这里我们设置了输出级别为 WARN，然后对应输出了五种不同级别的日志信息，运行结果如下：</p><blockquote><p>Critical Something<br>Error Occurred<br>Warning exists</p></blockquote><p>可以看到只有 CRITICAL、ERROR、WARNING 信息输出了，DEBUG、INFO 信息没有输出。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>下面我们先来了解一下 Handler 的用法，看下面的实例：</p><pre><code class="python">import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.INFO)handler = logging.FileHandler(&#39;output.log&#39;)formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)handler.setFormatter(formatter)logger.addHandler(handler)logger.info(&#39;This is a log info&#39;)logger.debug(&#39;Debugging&#39;)logger.warning(&#39;Warning exists&#39;)logger.info(&#39;Finish&#39;)</code></pre><p>这里我们没有再使用 basicConfig 全局配置，而是先声明了一个 Logger 对象，然后指定了其对应的 Handler 为 FileHandler 对象，然后 Handler 对象还单独指定了 Formatter 对象单独配置输出格式，最后给 Logger 对象添加对应的 Handler 即可，最后可以发现日志就会被输出到 output.log 中，内容如下：</p><blockquote><p>2018-06-03 14:53:36,467 - <strong>main</strong> - INFO - This is a log info<br>2018-06-03 14:53:36,468 - <strong>main</strong> - WARNING - Warning exists<br>2018-06-03 14:53:36,468 - <strong>main</strong> - INFO - Finish</p></blockquote><p>另外我们还可以使用其他的 Handler 进行日志的输出，logging 模块提供的 Handler 有：</p><ul><li>StreamHandler：logging.StreamHandler；日志输出到流，可以是 sys.stderr，sys.stdout 或者文件。</li><li>FileHandler：logging.FileHandler；日志输出到文件。</li><li>BaseRotatingHandler：logging.handlers.BaseRotatingHandler；基本的日志回滚方式。</li><li>RotatingHandler：logging.handlers.RotatingHandler；日志回滚方式，支持日志文件最大数量和日志文件回滚。</li><li>TimeRotatingHandler：logging.handlers.TimeRotatingHandler；日志回滚方式，在一定时间区域内回滚日志文件。</li><li>SocketHandler：logging.handlers.SocketHandler；远程输出日志到TCP/IP sockets。</li><li>DatagramHandler：logging.handlers.DatagramHandler；远程输出日志到UDP sockets。</li><li>SMTPHandler：logging.handlers.SMTPHandler；远程输出日志到邮件地址。</li><li>SysLogHandler：logging.handlers.SysLogHandler；日志输出到syslog。</li><li>NTEventLogHandler：logging.handlers.NTEventLogHandler；远程输出日志到Windows NT/2000/XP的事件日志。</li><li>MemoryHandler：logging.handlers.MemoryHandler；日志输出到内存中的指定buffer。</li><li>HTTPHandler：logging.handlers.HTTPHandler；通过”GET”或者”POST”远程输出到HTTP服务器。</li></ul><p>下面我们使用三个 Handler 来实现日志同时输出到控制台、文件、HTTP 服务器：</p><pre><code class="python">import loggingfrom logging.handlers import HTTPHandlerimport syslogger = logging.getLogger(__name__)logger.setLevel(level=logging.DEBUG)# StreamHandlerstream_handler = logging.StreamHandler(sys.stdout)stream_handler.setLevel(level=logging.DEBUG)logger.addHandler(stream_handler)# FileHandlerfile_handler = logging.FileHandler(&#39;output.log&#39;)file_handler.setLevel(level=logging.INFO)formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)file_handler.setFormatter(formatter)logger.addHandler(file_handler)# HTTPHandlerhttp_handler = HTTPHandler(host=&#39;localhost:8001&#39;, url=&#39;log&#39;, method=&#39;POST&#39;)logger.addHandler(http_handler)# Loglogger.info(&#39;This is a log info&#39;)logger.debug(&#39;Debugging&#39;)logger.warning(&#39;Warning exists&#39;)logger.info(&#39;Finish&#39;)</code></pre><p>运行之前我们需要先启动 HTTP Server，并运行在 8001 端口，其中 log 接口是用来接收日志的接口。<br>运行之后控制台输出会输出如下内容：</p><blockquote><p>This is a log info<br>Debugging<br>Warning exists<br>Finish</p></blockquote><p>output.log 文件会写入如下内容：</p><blockquote><p>2018-06-03 15:13:44,895 - <strong>main</strong> - INFO - This is a log info<br>2018-06-03 15:13:44,947 - <strong>main</strong> - WARNING - Warning exists<br>2018-06-03 15:13:44,949 - <strong>main</strong> - INFO - Finish</p></blockquote><p>HTTP Server 会收到控制台输出的信息。</p><p>这样一来，我们就通过设置多个 Handler 来控制了日志的多目标输出。</p><p>另外值得注意的是，在这里 StreamHandler 对象我们没有设置 Formatter，因此控制台只输出了日志的内容，而没有包含时间、模块等信息，而 FileHandler 我们通过 setFormatter() 方法设置了一个 Formatter 对象，因此输出的内容便是格式化后的日志信息。</p><p>另外每个 Handler 还可以设置 level 信息，最终输出结果的 level 信息会取 Logger 对象的 level 和 Handler 对象的 level 的交集。</p><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><p>在进行日志格式化输出的时候，我们可以不借助于 basicConfig 来全局配置格式化输出内容，可以借助于 Formatter 来完成，下面我们再来单独看下 Formatter 的用法：</p><pre><code class="python">import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.WARN)formatter = logging.Formatter(fmt=&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;, datefmt=&#39;%Y/%m/%d %H:%M:%S&#39;)handler = logging.StreamHandler()handler.setFormatter(formatter)logger.addHandler(handler)# Loglogger.debug(&#39;Debugging&#39;)logger.critical(&#39;Critical Something&#39;)logger.error(&#39;Error Occurred&#39;)logger.warning(&#39;Warning exists&#39;)logger.info(&#39;Finished&#39;)</code></pre><p>在这里我们指定了一个 Formatter，并传入了 fmt 和 datefmt 参数，这样就指定了日志结果的输出格式和时间格式，然后 handler 通过 setFormatter() 方法设置此 Formatter 对象即可，输出结果如下：</p><blockquote><p>2018/06/03 15:47:15 - <strong>main</strong> - CRITICAL - Critical Something<br>2018/06/03 15:47:15 - <strong>main</strong> - ERROR - Error Occurred<br>2018/06/03 15:47:15 - <strong>main</strong> - WARNING - Warning exists</p></blockquote><p>这样我们可以每个 Handler 单独配置输出的格式，非常灵活。</p><h2 id="捕获-Traceback"><a href="#捕获-Traceback" class="headerlink" title="捕获 Traceback"></a>捕获 Traceback</h2><p>如果遇到错误，我们更希望报错时出现的详细 Traceback 信息，便于调试，利用 logging 模块我们可以非常方便地实现这个记录，我们用一个实例来感受一下：</p><pre><code class="python">import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.DEBUG)# Formatterformatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)# FileHandlerfile_handler = logging.FileHandler(&#39;result.log&#39;)file_handler.setFormatter(formatter)logger.addHandler(file_handler)# StreamHandlerstream_handler = logging.StreamHandler()stream_handler.setFormatter(formatter)logger.addHandler(stream_handler)# Loglogger.info(&#39;Start&#39;)logger.warning(&#39;Something maybe fail.&#39;)try:    result = 10 / 0except Exception:    logger.error(&#39;Faild to get result&#39;, exc_info=True)logger.info(&#39;Finished&#39;)</code></pre><p>这里我们在 error() 方法中添加了一个参数，将 exc_info 设置为了 True，这样我们就可以输出执行过程中的信息了，即完整的 Traceback 信息。<br>运行结果如下：</p><blockquote><p>2018-06-03 16:00:15,382 - <strong>main</strong> - INFO - Start print log<br>2018-06-03 16:00:15,382 - <strong>main</strong> - DEBUG - Do something<br>2018-06-03 16:00:15,382 - <strong>main</strong> - WARNING - Something maybe fail.<br>2018-06-03 16:00:15,382 - <strong>main</strong> - ERROR - Faild to get result<br>Traceback (most recent call last):<br>  File “/private/var/books/aicodes/loggingtest/demo8.py”, line 23, in <module><br>    result = 10 / 0<br>ZeroDivisionError: division by zero<br>2018-06-03 16:00:15,383 - <strong>main</strong> - INFO - Finished<br>可以看到这样我们就非常方便地记录下来了报错的信息，一旦出现了错误，我们也能非常方便地排查。</module></p></blockquote><h1 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h1><p>在写项目的时候，我们肯定会将许多配置放置在许多模块下面，这时如果我们每个文件都来配置 logging 配置那就太繁琐了，logging 模块提供了父子模块共享配置的机制，会根据 Logger 的名称来自动加载父模块的配置。<br>例如我们这里首先定义一个 main.py 文件：</p><pre><code class="python">import loggingimport corelogger = logging.getLogger(&#39;main&#39;)logger.setLevel(level=logging.DEBUG)# Handlerhandler = logging.FileHandler(&#39;result.log&#39;)handler.setLevel(logging.INFO)formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)handler.setFormatter(formatter)logger.addHandler(handler)logger.info(&#39;Main Info&#39;)logger.debug(&#39;Main Debug&#39;)logger.error(&#39;Main Error&#39;)core.run()</code></pre><p>这里我们配置了日志的输出格式和文件路径，同时定义了 Logger 的名称为 main，然后引入了另外一个模块 core，最后调用了 core 的 run() 方法。<br>接下来我们定义 core.py，内容如下：</p><pre><code class="python">import logginglogger = logging.getLogger(&#39;main.core&#39;)def run():    logger.info(&#39;Core Info&#39;)    logger.debug(&#39;Core Debug&#39;)    logger.error(&#39;Core Error&#39;)</code></pre><p>这里我们定义了 Logger 的名称为 main.core，注意这里开头是 main，即刚才我们在 main.py 里面的 Logger 的名称，这样 core.py 里面的 Logger 就会复用 main.py 里面的 Logger 配置，而不用再去配置一次了。<br>运行之后会生成一个 result.log 文件，内容如下：</p><blockquote><p>2018-06-03 16:55:56,259 - main - INFO - Main Info<br>2018-06-03 16:55:56,259 - main - ERROR - Main Error<br>2018-06-03 16:55:56,259 - main.core - INFO - Core Info<br>2018-06-03 16:55:56,259 - main.core - ERROR - Core Error</p></blockquote><p>可以看到父子模块都使用了同样的输出配置。<br>如此一来，我们只要在入口文件里面定义好 logging 模块的输出配置，子模块只需要在定义 Logger 对象时名称使用父模块的名称开头即可共享配置，非常方便。<br>文件配置<br>在开发过程中，将配置在代码里面写死并不是一个好的习惯，更好的做法是将配置写在配置文件里面，我们可以将配置写入到配置文件，然后运行时读取配置文件里面的配置，这样是更方便管理和维护的，下面我们以一个实例来说明一下，首先我们定义一个 yaml 配置文件：</p><pre><code class="python">version: 1formatters:  brief:    format: &quot;%(asctime)s - %(message)s&quot;  simple:    format: &quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;handlers:  console:    class : logging.StreamHandler    formatter: brief    level   : INFO    stream  : ext://sys.stdout  file:    class : logging.FileHandler    formatter: simple    level: DEBUG    filename: debug.log  error:    class: logging.handlers.RotatingFileHandler    level: ERROR    formatter: simple    filename: error.log    maxBytes: 10485760    backupCount: 20    encoding: utf8loggers:  main.core:    level: DEBUG    handlers: [console, file, error]root:  level: DEBUG  handlers: [console]</code></pre><p>这里我们定义了 formatters、handlers、loggers、root 等模块，实际上对应的就是各个 Formatter、Handler、Logger 的配置，参数和它们的构造方法都是相同的。<br>接下来我们定义一个主入口文件，main.py，内容如下：</p><pre><code class="python">import loggingimport coreimport yamlimport logging.configimport osdef setup_logging(default_path=&#39;config.yaml&#39;, default_level=logging.INFO):    path = default_path    if os.path.exists(path):        with open(path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:            config = yaml.load(f)            logging.config.dictConfig(config)    else:        logging.basicConfig(level=default_level)def log():    logging.debug(&#39;Start&#39;)    logging.info(&#39;Exec&#39;)    logging.info(&#39;Finished&#39;)if __name__ == &#39;__main__&#39;:    yaml_path = &#39;config.yaml&#39;    setup_logging(yaml_path)    log()    core.run()</code></pre><p>这里我们定义了一个 setup_logging() 方法，里面读取了 yaml 文件的配置，然后通过 dictConfig() 方法将配置项传给了 logging 模块进行全局初始化。<br>另外这个模块还引入了另外一个模块 core，所以我们定义 core.py 如下：</p><pre><code class="python">import logginglogger = logging.getLogger(&#39;main.core&#39;)def run():    logger.info(&#39;Core Info&#39;)    logger.debug(&#39;Core Debug&#39;)    logger.error(&#39;Core Error&#39;)</code></pre><p>这个文件的内容和上文是没有什么变化的。<br>观察配置文件，主入口文件 main.py 实际上对应的是 root 一项配置，它指定了 handlers 是 console，即只输出到控制台。另外在 loggers 一项配置里面，我们定义了 main.core 模块，handlers 是 console、file、error 三项，即输出到控制台、输出到普通文件和回滚文件。<br>这样运行之后，我们便可以看到所有的运行结果输出到了控制台：</p><blockquote><p>2018-06-03 17:07:12,727 - Exec<br>2018-06-03 17:07:12,727 - Finished<br>2018-06-03 17:07:12,727 - Core Info<br>2018-06-03 17:07:12,727 - Core Info<br>2018-06-03 17:07:12,728 - Core Error<br>2018-06-03 17:07:12,728 - Core Error</p></blockquote><p>在 debug.log 文件中则包含了 core.py 的运行结果：</p><blockquote><p>2018-06-03 17:07:12,727 - main.core - INFO - Core Info<br>2018-06-03 17:07:12,727 - main.core - DEBUG - Core Debug<br>2018-06-03 17:07:12,728 - main.core - ERROR - Core Error</p></blockquote><p>可以看到，通过配置文件，我们可以非常灵活地定义 Handler、Formatter、Logger 等配置，同时也显得非常直观，也非常容易维护，在实际项目中，推荐使用此种方式进行配置。<br>以上便是 logging 模块的基本使用方法，有了它，我们可以方便地进行日志管理和维护，会给我们的工作带来极大的方便。</p><h1 id="日志记录使用常见误区"><a href="#日志记录使用常见误区" class="headerlink" title="日志记录使用常见误区"></a>日志记录使用常见误区</h1><p>在日志输出的时候经常我们会用到字符串拼接的形式，很多情况下我们可能会使用字符串的 format() 来构造一个字符串，但这其实并不是一个好的方法，因为还有更好的方法，下面我们对比两个例子：</p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG, format=&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)# badlogging.debug(&#39;Hello {0}, {1}!&#39;.format(&#39;World&#39;, &#39;Congratulations&#39;))# goodlogging.debug(&#39;Hello %s, %s!&#39;, &#39;World&#39;, &#39;Congratulations&#39;)</code></pre><p>这里有两种打印 Log 的方法，第一种使用了字符串的 format() 的方法进行构造，传给 logging 的只用到了第一个参数，实际上 logging 模块提供了字符串格式化的方法，我们只需要在第一个参数写上要打印输出的模板，占位符用 %s、%d 等表示即可，然后在后续参数添加对应的值就可以了，推荐使用这种方法。<br>运行结果如下：</p><blockquote><p>2018-06-03 22:27:51,220 - root - DEBUG - Hello World, Congratulations!<br>2018-06-03 22:27:51,220 - root - DEBUG - Hello World, Congratulations!</p></blockquote><p>另外在进行异常处理的时候，通常我们会直接将异常进行字符串格式化，但其实可以直接指定一个参数将 traceback 打印出来，示例如下：</p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG, format=&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)try:    result = 5 / 0except Exception as e:    # bad    logging.error(&#39;Error: %s&#39;, e)    # good    logging.error(&#39;Error&#39;, exc_info=True)    # good    logging.exception(&#39;Error&#39;)</code></pre><p>如果我们直接使用字符串格式化的方法将错误输出的话，是不会包含 Traceback 信息的，但如果我们加上 exc_info 参数或者直接使用 exception() 方法打印的话，那就会输出 Traceback 信息了。<br>运行结果如下：</p><blockquote><p>2018-06-03 22:24:31,927 - root - ERROR - Error: division by zero<br>2018-06-03 22:24:31,927 - root - ERROR - Error<br>Traceback (most recent call last):<br>  File “/private/var/books/aicodes/loggingtest/demo9.py”, line 6, in <module><br>    result = 5 / 0<br>ZeroDivisionError: division by zero<br>2018-06-03 22:24:31,928 - root - ERROR - Error<br>Traceback (most recent call last):<br>  File “/private/var/books/aicodes/loggingtest/demo9.py”, line 6, in <module><br>    result = 5 / 0<br>ZeroDivisionError: division by zero</module></module></p></blockquote><p>出处信息</p><p>作者：崔庆才丨静觅<br>链接：<a href="https://juejin.im/post/5b13fdd0f265da6e0b6ff3dd" target="_blank" rel="noopener">https://juejin.im/post/5b13fdd0f265da6e0b6ff3dd</a><br>来源：掘金</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置多个ssh密钥对并且永久多ssh管理</title>
      <link href="/article/config-local-ssh.html"/>
      <url>/article/config-local-ssh.html</url>
      <content type="html"><![CDATA[<p>这两天捣腾SSH，一直对其使用一知半解，由于要把博客迁移，弄来弄去发现还是部署到国内的coding吧<br>之前也弄过，但是由于重新安装了git-for-windows客户端，所以一开始用hexo d命令部署的时候报错了<br>趁着这次迁移也好好弄了一下本地的ssh管理，虽然还有些问题，但是至少比之前清晰一些了，这里也记录一下过程中遇到的问题</p><a id="more"></a><p>我的目的，将hexo生成的静态文件同时部署到github与coding上</p><h2 id="安装git-for-windows客户端"><a href="#安装git-for-windows客户端" class="headerlink" title="安装git-for-windows客户端"></a>安装git-for-windows客户端</h2><p>下载地址 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>无论是github还是coding都需要上传你的公钥，这两个地方可以上传相同的公钥，但也可以像我这样闲的蛋疼上传不同的公钥。</p><h2 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h2><p>使用<code class="text">ssh-keygen</code> 来创建密钥对，命令为 <code class="text">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>,其实这里-C 后面的email地址无所谓，可以随便写，只是为了你方便而已。<br>输入完该命令以后，首先会让你给密钥文件起个名字，这个是文件名，叫什么随心情<br><img src="/image/2018/usessh1.png" alt="生成密钥对"><br>接下来让你输入密码，我这里直接回车，不用密码<br>然后它就会生成一个密钥对，像我这个设置就会生成yyxtest和yyxtest_pub两个文件，yyxtest.pub是公钥，谁都可以给，但是你私钥要自已保存好，谁拿到了你私钥就呵呵了。</p><h2 id="上传公钥到github与coding中"><a href="#上传公钥到github与coding中" class="headerlink" title="上传公钥到github与coding中"></a>上传公钥到github与coding中</h2><p>根据github上的提示将公钥上传到github上你的个人账户中的ssh中<br><img src="/image/2018/usessh2.png" alt="上传公钥到github中"></p><p>同样的操作再生成一对密钥，将公钥上传到coding中，注意我这里是为了测试，你完全没有必要重新生成，你当然可以上传刚才生成的yyxtest.pub这个公钥，当然后面会有一些问题，之后再详细说明。</p><h2 id="上传文件到github上"><a href="#上传文件到github上" class="headerlink" title="上传文件到github上"></a>上传文件到github上</h2><p> 赶紧上传个文件到github上试试吧(使用hexo d 来部署)，其实你可以先不用上传文件，可以用<code class="text">ssh -vT git@github.com</code> 来查看一下信息<br>这里你不用试了，肯定是不行的…… 抗都被我踩了<br><img src="/image/2018/usessh4.png" alt="Permission denied"><br>提示Permission denied,原因是你现在用的私钥还是id_rsa，并不是刚才生成的yyxtest，<br>ssh默认使用id_rsa，如果连id_rsa都没有，那你还不赶紧生成一个默认的。</p><h2 id="添加yyxtest私钥到git-bash中"><a href="#添加yyxtest私钥到git-bash中" class="headerlink" title="添加yyxtest私钥到git bash中"></a>添加yyxtest私钥到git bash中</h2><p>根据github上的提示<a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">generate SSH keys</a> 先将yyxtest添加到git bash中,<br>    使用<code class="text">ssh-add ~/.ssh/yyxtest</code> ,然后顺利提交代码成功，但是在提交文件到coding时又不行了，提示</p><blockquote><p>Error: git@git.coding.net: Permission denied (publickey).<br>fatal: Could not read from remote repository.</p></blockquote><p>没办法，再用刚才的ssh-add 命令将用于coding的私钥也添加到git bash中，这次coding也可以提交了</p><h2 id="配置ssh本地的config文件"><a href="#配置ssh本地的config文件" class="headerlink" title="配置ssh本地的config文件"></a>配置ssh本地的config文件</h2><p>试试关掉这个git bash,然后再试着用hexo d 提交一些文件，这次又不行了，还是提示Permission denied，这怎么能行，总不能每次提交更新都输入ssh-add 添加各种私钥吧，这时就要用到config这个文件了。<br>如果git安装是默认的话，将会把生成的公钥保存在C:\Users\username.ssh目录中(我用的是windows，不丢人)，里面如果没有config文件，自已生成一个,里面写一些配置信息,各种字段说明如下</p><blockquote><p>  <strong>Host</strong>：代码托管平台的别名,但是这个别名和后面要用到的ssh链接 git@github.com:xxx/xxx.git 中的 @ 符号后面的内容要一致，而一般来说github默认提供的就是git@github.com，因此为了方便，github的Host写github.com即可，别取别名了<br>    <strong>HostName</strong>：代码托管平台真正的IP地址或域名,写域名就行，<br>    <strong>IdentityFile</strong>：对应的密钥文件路径。必须写绝对路径，windows下可以写 C:\Users\xxx.ssh\yyxtest<br>    <strong>PreferredAuthentications</strong>：配置登录时用什么权限认证。可设为publickey，password publickey，keyboard-interactive等<br>    <strong>User</strong>：对应的用户名。</p></blockquote><p>我这里有两个私钥，所以我的配置文件如下</p><pre><code class="python">Host git.coding.net    HostName git.coding.net    IdentityFile C:\Users\kevin\.ssh\rsa_coding    PreferredAuthentications publickey    User yangyanxingHost github.com    HostName github.com    IdentityFile C:\Users\kevin\.ssh\yyx    PreferredAuthentications publickey    User kevinkelin</code></pre><p>之前说过，你没有必要为不同的网站生成不同的密钥，用同一份也可以，如果用同一份，这里IdentityFile也要写一样的<br>保存之后先不用着急提交，使用ssh -vT 查看一下连接是否有问题<br>github 提示 <code class="text">Hi kevinkelin! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br>coding提示 <code class="text">yangyanxing，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</code><br>这样就可以直接使用<code class="text">hexo d</code>来提交文件更新了！</p><p>注意的问题</p><ol><li>config文件中的host 配置是区分大小写的，github.com 和github.COM是不同的，一定要写对</li><li>coding的host是git.coding.net 而不是coding.net</li></ol><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>git bash客户端，如果在非C盘上右键的方式启动，那么还是不行，它会寻找当前盘的中的.ssh目录，根本不存在的目录，所有找私钥肯定也找不到，只能先启动git bash,然后cd 到操作的目录中，这个我再研究研究怎么回事。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/Yvettre/article/details/79639700" target="_blank" rel="noopener">配置本地和github的ssh密钥对：永久多ssh管理(win10)</a></li><li><a href="https://blog.csdn.net/w410589502/article/details/53607691" target="_blank" rel="noopener">git window下配置SSH连接GitHub</a></li><li><a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">Generating a new SSH key and adding it to the ssh-agent</a></li></ul>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>将hexo生成的静态网站部署到七牛</title>
      <link href="/article/put-html-to-qiniu.html"/>
      <url>/article/put-html-to-qiniu.html</url>
      <content type="html"><![CDATA[<p>最近由于百度的BAE引擎取消了对基础版的支持，所以没有办法，继续寻找可以托管html的服务器。<br>之前用过gitpages,coding与bae，这几个可以说各有各的特点，也各有各的缺点<br>gitpages什么都好，就是访问相对慢，coding非要你加一个它们的链接，否则就要在访问网站最开始加个广告<br>BAE呢，其实BAE基础版挺好的，访问速度快，价钱也合理，没想到他们将要取消了。<br>在查找新的部署方案时发现有人提到七牛云存储，看了一下他们的文档，可以暂时的满足托管html纯静态网页需求。<br>开始动工！</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>备了案的域名</li><li>七牛账户，并且充了10块钱</li></ol><p>一、使用hexo生成静态html资源，这个不用多说，使用hexo的都知道<br>二、登录七牛账号，进入管理控制台，点击<code class="text">镜像存储</code>，新建一个存储空间，访问控制一定要选择<code class="text">公开空间</code><br>三、再点击<code class="text">绑定域名</code>,将你网站的域名绑定到刚才创建的空间<br><img src="/image/2018/qiniu1.png" alt="绑定域名"><br>四、将静态网站资源上传到七牛，这里七牛会提供一些工具，windows下有可视化工具，linux与mac下有对应的命令行工具，选自已喜欢的，由于我现在是在windows下操作，所以我使用了可视化工具,下载<br><a href="https://developer.qiniu.com/kodo/tools/1666/qsunsync" target="_blank" rel="noopener">https://developer.qiniu.com/kodo/tools/1666/qsunsync</a><br>打开这个工具，先点击<code class="text">账号设置</code>,输入你的AK与SK,这两个值可以到<code class="text">个人中心</code>下的<code class="text">密钥管理</code>中获取<br><img src="/image/2018/qiniu2.png" alt="设定AK与SK"><br>AK与SK设置好了以后就可以点击<code class="text">新建同步任务</code><br><img src="/image/2018/qiniu3.png" alt="新建同步任务"><br>本地目录选择hexo生成的public目录，目标空间选择你刚才创建的空间<br>切换到高级设置，这里一定要设置一下，遇到空间中存在同名文件则强制覆盖，否则之后生成的html如果同名的话就不会上传了<br>每次同步前检查本地增量文件并上传也要勾上，否则新产生的文件不会上传<br><img src="/image/2018/qiniu4.png" alt="新建同步任务"></p><p>设置好了以后就可以点击<code class="text">开始同步</code>了<br>上传过程有点慢，要耐心等待。</p><p>五、根据七牛的提示，将域名cname到它给你的地址<br><img src="/image/2018/qiniu5.png" alt="设置cname"></p><p>六、最最关键的一步，空间设置<br>如果不设置空间，那么你现在的七牛就是一个普通的存储文件的地址，还不能通过域名访问<br>比如你的首页是 <a href="http://www.abc.com/" target="_blank" rel="noopener">http://www.abc.com/</a> 如果你现在访问这个，会提示 error: “Document not found”，必须要加上 <a href="http://www.abc.com/index.html" target="_blank" rel="noopener">http://www.abc.com/index.html</a><br>七牛现在比较人性化的添加了默认首页展示设定，一定要将其打开<br><img src="/image/2018/qiniu6.png" alt="默认首页展示"></p><p>这样就可以通过 <a href="http://www.abc.com/" target="_blank" rel="noopener">http://www.abc.com/</a> 来访问网页了，访问categories等也会自动跳到相应的index.html页面</p><p>当cname生效以后就可以正常访问了</p><p>更新文章以后，有一个问题，七牛的缓存刷新的很慢，或者说刷新规则里设置的很慢，可以在域名管理处点击绑定的域名然后设置一些缓存规则<br><img src="/image/2018/qiniu7.png" alt="域名设置"></p><p>点击修改配置<br><img src="/image/2018/qiniu8.png" alt="缓存设置"><br>我将html的更新频率设置为1小时，并且全站缓存设置为1分钟</p><p>另外还可以根据自身的需求设置一些防盗链</p><p>大功告成，享受一下吧</p><p>要时刻关注一下域名的备案信息，如果哪天积案被注销了，七牛也会停止该域名的访问的！！！</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用python操作selenium操作第三方浏览器(360浏览器)</title>
      <link href="/article/use-selenium-op-browser.html"/>
      <url>/article/use-selenium-op-browser.html</url>
      <content type="html"><![CDATA[<p>最近在测试一个项目，使用360浏览器来做一些操作<br>之前使用过selenium来操作chrome和FireFox，这里记录一下</p><a id="more"></a><p>环境：windows7 python2.6 webdriver</p><h1 id="使用chrome进行测试"><a href="#使用chrome进行测试" class="headerlink" title="使用chrome进行测试"></a>使用chrome进行测试</h1><p>安装selenium </p><blockquote><p>pip install selenium </p></blockquote><p>下载浏览器驱动(chrome)<br><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">浏览器驱动</a></p><p>一定要根据自已的chrome版本来下载对应的chromedriver<br><img src="/image/2018/chromedriver.png" alt="download"></p><p>将chromedriver.exe的路径加到系统的环境变量中，个人用户和系统的都行<br>简单的测试一下selenium是否工作正常</p><pre><code class="python">from selenium import webdriverd = webdriver.Chrome()d.get(r&#39;http://www.yangyanxing.com&#39;)</code></pre><p>当输入<em> d = webdriver.Chrome() </em> 时，如果没有异常，那会将会打开Chrome浏览器<br><img src="/image/2018/chrome.png" alt="chrome"></p><p>接下来就可以用selenium的接口来进行相应的操作了<br>selenium的接口文档<br><a href="http://selenium-python.readthedocs.io/index.html" target="_blank" rel="noopener">selenium接口文档</a></p><blockquote><p>print d.find_element_by_class_name(‘text-muted’).text.encode(‘gbk’)<br>京ICP备18004468号</p></blockquote><h1 id="使用第三方浏览器进行测试，这里以360安全浏览器为例"><a href="#使用第三方浏览器进行测试，这里以360安全浏览器为例" class="headerlink" title="使用第三方浏览器进行测试，这里以360安全浏览器为例"></a>使用第三方浏览器进行测试，这里以360安全浏览器为例</h1><p>首先查看它的chrome内核版本<br><img src="/image/2018/360se.png" alt="360安全浏览器内核版本"></p><p>它的版本是55的，好低啊，对应的chromedriver.exe是2.28，<br>到<a href="https://chromedriver.storage.googleapis.com/index.html?path=2.28/" target="_blank" rel="noopener">https://chromedriver.storage.googleapis.com/index.html?path=2.28/</a> 处下载</p><p>这里要用到的是实例webdriver.Chrome()时要加上一些参数</p><pre><code class="python">chrome_options = webdriver.ChromeOptions()chrome_options.binary_location = r&quot;C:\Users\kevin\AppData\Roaming\360se6\Application\360se.exe&quot; #这里是360安全浏览器的路径chrome_options.add_argument(r&#39;--lang=zh-CN&#39;) # 这里添加一些启动的参数d = webdriver.Chrome(chrome_options=chrome_options)</code></pre><p>不出意外的话将启动360安全浏览器，之后就可以继续使用selenium的api来操作网页了</p><h1 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h1><p>浏览器闪退</p><p>查看报错信息</p><blockquote><p>raise exception_class(message, screen, stacktrace)<br>selenium.common.exceptions.WebDriverException: Message: session not created exception: Chrome version must be &gt;= 65.0.3325.0</p></blockquote><p>这个的意思就是chromedriver.exe版本不对，请下载与chrome内核版本对应的chromedriver.exe</p><blockquote><p>selenium.common.exceptions.WebDriverException: Message: ‘chromedriver’ executable needs to be in PATH. Please see <a href="https://sites.google.com/a/chromium.org/chromedriver/home" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/home</a></p></blockquote><p>这个的意思是chromedriver.exe 没有在环境变量里，请将chromedrive.exe放到环境变量里即可。</p><p>之后将研究一下远程的WebDriver。</p><p>参考文章<br><a href="https://cuiqingcai.com/2599.html" target="_blank" rel="noopener">Python爬虫利器五之Selenium的用法</a><br><a href="https://blog.csdn.net/vinson0526/article/details/51850929" target="_blank" rel="noopener">selenium 定制启动 chrome 的选项</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的异常处理</title>
      <link href="/article/try_in_python.html"/>
      <url>/article/try_in_python.html</url>
      <content type="html"><![CDATA[<p>写程序肯定要接触异常处理，还好python中的异常处理比较简单，但是有些细节还是需要好好看一下<br>这里记录一下try在python中的使用。</p><a id="more"></a><h4 id="最简单的，try…except"><a href="#最简单的，try…except" class="headerlink" title="最简单的，try…except"></a>最简单的，try…except</h4><p>先看一下以下的代码执行情况</p><pre><code class="python">def test():    print &#39;yangyanxing&#39;    print 5/0    print &#39;end script....&#39;if __name__ == &#39;__main__&#39;:    test()</code></pre><p>程序运行到 print ‘yangyanxing’ 时，并没有出错，可以正常的输出<br>但是当走到5/0的时候，会触发除0的错误，我们都知道，0是不能做为除数的，所以程序会在此处崩溃，<br>下面的 <code class="text">print &#39;end script... &#39;</code> 也就不会执行了<br>执行程序得到以下的输出</p><pre><code>yangyanxingTraceback (most recent call last):  File &quot;try.py&quot;, line 11, in &lt;module&gt;    test()  File &quot;try.py&quot;, line 7, in test    print 5/0ZeroDivisionError: integer division or modulo by zero</code></pre><p>如何让程序可以正常的运行呢？很简单，加个try呗，把可能出现异常的地方进行捕获</p><pre><code class="python">def test():    print &#39;yangyanxing&#39;    try:        print 5/0    except Exception as e:        print e    print &#39;end script....&#39;if __name__ == &#39;__main__&#39;:    test()</code></pre><p>将得到以下的输出</p><pre><code>yangyanxinginteger division or modulo by zeroend script....</code></pre><p>这样，当程序运行到出错的那行代码时，将执行except处定义代码，即 <code class="text">print e</code>，然后程序接着就执行<code class="text">print &#39;end script....&#39;</code></p><p>可是，你不可能在执行每一步操作的时候都对其加上单独的try语句，那样程序看上去会很诡异，有时你也不知道会出什么错误，所以try的范围可以加大一些</p><pre><code class="python">def test():    try:        print &#39;yangyanxing&#39;        print 5/0        print &#39;end script....&#39;    except Exception as e:        print eif __name__ == &#39;__main__&#39;:    test()</code></pre><p>这时得到的输出是</p><pre><code>yangyanxinginteger division or modulo by zero[Finished in 0.0s]</code></pre><p>嗯，很简单是不是，你也不知道是哪行出的错误？你是不是想要得到更加详细的信息？<br>python标准库已经为你准备好了，可以使用traceback来打印更加详细的异常信息</p><pre><code class="python">#coding:utf-8import tracebackdef test():    try:        print &#39;yangyanxing&#39;        print 5/0        print &#39;end script....&#39;    except Exception as e:        print e        print 1111        print traceback.format_exc()if __name__ == &#39;__main__&#39;:    test()</code></pre><p>它的输出结果为</p><pre><code>yangyanxinginteger division or modulo by zero1111Traceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test    print 5/0ZeroDivisionError: integer division or modulo by zero</code></pre><p>请看1111下面的那个trackback信息,这里标记的错误在哪一行，什么错误，一定要善用trackback</p><h4 id="try…except…finally"><a href="#try…except…finally" class="headerlink" title="try…except…finally"></a>try…except…finally</h4><p>这个比之前那个try…except多了一个finally，功能上也强大一些，这个finally不是必须的，使用的时候也根据实际情况自己来定。<br>而且加了finally以后也有很多注意的地方。<br>finally的意思是，无论程序是否有异常，最后都要执行它的代码。</p><p>看这样的例子</p><pre><code class="python">#coding:utf-8import tracebackdef test():    try:        print &#39;yangyanxing&#39;        print 5/0        print &#39;hello world&#39;    except Exception as e:        print traceback.format_exc()    finally:        print &#39;end script....&#39;if __name__ == &#39;__main__&#39;:    test()</code></pre><p>得到的输出为</p><pre><code>yangyanxingTraceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test    print 5/0ZeroDivisionError: integer division or modulo by zeroend script....</code></pre><p>注意，这里<code class="text">print &#39;end script....&#39;</code>被执行了，程序在print 5/0的时候发生的错误，在此中断，开始执行except代码，执行完except代码以后，就会执行finally代码，而出异常处后面的代码就不会被执行了</p><p>关于返回值的问题，看以下的代码 </p><pre><code class="python">#coding:utf-8import tracebackdef test():    try:        if 2&gt;1:            return 1        else:            return 0    except Exception as e:        print traceback.format_exc()        return 2    finally:        print &#39;end script....&#39;        return 3if __name__ == &#39;__main__&#39;:    print test()</code></pre><p>它的返回值是什么呢？0？1？2？3？</p><p>看一下程序运行的结果</p><pre><code>end script....3</code></pre><p>结果是3</p><p>也就是说，即使在try里定义了返回值，也是没有用的，程序最终返回的是finally中执行的返回值，所以如果使用finally的话，那么在try与except中最好不要定义返回值，可以将其保存到变量中，然后在finally中返回.</p><pre><code class="python">#coding:utf-8import tracebackdef test():    try:        if 2&gt;1:            result = 1        else:            result =  0    except Exception as e:        print traceback.format_exc()        result =  2    finally:        print &#39;end script....&#39;        return resultif __name__ == &#39;__main__&#39;:    print test()</code></pre><p>这样程序返回值就是1了</p><h4 id="函数中异常的嵌套使用"><a href="#函数中异常的嵌套使用" class="headerlink" title="函数中异常的嵌套使用"></a>函数中异常的嵌套使用</h4><p>这里不是try 里再加了个try，而是函数间的嵌套，看如下代码</p><pre><code class="python">#coding:utf-8import tracebackdef test():    print &#39;start test...&#39;    test2()    print &#39;end script...&#39;def test2():    try:        print &#39;start test2...&#39;        print 5/0        print &#39;end test2...&#39;    except Exception as e:        print traceback.format_exc()if __name__ == &#39;__main__&#39;:    test()</code></pre><p>它会有什么结果呢？</p><pre><code>start test...start test2...Traceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 13, in test2    print 5/0ZeroDivisionError: integer division or modulo by zeroend script...</code></pre><p>注意，这里在test2()函数中，已经将除0错误给逮到了，并且做了处理，所以在test函数中，不会受到什么影响，end script也可以正常的运行。<br>但是，对于某些复杂的程序，当test2函数中发生异常的时候，调用它的函数以接下来的操作中得是在test2运行正常才会执行正常，这种就比较尴尬。<br>怎么处理呢？</p><p>答案是在test2中使用raise将这个异常抛出，让调用者知道，它出错了。</p><pre><code class="python">#coding:utf-8import tracebackdef test():    try:        print &#39;start test...&#39;        test2()        print &#39;end script...&#39;    except Exception as e:        print traceback.format_exc()def test2():    try:        print &#39;start test2...&#39;        print 5/0        print &#39;end test2...&#39;    except Exception as e:        print traceback.format_exc()        raise eif __name__ == &#39;__main__&#39;:    test()</code></pre><p>得到的输出为</p><pre><code>start test...start test2...Traceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 16, in test2    print 5/0ZeroDivisionError: integer division or modulo by zeroTraceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test    test2()  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 20, in test2    raise eZeroDivisionError: integer division or modulo by zero</code></pre><p>上面的输出为test2()中打印的，下面的是test()函数打印的，这里test()函数中的<code class="text">print &#39;end script...&#39;</code>因为抓到了异常而没有执行。</p><p>这里也是根据业务流程来灵活的使用raise，有时某个异常会导致大流程失败的时候则要将其抛出，比如最近在做的一个项目，虚拟机启动并且执行相应的测试代码，有时经常会遇到虚拟机没有启动成功，但是程序还是会执行接下来的代码，检查原因就是虚拟机的会滚操作，它抓了异常，但是并没有抛出，然后上层在调用的时候就没有判断它的会滚是否成功，这样就会造成程序一直错误的执行。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>有时候系统定义的这些异常不能满足需求时就需要自己定义一些异常，这个用的也比较多，<br>比如要设计以下的场景，当循环到5次的时候，抛出一个’老子不干了，太累了’的异常</p><pre><code class="python">#coding:utf-8import tracebackimport timedef test():    try:        print &#39;start test...&#39;        test2()        print &#39;end script...&#39;    except Exception as e:        print traceback.format_exc()def test2():    try:        times = 10        while times &gt; 0:            print times            if times == 5:                raise TypeError(&#39;i don\&#39;t want to work....&#39;)            times -=1            time.sleep(1)    except Exception as e:        print traceback.format_exc()        raise eif __name__ == &#39;__main__&#39;:    test()</code></pre><p>得到以下输出 </p><pre><code>Traceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 19, in test2    raise TypeError(&#39;i don\&#39;t want to work....&#39;)TypeError: i don&#39;t want to work....Traceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 8, in test    test2()  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 24, in test2    raise eTypeError: i don&#39;t want to work....</code></pre><p>其实这里还不是自定义的异常，这里只是定义了异常信息，异常的类型还是TypeError，自定义的异常是写一个类继承自Exception</p><pre><code class="python">#coding:utf-8import tracebackimport timeclass IdontWantWork(Exception):    def __init__(self,err=&#39;&#39;):        Exception.__init__(self,err)def test2():    try:        times = 10        while times &gt; 0:            print times            if times == 5:                raise IdontWantWork(&#39;老子不干了，太累了&#39;)            times -=1            time.sleep(1)    except Exception as e:        print traceback.format_exc()if __name__ == &#39;__main__&#39;:    test2()</code></pre><p>输出如下</p><pre><code>1098765Traceback (most recent call last):  File &quot;/Users/yangyanxing/Desktop/try.py&quot;, line 25, in test2    raise IdontWantWork(&#39;老子不干了，太累了&#39;)IdontWantWork: 老子不干了，太累了</code></pre><p>简单的异常就记录这些，以后再补充。</p><p>参考文章<br><a href="http://blog.csdn.net/flyingshuai/article/details/73482177" target="_blank" rel="noopener">python 自定义异常和异常捕捉</a><br><a href="http://www.cnblogs.com/jessonluo/p/4743574.html" target="_blank" rel="noopener">Python中的异常处理</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用python抓取自住房信息</title>
      <link href="/article/use-python-get-house-info.html"/>
      <url>/article/use-python-get-house-info.html</url>
      <content type="html"><![CDATA[<p>使用python也有一段时间了，最近比较关注自住房信息，虽说它更新的比较缓慢，但是平时也不怎么会特意的去它的网站上去看，<br>于是就想用python抓它的信息，如果有新的信息就给自己发个邮件，这样手机上得到通知以后就可以再去它的网站上看看。<br>功能比较简单，但是用到的点还是挺多的，这里记录一下。<br>主要有以下几个步骤</p><ol><li>python beautifulsoup 与requests的使用</li><li>ubuntu 中安装 mysql 与mysql-python </li><li>beautifulsoup与requests编码的问题</li><li>使用gmail发送邮件，其中gmail采用两步认证要单独申请一个密码</li><li>在ubuntu中使用crontab定时来触发脚本</li></ol><a id="more"></a><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><p>自住房信息的网址为 <a href="http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/tzgg/index.shtml" target="_blank" rel="noopener">http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/tzgg/index.shtml</a><br>主要就是抓取上面的通知，使用数据库或者本地文件记录一下url和标题<br>主要就是以下这块html</p><pre><code class="html">&lt;ul opentype=&quot;page&quot;&gt;  &lt;li&gt;&lt;a href=&quot;/bjjs/fwgl/zzxspzf/tzgg/427793/index.shtml&quot; onclick=&quot;void(0)&quot; target=&quot;_blank&quot; title=&quot;富兴鹏城自住型商品住房递补选房公告&quot;&gt;富兴鹏城自住型商品住房递补选房公告&lt;/a&gt;&lt;span&gt;2017-07-06&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/bjjs/fwgl/zzxspzf/tzgg/425403/index.shtml&quot; onclick=&quot;void(0)&quot; target=&quot;_blank&quot; title=&quot;朝阳区锦都家园自住型商品住房项目申购登记公告&quot;&gt;朝阳区锦都家园自住型商品住房项目申购登记公告&lt;/a&gt;&lt;span&gt;2017-06-12&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/bjjs/fwgl/zzxspzf/tzgg/425259/index.shtml&quot; onclick=&quot;void(0)&quot; target=&quot;_blank&quot; title=&quot;住总万科&amp;middot;TBD万科天地自住型商品住房递补选房公告&quot;&gt;住总万科&amp;middot;TBD万科天地自住型商品住房递补选房公告&lt;/a&gt;&lt;span&gt;2017-06-09&lt;/span&gt;&lt;/li&gt; .... ... .. .&lt;/ul&gt;</code></pre><p>我这里使用的是beautifulsoup来进行解析。<br>beautifulsoup的使用参考 <a href="http://cuiqingcai.com/1319.html" target="_blank" rel="noopener">beautifulsoup使用</a><br>我一开始使用requests库的get方法来抓取网页，后来我被它的编码逼疯了，在网上查了下，requests与beautifulsoup都会对网页的编码进行优化，</p><p><img src="/image/houseluanma.png" alt="乱码"><br>但是它们同时优化就会出现很多头疼的问题，所以最后我使用python的urllib来抓取网页</p><pre><code class="python">url = r&#39;http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/tzgg/index.shtml&#39;s = urllib.urlopen(url)if s.code == 200:    soup = BeautifulSoup(s.read(),&quot;lxml&quot;)</code></pre><h2 id="解析出url-与title信息"><a href="#解析出url-与title信息" class="headerlink" title="解析出url 与title信息"></a>解析出url 与title信息</h2><pre><code class="python">ulcontent = soup.find(&#39;ul&#39;,opentype=&quot;page&quot;)    for i in ulcontent.children:    acontent = i.find(&#39;a&#39;)    if type(acontent)!=int:        title = acontent.get(&#39;title&#39;).encode(&#39;utf-8&#39;)        if acontent.get(&#39;href&#39;).startswith(r&#39;/&#39;):            url = &quot;%s%s&quot;%(r&#39;http://www.bjjs.gov.cn&#39;,acontent.get(&#39;href&#39;))                                else:            url = acontent.get(&#39;href&#39;)</code></pre><p>使用 <code class="text">soup.find(&#39;ul&#39;,opentype=&quot;page&quot;)</code> 来定位到通知的ul dom结构，然后再寻找下面的a结构，美汤的用法还是很牛逼的。</p><h1 id="使用mysql来记录"><a href="#使用mysql来记录" class="headerlink" title="使用mysql来记录"></a>使用mysql来记录</h1><p>得到url与title信息后，就去数据库中查寻一下，我一开始想用mongo，但是由于我的VPS是OpenVZ的，所以安装mongodb以后发现有很多问题，最后索性放弃，改用mysql。<br>ubuntu 上安装mysql还是挺简单的</p><blockquote><p>sudo apt-get install mysql-server mysql-client</p></blockquote><p>安装过程中会设置root密码，安装结束后，我创建了一个库和表</p><pre><code class="html">mysql&gt; CREATE DATABASE houseinfo；mysql&gt; use houseinfo;mysql&gt; create table house ( id int NOT NULL AUTO_INCREMENT PRIMARY KEY, url text NOT NULL, title text NOT NULL) DEFAULT CHARSET=utf8;</code></pre><p>在表中查询url字段是否存在,不存在的话就插入</p><pre><code class="python">def executesql(sql):    dbo  = MySQLdb.connect(&quot;localhost&quot;,&quot;root&quot;,&quot;password&quot;,&quot;houseinfo&quot;)    cursor = dbo.cursor()    data = &#39;&#39;    try:        cursor.execute(sql)        if sql.startswith(&#39;select&#39;):            data = cursor.fetchall()        elif sql.startswith(&#39;insert&#39;):            data = dbo.commit()    except:        print &quot;Error: unable to fecth data&quot;        print traceback.format_exc()        dbo.rollback()    finally:        dbo.close()                return datas = urllib.urlopen(url)if s.code == 200:    soup = BeautifulSoup(s.read(),&quot;lxml&quot;)    ulcontent = soup.find(&#39;ul&#39;,opentype=&quot;page&quot;)        for i in ulcontent.children:        acontent = i.find(&#39;a&#39;)        if type(acontent)!=int:            title = acontent.get(&#39;title&#39;).encode(&#39;utf-8&#39;)            if acontent.get(&#39;href&#39;).startswith(r&#39;/&#39;):                url = &quot;%s%s&quot;%(r&#39;http://www.bjjs.gov.cn&#39;,acontent.get(&#39;href&#39;))                                    else:                url = acontent.get(&#39;href&#39;)            sql = &#39;select * from house where url = &quot;%s&quot;&#39;% url            rst = executesql(sql)            if not rst:                insertsql = &#39;insert into house (url,title) values(&quot;%s&quot;,&quot;%s&quot;)&#39;%(url,title)                executesql(insertsql)</code></pre><h1 id="发送新通知邮件"><a href="#发送新通知邮件" class="headerlink" title="发送新通知邮件"></a>发送新通知邮件</h1><p>当有一个新的通知发出来以后需要发送一封邮件</p><p>因为VPS是在国外，所在我这里使用的是gmail的smtp服务，因为我的google账户采用了两步认证，所以这里还得重新申请一个临时密码，这里不得不提一下google的服务，太人性化了！具体使用请参考 <a href="https://support.google.com/accounts/answer/185833" target="_blank" rel="noopener">https://support.google.com/accounts/answer/185833</a></p><pre><code class="python">HOST = &#39;smtp.gmail.com&#39;PORT = 587mail_username=&#39;yanxingyang@gmail.com&#39;  mail_password=&#39;linshimima&#39;to_addrs=[&#39;yanxingyang@gmail.com&#39;] def sendmail(contents,title):    try:        smtp = smtplib.SMTP()         smtp.set_debuglevel(1)        smtp.connect(HOST,PORT)        smtp.starttls()        smtp.login(mail_username,mail_password)        msg = email.mime.text.MIMEText(contents,&#39;html&#39;)        msg[&#39;From&#39;] = &#39;yanxingyang@gmail.com&#39;        msg[&#39;To&#39;] = &#39;;&#39;.join(to_addrs)          msg[&#39;Subject&#39;]=  &#39;有新的房产信息,请注意查看《%s》&#39;% title           smtp.sendmail(&#39;yanxingyang@gmail.com&#39;,to_addrs,msg.as_string())      except:        print traceback.format_exc()    finally:        smtp.quit()</code></pre><h1 id="设置crontab任务"><a href="#设置crontab任务" class="headerlink" title="设置crontab任务"></a>设置crontab任务</h1><p>在linux的世界里crontab绝对是神一样的存在<br>使用参考 <a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="noopener">crontab使用</a></p><p>我这里设置的是每隔一个小时执行一次</p><pre><code>* */1 * * * python /root/gethouseinfo.py</code></pre><p>最终的效果是我收到了好多邮件。。。<br><img src="/image/houseinfo.png" alt="手机中收到的邮件"></p><p>mac上也可以实时的收到<br><img src="/image/housemac.png" alt="mac上的邮件"></p><p>最张的全代码</p><pre><code class="python">#coding:utf-8import time,os,sys,chardetfrom datetime import datetimeimport requestsfrom bs4 import BeautifulSoupimport jsonimport MySQLdbimport smtplibimport email.mime.textimport tracebackfrom email.utils import parseaddr, formataddrfrom email import encodersfrom email.header import Headerimport urllibHOST = &#39;smtp.gmail.com&#39;PORT = 587mail_username=&#39;yanxingyang@gmail.com&#39;  mail_password=&#39;linshimima&#39; to_addrs=[&#39;yanxingyang@gmail.com&#39;] urls = [r&#39;http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/tzgg/index.shtml&#39;]def sendmail(contents,title):    try:        smtp = smtplib.SMTP()         smtp.set_debuglevel(1)        smtp.connect(HOST,PORT)        smtp.starttls()        smtp.login(mail_username,mail_password)        msg = email.mime.text.MIMEText(contents,&#39;html&#39;)        msg[&#39;From&#39;] = &#39;yanxingyang@gmail.com&#39;        msg[&#39;To&#39;] = &#39;;&#39;.join(to_addrs)          msg[&#39;Subject&#39;]=  &#39;有新的房产信息,请注意查看《%s》&#39;% title           smtp.sendmail(&#39;yanxingyang@gmail.com&#39;,to_addrs,msg.as_string())      except:        print traceback.format_exc()    finally:        smtp.quit()def executesql(sql):    dbo  = MySQLdb.connect(&quot;localhost&quot;,&quot;root&quot;,&quot;password&quot;,&quot;houseinfo&quot;)    cursor = dbo.cursor()    data = &#39;&#39;    try:        cursor.execute(sql)        if sql.startswith(&#39;select&#39;):            data = cursor.fetchall()        elif sql.startswith(&#39;insert&#39;):            data = dbo.commit()    except:        print &quot;Error: unable to fecth data&quot;        print traceback.format_exc()        dbo.rollback()    finally:        dbo.close()                return datadef main():    for url in urls:        # r = requests.get(url)        s = urllib.urlopen(url)        if s.code == 200:            soup = BeautifulSoup(s.read(),&quot;lxml&quot;)            ulcontent = soup.find(&#39;ul&#39;,opentype=&quot;page&quot;)                for i in ulcontent.children:                acontent = i.find(&#39;a&#39;)                if type(acontent)!=int:                    title = acontent.get(&#39;title&#39;).encode(&#39;utf-8&#39;)                    if acontent.get(&#39;href&#39;).startswith(r&#39;/&#39;):                        url = &quot;%s%s&quot;%(r&#39;http://www.bjjs.gov.cn&#39;,acontent.get(&#39;href&#39;))                                            else:                        url = acontent.get(&#39;href&#39;)                    sql = &#39;select * from house where url = &quot;%s&quot;&#39;% url                    rst = executesql(sql)                    if not rst:                        insertsql = &#39;insert into house (url,title) values(&quot;%s&quot;,&quot;%s&quot;)&#39;%(url,title)                        executesql(insertsql)                        contents = &#39;&lt;h1&gt;%s&lt;/h1&gt;&lt;/br&gt;&lt;p&gt;%s&lt;/p&gt;&#39;%(title,url)                        sendmail(contents,title)if __name__ == &#39;__main__&#39;:    main()</code></pre><h1 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h1><p>如果长时间的使用某个IP去抓该网站的信息它如果给封了IP就不行了，而且我也没有设置访问的header，以后可以设置一下代理或者header信息</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用于python的定时任务apscheduler的使用</title>
      <link href="/article/use-apscheduler.html"/>
      <url>/article/use-apscheduler.html</url>
      <content type="html"><![CDATA[<p>最近在项目中有一个比较特殊的需求，要求在每个月第二个周二暂停任务，然后周三再开启<br>于是在网上查了一下，python中有一个apscheduler库可以实现，而且这个框架还挺强大的<br>这里记录一下它的使用</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我一开始在python2.6中安装的，但是安装有错误，估计是支持不好，在python2.7中是可以的</p><blockquote><p>pip install apscheduler -i <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a></p></blockquote><p>安装过程中会额外安装一个pytz的库，是关于timezone的</p><h3 id="基础概念-参考-http-debugo-com-apscheduler"><a href="#基础概念-参考-http-debugo-com-apscheduler" class="headerlink" title="基础概念 参考 http://debugo.com/apscheduler/"></a>基础概念 参考 <a href="http://debugo.com/apscheduler/" target="_blank" rel="noopener">http://debugo.com/apscheduler/</a></h3><blockquote><p>触发器(trigger)包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。除了他们自己初始配置意外，触发器完全是无状态的。<br>作业存储(job store)存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。一个作业的数据讲在保存在持久化作业存储时被序列化，并在加载时被反序列化。调度器不能分享同一个作业存储。<br>执行器(executor)处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。<br>调度器(scheduler)是其他的组成部分。你通常在应用只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。<br>你需要选择合适的调度器，这取决于你的应用环境和你使用APScheduler的目的。通常最常用的两个：<br>– BlockingScheduler: 当调度器是你应用中唯一要运行的东西时使用。<br>– BackgroundScheduler: 当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。</p></blockquote><p>最主要用的就是scheduler与job store</p><h3 id="作业存储"><a href="#作业存储" class="headerlink" title="作业存储"></a>作业存储</h3><p>一般存储分为内存存储和持久化的存储，推荐使用持久化的存储，这样一旦主机挂了或者重启了，这样只要重新运行脚本就可以接着运行了，我这里使用的是mongodb来存储。</p><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>任务的执行调度工作由其来完成，主要用到的有BlockingScheduler（阻塞的），BackgroundScheduler（非阻塞的）</p><p>一个简单的例子，每隔5s钟输出‘hello world’，每天的13点50分输出‘i m blocking task’</p><pre><code class="python">#coding:utf-8from apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.schedulers.blocking import BlockingSchedulerimport timefrom datetime import datetimefrom pymongo import MongoClientmongoDBhost = &#39;vps.yangyanxing.com&#39; #mongodb 服务器mongoDBport = &#39;29017&#39; # 端口号mongoDBuser = &#39;yangyanxing&#39; # 用户名mongoDBpwd = &#39;pwd&#39; # 密码mongoclient = MongoClient(host=[&#39;%s:%s&#39;%(mongoDBhost,mongoDBport)])mongoclient.admin.authenticate(mongoDBuser,mongoDBpwd)dbjob = mongoclient.mac.jobs  # mongodb所用到的collection，这里是BackgroundScheduler的dbjob_b = mongoclient.mac.jobs_block # mongodb所用到的collection，这里是blockingScheduler的job_defaults = {    &#39;coalesce&#39;: False,    &#39;max_instances&#39;: 3,    &#39;misfire_grace_time&#39;: 30}def timetest():    print &#39;hello world&#39;def timetestblock():    print &#39;i m blocking task&#39;if __name__ == &#39;__main__&#39;:    scheduler = BackgroundScheduler(job_defaults=job_defaults)    scheduler_b = BlockingScheduler(job_defaults=job_defaults)    scheduler.add_jobstore(&#39;mongodb&#39;, client=dbjob)    scheduler_b.add_jobstore(&#39;mongodb&#39;, client=dbjob_b)    scheduler.add_job(timetest, &#39;interval&#39;, seconds=5)    scheduler_b.add_job(timetestblock, &#39;cron&#39;, minute=50, hour=13, start_date=datetime.now())    scheduler.start()    scheduler_b.start()</code></pre><p>运行脚本发现报错了。。。</p><blockquote><p>pytz.exceptions.UnknownTimeZoneError: u’Can not find timezone China Standard time’</p></blockquote><p><img src="/image/timezoneerror.png" alt="时区找不着的错误"></p><p>有的环境是不报这个错误的，如果报的话就手动指定一个时区，指定一个pytz库中定义了的时区，可以在site-packages中查看一下，具体原因没有细追。。。</p><pre><code>timez = pytz.timezone(&#39;Asia/Shanghai&#39;)# 初始化scheduler的时候加上timezone参数scheduler = BackgroundScheduler(job_defaults=job_defaults,timezone=timez)scheduler_b = BlockingScheduler(job_defaults=job_defaults,timezone=timez)</code></pre><p>再次运行该脚本，则可以正常运行了，查看mongo数据库<br><img src="/image/mongorecord.png" alt="mongodb中该任务的记录"></p><p>这里也记录着next_run_time</p><p>最终的代码</p><pre><code class="python">#coding:utf-8from apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.schedulers.blocking import BlockingSchedulerimport timefrom datetime import datetimefrom pymongo import MongoClientimport pytz&#39;&#39;&#39;两个问题1. 对于 interval，比如说每5秒钟进行一次的任务，当该脚本被停了，重新运行该脚本的时候，已经过了nexttime了，   程序是怎么操作的2. 报pytz.exceptions.UnknownTimeZoneError: u&#39;Can not find timezone China Standard time&#39; 的问题&#39;&#39;&#39;timez = pytz.timezone(&#39;Asia/Shanghai&#39;)# 当有不识别的timezone的时候，初始化的时候可以加上timezone，最好也要加上，否则时间日期不对应会出问题mongoDBhost = &#39;vps.yangyanxing.com&#39;mongoDBport = &#39;29017&#39;mongoDBuser = &#39;yangyanxing&#39;mongoDBpwd = &#39;pwd&#39;mongoclient = MongoClient(host=[&#39;%s:%s&#39;%(mongoDBhost,mongoDBport)])mongoclient.admin.authenticate(mongoDBuser,mongoDBpwd)dbjob = mongoclient.mac.jobsdbjob_b = mongoclient.mac.jobs_blockjob_defaults = {    &#39;coalesce&#39;: False,    &#39;max_instances&#39;: 3,    &#39;misfire_grace_time&#39;: 30}def timetest():    print time.strftime(&#39;%Y%m%d--%H:%M:%S&#39;,time.localtime(time.time())),&#39;hello world&#39;def timetestblock():    print &#39;i m blocking task&#39;if __name__ == &#39;__main__&#39;:    scheduler = BackgroundScheduler(timezone=timez)    scheduler_b = BlockingScheduler(timezone=timez)    scheduler.add_jobstore(&#39;mongodb&#39;, client=dbjob)    scheduler_b.add_jobstore(&#39;mongodb&#39;, client=dbjob_b)    scheduler.add_job(timetest, &#39;interval&#39;, seconds=5)    scheduler_b.add_job(timetestblock, &#39;cron&#39;, minute=50, hour=13, start_date=datetime.now())    scheduler.start()    scheduler_b.start()</code></pre><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><p>1、运行的时候会有一些误差，由于我这个mongodb在国外的VPS上，所以在操作的时候就有一些延迟，正常如果很快的话误差不会很大<br>2、关于timezone，如果有报错的话则要手工的指定，在中国境内可以定义为’Asia/Shanghai’<br>3、添加作业的时候，类型可以为cron,这个定义和linux中的crontab格式，比较灵活，而且它本身就可以定义第周几进行，第几个星期几等，推荐使用<br>4、添加作业的时候也可以使用装饰器</p><pre><code class="python">@scheduler_b.scheduled_job(&#39;cron&#39;,id=&#39;timetest_b&#39;,minute=50, hour=13)def timetestblock():    print &#39;i m blocking task&#39;</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpy的常规使用与踩过的坑</title>
      <link href="/article/use-webpy.html"/>
      <url>/article/use-webpy.html</url>
      <content type="html"><![CDATA[<p>在使用python做网站的时候首先接触的就是webpy了，这个框架小巧简单，对于小型的网络应用功能足以了，在使用的过程中也遇到过一些总是，在这里也记录总结一下</p><h1 id="基础的框架搭建"><a href="#基础的框架搭建" class="headerlink" title="基础的框架搭建"></a>基础的框架搭建</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>pip install web.py -i https://pypi.douban.com/simple</code></pre><a id="more"></a><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><pre><code class="python">import weburls = (&quot;/.*&quot;, &quot;hello&quot;)app = web.application(urls, globals())class hello:    def GET(self):        return &#39;Hello, world!&#39;if __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>return 可以返回字符串也可以返回字典，不过直接返回字符串不是一个很好的网页习惯，如果是对外提供的api是很好的，但是如果是做的网页，最好还是将数据render（渲染）到模板中</p><h3 id="使用GET或者POST接收数据"><a href="#使用GET或者POST接收数据" class="headerlink" title="使用GET或者POST接收数据"></a>使用GET或者POST接收数据</h3><p><code class="text">web.input()</code> 既可以接收GET的数据，也可以接收POST过来的数据</p><p><code class="text">web.data()</code> 通过这个方法可以取到数据</p><pre><code class="python">import weburls = (&quot;/.*&quot;, &quot;hello&quot;)app = web.application(urls, globals())class hello:    def GET(self):        return &#39;Hello, world!&#39;    def POST(self):        username = web.input().get(&#39;username&#39;,&#39;&#39;)if __name__ == &quot;__main__&quot;:    app.run()</code></pre><h3 id="模板的定义使用"><a href="#模板的定义使用" class="headerlink" title="模板的定义使用"></a>模板的定义使用</h3><pre><code class="python">import weburls = (&quot;/.*&quot;, &quot;hello&quot;)app = web.application(urls, globals())class hello:    def GET(self):        return &#39;Hello, world!&#39;app_root = os.path.dirname(__file__) #定义根路径templates_root = os.path.join(app_root, &#39;templates&#39;) #定义模板所在的路径render = web.template.render(templates_root)if __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>使用的时候用return render<br>如： return rende.index() 则需要在templates目录下创建一个index.html 这样访问</p><h3 id="模板中使用渲染的数据"><a href="#模板中使用渲染的数据" class="headerlink" title="模板中使用渲染的数据"></a>模板中使用渲染的数据</h3><p>当有以下代码的时候</p><pre><code class="python">name = &#39;yangyanxing&#39;return render.index(name)</code></pre><p>此时可以在index.html中使用渲染过来的name值</p><pre><code class="html">$def with(name_t)&lt;html&gt;  &lt;body&gt;  hello $name_t  &lt;/body&gt;&lt;/html&gt;</code></pre><p>$def with 必须写在首行，with里面有多少个参数，那个在之前的py文件中就需要render多少个参数，多了少了都不行，with里可以使用默认参数，这个和一般的函数定义是一样的。</p><h1 id="中级使用"><a href="#中级使用" class="headerlink" title="中级使用"></a>中级使用</h1><h3 id="session的使用"><a href="#session的使用" class="headerlink" title="session的使用"></a>session的使用</h3><ul><li>session 可以使用文件的形式也可以存储在数据库中</li></ul><pre><code class="python">import weburls = (&quot;/.*&quot;, &quot;hello&quot;)app = web.application(urls, globals())store = web.session.DiskStore(&#39;sessions&#39;) #定义session使用文件存储方式#定义session格式，使用本地存储，还可以使用数据库存储方式if web.config.get(&#39;_session&#39;) is None:    session = web.session.Session(app, store,)    web.config._session = sessionelse:    session = web.config._sessionclass hello:    def GET(self):        return &#39;Hello, world!&#39;app_root = os.path.dirname(__file__) #定义根路径templates_root = os.path.join(app_root, &#39;templates&#39;) #定义模板所在的路径render = web.template.render(templates_root,globals={&#39;session&#39;: session}) #将session应用到模板中if __name__ == &quot;__main__&quot;:    app.run()</code></pre><ul><li>session的赋值</li></ul><pre><code class="python">username = &#39;yangyanxing&#39;session.realname = username</code></pre><ul><li><p>session的读取</p><blockquote><p>print session.realname</p></blockquote></li><li><p>session在模板中的使用<br>``` html<br>$def with (something)</p></li></ul><p>$session.realname</p><pre><code>上面在定义&gt; render = web.template.render(templates_root,globals={&#39;session&#39;: session})时`globals={&#39;session&#39;: session}` 这里如果定义成`globals={&#39;session_t&#39;: session}` 那么在模板中使用session中也要使用`$session_t### 模板布局的使用有时候对于一个小型网站，它的header与footer是一样的，只是中间的内容不一样，那么可以定义一个模板，base.html包括了header与footer，其它模板在定义的时候只要引用这个模板就行了，这样做的好处也在于当修改base.html，不用修改每一个模板。首先定义一个基础的模板，我这里就叫做base.html``` html$def with (content)&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta name=”renderer” content=”webkit” /&gt;&lt;title&gt;欢迎来到我们的世界&lt;/title&gt;&lt;/head&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;header&quot;&gt;        something here    &lt;/div&gt;    &lt;div class=&quot;container&quot;&gt;        $:content        &lt;footer&gt;            &lt;p&gt;&amp;copy; yangyanxing.com 2016&lt;/p&gt;        &lt;/footer&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里有两个要点 <code class="text">$def with (content)</code> 这里的content可以随意写，而下面的<code class="text">$:content</code> 则是别的模板文件内容，可以这样理解，当你再使用<code class="text">return render.index(name)</code> 时，其实它是将index.html里的内容当成这里的<code class="text">content</code> 这样也就实现了一个基础的模板，只更新里面的内容的效果。</p><p>定义完基础模板还不行，如果要使其生效还得在py文件中修改以下定义render的代码<br><code class="text">render = web.template.render(templates_root,globals={&#39;session&#39;: session},base=&#39;base&#39;)</code><br>这样定义render才能将base.html设置为基础模板</p><p>此时如果index.html中是以下的样子</p><pre><code class="html">$def with (name)hello $name</code></pre><p>那么当你有以下代码的时候</p><pre><code class="python">myname = &#39;yangyanxing&#39;return render.index(myname)</code></pre><p>那么最终生成的html应该是</p><pre><code class="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta name=”renderer” content=”webkit” /&gt;&lt;title&gt;欢迎来到我们的世界&lt;/title&gt;&lt;/head&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;header&quot;&gt;        something here    &lt;/div&gt;    &lt;div class=&quot;container&quot;&gt;        hello yangyanxing        &lt;footer&gt;            &lt;p&gt;&amp;copy; yangyanxing.com 2016&lt;/p&gt;        &lt;/footer&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="高级使用-踩过的坑"><a href="#高级使用-踩过的坑" class="headerlink" title="高级使用(踩过的坑)"></a>高级使用(踩过的坑)</h1><h3 id="checkbox传过来多个值的时候数据的处理"><a href="#checkbox传过来多个值的时候数据的处理" class="headerlink" title="checkbox传过来多个值的时候数据的处理"></a>checkbox传过来多个值的时候数据的处理</h3><p>有这种情况，有一个表单它的name值下面是checkbox，如以下的html</p><pre><code class="html">&lt;form action=&#39;/groupaddcase&#39; method=&#39;POST&#39;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;caseids&quot;  value=&quot;1&quot; checked=&quot;true&quot;&gt;1&lt;input type=&quot;checkbox&quot; name=&quot;caseids&quot;  value=&quot;2&quot; &gt;2&lt;input type=&quot;checkbox&quot; name=&quot;caseids&quot;  value=&quot;3&quot; &gt;3&lt;input type=&quot;checkbox&quot; name=&quot;caseids&quot;  value=&quot;4&quot; &gt;4&lt;input type=&quot;checkbox&quot; name=&quot;caseids&quot;  value=&quot;5&quot; &gt;5&lt;input class=&quot;btn btn-success&quot; type=&quot;submit&quot; value=&quot;修改&quot;&gt;&lt;/form&gt;</code></pre><p>此时如果在py中处理如下</p><pre><code class="python">class Groupaddcase:    def POST(self):        caseids = web.input().get(&#39;caseids&#39;)        print caseids</code></pre><p>这样处理的话那么传过来的caseids只有一个，当你勾选了多个checkbox时也只有一个数据传过来，解决的办法是在接收的时候将其定义成数组</p><pre><code class="python">class Groupaddcase:    def POST(self):        groupinfo  =  web.input(caseids=[])        groupid = groupinfo.get(&#39;groupid&#39;,&#39;&#39;)</code></pre><p>这样groupid就以数组的形式保存了传过来的checkbox的值,多个checkbox可以定义多个数组<br><code class="text">groupinfo  =  web.input(caseids=[],casenames=[])</code></p><h3 id="添加一个hook来处理在所有请求前做的处理"><a href="#添加一个hook来处理在所有请求前做的处理" class="headerlink" title="添加一个hook来处理在所有请求前做的处理"></a>添加一个hook来处理在所有请求前做的处理</h3><p>有时会有这样的需求，需要屏蔽某一个IP的客户端访问或者在访问前需要检查一下是否登录了，这种情况下可以使用hook方法来控制</p><pre><code class="python">def __redirect():    rejectIP = [&#39;192.168.0.101&#39;]    if web.ctx.ip in rejectIP:        raise web.seeother(r&#39;http://so.com&#39;)if __name__ == &quot;__main__&quot;:    app.add_processor(web.loadhook(__redirect))    app.run()</code></pre><h3 id="模板中使用python的逻辑处理方法"><a href="#模板中使用python的逻辑处理方法" class="headerlink" title="模板中使用python的逻辑处理方法"></a>模板中使用python的逻辑处理方法</h3><ul><li>判断<pre><code class="python">$if condition:  &lt;td&gt;yes&lt;/td&gt;$else:  &lt;td&gt;no&lt;/td&gt;</code></pre></li><li>循环<pre><code class="python">$for item in some_array:  &lt;td&gt;$item[&#39;title&#39;]&lt;/td&gt;</code></pre></li></ul><p>判断和循环的使用都要在前面加一个$,以<code class="text">:</code> 结尾，且下面的语句也要遵守缩进规则</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> webpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在MAC下加载NTFS移动硬盘或者U盘</title>
      <link href="/article/use-mac-mount-ntfs-disk.html"/>
      <url>/article/use-mac-mount-ntfs-disk.html</url>
      <content type="html"><![CDATA[<p>在windows下使用的移动硬盘或者U盘大部分都是ntfs格式，在MAC下默认是不支持的，将一块硬盘分两个区一个给windows用一个给MAC用也不大方便，可以借用第三方软件来支持，其实仔细想想这样的功能苹果公司在技术上肯定是可以支持的，只是由于种种原因微软不让其默认支持，以下的方法不借用任何第三方软件，几条命令搞定在MAC下挂载nfts硬盘。<br><a id="more"></a></p><ol><li>打开终端查看磁盘的Volume Name</li></ol><p>插件移动硬盘或者U盘，打开终端，输入<code class="text">diskutil list</code> 命令来查看磁盘信息<br><img src="http://ww3.sinaimg.cn/large/795ab47fgw1f5r3wnz6h8j20pm0i3wjm.jpg" alt="disk-info"></p><p>上面的是本机的磁盘，下面那个disk2是U盘，可以看到type是windows_NTFS,NAME是<code class="text">奔波霸</code><br>记住这个<code class="text">奔波霸</code></p><ol><li>sudo打开/etc/fstab</li></ol><p><code class="text">sudo vim /etc/fstab</code></p><p>有的系统可能没有这个文件，那么就新建一个<br>输入<code class="text">LABEL=奔波霸 none ntfs rw,auto,nobrowse</code><br>LABEL为刚才记录的值，这里也可以是中文(有时中文会有问题，最好还是将磁盘设置为英文的)，如果有空格的话使用<code class="text">\040</code>代替<br><img src="http://ww1.sinaimg.cn/large/795ab47fgw1f5r4p8i7d0j20pm0iq40b.jpg" alt=""></p><p>后面的ntfs rw表示把这个分区挂载为可读写的ntfs格式，最后nobrowse非常重要，因为这个代表了在finder里不显示这个分区，这个选项非常重要，如果不打开的话挂载是不会成功的。编辑好以后重新插入磁盘，就能识别到了。</p><ol><li>建立一个软链接到Volumes文件夹下<blockquote><p>sudo ln -s /Volumes ~/Desktop/Volumes</p></blockquote></li></ol><p>这样就在桌面上创建了一个指向/Volumes的链接，以后接上磁盘的时候就可以方便的从桌面上进入磁盘了。</p><p>参考文章：<a href="http://www.tianwaihome.com/2014/07/mac-osx-ntfs.html" target="_blank" rel="noopener">http://www.tianwaihome.com/2014/07/mac-osx-ntfs.html</a></p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Xposed框架初体验</title>
      <link href="/article/first-use-Xposed.html"/>
      <url>/article/first-use-Xposed.html</url>
      <content type="html"><![CDATA[<p>想必很多人都听说过微信抢红包插件，但是很少有人想过它是怎么实现的，以前我以为是可能通过监听某个消息广播或者什么的，但是前几天在testerhome中看到有一篇介绍Xposed框架的文章<a href="https://testerhome.com/topics/3819" target="_blank" rel="noopener">用黑客思维做测试——神器 Xposed 框架介绍</a>,我觉得这应该是广大抢红包插件的实现。正好有个同事和我说过有一个微信计步的作弊器(汗，怎么这个东西净用在这方面呢)<a href="http://drops.wooyun.org/tips/8416" target="_blank" rel="noopener">手把手教你当微信运动第一名</a>,于是对这个大名鼎鼎的Xposed学习了一番，觉得它有很多潜能！<br><a id="more"></a></p><p>参考文章<br><a href="https://testerhome.com/topics/3819" target="_blank" rel="noopener">用黑客思维做测试——神器 Xposed 框架介绍</a><br><a href="http://www.csdn.net/article/2015-08-14/2825462" target="_blank" rel="noopener">Android Hook神器：XPosed入门与登陆劫持演示</a><br><a href="http://repo.xposed.info/" target="_blank" rel="noopener">Xposed Home</a></p><h1 id="关于Xposed"><a href="#关于Xposed" class="headerlink" title="关于Xposed"></a>关于Xposed</h1><p>Xposed 框架是一款可以在不修改APK的情况下影响程序运行（修改系统）的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>Zygote 进程是 Android 的核心，所有的应用程序进程以及系统服务进程都是由Zygote进程 fork 出来的。Xposed Framework 深入到了 Android 核心机制中，通过改造 Zygote 来实现一些很牛逼的功能。Zygote 的启动配置在/init.rc 脚本中，由系统启动的时候开启此进程，对应的执行文件是/system/bin/app_process，这个文件完成类库加载及一些初始化函数调用的工作。 当系统中安装了 Xposed Framework 之后，会拿自己实现的 app_process 覆盖掉 Android 原生提供的文件，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在android5.0以上要使用不同的包，具体可以参考<a href="http://repo.xposed.info/module/de.robv.android.xposed.installer" target="_blank" rel="noopener">http://repo.xposed.info/module/de.robv.android.xposed.installer</a><br>为了方便我使用了一台android4.4的手机，只要安装一个apk即可，手机要有root，因为安装Xposed的时候需要root，但是一旦安装成功则不再需要root了，安装后启动<br><img src="/image/xposed.jpg" alt="Xposed"></p><p>按照上面的说明点击安装，如果顺利的话重启后就可以正常的使用了<br><img src="/image/XposedSuc.png" alt="Xposed安装成功"></p><h1 id="写hook模块使用"><a href="#写hook模块使用" class="headerlink" title="写hook模块使用"></a>写hook模块使用</h1><p>Xposed网站已经有很多别人写好的模块，可以直接下载安装使用，也可以自已写模块，模块其实就是一个apk，按照一定的规则生成的，当安装模块以后，Xposed会自已识别。<br>开始自已写一个小demo吧，采用testerhome中的那个hook取时间的例子。</p><h2 id="首先先写测试的apk"><a href="#首先先写测试的apk" class="headerlink" title="首先先写测试的apk"></a>首先先写测试的apk</h2><pre><code class="java">package com.example.showtimer;import java.util.Calendar;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.view.Window;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        requestWindowFeature(Window.FEATURE_NO_TITLE);        setContentView(R.layout.activity_main);        final TextView tv = (TextView) findViewById(R.id.tv);        Button show = (Button) findViewById(R.id.showTimer);        show.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                Calendar c = Calendar.getInstance();                int year = c.get(Calendar.YEAR);                int month = c.get(Calendar.MONTH);                int day = c.get(Calendar.DAY_OF_MONTH);                int hour = c.get(Calendar.HOUR);                int min = c.get(Calendar.MINUTE);                String time = &quot;&quot;+year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+min;                tv.setText(time);            }        });}</code></pre><p>这个apk很简单，点击按钮后，显示了当前的时间</p><p><img src="/image/showTime.png" alt="显示当前时间"></p><h2 id="写hook模块"><a href="#写hook模块" class="headerlink" title="写hook模块"></a>写hook模块</h2><p>只要修改系统的java.util.Calendar类中的get函数，并修改相应的返回值则能达到hook目的</p><h3 id="新建一个hookTest的android项目并将XposedBridgeApi-54-jar加入项目的build-path中"><a href="#新建一个hookTest的android项目并将XposedBridgeApi-54-jar加入项目的build-path中" class="headerlink" title="新建一个hookTest的android项目并将XposedBridgeApi-54.jar加入项目的build-path中"></a>新建一个hookTest的android项目并将XposedBridgeApi-54.jar加入项目的build-path中</h3><p>api下载地址 <a href="http://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067" target="_blank" rel="noopener">http://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067</a><br>在项目中新建一个lib目录，将jar包放进去，添加到build paht中<br><img src="/image/xposedapi.png" alt="将xposed加入到build path中"></p><h3 id="新建一个Hook类实现IXposedHookLoadPackage接口"><a href="#新建一个Hook类实现IXposedHookLoadPackage接口" class="headerlink" title="新建一个Hook类实现IXposedHookLoadPackage接口"></a>新建一个Hook类实现IXposedHookLoadPackage接口</h3><p>实现handleLoadPackage方法</p><pre><code class="java">public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {        if (!lpparam.packageName.equals(&quot;com.example.showtimer&quot;))              return;          XposedBridge.log(&quot;Loaded app name   : &quot; + lpparam.packageName);    }</code></pre><p>上面的代码定义了只有packageName是com.example.showtimer才进行hook操作，其它的放过</p><p><code class="text">findAndHookMethod()</code> 方法是找到并且Hook方法<br>findAndHookMethod的参数说明<br>第一个参数定义了要hook的类，对于某个akp来说就是其包名+activity，第二个参数是个固定的lpparam.classLoader，第三个是要hook的方法名，之后的参数是这个方法需要的参数类型class，有几个就写几个，最后是初始化一个XC_MethodHook的对象。然后重写其beforeHookedMethod与afterHookedMethod方法。</p><pre><code class="java">findAndHookMethod(&quot;java.util.Calendar&quot;, lpparam.classLoader,&quot;get&quot;,int.class,new XC_MethodHook() {            @Override            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                // this will be called before the clock was updated by the original method                XposedBridge.log(&quot;Enter-&gt;beforeHookedMethod:Calendar.get&quot;);            }            @Override            protected void afterHookedMethod(MethodHookParam param) throws Throwable {                // this will be called after the clock was updated by the original method                XposedBridge.log(&quot;Enter-&gt;afterHookedMethod:Calendar.get&quot;);                param.setResult((int)11);            }        });</code></pre><p>在findAndHookMethod中重写了两个方法，beforeHookedMethod和afterHookedMethod，看名字也能猜出它们的作用，before是在hook之前，可以得到一些正常的值，after那个函数则可以修改一些返回值。上面这里就是将java.util.Calendar这个类的get方法所有返回值都修改为11</p><p>Hook.java的总代码为</p><pre><code class="java">package com.example.xposedtest;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;import java.util.ArrayList;import java.util.List;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import android.widget.Toast; public class Hook implements IXposedHookLoadPackage {    @Override    public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {        if (!lpparam.packageName.equals(&quot;com.example.showtimer&quot;))              return;          XposedBridge.log(&quot;Loaded app name   : &quot; + lpparam.packageName);        findAndHookMethod(&quot;java.util.Calendar&quot;, lpparam.classLoader,&quot;get&quot;,int.class,new XC_MethodHook() {            @Override            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                // this will be called before the clock was updated by the original method                XposedBridge.log(&quot;Enter-&gt;beforeHookedMethod:Calendar.get&quot;);            }            @Override            protected void afterHookedMethod(MethodHookParam param) throws Throwable {                // this will be called after the clock was updated by the original method                XposedBridge.log(&quot;Enter-&gt;afterHookedMethod:Calendar.get&quot;);                param.setResult((int)11);            }        });    }}</code></pre><h3 id="声明主入口路径"><a href="#声明主入口路径" class="headerlink" title="声明主入口路径"></a>声明主入口路径</h3><p>需要在assets文件夹中新建一个xposed_init的文件，并在其中声明主入口类。如这里我们的主入口类为com.example.xposedtest.Hook</p><h3 id="在AndroidManifest-xml文件中配置插件名称与Api版本号"><a href="#在AndroidManifest-xml文件中配置插件名称与Api版本号" class="headerlink" title="在AndroidManifest.xml文件中配置插件名称与Api版本号"></a>在AndroidManifest.xml文件中配置插件名称与Api版本号</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.example.xposedtest&quot;    android:versionCode=&quot;1&quot;    android:versionName=&quot;4.0&quot; &gt;    &lt;uses-sdk        android:minSdkVersion=&quot;17&quot;        android:targetSdkVersion=&quot;21&quot; /&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@drawable/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:theme=&quot;@style/AppTheme&quot; &gt;        &lt;meta-data              android:name=&quot;xposedmodule&quot;              android:value=&quot;true&quot; /&gt;          &lt;meta-data              android:name=&quot;xposeddescription&quot;              android:value=&quot;劫持获得时间函数&quot; /&gt;        &lt;meta-data              android:name=&quot;xposedminversion&quot;              android:value=&quot;30&quot; /&gt;          &lt;activity            android:name=&quot;.MainActivity&quot;            android:label=&quot;@string/app_name&quot; &gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="编译并安全这个apk"><a href="#编译并安全这个apk" class="headerlink" title="编译并安全这个apk"></a>编译并安全这个apk</h3><p>Xposed会自已识别，打开Xposed的”模块”，启用刚才安装的模块<br><img src="/image/xposedmodule.png" alt="安装好的模块"></p><h3 id="再打开之前写的showTime应用，点击按钮看看"><a href="#再打开之前写的showTime应用，点击按钮看看" class="headerlink" title="再打开之前写的showTime应用，点击按钮看看"></a>再打开之前写的showTime应用，点击按钮看看</h3><p><img src="/image/errorTime.png" alt="被hook后的时间"></p><p>使用XposedBridge.log() 记录的log可以在Xposed的日志里看到</p><h1 id="Hook自定义的函数"><a href="#Hook自定义的函数" class="headerlink" title="Hook自定义的函数"></a>Hook自定义的函数</h1><p>刚才hook的是系统的函数，下面写一个hook自定义的函数<br>还是在刚才showTime的项目中再加一个用户登录的模拟操作</p><pre><code class="java">package com.example.showtimer;import java.util.Calendar;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.view.Window;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        requestWindowFeature(Window.FEATURE_NO_TITLE);        setContentView(R.layout.activity_main);        final EditText usename = (EditText) findViewById(R.id.username);        final EditText password = (EditText) findViewById(R.id.password);        Button login = (Button) findViewById(R.id.button1);        final TextView tv = (TextView) findViewById(R.id.tv);        Button show = (Button) findViewById(R.id.showTimer);        show.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                Calendar c = Calendar.getInstance();                int year = c.get(Calendar.YEAR);                int month = c.get(Calendar.MONTH);                int day = c.get(Calendar.DAY_OF_MONTH);                int hour = c.get(Calendar.HOUR);                int min = c.get(Calendar.MINUTE);                String time = &quot;&quot;+year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+min;                tv.setText(time);            }        });        login.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                String user = usename.getText()+&quot;&quot;;                String pass = password.getText()+&quot;&quot;;                if (validate(user,pass)) {                    Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_LONG).show();                }else{                    Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_LONG).show();                }                           }        });    }    private boolean validate(String user, String pass) {            if (user.equals(&quot;yang&quot;)&amp;&amp;pass.equals(&quot;123&quot;)) {                return true;            }            return false;    }}</code></pre><p>这里自定义了一个validate方法，校验user为”yang”且pass为123则返回真，Toast显示登录成功<br>其它的都返回假。</p><p>接着再刚才的Hook类中写hook方法</p><pre><code class="java">package com.example.xposedtest;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;import java.util.ArrayList;import java.util.List;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import android.widget.Toast; public class Hook implements IXposedHookLoadPackage {    @Override    public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {        if (!lpparam.packageName.equals(&quot;com.example.showtimer&quot;))              return;          XposedBridge.log(&quot;Loaded app name   : &quot; + lpparam.packageName);        XposedBridge.log(&quot;Loaded app process: &quot; + lpparam.processName);        XposedBridge.log(&quot;Loaded app appInfo: &quot; + lpparam.appInfo);        findAndHookMethod(&quot;java.util.Calendar&quot;, lpparam.classLoader,&quot;get&quot;,int.class,new XC_MethodHook() {            @Override            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                // this will be called before the clock was updated by the original method                XposedBridge.log(&quot;Enter-&gt;beforeHookedMethod:Calendar.get&quot;);            }            @Override            protected void afterHookedMethod(MethodHookParam param) throws Throwable {                // this will be called after the clock was updated by the original method                XposedBridge.log(&quot;Enter-&gt;afterHookedMethod:Calendar.get&quot;);                param.setResult((int)11);            }        });        findAndHookMethod(&quot;com.example.showtimer.MainActivity&quot;, lpparam.classLoader, &quot;validate&quot;, String.class,String.class,new XC_MethodHook(){            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                XposedBridge.log(&quot;Enter-&gt;beforeHookedMethod:validate&quot;);                XposedBridge.log(&quot;afterHookedMethod userName:&quot; + param.args[0]);                   //传入参数2                   XposedBridge.log(&quot;afterHookedMethod pass:&quot; + param.args[1]);                  //函数返回值                  XposedBridge.log(&quot;afterHookedMethod result:&quot; + param.getResult());            }            protected void afterHookedMethod(MethodHookParam param) throws Throwable {                // this will be called after the clock was updated by the original method                XposedBridge.log(&quot;Enter-&gt;afterHookedMethod:validate&quot;);                param.setResult(true);                XposedBridge.log(&quot;afterHookedMethod userName:&quot; + param.args[0]);                   //传入参数2                   XposedBridge.log(&quot;afterHookedMethod pass:&quot; + param.args[1]);                  //函数返回值                  XposedBridge.log(&quot;afterHookedMethod result:&quot; + param.getResult());              }        });}</code></pre><p>在afterHookedMethod方法中将param.setResult(true);则无论输入什么或者不输入都会返回真，这样无论如何都能显示一个Toast登录成功。</p><p><img src="/image/loginSuc.png" alt="登录成功"></p><p>后记：<br>如果测试的apk用了混淆，则hook的时候也要修改相应的函数为混淆后的函数。<br>Xposed这个工具可以做很多事情，在测试行业里可以用于构造一些很不好模拟的环境，另外各种插件也能玩的很6。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用wireshark抓取解密https包</title>
      <link href="/article/use-wireshark-capture-https.html"/>
      <url>/article/use-wireshark-capture-https.html</url>
      <content type="html"><![CDATA[<p>今天在看https的相关技术，于是想要使用wireshark抓取并解密https流量<br>关于https的基础可以看看这篇文章<br><a href="http://www.yangyanxing.com/article/https-basic.html">HTTPS理论基础</a></p><p>本文参考文章<br><a href="https://imququ.com/post/http2-traffic-in-wireshark.html" target="_blank" rel="noopener">使用 Wireshark 调试 HTTP/2 流量</a><br><a id="more"></a></p><p>当系统环境变量中存在<code class="text">SSLKEYLOGFILE</code>这个变量的时候，chrome与firefox在访问https网站的时候会将密钥写入这个环境变量中，如果在wireshark中设置一下，这样就可以解析https的流量了。</p><ol><li>设置环境变量，添加SSLKEYLOGFILE变量，不同的系统不一样</li><li>在wireshark中设置，打开wireshark,点击编辑-&gt;首选项，切换到PRotocols，选择SSL，在(Pre)-Master-Secret log filename那选择刚刚SSLKEYLOGFILE的值<br><img src="/image/Setting-wireshark-protols.png" alt="wireshark设置"></li><li>开始抓包吧<br><img src="/image/alipayhttps.png" alt="抓到的访问alipay的流量"></li></ol><p>可以看到，wireshark已经将http/2转成了http，并且在下面显示了相应的Decrypted SSL data的tab，我随便输入了用户名与密码，已经可以在wireshark上显示了</p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在wireshark上显示host</title>
      <link href="/article/display-host-clumn-in-wireshark.html"/>
      <url>/article/display-host-clumn-in-wireshark.html</url>
      <content type="html"><![CDATA[<p>wireshark默认不显示目标的host，只显示IP，有时对于查看非常不直观。<br>可以自定义显示一些列<br><img src="/image/wireshark.jpg" alt="wireshark"></p><p>点击”编辑”–&gt;”首选项”<br><img src="/image/wiresharkOption.png" alt="首选项"></p><p>点击下面的”+”，添加一个列，类型选择Custom,字段那填写http.host,字段发生那填写0,点击OK，界面上就会显示host字段了<br><img src="/image/showhost.png" alt="显示host"></p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTPS理论基础</title>
      <link href="/article/https-basic.html"/>
      <url>/article/https-basic.html</url>
      <content type="html"><![CDATA[<p>在网上看了好多https的相关文章，但一般都是千篇一律，越看越糊涂<br>今天在网上看了一篇文章，觉得还不错，讲的还比较清晰，看完以后对于https有了相对深入的理解<br><a href="http://blog.csdn.net/iispring/article/details/51615631" target="_blank" rel="noopener">HTTPS理论基础及其在Android中的最佳实践</a><br>以下是我读后的一些理解<br><a id="more"></a></p><p><img src="/image/https.jpg" alt="https"></p><h1 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。<br>其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文<br>解密过程如下：密文 + 解密算法 + 私钥 =&gt; 明文<br>对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。<br>其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难 </p><p>以下是参考网上的java实现DES加密与解密的demo<br><a href="http://blog.csdn.net/techzero/article/details/17282637" target="_blank" rel="noopener">Java DES 加密 解密 示例</a></p><pre><code class="java">package desTest;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;public class DESTest {    /**     * @param args     */    public static void main(String[] args) {        String content = &quot;杨彦星&quot;;        String password = &quot;123456789&quot;;//不明白原文为啥说密码必须是8的位数。。。        System.out.println(&quot;密　钥：&quot; + password);        System.out.println(&quot;加密前：&quot; + content);        byte[] result = encrypt(content, password);        System.out.println(&quot;加密后：&quot; + new String(result));        String decryResult = decrypt(result, password);        System.out.println(&quot;解密后：&quot; + decryResult);    }    /**     * 加密     *      * @param content     *            待加密内容     * @param key     *            加密的密钥     * @return     */    public static byte[] encrypt(String content, String key) {        try {            SecureRandom random = new SecureRandom();            DESKeySpec desKey = new DESKeySpec(key.getBytes());            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);            SecretKey securekey = keyFactory.generateSecret(desKey);            Cipher cipher = Cipher.getInstance(&quot;DES&quot;);            cipher.init(Cipher.ENCRYPT_MODE, securekey, random);            byte[] result = cipher.doFinal(content.getBytes());            return result;        } catch (Throwable e) {            e.printStackTrace();        }        return null;    }    /**     * 解密     *      * @param content     *            待解密内容     * @param key     *            解密的密钥     * @return     */    public static String decrypt(byte[] content, String key) {        try {            SecureRandom random = new SecureRandom();            DESKeySpec desKey = new DESKeySpec(key.getBytes());            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);            SecretKey securekey = keyFactory.generateSecret(desKey);            Cipher cipher = Cipher.getInstance(&quot;DES&quot;);            cipher.init(Cipher.DECRYPT_MODE, securekey, random);            byte[] result = cipher.doFinal(content);            return new String(result);        } catch (Throwable e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>可见其实这里的私钥其实就是一个字符串，如果知道了这个私钥，同时也知道了加密算法是DES，那么就可以轻松的解密加密数据了。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。<br>被公钥加密过的密文只能被私钥解密，过程如下：<br>明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文<br>被私钥加密过的密文只能被公钥解密，过程如下：<br>明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文<br>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。<br>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><h1 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h1><p>HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。<br>HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</p><p>https传输过程，为了效率数据采用对称加密，但是对称加密所采用的私钥为了安全采用非对称加密<br><img src="http://img.blog.csdn.net/20160608220337692" alt="https传输过程"></p><p>整个过程中会涉及到三个密钥</p><ul><li>服务器端的公钥与私钥，用来进行非对称加密</li><li>客户端生成的随机密钥，用来对数据进行对称加密</li></ul><ol><li>客户端发起https请求，用户输入一个https网址以后，访问服务器的443端口</li><li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li><li>传送证书，也就是公钥，服务端将公钥传给客户端。</li><li>客户端解析证书，客户端收到服务器发过来的公钥以后先要对其有效性进行校验，如果公钥有问题则无法进行https传输，这个公钥也就是服务器发过来的数字证书。如果没有问题，则会生成一个随机值，这个随机值就是对于对称加密的密钥。然后用服务端发过来的公钥对这个随机值(也就是客户端私钥)进行非对称加密，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ol><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>在整个https的传输过程中，当服务器发送自已的公钥时，会有黑客进行篡改，那个客户端怎么信赖这个公钥呢？这里就用到了了数字证书。<br>数字证书可以很方便的生成，黑客也可以很方便的生成，但是一个客户端凭什么就相信你的数字证书呢？这里就有数字认证中心CA 专门对公钥进行认证，全球知名的CA也就100多个，客户端默认只信任这100多个CA颁发的证书，客户端也可以自已添加信任的证书。<br>但是很有可能你网站的数字证书不是这100家CA颁发的，而是其下属的认证中心，好比说，我相信了A,A又相信了B，B又相信了C，那么我也就相信了C。那CA怎么对公钥做担保认证呢？CA本身也有一对公钥和私钥，CA会用CA自己的私钥对要进行认证的公钥进行非对称加密，此处待认证的公钥就相当于是明文，加密完之后，得到的密文再加上证书的过期时间、颁发给、颁发者等信息，就组成了数字证书。</p><p>当客户端接收到服务器的数字证书的时候，会进行如下验证：</p><ol><li><p>首先客户端会用设备中内置的CA的公钥尝试解密数字证书，如果所有内置的CA的公钥都无法解密该数字证书，说明该数字证书不是由一个全球知名的CA签发的，这样客户端就无法信任该服务器的数字证书。</p></li><li><p>如果有一个CA的公钥能够成功解密该数字证书，说明该数字证书就是由该CA的私钥签发的，因为被私钥加密的密文只能被与其成对的公钥解密。</p></li><li><p>除此之外，还需要检查客户端当前访问的服务器的域名是与数字证书中提供的“颁发给”这一项吻合，还要检查数字证书是否过期等。</p></li></ol><h1 id="12306网站的数字证书问题"><a href="#12306网站的数字证书问题" class="headerlink" title="12306网站的数字证书问题"></a>12306网站的数字证书问题</h1><p>当用户访问 <a href="https://kyfw.12306.cn/otn/regist/init" target="_blank" rel="noopener">https://kyfw.12306.cn/otn/regist/init</a> 如果没有导入其根证书的话那个浏览器上会显示一个不安全的提示<br><img src="/image/12306notsafe.png" alt="12306不安全"></p><p>为什么会这样呢？<br>看一下12306的证书信息<br><img src="http://img.blog.csdn.net/20160608223638227" alt=""></p><p>可以看到，该12306.cn的证书是由SRCA这个机构签发的，也就是说SRCA是证书链上的根CA。<br>但是SRCA是啥呢？没听过啊！因为其不在默认的100多个CA里，所以这里安全校验不通过，浏览器认为它是不安全的<br>解决办法12306的网站上也说明了，要导入它的根证书<br><img src="/image/import12306.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(转)Android Context完全解析，你所不知道的Context的各种细节</title>
      <link href="/article/learning-context.html"/>
      <url>/article/learning-context.html</url>
      <content type="html"><![CDATA[<p>以下转自郭霖大神的博客</p><p>转载请注明出处：<a href="http://blog.csdn.net/guolin_blog/article/details/47028975" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/47028975</a><br>前几篇文章，我也是费劲心思写了一个ListView系列的三部曲，虽然在内容上可以说是绝对的精华，但是很多朋友都表示看不懂。好吧，这个系列不仅是把大家给难倒了，也确实是把我给难倒了，之前为了写瀑布流ListView的Demo就写了大半个月的时间。那么本篇文章我们就讲点轻松的东西，不去分析那么复杂的源码了，而是来谈一谈大家都熟知的Context。<br>Context相信所有的Android开发人员基本上每天都在接触，因为它太常见了。但是这并不代表Context没有什么东西好讲的，实际上Context有太多小的细节并不被大家所关注，那么今天我们就来学习一下那些你所不知道的细节。<br><a id="more"></a></p><h1 id="Context类型"><a href="#Context类型" class="headerlink" title="Context类型"></a>Context类型</h1><p>我们知道，Android应用都是使用Java语言来编写的，那么大家可以思考一下，一个Android程序和一个Java程序，他们最大的区别在哪里？划分界限又是什么呢？其实简单点分析，Android程序不像Java程序一样，随便创建一个类，写个main()方法就能跑了，而是要有一个完整的Android工程环境，在这个环境下，我们有像Activity、Service、BroadcastReceiver等系统组件，而这些组件并不是像一个普通的Java对象new一下就能创建实例的了，而是要有它们各自的上下文环境，也就是我们这里讨论的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。<br>下面我们来看一下Context的继承结构：<br><img src="http://img.blog.csdn.net/20151022212109519?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Context的继承结构"></p><p>Context的继承结构还是稍微有点复杂的，可以看到，直系子类有两个，一个是ContextWrapper，一个是ContextImpl。那么从名字上就可以看出，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。而ContextWrapper又有三个直接的子类，ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity。<br>那么在这里我们至少看到了几个所比较熟悉的面孔，Activity、Service、还有Application。由此，其实我们就已经可以得出结论了，Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的。<br>那么Context到底可以实现哪些功能呢？这个就实在是太多了，弹出Toast、启动Activity、启动Service、发送广播、操作数据库等等等等都需要用到Context。由于Context的具体能力是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p><h1 id="Context数量"><a href="#Context数量" class="headerlink" title="Context数量"></a>Context数量</h1><p>那么一个应用程序中到底有多少个Context呢？其实根据上面的Context类型我们就已经可以得出答案了。Context一共有Application、Activity和Service三种类型，因此一个应用程序中Context数量的计算公式就可以这样写：<br>[plain] view plain copy</p><blockquote><p>Context数量 = Activity数量 + Service数量 + 1  </p></blockquote><p>上面的1代表着Application的数量，因为一个应用程序中可以有多个Activity和多个Service，但是只能有一个Application。</p><h1 id="Application-Context的设计"><a href="#Application-Context的设计" class="headerlink" title="Application Context的设计"></a>Application Context的设计</h1><p>基本上每一个应用程序都会有一个自己的Application，并让它继承自系统的Application类，然后在自己的Application类中去封装一些通用的操作。其实这并不是Google所推荐的一种做法，因为这样我们只是把Application当成了一个通用工具类来使用的，而实际上使用一个简单的单例类也可以实现同样的功能。但是根据我的观察，有太多的项目都是这样使用Application的。当然这种做法也并没有什么副作用，只是说明还是有不少人对于Application理解的还有些欠缺。那么这里我们先来对Application的设计进行分析，讲一些大家所不知道的细节，然后再看一下平时使用Application的问题。<br>首先新建一个MyApplication并让它继承自Application，然后在AndroidManifest.xml文件中对MyApplication进行指定，如下所示：</p><pre><code class="xml">&lt;application      android:name=&quot;.MyApplication&quot;      android:allowBackup=&quot;true&quot;      android:icon=&quot;@drawable/ic_launcher&quot;      android:label=&quot;@string/app_name&quot;      android:theme=&quot;@style/AppTheme&quot; &gt;      ......  &lt;/application&gt;</code></pre><p>指定完成后，当我们的程序启动时Android系统就会创建一个MyApplication的实例，如果这里不指定的话就会默认创建一个Application的实例。<br>前面提到过，现在很多的Application都是被当作通用工具类来使用的，那么既然作为一个通用工具类，我们要怎样才能获取到它的实例呢？如下所示：</p><pre><code class="java">public class MainActivity extends Activity {      @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          setContentView(R.layout.activity_main);          MyApplication myApp = (MyApplication) getApplication();          Log.d(&quot;TAG&quot;, &quot;getApplication is &quot; + myApp);      }  }</code></pre><p>可以看到，代码很简单，只需要调用getApplication()方法就能拿到我们自定义的Application的实例了，打印结果如下所示：<br><img src="http://img.blog.csdn.net/20151101215354919" alt=""></p><p>那么除了getApplication()方法，其实还有一个getApplicationContext()方法，这两个方法看上去好像有点关联，那么它们的区别是什么呢？我们将代码修改一下：</p><pre><code class="java">public class MainActivity extends Activity {      @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          setContentView(R.layout.activity_main);          MyApplication myApp = (MyApplication) getApplication();          Log.d(&quot;TAG&quot;, &quot;getApplication is &quot; + myApp);          Context appContext = getApplicationContext();          Log.d(&quot;TAG&quot;, &quot;getApplicationContext is &quot; + appContext);      }  }</code></pre><p>同样，我们把getApplicationContext()的结果打印了出来，现在重新运行代码，结果如下图所示：<br><img src="http://img.blog.csdn.net/20151101215827074" alt=""></p><p>咦？好像打印出的结果是一样的呀，连后面的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是MyApplication本身的实例。<br>那么有的朋友可能就会问了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了，如下所示：</p><pre><code class="java">public class MyReceiver extends BroadcastReceiver {      @Override      public void onReceive(Context context, Intent intent) {          MyApplication myApp = (MyApplication) context.getApplicationContext();          Log.d(&quot;TAG&quot;, &quot;myApp is &quot; + myApp);      }  }</code></pre><p>也就是说，getApplicationContext()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。<br>那么更加细心的朋友会发现，除了这两个方法之外，其实还有一个getBaseContext()方法，这个baseContext又是什么东西呢？我们还是通过打印的方式来验证一下：<br><img src="http://img.blog.csdn.net/20151102215834048" alt=""></p><p>哦？这次得到的是不同的对象了，getBaseContext()方法得到的是一个ContextImpl对象。这个ContextImpl是不是感觉有点似曾相识？回去看一下Context的继承结构图吧，ContextImpl正是上下文功能的实现类。也就是说像Application、Activity这样的类其实并不会去具体实现Context的功能，而仅仅是做了一层接口封装而已，Context的具体功能都是由ContextImpl类去完成的。那么这样的设计到底是怎么实现的呢？我们还是来看一下源码吧。因为Application、Activity、Service都是直接或间接继承自ContextWrapper的，我们就直接看ContextWrapper的源码，如下所示：</p><pre><code class="java">/**  * Proxying implementation of Context that simply delegates all of its calls to  * another Context.  Can be subclassed to modify behavior without changing  * the original Context.  */  public class ContextWrapper extends Context {      Context mBase;      /**      * Set the base context for this ContextWrapper.  All calls will then be      * delegated to the base context.  Throws      * IllegalStateException if a base context has already been set.      *       * @param base The new base context for this wrapper.      */      protected void attachBaseContext(Context base) {          if (mBase != null) {              throw new IllegalStateException(&quot;Base context already set&quot;);          }          mBase = base;      }      /**      * @return the base context as set by the constructor or setBaseContext      */      public Context getBaseContext() {          return mBase;      }      @Override      public AssetManager getAssets() {          return mBase.getAssets();      }      @Override      public Resources getResources() {          return mBase.getResources();      }      @Override      public ContentResolver getContentResolver() {          return mBase.getContentResolver();      }      @Override      public Looper getMainLooper() {          return mBase.getMainLooper();      }      @Override      public Context getApplicationContext() {          return mBase.getApplicationContext();      }      @Override      public String getPackageName() {          return mBase.getPackageName();      }      @Override      public void startActivity(Intent intent) {          mBase.startActivity(intent);      }      @Override      public void sendBroadcast(Intent intent) {          mBase.sendBroadcast(intent);      }      @Override      public Intent registerReceiver(          BroadcastReceiver receiver, IntentFilter filter) {          return mBase.registerReceiver(receiver, filter);      }      @Override      public void unregisterReceiver(BroadcastReceiver receiver) {          mBase.unregisterReceiver(receiver);      }      @Override      public ComponentName startService(Intent service) {          return mBase.startService(service);      }      @Override      public boolean stopService(Intent name) {          return mBase.stopService(name);      }      @Override      public boolean bindService(Intent service, ServiceConnection conn,              int flags) {          return mBase.bindService(service, conn, flags);      }      @Override      public void unbindService(ServiceConnection conn) {          mBase.unbindService(conn);      }      @Override      public Object getSystemService(String name) {          return mBase.getSystemService(name);      }      ......  }</code></pre><p>由于ContextWrapper中的方法还是非常多的，我就进行了一些筛选，只贴出来了部分方法。那么上面的这些方法相信大家都是非常熟悉的，getResources()、getPackageName()、getSystemService()等等都是我们经常要用到的方法。那么所有这些方法的实现又是什么样的呢？其实所有ContextWrapper中方法的实现都非常统一，就是调用了mBase对象中对应当前方法名的方法。<br>那么这个mBase对象又是什么呢？我们来看第16行的attachBaseContext()方法，这个方法中传入了一个base参数，并把这个参数赋值给了mBase对象。而attachBaseContext()方法其实是由系统来调用的，它会把ContextImpl对象作为参数传递到attachBaseContext()方法当中，从而赋值给mBase对象，之后ContextWrapper中的所有方法其实都是通过这种委托的机制交由ContextImpl去具体实现的，所以说ContextImpl是上下文功能的实现类是非常准确的。<br>那么另外再看一下我们刚刚打印的getBaseContext()方法，在第26行。这个方法只有一行代码，就是返回了mBase对象而已，而mBase对象其实就是ContextImpl对象，因此刚才的打印结果也得到了印证。</p><h1 id="使用Application的问题"><a href="#使用Application的问题" class="headerlink" title="使用Application的问题"></a>使用Application的问题</h1><p>虽说Application的用法确实非常简单，但是我们平时的开发工作当中也着实存在着不少Application误用的场景，那么今天就来看一看有哪些比较容易犯错的地方是我们应该注意的。<br>Application是Context的其中一种类型，那么是否就意味着，只要是Application的实例，就能随时使用Context的各种方法呢？我们来做个实验试一下就知道了：</p><pre><code class="java">public class MyApplication extends Application {      public MyApplication() {          String packageName = getPackageName();          Log.d(&quot;TAG&quot;, &quot;package name is &quot; + packageName);      }  }</code></pre><p>这是一个非常简单的自定义Application，我们在MyApplication的构造方法当中获取了当前应用程序的包名，并打印出来。获取包名使用了getPackageName()方法，这个方法就是由Context提供的。那么上面的代码能正常运行吗？跑一下就知道了，你将会看到如下所示的结果：</p><p>应用程序一启动就立刻崩溃了，报的是一个空指针异常。看起来好像挺简单的一段代码，怎么就会成空指针了呢？但是如果你尝试把代码改成下面的写法，就会发现一切正常了：</p><pre><code class="java">public class MyApplication extends Application {      @Override      public void onCreate() {          super.onCreate();          String packageName = getPackageName();          Log.d(&quot;TAG&quot;, &quot;package name is &quot; + packageName);      }  }</code></pre><p>运行结果如下所示：<br><img src="http://img.blog.csdn.net/20151108161039795?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>在构造方法中调用Context的方法就会崩溃，在onCreate()方法中调用Context的方法就一切正常，那么这两个方法之间到底发生了什么事情呢？我们重新回顾一下ContextWrapper类的源码，ContextWrapper中有一个attachBaseContext()方法，这个方法会将传入的一个Context参数赋值给mBase对象，之后mBase对象就有值了。而我们又知道，所有Context的方法都是调用这个mBase对象的同名方法，那么也就是说如果在mBase对象还没赋值的情况下就去调用Context中的任何一个方法时，就会出现空指针异常，上面的代码就是这种情况。Application中方法的执行顺序如下图所示：<br><img src="http://img.blog.csdn.net/20151108174114045?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>Application中在onCreate()方法里去初始化各种全局的变量数据是一种比较推荐的做法，但是如果你想把初始化的时间点提前到极致，也可以去重写attachBaseContext()方法，如下所示：</p><pre><code class="java">public class MyApplication extends Application {      @Override      protected void attachBaseContext(Context base) {          // 在这里调用Context的方法会崩溃          super.attachBaseContext(base);          // 在这里可以正常调用Context的方法      }  }</code></pre><p>以上是我们平时在使用Application时需要注意的一个点，下面再来介绍另外一种非常普遍的Application误用情况。<br>其实Android官方并不太推荐我们使用自定义的Application，基本上只有需要做一些全局初始化的时候可能才需要用到自定义Application，官方文档描述如下：<br><img src="http://img.blog.csdn.net/20151108165256423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>但是就我的观察而言，现在自定义Application的使用情况基本上可以达到100%了，也就是我们平时自己写测试demo的时候可能不会使用，正式的项目几乎全部都会使用自定义Application。可是使用归使用，有不少项目对自定义Application的用法并不到位，正如官方文档中所表述的一样，多数项目只是把自定义Application当成了一个通用工具类，而这个功能并不需要借助Application来实现，使用单例可能是一种更加标准的方式。<br>不过自定义Application也并没有什么副作用，它和单例模式二选一都可以实现同样的功能，但是我见过有一些项目，会把自定义Application和单例模式混合到一起使用，这就让人大跌眼镜了。一个非常典型的例子如下所示：</p><pre><code class="java">public class MyApplication extends Application {      private static MyApplication app;      public static MyApplication getInstance() {          if (app == null) {              app = new MyApplication();          }          return app;      }  }</code></pre><p>就像单例模式一样，这里提供了一个getInstance()方法，用于获取MyApplication的实例，有了这个实例之后，就可以调用MyApplication中的各种工具方法了。<br>但是这种写法对吗？这种写法是大错特错！因为我们知道Application是属于系统组件，系统组件的实例是要由系统来去创建的，如果这里我们自己去new一个MyApplication的实例，它就只是一个普通的Java对象而已，而不具备任何Context的能力。有很多人向我反馈使用 LitePal 时发生了空指针错误其实都是由于这个原因，因为你提供给LitePal的只是一个普通的Java对象，它无法通过这个对象来进行Context操作。<br>那么如果真的想要提供一个获取MyApplication实例的方法，比较标准的写法又是什么样的呢？其实这里我们只需谨记一点，Application全局只有一个，它本身就已经是单例了，无需再用单例模式去为它做多重实例保护了，代码如下所示：</p><pre><code class="java">public class MyApplication extends Application {      private static MyApplication app;      public static MyApplication getInstance() {          return app;      }      @Override      public void onCreate() {          super.onCreate();          app = this;      }  }</code></pre><p>getInstance()方法可以照常提供，但是里面不要做任何逻辑判断，直接返回app对象就可以了，而app对象又是什么呢？在onCreate()方法中我们将app对象赋值成this，this就是当前Application的实例，那么app也就是当前Application的实例了。<br>好了，关于Context的介绍就到这里吧，内容还是比较简单易懂的，希望大家通过这篇文章可以理解Context更多的细节，并且不要去犯使用Context时的一些低级错误。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Uiautomator中watcher的使用</title>
      <link href="/article/use-watcher-in-uiautomator.html"/>
      <url>/article/use-watcher-in-uiautomator.html</url>
      <content type="html"><![CDATA[<p>今天在uiautomator中实践了watcher的用法，这个也是之前在python中使用uiautomator中比较喜欢的功能，它可以提前定义一些条件，当满足一些条件时，进行一些操作，这个常用于处理测试过程中某些意料之外的或者不知道什么时候弹出来的框而阻碍测试的正常进行。<br>之前在写自动化用例的时候，遇到过小米手机在安装app的时候，会弹一个框来让用户点击安装，还有弹出一个升级检测的框点击“取消”按钮，或者遇到退出的时候点击确定，当然这些完全可以在用例里写逻辑来处理，而且有些还是程序本身要测试的检测点，当然这些对于大多数测试来说没有太大的意义，所以可以将其放入一个watcher里来让uiautomator来帮你进行相应的点击处理。<br><a id="more"></a><br>查看官方文档， UiWatcher是由UiDevice来registerWatcher (String name, UiWatcher watcher)，name为一个名字，这个名字相当于一个key,可以在之后的查看该watcher是否被检测到了使用和remove的时候使用</p><p>初始化UiWatcher时要重写一个checkForCondition()这个抽象方法，这个方法主要就是写一些判断哪些UiSelector是否出现了，出现了怎么处理，我重新封装了一个方法</p><pre><code class="java">public void initwatch(final String name,final UiSelector checkSelecto,final UiSelector opSelector){        //将name添加到watcherNames的list中，为了tearDown方法中remove掉用        watcherNames.add(name);        final UiObject check = new UiObject(checkSelecto);        final UiObject op = new UiObject(opSelector);        mDevice.registerWatcher(name, new UiWatcher() {            //这里重写checkForCondition方法            public boolean checkForCondition() {                try {                    if (check.exists()) {                        op.click();                        Thread.sleep(1000);                        return true;                    }                    else{                        Thread.sleep(1000);                    }                } catch (Exception e) {                    e.printStackTrace();                }                return false;            }        });    }</code></pre><p>checkForConditon方法的返回值是boolean值，当返回true的时候，则uidevice.hasWatcherTriggered(name) 则返回true，checkForConditon这里不用写循环，uiautomator会在测试过程中一直在循环的调用。</p><p>以下是全部代码<br>TestUtil.java</p><pre><code class="java">package com.yangyanxing.test;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.ArrayList;import com.android.uiautomator.core.UiDevice;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.core.UiWatcher;public class TestUtil {    public ArrayList&lt;String&gt; watcherNames = new ArrayList&lt;String&gt;();     public UiDevice mDevice = UiDevice.getInstance();    public static String doCmdshell(String commond){        String s = null;        try        {            Process p = Runtime.getRuntime().exec(commond);            BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));            BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));            String result = &quot;&quot;;            while ((s = stdInput.readLine()) != null)            {                result = result + s + &quot;\n&quot;;            }            while ((s = stdError.readLine()) != null)            {                System.out.println(s);            }            return result;        }        catch (Exception e)        {            return &quot;Exception occurred&quot;;        }    }    //init watcher     public void initwatch(final String name,final UiSelector checkSelecto,final UiSelector opSelector){        //将name添加到watcherNames的list中，为了tearDown方法中remove掉用        watcherNames.add(name);        final UiObject check = new UiObject(checkSelecto);        final UiObject op = new UiObject(opSelector);        mDevice.registerWatcher(name, new UiWatcher() {            //这里重写checkForCondition方法            public boolean checkForCondition() {                try {                    if (check.exists()) {                        op.click();                        Thread.sleep(1000);                        return true;                    }                    else{                        Thread.sleep(1000);                    }                } catch (Exception e) {                    e.printStackTrace();                }                return false;            }        });    }    public static Boolean waitForUiselectorAppears(UiSelector selector,int timeout)    {        UiObject uiObject = new UiObject(selector);        return uiObject.waitForExists(timeout*1000);     }}</code></pre><p>UitestRunner.java</p><pre><code class="java">package com.yangyanxing.test;import com.android.uiautomator.core.UiDevice;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiObjectNotFoundException;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.testrunner.UiAutomatorTestCase;import static com.yangyanxing.test.TestUtil.doCmdshell;public class UitestRunner extends UiAutomatorTestCase {    //初始化一个UiDevice    private UiDevice mDevice = UiDevice.getInstance();    private TestUtil tUtil = new TestUtil();    public UitestRunner(){        super();    }       //写setUp()方法    public void setUp() throws Exception{        super.setUp();        //每次测试的时候都需要启动急救箱，所以将这个方法放到setUp里        doCmdshell(&quot;am start com.qihoo.mkiller/com.qihoo.mkiller.ui.index.AppEnterActivity&quot;);               System.out.println(&quot;开始测试啦。。。&quot;);        //注册一些watcher        tUtil.initwatch(&quot;ignorSafe&quot;, new UiSelector().textContains(&quot;安全上网&quot;).className(&quot;android.widget.TextView&quot;),                 new UiSelector().text(&quot;取消&quot;));        tUtil.initwatch(&quot;agree&quot;, new UiSelector().text(&quot;同意并使用&quot;),                 new UiSelector().text(&quot;同意并使用&quot;));        tUtil.initwatch(&quot;Noupdate&quot;, new UiSelector().textContains(&quot;升级&quot;),                 new UiSelector().text(&quot;取消&quot;));        mDevice.runWatchers();//将watchers运行起来    }    //写tearDown方法，将急救箱force-stop    public void tearDown() throws Exception{        super.tearDown();        doCmdshell(&quot;am force-stop com.qihoo.mkiller&quot;);        System.out.println(&quot;用例测试完了！&quot;);        for (String watcherName : tUtil.watcherNames) {            System.out.println(watcherName+&quot;被remove了！&quot;);            mDevice.removeWatcher(watcherName);        }    }    //检测急救箱启动后是否有&quot;开始扫描&quot;按钮    public void test_startScanButton() throws UiObjectNotFoundException{        UiSelector scanButton = new UiSelector().className(&quot;android.widget.Button&quot;).text(&quot;开始扫描&quot;);        if(TestUtil.waitForUiselectorAppears(scanButton, 20)){            UiObject scanoObject = new UiObject(scanButton);            if (scanoObject.click()) {                System.out.println(&quot;开始扫描 按钮被点击了！&quot;);            }else{                System.out.println(&quot;开始扫描 按钮点击失败了&quot;);            }        }else {            System.out.println(&quot;急救箱启动失败&quot;);        }        UiSelector exitbutton = new UiSelector().className(&quot;android.widget.Button&quot;).text(&quot;退出&quot;);        assertEquals(Boolean.TRUE, TestUtil.waitForUiselectorAppears(exitbutton, 120));    }    public void test_print(){        System.out.println(&quot;用例2开始测试了！&quot;);    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Uiautomator做基于UI界面的测试</title>
      <link href="/article/use-uiautomator-for-uitest.html"/>
      <url>/article/use-uiautomator-for-uitest.html</url>
      <content type="html"><![CDATA[<p>这两天在看原生的<code class="text">uiautomator</code>的测试，之前也有使用，但是只是把Android官方的例子简单的实现一样，并没有什么实际的测试意思，<a href="http://www.yangyanxing.com/article/1264.html">Android官方的uiautomator例子的实现</a>,今天结合最近正在做的自动化项目，简单的使用uiautomator来实现了一下，只是做了一个小例子，但是基本上都如何编译jar与运行调通了，这里也简单的记录一下。<br>之前也有使用别人封装好的python做过，那个写起来也比较简单，<a href="http://www.yangyanxing.com/article/how-to-use-uiautomator-with-python.html">使用uiautomator的python封装进行android的UI测试</a></p><a id="more"></a><h1 id="新建一个java工程"><a href="#新建一个java工程" class="headerlink" title="新建一个java工程"></a>新建一个java工程</h1><p>新建工程的时候要注意编码要是<code class="text">utf-8</code>的，不然后面使用ant编译jar文件的时候会有问题.<br>引入JUnit与android.jar和uiautomator.jar，我使用的是api-16的jar，这个16要记住，后面生成build.xml有用<br><img src="/image/libs.png" alt="引入相应的库文件"></p><h1 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h1><p>新建的类要继承UiAutomatorTestCase类<br>我这个操作要用到am命令来启动手机急救箱和关闭急救箱，所以我创建一个util类来封了两个方法</p><pre><code class="java">package com.yangyanxing.test;import java.io.BufferedReader;import java.io.InputStreamReader;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiSelector;public class TestUtil {    public static String doCmdshell(String commond){        String s = null;        try        {            Process p = Runtime.getRuntime().exec(commond);            BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));            BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));            String result = &quot;&quot;;            while ((s = stdInput.readLine()) != null)            {                result = result + s + &quot;\n&quot;;            }            while ((s = stdError.readLine()) != null)            {                System.out.println(s);            }            return result;        }        catch (Exception e)        {            return &quot;Exception occurred&quot;;        }    }    //这个方法是在timeout的时间内等待ui元素的出现，出现了返回真，异常了或者超时了返回假    public static Boolean waitForUiselectorAppears(UiSelector selector,int timeout)    {        UiObject uiObject = new UiObject(selector);             return uiObject.waitForExists(timeout*1000);    }}</code></pre><h1 id="写具体的测试方法"><a href="#写具体的测试方法" class="headerlink" title="写具体的测试方法"></a>写具体的测试方法</h1><pre><code class="java">package com.yangyanxing.test;import com.android.uiautomator.core.UiDevice;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiObjectNotFoundException;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.testrunner.UiAutomatorTestCase;public class UitestRunner extends UiAutomatorTestCase {    //初始化一个UiDevice    private UiDevice mDevice = UiDevice.getInstance();    public UitestRunner(){        super();    }    //写setUp()方法    public void setUp() throws Exception{        super.setUp();        //每次测试的时候都需要启动急救箱，所以将这个方法放到setUp里        TestUtil.doCmdshell(&quot;am start com.qihoo.mkiller/com.qihoo.mkiller.ui.index.AppEnterActivity&quot;);          }    //写tearDown方法，将急救箱force-stop    public void tearDown() throws Exception{        super.tearDown();        TestUtil.doCmdshell(&quot;am force-stop com.qihoo.mkiller&quot;);    }    //检测急救箱启动后是否有&quot;开始扫描&quot;按钮    public void test_startScanButton() throws UiObjectNotFoundException{        UiSelector scanButton = new UiSelector().className(&quot;android.widget.Button&quot;).text(&quot;开始扫描&quot;);        if(TestUtil.waitForUiselectorAppears(scanButton, 20)){            UiObject scanoObject = new UiObject(scanButton);            if (scanoObject.click()) {                System.out.println(&quot;开始扫描 按钮被点击了！&quot;);            }else{                System.out.println(&quot;开始扫描 按钮点击失败了&quot;);            }        }else {            System.out.println(&quot;急救箱启动失败&quot;);        }        UiSelector exitbutton = new UiSelector().className(&quot;android.widget.Button&quot;).text(&quot;退出&quot;);        assertEquals(Boolean.TRUE, TestUtil.waitForUiselectorAppears(exitbutton, 120));    }}</code></pre><h1 id="使用android-bat生成build-xml文件"><a href="#使用android-bat生成build-xml文件" class="headerlink" title="使用android.bat生成build.xml文件"></a>使用android.bat生成build.xml文件</h1><p>到android sdk目录的tools目录下，使用</p><blockquote><p>android create uitest-project -n mkillerTest -t 2 -p D:\EclipseWorkPlace\uiautomatorTest` </p></blockquote><p>命令生成build.xml</p><p>-n 为最终生成的jar包的名字，随意起<br>-t 为android targets的id,稍后说怎么获得<br>-p 为刚才创建的工程目录</p><p>-t 的值可以通过 sdk/tools 目录下的android list 来获得<br><img src="/image/android-list.png" alt="android target的获取"></p><p>刚才使用的uiautomator的api版本为16，那么对应这里的id值就是2</p><h1 id="使用ant-build…生成mkillerTest-jar文件"><a href="#使用ant-build…生成mkillerTest-jar文件" class="headerlink" title="使用ant build…生成mkillerTest.jar文件"></a>使用ant build…生成mkillerTest.jar文件</h1><p>刷新eclipse里的工程目录，这个build.xml就会出来了，<br>右键build.xml选择Run as-&gt;Ant build….<br>在Targets标签里勾选build[from imort${sdk.dir}/tools/ant/uibuild.xml]<br>然后点击run，如果没有错误的话最终会生成BUILD SUCCESSFUL的提示并且把jar文件位置打印出来<br><img src="/image/jar.png" alt="成功生成jar文件"></p><h1 id="将生成的jar-push到手机里进行测试"><a href="#将生成的jar-push到手机里进行测试" class="headerlink" title="将生成的jar push到手机里进行测试"></a>将生成的jar push到手机里进行测试</h1><p>使用adb push 命令将这个mkillerTest.jar推到手机的/data/local/tmp/目录下</p><blockquote><p>adb push mkillerTest.jar /data/local/tmp/</p></blockquote><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><p>adb shell 到手机里，cd到/data/local/tmp目录下，也可以不cd 到这个目录(只要前面将.jar文件push到/data/local/tmp目录下也行)，运行uiautomator命令进行测试</p><blockquote><p>uiautomator runtest mkillerTest.jar </p></blockquote><p>或者</p><blockquote><p>uiautomator runtest mkillerTest.jar -c com.yangyanxing.test.UitestRunner</p></blockquote><p>-c 命令为指定类来跑，当有多个类的时候可以选择只跑部分用例</p><p><img src="/image/rst.png" alt="运行结果"></p><p>基本的流程就是这样，以后再扩展吧。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p><a href="http://www.yangyanxing.com/article/use-watcher-in-uiautomator.html">Uiautomator中watcher的使用</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>过年</title>
      <link href="/article/Spring-Festival.html"/>
      <url>/article/Spring-Festival.html</url>
      <content type="html"><![CDATA[<p><img src="/image/665344343178029836.jpg" alt="新年快乐"></p><p>首都再见，北京你好<br>又是一年，这个年过的相对平静<br>年味少了很多，不像小时候那样还会放鞭炮，不会像小时候那样盼着大吃大喝<br>现在更加喜欢过了一个清淡的年</p><p>春节，对于中国人来说是最重要的节日，家人可以放下手中的工作相聚一起<br>家在农村，平时在城市里工作生活，每逢周末回家，在家里总能睡个很好的觉</p><a id="more"></a><p>在家里才能享受这种平静，过年了，在2015年，有很多没有实现的目标，2016又有一些新的目标<br>在2015年，得到了一些想要的东西，也失去了一些东西<br>工作上，现在可以做一些自已喜欢的东西，自已支配一些时间，没有那么看起来要很忙的样子。<br>今年过年，还是没能带回个儿媳。<br>在网上看到一句话，说有个人其实30岁已经死了，只是到80岁才埋<br>一个人的激情终究能持续多久？<br>自我感觉已经没有之前对新鲜事物的敏感与兴趣，有种得过且过的想法了<br>这样不好，但所幸还是有一些的，还没到那种当一天和尚撞一天钟的状态<br>对于新鲜的技术主观上还是喜欢接受与学习的。<br>这一年，自已的脾气变坏了很多，自我反思应该是平时接触人太少的原因<br>自已的想法有时也很偏激，对于看不惯的事物总想要骂上几句发泄一下才爽<br>但是骂过之后又能怎样呢？<br>前初想要多读一些书，不光是IT技术方面，也要多一些人文方面<br>这点已经算实现了，今年读了不少书，但是感觉还是少，自已的阅历与想法还是太单一<br>16年要读更多的书。</p><p>去年开始重新用朋友圈，之前删除过所有的朋友圈，并关闭了此功能<br>其实这种和朋友之间相互沟通相互了解也是很好的，不能太封闭了自已<br>那会也删除了一些好友，后来也觉得后悔，今年过节的时候还能收到人家的微信，说明人家并没有删除我<br>只是当时自已太玻璃心，有些太固执，现在也算了，既然做了也就没必要再想这些<br>这一年也新加了很多好友，很多“朋友圈”里的好友，为什么这么说呢，可能我们在现实生活中不会见面的人，只是在朋友圈里寒暄的好友。<br>16年要在朋友圈里花太多的时间，不用太关注那些留言与他人是否回复了自已的留言<br>好在这一年自已的性格也有了一些变化，说起话来更加的放松，开的玩笑也不那么放肆了，也会注意一些场合。</p><p>16年，要有一些变化，15年很长时间都在纠结于工作的问题上，自已技术上没有太大的长进，属于那种吃老本的，所以今年要学习与巩固一些新的技术，技术不能太单一。</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>在ThinkPHP整合新浪微博SDK</title>
      <link href="/article/ThinkPHP-workwith-weibo-sdk.html"/>
      <url>/article/ThinkPHP-workwith-weibo-sdk.html</url>
      <content type="html"><![CDATA[<p>最近在玩PHP，在看了基本语法以后就开始看ThinkPHP了，几年以前接触过一些，但是基本上都忘的差不多了<br>现在再看的时候，发现版本更新了好多，添加了很多新的功能特性，使用时候也有很多不一样的，之前写了一篇边看边写的笔记，<a href="http://www.yangyanxing.com/article/thinkphp-study-note.html">ThinkPHP的学习笔记</a><br>今天结合<a href="http://document.thinkphp.cn/manual_3_2.html" target="_blank" rel="noopener">官方的文档</a>来整合一下新浪微博的SDK，在使用的过程中还是有一些问题需要注意的，我使用的是3.2.3版本<br><a id="more"></a></p><h1 id="ThinkPHP和项目与模块的初始化"><a href="#ThinkPHP和项目与模块的初始化" class="headerlink" title="ThinkPHP和项目与模块的初始化"></a>ThinkPHP和项目与模块的初始化</h1><p>这个就不详细写了，学习笔记中有记录，也是比较基础的</p><h1 id="整合新浪微博的SDK"><a href="#整合新浪微博的SDK" class="headerlink" title="整合新浪微博的SDK"></a>整合新浪微博的SDK</h1><p>下载SDK <a href="http://open.weibo.com/wiki/SDK#PHP_SDK" target="_blank" rel="noopener">新浪微博SDK</a><br>下载后将压缩包中的saetv2.ex.class.php取下来，重新命名，叫什么无所谓，只是为了去掉那个点，<br>我重新命名为saetv2.class.php, <code class="text">.class.php</code> 是必须要保留的，我将其放到了ThinkPHP/Library/Org/Com/Sina/ 目录下，文档上说这个目录下的类库是可以自动加载的，但是文档上使用的是namespace的方式<br>我一开始也按照文档的介绍使用namespace方式，但是后来发现这种以名称空间的方式有很多限制，首先一个文件里只能有一个类且文件名还要和这个类名对应，微博SDK里有三个类，如果按照namespace的方法，我还得新建一个文件重新拷贝一下相应的类，很麻烦，后来我直接采用import这个类的方式，使用起来方便了很多。</p><h1 id="在WeiboController-class-php中写逻辑"><a href="#在WeiboController-class-php中写逻辑" class="headerlink" title="在WeiboController.class.php中写逻辑"></a>在WeiboController.class.php中写逻辑</h1><p>首先把新浪微博sdk引入进来，在use Think\Controller; 下面加入 引用</p><blockquote><p>import(‘Org\Com.Sina\saetv2’);</p></blockquote><pre><code class="php">&lt;?phpnamespace Home\Controller;use Think\Controller;import(&#39;Org\Com.Sina\saetv2&#39;);</code></pre><p>这里的目录结构中的<code class="text">com\sina</code> 要改成<code class="text">Com.Sina</code><br>下面如果要使用saetv2中的类就可以直接使用 \类名调用，如使用SaeTOAuthV2类就可以使用<br><code class="text">$c = new \SaeTClientV2()</code></p><h1 id="获得token"><a href="#获得token" class="headerlink" title="获得token"></a>获得token</h1><p>其实里面的代码基本上就是sdk中的callback.php中的代码,这里又加上了ThinkPHP对于session与cookie的封装</p><pre><code class="php">$o = new \SaeTOAuthV2( WB_AKEY , WB_SKEY );$code_url = $o-&gt;getAuthorizeURL( WB_CALLBACK_URL );if(isset($_GET[&#39;code&#39;])){    $code = $_GET[&#39;code&#39;];    $keys = array();    $keys[&#39;code&#39;] = $_REQUEST[&#39;code&#39;];    $keys[&#39;redirect_uri&#39;] = WB_CALLBACK_URL;    $token = $o-&gt;getAccessToken( &#39;code&#39;, $keys ) ;    if (!empty($token[&#39;uid&#39;]) &amp;&amp; !empty($token[&#39;access_token&#39;])) {       session(&#39;token&#39;,$token);       cookie(&#39;weibojs_&#39;.$o-&gt;client_id, http_build_query($token));       $this-&gt;success(&#39;新浪微博授权成功&#39;,U(&#39;index&#39;,&#39;&#39;,&#39;&#39;),3);    }    else{       $this-&gt;error(&#39;新浪微博授权失败&#39;,U(&#39;index&#39;,&#39;&#39;,&#39;&#39;),3);     }</code></pre><h1 id="调用微博的接口"><a href="#调用微博的接口" class="headerlink" title="调用微博的接口"></a>调用微博的接口</h1><p>当获得了token后就可以使用token访问新浪微博的接口了，<a href="http://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9AAPI" target="_blank" rel="noopener">接口文档</a></p><p>全部代码如下</p><pre><code class="php">&lt;?phpnamespace Home\Controller;use Think\Controller;import(&#39;Org\Com.Sina.weibo\saetv2&#39;);class WeiboController extends Controller {        public function index(){        // session(&#39;[destroy]&#39;);        define(&#39;WB_AKEY&#39;, C(&#39;AKEY&#39;));        define(&#39;WB_SKEY&#39;, C(&#39;SKEY&#39;));        define(&#39;WB_CALLBACK_URL&#39;, C(&#39;CALLBACK&#39;));        if (session(&#39;token&#39;)) {            dump(session(&#39;token&#39;));            $c = new \SaeTClientV2( WB_AKEY , WB_SKEY , $_SESSION[&#39;token&#39;][&#39;access_token&#39;] );            // 这个是调用发微博的接口            // $up = $c-&gt;update(&quot;使用ThinkPHP发微博&quot;.(string)(mt_rand()));            $ht = $c-&gt;home_timeline();            $userinfo = $c-&gt;show_user_by_id(session(&#39;token&#39;)[&#39;uid&#39;]);            dump($userinfo);            echo &quot;点此&lt;a href=&quot;.U(&#39;logout&#39;,&#39;&#39;,&#39;&#39;).&quot;&gt;退出登录&lt;/a&gt;&quot;;        }else{            // 这个是使用namespace方式调用，麻烦            // $o = new \Org\Com\Sina\SaeTOAuthV2( WB_AKEY , WB_SKEY );            //             // 下面这个是使用import库以后使用方法，比较简单            $o = new \SaeTOAuthV2( WB_AKEY , WB_SKEY );            $code_url = $o-&gt;getAuthorizeURL( WB_CALLBACK_URL );            if(isset($_GET[&#39;code&#39;])){                $code = $_GET[&#39;code&#39;];                $keys = array();                $keys[&#39;code&#39;] = $_REQUEST[&#39;code&#39;];                $keys[&#39;redirect_uri&#39;] = WB_CALLBACK_URL;                // dump($keys);                $token = $o-&gt;getAccessToken( &#39;code&#39;, $keys ) ;                // dump($token);                if (!empty($token[&#39;uid&#39;]) &amp;&amp; !empty($token[&#39;access_token&#39;])) {                   session(&#39;token&#39;,$token);                   cookie(&#39;weibojs_&#39;.$o-&gt;client_id, http_build_query($token));                   $this-&gt;success(&#39;新浪微博授权成功&#39;,U(&#39;index&#39;,&#39;&#39;,&#39;&#39;),3);                }                else{                   $this-&gt;error(&#39;新浪微博授权失败&#39;,U(&#39;index&#39;,&#39;&#39;,&#39;&#39;),3);                 }            }            echo &quot;您还没有登录，请使用&lt;a href=&quot;.$code_url.&quot;&gt;新浪微博&lt;/a&gt;进行登录&quot;;        }        $this-&gt;show(&#39;&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} body{ background: #fff; font-family: &quot;微软雅黑&quot;; color: #333;font-size:24px} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.8em; font-size: 36px } a,a:hover{color:blue;}&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &#39;,&#39;utf-8&#39;);    }    public function logout(){        // 退出实际上就是简单地调用了销毁session的方式        session(&#39;[destroy]&#39;);        cookie(NULL);        $this-&gt;success(&#39;您已经退出登录&#39;,U(&#39;index&#39;,&#39;&#39;,&#39;&#39;),2);    }}</code></pre><p>当访问 index.php/Weibo/index 时，显示授权链接<br><img src="/image/20160210231742.png" alt="点击授权"></p><p>点击后使用微博账号进行登录，成功后跳转回index.php/Weibo/index </p><p><img src="/image/20160210232553.png" alt="dump_usre_info"></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP </tag>
            
            <tag> PHP </tag>
            
            <tag> 微博 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThinkPHP的学习笔记</title>
      <link href="/article/thinkphp-study-note.html"/>
      <url>/article/thinkphp-study-note.html</url>
      <content type="html"><![CDATA[<h1 id="初始化一个项目"><a href="#初始化一个项目" class="headerlink" title="初始化一个项目"></a>初始化一个项目</h1><p>thinkphp是单入口文件</p><pre><code class="php">&lt;?phpdefine(&quot;APP_NAME&quot;, &quot;THINK_Study&quot;);define(&quot;APP_PATH&quot;, &quot;./study/&quot;);define(&quot;APP_DEBUG&quot;, true);require(&quot;./ThinkPHP/ThinkPHP.php&quot;);</code></pre><p>Note:</p><ol><li>要先定义APP_PATH,后再include thinkphp 主入口文件，要不然会在当前目录上建立目录，很乱</li><li>各种版本生成的目录有些不同，我现在用的是3.2.3 就没有lib目录，而是只有一个home目录,下面的Controller目录相当于之前版本的是lib目录，里面记录着控制器，是MVC中的C，同级目录还有Model和View目录，这样更明显</li><li><p>各个项目下的<code class="text">Conf\config.php</code> 里的内容只有自已的项目才能读取，其它项目读取不了，比如<code class="text">admin</code>读不了<code class="text">study</code>配置</p><a id="more"></a><h1 id="关于多模块的设计"><a href="#关于多模块的设计" class="headerlink" title="关于多模块的设计"></a>关于多模块的设计</h1></li><li><p>3.2.3以后采用多模块设计，即一个项目里采用多个模块的设计思路，比如可以有一个前台的web模块，再加上一个后台的admin模块，而之前版本的thinkphp则需要建立两个入口文件 index.php=&gt;web,admin.php=&gt;admin</p></li><li>多模块后，则要url上加上模块名，如 <a href="http://localhost/index.php/admin/index/index" target="_blank" rel="noopener">http://localhost/index.php/admin/index/index</a></li><li>可以绑定一个默认的模块，在主入口文件中加入<br><code class="text">define(&#39;BIND_MODULE&#39;,&#39;Home&#39;);</code>则将home模块绑定到默认模块中，这样在访问home模块的时候就可以不用加上home了，如 <a href="http://localhost/index.php/index/index" target="_blank" rel="noopener">http://localhost/index.php/index/index</a> 则是访问home模块下的index控制器下的index方法</li><li><p>可以在项目的<code class="text">Config.php</code>文件中自定义模块的访问，达到一种不写Home模块时使用Home模块，写上其他的模块则使用其它的模块,<code class="text">不能写在index.php中，没用的</code></p><blockquote><p>‘MODULE_ALLOW_LIST’    =&gt;    array(‘Home’,’Admin’,’User’),<br>‘DEFAULT_MODULE’       =&gt;    ‘Home’,</p></blockquote></li><li><p>我曾尝试一次性生成多个模块目录，但是按照官方的方法不能实现</p></li></ol><h1 id="使用U方法生成url"><a href="#使用U方法生成url" class="headerlink" title="使用U方法生成url"></a>使用U方法生成url</h1><p><a href="http://www.thinkphp.cn/info/132.html" target="_blank" rel="noopener">ThinkPHP函数详解：U方法</a></p><blockquote><p>$url = U(“Index/index@sina.com”,array(‘id’ =&gt; 1),”html”,false);</p></blockquote><h1 id="使用公共库函数"><a href="#使用公共库函数" class="headerlink" title="使用公共库函数"></a>使用公共库函数</h1><p>在3.2 版本中，不再是common.php，要在项目的Common目录下建立一个function.php </p><h1 id="数组在模板中的显示"><a href="#数组在模板中的显示" class="headerlink" title="数组在模板中的显示"></a>数组在模板中的显示</h1><ol><li>一维数组<pre><code class="php">$jin = array(         &#39;name&#39; =&gt; &#39;zhangjin&#39;,          &#39;sex&#39;  =&gt; &#39;female&#39;,         &#39;age&#39;  =&gt; &#39;25&#39;,         );$this-&gt;assign(&quot;jin&quot;,$jin);$this-&gt;display();</code></pre></li></ol><p>上面定义了一个一维数组，将其赋值于jin,然后渲染到对应的模板中<br>我个人比较喜欢用foreach</p><pre><code class="html">&lt;foreach name=&quot;jin&quot; item=&#39;vo&#39;&gt;{$key}---{$vo}&lt;br /&gt;&lt;/foreach&gt;</code></pre><p><code class="text">$key</code> 为一维数组中的key</p><ol><li>多维数组在模板中的遍历<br>其实更多的时候是使用的多维数组，很多时候在数据库中取得数据以后在模板中进行渲染</li></ol><pre><code class="php">$psersons = array(    1=&gt;array(&#39;name&#39;=&gt;&#39;yyx&#39;,&#39;age&#39;=&gt;28,&#39;sex&#39;=&gt;&#39;male&#39;),    2=&gt;array(&#39;name&#39;=&gt;&#39;jin&#39;,&#39;age&#39;=&gt;24,&#39;sex&#39;=&gt;&#39;female&#39;),    3=&gt;array(&#39;name&#39;=&gt;&#39;shi&#39;,&#39;age&#39;=&gt;28,&#39;sex&#39;=&gt;&#39;female&#39;),    )$this-&gt;assign(&#39;persons&#39;,$persons);$this-&gt;display();</code></pre><pre><code class="html">&lt;foreach name=&quot;persons&quot; item=&#39;person&#39;&gt;{$person[&#39;name&#39;]}---{$person[&#39;age&#39;]}---{$person[&#39;sex&#39;]} &lt;br /&gt;&lt;/foreach&gt;</code></pre><p>它是将二维数组里第一组作为一项进行遍历</p><h1 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h1><ol><li><p>M方法，大M方法可以在不实现模型的基础上对数据库进行简单的curd，多以查询为主</p><blockquote><p>$data = M(‘user’) </p></blockquote></li><li><p>查询方式<br>2.1 使用字符串作为查询条件 </p><blockquote><p>$User = M(“User”); // 实例化User对象<br>$User-&gt;where(‘type=1 AND status=1’)-&gt;select(); </p></blockquote></li></ol><p>生成的SQL语句是</p><blockquote><p>SELECT * FROM think_user WHERE type=1 AND status=1</p></blockquote><p>2.2 使用数组作为查询条件</p><blockquote><p>$data = M(‘data’);<br>$condition[‘id’] = 1;<br>$condition[‘data’] = ‘framework’;<br>$condition[‘_logic’] = ‘or’;<br>$rst = $data-&gt;where($condition)-&gt;select();</p></blockquote><p>生成的SQL语句是</p><blockquote><p>SELECT * FROM <code class="text">think_data</code> WHERE <code class="text">id</code> = 1 OR <code class="text">data</code> = ‘framework’</p></blockquote><p>注意</p><ol><li>如果数组里的key不是表中的列的话则该条件不生效</li><li><code class="text">_logic</code> 默认是<code class="text">and</code></li></ol><p>2.3 表达式查询<br>这种查询比较灵活</p><p>表达式 含义<br>EQ  等于（=）<br>NEQ 不等于（&lt;&gt;）<br>GT  大于（&gt;）<br>EGT 大于等于（&gt;=）<br>LT  小于（&lt;）<br>ELT 小于等于（&lt;=）<br>LIKE    模糊查询<br>[NOT] BETWEEN   （不在）区间查询<br>[NOT] IN    （不在）IN 查询<br>EXP 表达式查询，支持SQL语法</p><p><code class="text">$where[字段名]=array(表达式,查询条件)</code></p><blockquote><p>$condition[‘id’] = array(‘lt’,3);<br>$rst = $data-&gt;where($condition)-&gt;select();</p></blockquote><p>SQL: SELECT * FROM <code class="text">think_data</code> WHERE <code class="text">id</code> &lt; 3 </p><blockquote><p>$condition[‘id’] = array(‘lt’,3);<br>$condition[‘data’] = array(‘like’,’%php’);<br>$rst = $data-&gt;where($condition)-&gt;select();</p></blockquote><p>SQL: SELECT * FROM <code class="text">think_data</code> WHERE <code class="text">id</code> &lt; 3 AND <code class="text">data</code> LIKE ‘%php’ </p><p>如果想要查询以php结尾或者是fr开头的</p><blockquote><p>$condition[‘id’] = array(‘lt’,3);<br>$condition[‘data’] = array(‘like’,array(‘%php’,’fr%’));<br>$rst = $data-&gt;where($condition)-&gt;select();</p></blockquote><p>SQL: SELECT * FROM <code class="text">think_data</code> WHERE <code class="text">id</code> &lt; 3 AND (<code class="text">data</code> LIKE ‘%php’ OR <code class="text">data</code> LIKE ‘fr%’)</p><p>2.4 区间查询</p><blockquote><p>$condition[‘id’] = array(array(‘gt’,0),array(‘lt’,3),’or’);<br>$rst = $data-&gt;where($condition)-&gt;select();  </p></blockquote><p>SQL: SELECT * FROM <code class="text">think_data</code> WHERE ( <code class="text">id</code> &gt; 0 OR <code class="text">id</code> &lt; 3 )</p><p>区间查询与上面的表达式查询中的between有一些相似,但是<code class="text">between</code>只能是<code class="text">and</code>的关系，没有区间查询中的<code class="text">or</code>关系</p><blockquote><p>$condition[‘id’] = array(‘between’,’1,5’);<br>$rst = $data-&gt;where($condition)-&gt;select();</p></blockquote><p>SQL: SELECT * FROM <code class="text">think_data</code> WHERE <code class="text">id</code> BETWEEN ‘1’ AND ‘5’ </p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用python进行文件夹对比</title>
      <link href="/article/use-python-dircompare.html"/>
      <url>/article/use-python-dircompare.html</url>
      <content type="html"><![CDATA[<p>最近写一个小脚本，在使用系统急救箱扫描并且处理完后，要将处理以后的样本和提供的标准进行对比<br>已经提供了样本与处理以后的文件，我要写的脚本就是启急救箱并且将两个文件夹进行比较<br>启动并且扫描比较好实现，但是在进行文件夹对比的时候走了一些弯路<br>上网查到python的标准库里有一个filecmp类，这个类可以对文件夹或者文件进行对比，使用起来还是比较方便的<br><a href="http://python.usyiyi.cn/python_278/library/filecmp.html" title="filecmp官方文档" target="_blank" rel="noopener">filecmp官方文档/</a></p><p>使用最下面的例子程序，我又对其进行了扩充<br>我想达到的目的就是先对两个文件夹进行比较，输出不同的文件，然后再输出各自文件夹中独有的文件<br> <a id="more"></a></p><pre><code class="python">#coding:gbkfrom filecmp import dircmpdef show_diff_files(dcmp):    for name in dcmp.diff_files:        print &quot;diff_file %s found in %s and %s&quot; % (name, dcmp.left,dcmp.right)    for sub_dcmp in dcmp.subdirs.values():        show_diff_files(sub_dcmp)def show_only(dcmp):    if dcmp.left_only:        ave_rst = 1        for i in dcmp.left_only:            print &quot;%s只存在于%s中&quot;%(i,dcmp.left)    if dcmp.right_only:        for i in dcmp.right_only:            print &quot;%s只存在于%s中&quot;%(i,dcmp.right)    for sub_dcmp in dcmp.subdirs.values():        show_only(sub_dcmp)def compare(dir1,dir2):    dcmp = dircmp(dir1,dir2)    show_diff_files(dcmp)    show_only(dcmp)</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用国内镜像源来加速python pypi包的安装</title>
      <link href="/article/1389.html"/>
      <url>/article/1389.html</url>
      <content type="html"><![CDATA[<p>在国内使用pip安装包的时候，很多时候由于各种原因无法正常使用pypi.python.org的源，还好有国内的良心网站提供了国内镜像</p><p>网上的方法都是在%HOMEPATH%中新建pip目录，再新建一个pip.ini，可是我试了以后还是不能用，也不知道原作者是否可以用</p><p>后来我看了一下它的文档 <a id="more"></a></p><p><a href="/image/2015/10/image1.png"><img src="/image/2015/10/image1.png" alt="image" title="image"></a> </p><p>这里应该是配制一个%HOME%的环境变量</p><p>于是我在环境变量里新建了一个HOME，值为%HOMEPATH%，然后在%HOMEPATH%目录里新建一个pip目录，在里面新建一个pip.ini</p><p>里面写入</p><pre><code class="python">[global]index-url = http://pypi.douban.com/simple</code></pre><p>或者</p><pre><code class="python">[global]index-url = http://pypi.douban.com/simple[install]trusted-host=pypi.douban.com</code></pre><p>之后再使用pip install 就可以很顺利的安装了，我这里使用的是douban的安装源</p><h1 id="20160113-更新"><a href="#20160113-更新" class="headerlink" title="20160113 更新"></a>20160113 更新</h1><p>今天在我的Raspberry中无论怎么修改pip.conf都不能生效<br>无奈只能查看pip的源代码，把源代码中的默认下载地址改了<br>修改 /usr/lib/python2.7/dist-packages/pip目录下的cmdoptions.py<br>搜索 pypi.python.org<br>将其修改为</p><pre><code class="python">index_url = OptionMaker(    &#39;-i&#39;, &#39;--index-url&#39;, &#39;--pypi-url&#39;,    dest=&#39;index_url&#39;,    metavar=&#39;URL&#39;,    default=&#39;http://pypi.douban.com/simple/&#39;,    help=&#39;Base URL of Python Package Index (default %default).&#39;)</code></pre><p>这里就直接使用http，而不是https，之后再使用sudo pip install 安装就默认走douban的了<br>还可以修改/usr/lib/python2.7/dist-packages/setuptools/command下面的 easy_install.py<br>也将里面的</p><blockquote><p>self.index_url = self.index_url or “<a href="http://pypi.python.org/simple" target="_blank" rel="noopener">http://pypi.python.org/simple</a>“<br>改为<br>self.index_url = self.index_url or “<a href="http://pypi.douban.com/simple" target="_blank" rel="noopener">http://pypi.douban.com/simple</a>“</p></blockquote><p>这样以后就可以通过 sudo easy_install 来安装，这个也是默认就走douban的源了</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中的listView与ArrayAdapter与LayoutInflater的使用</title>
      <link href="/article/1385.html"/>
      <url>/article/1385.html</url>
      <content type="html"><![CDATA[<p>最近在看《第一行代码-android》，这本书讲的不错，从最android基础的开始讲起，由浅入深，一步一步的教怎么使用android开发中的各种内容，今天看到listView，书中讲到listView可能是使用最多也是最难的一个组件，看过之后觉得还是需要好好消化一下的，借助书中的代码，来记录一下学习的过程</p><p>一、在listView中简单的显示一行文字</p><p>这个应该是listView应用中最简单的了，在使用listView中，一般的步骤应该是，先在main_activity.xml中创建好listView的布局</p><pre><code class="html">LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:orientation=&quot;vertical&quot; &gt;&lt;ListView    android:id=&quot;@+id/list_view&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    &gt;&lt;/ListView&gt;&lt;/LinearLayout&gt;</code></pre><a id="more"></a><p>之后在MainActivity.java中构造数据，这里应该是从数据库或者网上来获得数据，而为了方便只是简单的使用了一个数组</p><p><code class="text">private String[] data = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot; };</code></p><p>之后再使用一个arrayAdapter来适配array与listView</p><pre><code class="java">ArrayAdapter&lt;String&gt; adapter = new    ArrayAdapter&lt;String&gt;(MainActivity.this,    android.R.layout.simple_list_item_1,</code></pre><p>关于arrayAdapter的使用，<a href="http://www.cnblogs.com/loulijun/archive/2011/12/26/2302287.html" title="http://www.cnblogs.com/loulijun/archive/2011/12/26/2302287.html" target="_blank" rel="noopener">http://www.cnblogs.com/loulijun/archive/2011/12/26/2302287.html</a> 这篇文章介绍的还算比较简单</p><p>ArrayAdapter的初始化有多种方法，上面的应该是最简单通用的方法，第一个参数是一个上下文，一般是this,第二个布局文件，这里使用系统自带的android.R.layout.simple_list_item_1，后面有介绍如何使用自定义的布局文件，第三个参数是数据源。</p><p>将适配器适配到listView中</p><p>MainActivity.java的完整代码如下</p><pre><code class="java">package com.example.uilayouttest;import java.util.ArrayList;import java.util.List;import android.app.Activity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.Window;import android.widget.AdapterView;import android.widget.AdapterView.OnItemClickListener;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;public class MainActivity extends Activity {private String[] data = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;,&quot;Cherry&quot;, &quot;Mango&quot; };@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);requestWindowFeature(Window.FEATURE_NO_TITLE);setContentView(R.layout.activity_main);ArrayAdapter&lt;String&gt; adapter = newArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_1,            data);ListView listView = (ListView) findViewById(R.id.list_view);listView.setAdapter(adapter);}@Overridepublic boolean onCreateOptionsMenu(Menu menu) {// Inflate the menu; this adds items to the action bar if it is present.getMenuInflater().inflate(R.menu.main, menu);return true;}@Overridepublic boolean onOptionsItemSelected(MenuItem item) {// Handle action bar item clicks here. The action bar will// automatically handle clicks on the Home/Up button, so long// as you specify a parent activity in AndroidManifest.xml.int id = item.getItemId();if (id == R.id.action_settings) {return true;}return super.onOptionsItemSelected(item);}}</code></pre><p>二、使用自定义的ListView</p><p>上面这个应该说是最简单的，下面来说说自定义的</p><p>如果说如果想要在listView和每个项(item)里包含一张图片与一个文字，那么就需要自定义listView了</p><p>首先先在layout下自定义一个xml文件,fruit_item.xml</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot; &gt;    &lt;ImageView        android:id=&quot;@+id/fruit_image&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/fruit_name&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center&quot;        android:layout_marginLeft=&quot;10dip&quot; /&gt;</code></pre><p>这个布局文件其实就是定义了每个项的布局，之后创建一个数据源，它这里是使用了一个ArrayLlist，并创建了一个Fruit类，在初始化ArrayList的时候采用泛型限制只能用Fruit类。</p><p>Fruit类定义如下</p><pre><code class="java">package com.example.uilayouttest;public class Fruit {private String name;public Fruit(String name){this.name = name;}public String getName(){return this.name;}public int getImageId() {return R.drawable.ic_launcher;}}</code></pre><p>由于我没有那么多的图片，所以我就只返回了一张默认的ic_launcher的图片</p><p>自定义一个FruitAdapter类继承自ArrayAdapter类</p><pre><code class="java">package com.example.uilayouttest;import java.util.List;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ArrayAdapter;import android.widget.ImageView;import android.widget.TextView;public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; {private int resourceId;public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) {super(context, textViewResourceId, objects);resourceId = textViewResourceId;}// 这个方法在每个子项被滚动到屏幕内的时候 会被调用public View getView(int position, View convertView, ViewGroup parent) {Fruit fruit = getItem(position);// getItem()方法得到当前项的 Fruit 实例View view;ViewHolder viewHolder;if (convertView == null) {view = LayoutInflater.from(getContext()).inflate(resourceId, null);viewHolder = new ViewHolder();viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image);viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name);view.setTag(viewHolder);} else {view = convertView;viewHolder = (ViewHolder) view.getTag();}viewHolder.fruitImage.setImageResource(fruit.getImageId());viewHolder.fruitName.setText(fruit.getName());return view;}class ViewHolder {ImageView fruitImage;TextView fruitName;}}</code></pre><p>这里有一些要记录的，首先初始化</p><p>public FruitAdapter(Context context, int textViewResourceId, List<fruit> objects) {</fruit></p><pre><code>super(context, textViewResourceId, objects);resourceId = textViewResourceId; </code></pre><p>}</p><p>这里有三个参数，其实和ArrayAdapter的简单初始化一样，但是这里的第二个参数，在之后的初始化时，要传入的就是刚才自定义的fruit_item.xml布局文件。</p><p>第三个参数是数据源。</p><p>在FruitAdapter适配器的定义中使用到了LayoutInflater</p><p>view = LayoutInflater.from(getContext()).inflate(resourceId, null);</p><p>网上查了查，这个是加载布局文件的函数，之前一直都是使用setContentView(R.layout.activity_main);</p><p>其实这个是更深入的函数</p><p><a href="http://blog.csdn.net/guolin_blog/article/details/12921889" title="http://blog.csdn.net/guolin_blog/article/details/12921889" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/12921889</a>; 这彷文章介绍的比较详细</p><p>比如说要在A布局上加载B布局，那么先初始化LayoutInflater的实例</p><p>LayoutInflater.from(getContext())，from里的参数就是A，这里就直接使用getContent()，然后再使用inflate(resourceId, null)加载B布局</p><p>这里由于在FruitAdapter初始化的时候将resourceId = textViewResourceId;也就是说这里是将自定义的fruit_item布局加载到主的main_activity中</p><p>之后为了性能的优化，使用了ViewHolder与convertView，convertView这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用</p><p>最终的MainActivity.java如下</p><pre><code class="java">package com.example.uilayouttest;import java.util.ArrayList;import java.util.List;import android.app.Activity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.Window;import android.widget.AdapterView;import android.widget.AdapterView.OnItemClickListener;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;public class MainActivity extends Activity {private List&lt;Fruit&gt; frutlist = new ArrayList&lt;Fruit&gt;();private void initFruit() {Fruit apple = new Fruit(&quot;apple&quot;);Fruit banana = new Fruit(&quot;banane&quot;);Fruit orange = new Fruit(&quot;orange&quot;);Fruit Watermelon = new Fruit(&quot;Watermelon&quot;);Fruit Pear = new Fruit(&quot;Pear&quot;);Fruit Grape = new Fruit(&quot;Grape&quot;);Fruit Strawberry = new Fruit(&quot;Strawberry&quot;);Fruit Pineapple = new Fruit(&quot;Pineapple&quot;);Fruit Cherry = new Fruit(&quot;Cherry&quot;);Fruit Mango = new Fruit(&quot;Mango&quot;);frutlist.add(apple);frutlist.add(banana);frutlist.add(Mango);frutlist.add(Cherry);frutlist.add(Pineapple);frutlist.add(Strawberry);frutlist.add(Grape);frutlist.add(Pear);frutlist.add(Watermelon);frutlist.add(orange);}@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);requestWindowFeature(Window.FEATURE_NO_TITLE);setContentView(R.layout.activity_main);initFruit();FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, frutlist);ListView listView = (ListView) findViewById(R.id.list_view);listView.setAdapter(adapter);listView.setOnItemClickListener(new OnItemClickListener() {@Overridepublic void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {String name = frutlist.get(position).getName();Toast.makeText(MainActivity.this, name, Toast.LENGTH_SHORT).show();}});}@Overridepublic boolean onCreateOptionsMenu(Menu menu) {// Inflate the menu; this adds items to the action bar if it is present.getMenuInflater().inflate(R.menu.main, menu);return true;}@Overridepublic boolean onOptionsItemSelected(MenuItem item) {// Handle action bar item clicks here. The action bar will// automatically handle clicks on the Home/Up button, so long// as you specify a parent activity in AndroidManifest.xml.int id = item.getItemId();if (id == R.id.action_settings) {return true;}return super.onOptionsItemSelected(item);}}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用jquery在一个页面中有多个form表单做数据有效性校验</title>
      <link href="/article/1381.html"/>
      <url>/article/1381.html</url>
      <content type="html"><![CDATA[<p>最近在做一个小网站的项目，有一个小问题，可能在有经验的前端er面前不是什么问题，但是由于我接触前端很少，所以这个问题也搞了好一会才解决</p><p>在一个页面里有两个表单，在各自点击提交时，先要对相应的input里做非空校验，然后再对里面的数据做下简单的字符串判断<br> <a id="more"></a><br>html里是这样的</p><pre><code class="html">&lt;tbody&gt;    &lt;tr&gt;        &lt;td class=&quot;sync&quot;&gt;&lt;a class=&quot;btn btn-success&quot;  href=&quot;/syncfile?redo=1&amp;systype=x86&quot;&gt;32位同步其他组文件&lt;/a&gt;&lt;/td&gt;        &lt;td class=&quot;update&quot;&gt;&lt;a class=&quot;btn btn-success&quot;  href=&quot;/selfupdate?redo=1&amp;systype=x86&quot; &gt;32位急救箱自升级文件&lt;/a&gt;&lt;/td&gt;        &lt;td class=&quot;twice&quot;&gt;            &lt;form class=&quot;form-inline&quot; action=&quot;/check2&quot; method=&quot;GET&quot;&gt;              &lt;input type=&quot;hidden&quot; name=&quot;type&quot; value=&quot;zip&quot; /&gt;              &lt;input type=&quot;hidden&quot; name=&quot;redo&quot; value=1 /&gt;              &lt;input type=&quot;text&quot; class=&quot;form-control sftppath&quot; name=&quot;sftppath&quot; placeholder=&quot;请输入急救箱捆包地址&quot;&gt;              &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;急救箱捆包二次&lt;/button&gt;            &lt;/form&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td class=&quot;sync&quot;&gt;&lt;a class=&quot;btn btn-success&quot;  href=&quot;/syncfile?redo=1&amp;systype=x64&quot;&gt;64位同步其他组文件&lt;/a&gt;&lt;/td&gt;        &lt;td class=&quot;update&quot;&gt;&lt;a class=&quot;btn btn-success&quot;  href=&quot;/selfupdate?redo=1&amp;systype=x64&quot; &gt;64位急救箱自升级文件&lt;/a&gt;&lt;/td&gt;        &lt;td class=&quot;twice&quot;&gt;            &lt;form class=&quot;form-inline&quot; action=&quot;/check2&quot; method=&quot;GET&quot;&gt;              &lt;input type=&quot;hidden&quot; name=&quot;type&quot; value=&quot;update&quot; /&gt;              &lt;input type=&quot;hidden&quot; name=&quot;redo&quot; value=1 /&gt;              &lt;input type=&quot;text&quot; class=&quot;form-control sftppath&quot; name=&quot;sftppath&quot; placeholder=&quot;请输入急救箱升级地址&quot;&gt;              &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; id=&quot;123&quot;&gt;急救箱升级二次&lt;/button&gt;            &lt;/form&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;</code></pre><p>&#160;</p><p>起初我只是简单的用jquery做下非空校验</p><pre><code class="javascript">$(&quot;form&quot;).submit(function(){        if($(&quot;input.sftppath&quot;).val()==&#39;&#39;){            alert(&quot;sftp不能为空&quot;);        }</code></pre><p>这样写，在点击第一个按钮(急救箱捆包二次)时，当前面的input里没有写数据的时候会有alert提示，</p><p>但是点击第二个按钮(急救箱升级二次)时，即使在前面的input里填写上数据也会有alert提示，因为在急救箱捆包二次那的input里没有值。</p><p>于是在网上找了一下，没有使用第三方的jquery插件，因为这个功能太小了。</p><p>我先打印了一个$(this).html()</p><p>$(“form”).submit(function(){</p><p>alert($(this).html())</p><p>})</p><p>在submit里，$(this)所指的节点是form的根节点</p><p>于是这里就好弄了</p><p>使用$(this).children(“input.sftppath”).val()来获得相应form中的sftppath的内容</p><pre><code class="javascript">$(&quot;form&quot;).submit(function(){    if($(this).children(&quot;input.sftppath&quot;).val() == &#39;&#39;){        alert(&quot;sftp路径不能为空&quot;);        return false;    }else{        var buttontext = $(this).children(&#39;button.btn-primary&#39;).text();        var sftppath = $(this).children(&quot;input.sftppath&quot;).val();        if (buttontext == &quot;急救箱升级二次&quot;){            if(sftppath.indexOf(&#39;-all&#39;)==-1){                alert(&quot;不是有效的升级sftp路径&quot;);                return false;            }else{                return true;            };        }else if (buttontext == &quot;急救箱捆包二次&quot;){            if(sftppath.indexOf(&#39;-zip&#39;) == -1){                alert(&quot;不是有效的捆包sftp路径&quot;);                return false;            }else{                return true;            };        };    };});</code></pre><p>其实这里也就是明白了在submit函数里，$(this)指的是form的根节点，而不是那个button节点。</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用uiautomator的python封装进行android的UI测试</title>
      <link href="/article/how-to-use-uiautomator-with-python.html"/>
      <url>/article/how-to-use-uiautomator-with-python.html</url>
      <content type="html"><![CDATA[<p>最近项目中有个需求要在至少100台手机上对应用进行兼容性测试，首先想到的就是自动化来操作，不想一台台的操作相同的重复操作</p><p>基本的需求是这样的，安装被测试的应用，启动并退出，然后安装测试样本，检测是否有相应的弹窗拦截</p><p>考虑到市面上的各种测试框架与自已熟悉的编程语言，最后选择了google自家的uiautomator来搞，借助于前人对其进行了python封装，所以一开始还是挺顺利的，但是整个过程中还是有很多需要注意的地方<br> <a id="more"></a><br><a href="https://github.com/xiaocong/uiautomator" title="https://github.com/xiaocong/uiautomator" target="_blank" rel="noopener">https://github.com/xiaocong/uiautomator</a>   这个是xiaocong对其进行的python封装，也是这个小测试用例使用的，膜拜下</p><h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h1><p>python27,不能使用python26，安装urllib3与uiautomator，可以使用easy_install命令，安装android SDK，配置好adb的环境变量，这些应该都是作为android测试人员最基本的环境配置，要测试的应用是360手机急救箱，可以从<a href="http://jijiu.360.cn/" title="http://jijiu.360.cn/" target="_blank" rel="noopener">http://jijiu.360.cn/</a> 这个网址下载</p><p>下面是基本的测试流程</p><pre><code class="python"># 需要配置好adb 环境变量# 1.先确定有几台手机# 2.再确定有多少个应用# 3.先安装mkiller,启动mkiller# 4.再安装测试的样本# 5.检查是否有取消安装的按钮出现，出现说明测试通过，没出现说明测试失败</code></pre><p>既然要采用自动化，就不能手机测试那样，一台一台的跑，应该可以同时跑多台手机，我的想法就是启用多线程来跑，每个手机用一个线程来跑</p><h1 id="确定有几台手机"><a href="#确定有几台手机" class="headerlink" title="确定有几台手机"></a>确定有几台手机</h1><p>我封了一个方法</p><pre><code class="python">def finddevices():    rst = util.exccmd(&#39;adb devices&#39;)    devices = re.findall(r&#39;(.*?)\s+device&#39;,rst)    if len(devices) &gt;1:        deviceIds = devices[1:]        logger.info(&#39;共找到%s个手机&#39;%str(len(devices)-1))        for i in deviceIds:                        logger.info(&#39;ID为%s&#39;%i)        return deviceIds    else:        logger.error(&#39;没有找到手机，请检查&#39;)        return</code></pre><h1 id="uiautomator在python中的使用"><a href="#uiautomator在python中的使用" class="headerlink" title="uiautomator在python中的使用"></a>uiautomator在python中的使用</h1><p>下面来说说uiautomator在python中的使用，其实github中的readme.md写的挺清楚，但是实践起来还是有一些问题</p><p>uiautomator在使用的时候都要初始化一个d对象，单个手机可以通过</p><pre><code class="python">from uiautomator import device as d</code></pre><p>多台手机可以</p><pre><code class="python">from uiautomator import Device</code></pre><p>然后通过 d=Device(Serial)的方式初始化d对象，以后的操作基本上都是操作这个d对象，可以想象每个d对应着一台手机</p><p>我觉得这个设计有点不大好，我现在还经常在device的大小写上犯迷糊</p><h1 id="基本的点击操作"><a href="#基本的点击操作" class="headerlink" title="基本的点击操作"></a>基本的点击操作</h1><pre><code class="python"># press home keyd.press.home()# press back keyd.press.back()# the normal way to press back keyd.press(&quot;back&quot;)# press keycode 0x07(&#39;0&#39;) with META ALT(0x02) ond.press(0x07, 0x02)</code></pre><p>首先安装启动应用，安装采用adb install 命令，启动采用adb shell am start 命令</p><p>手机急救箱的launchable-activity是’com.qihoo.mkiller.ui.index.AppEnterActivity’,第一次启动会弹出使用协议要用户来点击”同意并使用”</p><p><a href="/image/2015/08/dump_3164510212585030182.png"><img src="/image/2015/08/dump_3164510212585030182_thumb.png" alt="dump_3164510212585030182" title="dump_3164510212585030182"></a></p><h1 id="watcher的使用"><a href="#watcher的使用" class="headerlink" title="watcher的使用"></a>watcher的使用</h1><p>我这里采用了watcher来监视并且点击，基本的watcher方法是</p><pre><code class="python">d.watcher(&#39;agree&#39;).when(text=u&#39;同意并使用&#39;).click(text=u&#39;同意并使用&#39;)</code></pre><p>先给watcher起一个名字，随便起，我这里叫agree，when里面写条件，我这里就是当text为’同意并使用’,后面写当符合这些条件的时候进行的操作，我这里就是click(text=u’同意并使用’),这里有一个坑，我之前写watcher的时候，就直接写click() 我以为里面不写内容默认就会点击前面找到的元素，但是后来发现这样是不行的，必须要写上要点击哪个对象</p><p>其实对于这种只出现一次的view可以不用写在watcher里，可以直接写d(text=u’同意并使用’).click(),但是考虑到这个界面出现之前会有一些延迟，各种手机的性能不同，也不好加time.sleep()时间，所以我建议像这种一律写到watcher里，什么时候出现就什么时候点击。</p><p>由于这个应用会请求root权限，所以有时第三方的root工具会弹相应的授权提示框，我想大部分的root工具应该都是有”允许”这个按钮的，于是我就加了一个watcher</p><pre><code class="python">d.watcher(&#39;allowroot&#39;).when(text=u&#39;允许&#39;).click(text=u&#39;允许&#39;)</code></pre><p>点击同意后会再弹一个开启超强模式的弹框，这里我要点击的是取消</p><p><a href="/image/2015/08/dump_3893862848196469772.png"><img src="/image/2015/08/dump_3893862848196469772_thumb.png" alt="dump_3893862848196469772" title="dump_3893862848196469772"></a></p><pre><code class="python">d.watcher(&#39;cancel&#39;).when(text=u&#39;取消&#39;).click(text=u&#39;取消&#39;)</code></pre><p>之后要点击一下back键，这时又会弹一个是否退出的框，这次我要点击“确认”</p><p><a href="/image/2015/08/dump_8250787869838979823.png"><img src="/image/2015/08/dump_8250787869838979823_thumb.png" alt="dump_8250787869838979823" title="dump_8250787869838979823"></a></p><p>这个确认我是后面单独处理的，其实也可以放在watcher里，只是我的考虑是有时点击back键的时候不一定会弹出来这个框，所以我会尝试多点击几次，直到这个框出来</p><p>但现在就有一个问题了，刚才写了一个d.watcher(‘cancel’).when(text=u’取消’).click(text=u’取消’)，这时当弹出这个框的时候，watcher就要起作用了，就会先去点击取消，这不是我想要的，所以我将之前点击取消的加了一个限制条件</p><pre><code class="python">d.watcher(&#39;cancel&#39;).when(text=u&#39;取消&#39;).when(textContains=u&#39;超强防护能够极大提高&#39;).click(text=u&#39;取消&#39;)</code></pre><p>textContains的意思就是和包含里面的文字，上面的意思就是当界面中text是“取消”的同时还要有一个view的text中要包含u’超强防护能够极大提高’,这样的话就限制的点击“取消”的条件，再遇到退出时的提示框就不会再会点击”取消”了</p><p>尽可能的想到可能出现的弹框，比较在小米手机中安装应用会弹一个小米的安装确认界面，使用下面的watcher来进行监测点击</p><pre><code class="python">d.watcher(&#39;install&#39;).when(text=u&#39;安装&#39;).when(textContains=u&#39;是否要安装该应用程序&#39;).click(text=u&#39;安装&#39;,className=&#39;android.widget.Button&#39;)</code></pre><p>总的watcher就是下面的样子</p><pre><code class="python">d.watcher(&#39;allowroot&#39;).when(text=u&#39;允许&#39;).click(text=u&#39;允许&#39;)        d.watcher(&#39;install&#39;).when(text=u&#39;安装&#39;).when(textContains=u&#39;是否要安装该应用程序&#39;).click(text=u&#39;安装&#39;,className=&#39;android.widget.Button&#39;) #专门为小米弹出的安装拦截        d.watcher(&#39;cancel&#39;).when(text=u&#39;取消&#39;).when(textContains=u&#39;超强防护能够极大提高&#39;).click(text=u&#39;取消&#39;)        d.watcher(&#39;confirm&#39;).when(text=u&#39;确认&#39;).when(textContains=u&#39;应用程序许可&#39;).click(text=u&#39;确认&#39;)        d.watcher(&#39;agree&#39;).when(text=u&#39;同意并使用&#39;).click(text=u&#39;同意并使用&#39;)        d.watcher(&#39;weishiuninstall&#39;).when(textContains=u&#39;暂不处理&#39;).click(textContains=u&#39;暂不处理&#39;)</code></pre><p>然后使用d.watchers.run()来启动watcher</p><p>但是在实际的watcher中，我发现这个watcher并没有想象的那样好用，有时经常是明明有相应的view但是就是点击不上，经过多次尝试，我发现，当界面已经出现的时候，这时我再强行的使用run()方法来启动watchers，这时它就能很好的点击了，所以基于此，我写了一个循环来来无限的调用run方法，times限制了次数，根据项目的实际进行调整吧，sleep时间也可以相应的调整</p><pre><code class="python">def runwatch(d,data):    times = 120    while True:        if data == 1:                            return True        # d.watchers.reset()        d.watchers.run()                times -= 1        if times == 0:            break        else:            time.sleep(0.5)</code></pre><p>监视的时候又不能只跑监视程序，还要跑相应的测试步骤，所以这里我把这个runwatch方法放到一个线程中去跑，起一个线程用作监视，脚本的测试方法放在另外的线程上跑</p><p>线程函数</p><pre><code class="python">#线程函数class FuncThread(threading.Thread):    def __init__(self, func, *params, **paramMap):        threading.Thread.__init__(self)        self.func = func        self.params = params        self.paramMap = paramMap        self.rst = None        self.finished = False    def run(self):        self.rst = self.func(*self.params, **self.paramMap)        self.finished = True    def getResult(self):        return self.rst    def isFinished(self):        return self.finisheddef doInThread(func, *params, **paramMap):    t_setDaemon = None    if &#39;t_setDaemon&#39; in paramMap:        t_setDaemon = paramMap[&#39;t_setDaemon&#39;]        del paramMap[&#39;t_setDaemon&#39;]    ft = FuncThread(func, *params, **paramMap)    if t_setDaemon != None:        ft.setDaemon(t_setDaemon)    ft.start()    return ft</code></pre><p>所以这里启动线程来跑runwatcher的调用就是</p><p>data = 0</p><p>doInThread(runwatch,d,data,t_setDaemon=True)</p><h1 id="多台手机的运行问题"><a href="#多台手机的运行问题" class="headerlink" title="多台手机的运行问题"></a>多台手机的运行问题</h1><p>基本的思路就是这样，这样当脚本都写完了以后在单个手机上运行很好，但是一旦插入多个手机就会出现一个问题，所有watcher只在一台手机上有效，另外的手机就只能傻傻的不知道点击，这个问题困扰了很久，我在github上也给作者发issue，但是后来我自已找到了解决的办法，就是在d=Device(Serial)的时候加上local_port端口号，让每台手机使用不同的local_port端口号，这样各自运行各自的，都很完好</p><h1 id="最终的代码"><a href="#最终的代码" class="headerlink" title="最终的代码"></a>最终的代码</h1><p>以下了测试脚本的代码</p><p>mkiller.py,主测试脚本文件</p><pre><code class="python">#coding:gbkimport os,sys,time,re,csvimport logimport utilfrom uiautomator import Deviceimport tracebackimport log,loggingimport multiprocessingoptpath = os.getcwd()                      #获取当前操作目录imgpath = os.path.join(optpath,&#39;img&#39;)      #截图目录def cleanEnv():    os.system(&#39;adb kill-server&#39;)    needClean = [&#39;log.log&#39;,&#39;img&#39;,&#39;rst&#39;]    pwd = os.getcwd()    for i in needClean:        delpath = os.path.join(pwd,i)        if os.path.isfile(delpath):            cmd = &#39;del /f/s/q &quot;%s&quot;&#39;% delpath            os.system(cmd)        elif os.path.isdir(delpath):            cmd = &#39;rd /s/q &quot;%s&quot;&#39; %delpath            os.system(cmd)    if not os.path.isdir(&#39;rst&#39;):        os.mkdir(&#39;rst&#39;)def runwatch(d,data):    times = 120    while True:        if data == 1:                            return True        # d.watchers.reset()        d.watchers.run()                times -= 1        if times == 0:            break        else:            time.sleep(0.5)def installapk(apklist,d,device):    sucapp = []    errapp = []    # d = Device(device)    #初始化一个结果文件    d.screen.on()    rstlogger = log.Logger(&#39;rst/%s.log&#39;%device,clevel = logging.DEBUG,Flevel = logging.INFO)    #先安装mkiller    mkillerpath = os.path.join(os.getcwd(),&#39;MKiller_1001.apk&#39;)    cmd = &#39;adb -s %s install -r %s&#39;% (device,mkillerpath)    util.exccmd(cmd)    def checkcancel(d,sucapp,errapp):        times = 10        while(times):            if d(textContains = u&#39;取消安装&#39;).count:                print d(textContains = u&#39;取消安装&#39;,className=&#39;android.widget.Button&#39;).info[&#39;text&#39;]                d(textContains = u&#39;取消安装&#39;,className=&#39;android.widget.Button&#39;).click()                rstlogger.info(device+&#39;测试成功，有弹出取消安装对话框&#39;)                break            else:                time.sleep(1)                times -= 1                if times == 0:                    rstlogger.error(device+&#39;测试失败，没有弹出取消安装对话框&#39;)    try:                d.watcher(&#39;allowroot&#39;).when(text=u&#39;允许&#39;).click(text=u&#39;允许&#39;)        d.watcher(&#39;install&#39;).when(text=u&#39;安装&#39;).when(textContains=u&#39;是否要安装该应用程序&#39;).click(text=u&#39;安装&#39;,className=&#39;android.widget.Button&#39;) #专门为小米弹出的安装拦截        d.watcher(&#39;cancel&#39;).when(text=u&#39;取消&#39;).when(textContains=u&#39;超强防护能够极大提高&#39;).click(text=u&#39;取消&#39;)        d.watcher(&#39;confirm&#39;).when(text=u&#39;确认&#39;).when(textContains=u&#39;应用程序许可&#39;).click(text=u&#39;确认&#39;)        d.watcher(&#39;agree&#39;).when(text=u&#39;同意并使用&#39;).click(text=u&#39;同意并使用&#39;)        d.watcher(&#39;weishiuninstall&#39;).when(textContains=u&#39;暂不处理&#39;).click(textContains=u&#39;暂不处理&#39;)        # d.watchers.run()        data = 0        util.doInThread(runwatch,d,data,t_setDaemon=True)        #启动急救箱并退出急救箱        cmd = &#39;adb -s %s shell am start com.qihoo.mkiller/com.qihoo.mkiller.ui.index.AppEnterActivity&#39;% device        util.exccmd(cmd)        time.sleep(5)        times = 3        while(times):            d.press.back()            if d(text=u&#39;确认&#39;).count:                d(text=u&#39;确认&#39;).click()                break            else:                time.sleep(1)                times -=1        for item in apklist:            apkpath = item            if not os.path.exists(apkpath):                logger.error(&#39;%s的应用不存在，请检查&#39;%apkpath)                continue             if not device:                cmd = &#39;adb install -r &quot;%s&quot;&#39; % apkpath            else:                cmd = &#39;adb -s %s install -r &quot;%s&quot;&#39;%(device,apkpath)            util.doInThread(checkcancel,d,sucapp,errapp)            rst = util.exccmd(cmd)    except Exception, e:        logger.error(traceback.format_exc())        data = 1    data = 1    return sucappdef finddevices():    rst = util.exccmd(&#39;adb devices&#39;)    devices = re.findall(r&#39;(.*?)\s+device&#39;,rst)    if len(devices) &gt;1:        deviceIds = devices[1:]        logger.info(&#39;共找到%s个手机&#39;%str(len(devices)-1))        for i in deviceIds:                        logger.info(&#39;ID为%s&#39;%i)        return deviceIds    else:        logger.error(&#39;没有找到手机，请检查&#39;)        return #needcount:需要安装的apk数量，默认为0，既安所有#deviceids:手机的列表#apklist:apk应用程序的列表def doInstall(deviceids,apklist):    count = len(deviceids)    port_list = range(5555,5555+count)    for i in range(len(deviceids)):        d = Device(deviceids[i],port_list[i])        util.doInThread(installapk,apklist,d,deviceids[i])#结束应用def uninstall(deviceid,packname,timeout=20):    cmd = &#39;adb -s %s uninstall %s&#39; %(deviceid,packname)     ft = util.doInThread(os.system,cmd,t_setDaemon=True)    while True:        if ft.isFinished():            return True        else:            time.sleep(1)            timeout -= 1            if timeout == 0:                return False# 需要配置好adb 环境变量# 1.先确定有几台手机# 2.再确定有多少个应用# 3.先安装mkiller,启动mkiller# 4.再安装测试的样本# 5.检查是否有取消安装的按钮出现，出现说明测试通过，没出现说明测试失败if __name__ == &quot;__main__&quot;:    cleanEnv()    logger = util.logger    devicelist = finddevices()    if devicelist:               apkpath = os.path.join(os.getcwd(),&#39;apk&#39;)        apklist = util.listFile(apkpath)        doInstall(devicelist,apklist) #每个手机都要安装apklist里的apk</code></pre><p>util.py 线程与执行cmd脚本函数文件</p><pre><code class="python">#coding:gbkimport os,sysimport logimport loggingimport threadingimport multiprocessingimport timelogger = log.Logger(&#39;log.log&#39;,clevel = logging.DEBUG,Flevel = logging.INFO)def exccmd(cmd):    try:        return os.popen(cmd).read()    except Exception:        return None#遍历目录内的文件列表def listFile(path, isDeep=True):    _list = []    if isDeep:        try:            for root, dirs, files in os.walk(path):                for fl in files:                    _list.append(&#39;%s\%s&#39; % (root, fl))        except:            pass    else:        for fn in glob.glob( path + os.sep + &#39;*&#39; ):            if not os.path.isdir(fn):                _list.append(&#39;%s&#39; % path + os.sep + fn[fn.rfind(&#39;\\&#39;)+1:])    return _list#线程函数class FuncThread(threading.Thread):    def __init__(self, func, *params, **paramMap):        threading.Thread.__init__(self)        self.func = func        self.params = params        self.paramMap = paramMap        self.rst = None        self.finished = False    def run(self):        self.rst = self.func(*self.params, **self.paramMap)        self.finished = True    def getResult(self):        return self.rst    def isFinished(self):        return self.finisheddef doInThread(func, *params, **paramMap):    t_setDaemon = None    if &#39;t_setDaemon&#39; in paramMap:        t_setDaemon = paramMap[&#39;t_setDaemon&#39;]        del paramMap[&#39;t_setDaemon&#39;]    ft = FuncThread(func, *params, **paramMap)    if t_setDaemon != None:        ft.setDaemon(t_setDaemon)    ft.start()    return ft</code></pre><p>log.py log相应的函数文件</p><pre><code class="python">#coding=gbkimport logging,osimport ctypesFOREGROUND_WHITE = 0x0007FOREGROUND_BLUE = 0x01 # text color contains blue.FOREGROUND_GREEN= 0x02 # text color contains green.FOREGROUND_RED  = 0x04 # text color contains red.FOREGROUND_YELLOW = FOREGROUND_RED | FOREGROUND_GREENSTD_OUTPUT_HANDLE= -11std_out_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)def set_color(color, handle=std_out_handle):    bool = ctypes.windll.kernel32.SetConsoleTextAttribute(handle, color)    return boolclass Logger:    def __init__(self, path,clevel = logging.DEBUG,Flevel = logging.DEBUG):        self.logger = logging.getLogger(path)        self.logger.setLevel(logging.DEBUG)        fmt = logging.Formatter(&#39;[%(asctime)s] [%(levelname)s] %(message)s&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)        #设置CMD日志        sh = logging.StreamHandler()        sh.setFormatter(fmt)        sh.setLevel(clevel)        #设置文件日志        fh = logging.FileHandler(path)        fh.setFormatter(fmt)        fh.setLevel(Flevel)        self.logger.addHandler(sh)        self.logger.addHandler(fh)    def debug(self,message):        self.logger.debug(message)    def info(self,message):        self.logger.info(message)    def war(self,message,color=FOREGROUND_YELLOW):        set_color(color)        self.logger.warn(message)        set_color(FOREGROUND_WHITE)    def error(self,message,color=FOREGROUND_RED):        set_color(color)        self.logger.error(message)        set_color(FOREGROUND_WHITE)    def cri(self,message):        self.logger.critical(message)if __name__ ==&#39;__main__&#39;:    logyyx = Logger(&#39;yyx.log&#39;,logging.WARNING,logging.DEBUG)    logyyx.debug(&#39;一个debug信息&#39;)    logyyx.info(&#39;一个info信息&#39;)    logyyx.war(&#39;一个warning信息&#39;)    logyyx.error(&#39;一个error信息&#39;)    logyyx.cri(&#39;一个致命critical信息&#39;)</code></pre><p>这个小测试应用虽然比较简单，但是由于刚刚接触uiautomator的python封装，所以还是遇到了一些麻烦，不过还好，最终的结果是很好的解决了相应的问题，这里也算是抛砖引玉吧，这个uiautomator还有很多好玩的值得探索的地方，待以后慢慢发现~</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> android </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用wxPython建立一个计算文件md5的GUI工具</title>
      <link href="/article/1350.html"/>
      <url>/article/1350.html</url>
      <content type="html"><![CDATA[<p>最近在看wxPython，一开始觉得它的布局好乱，半天整不明白，这里通过写一个小工具来记录一下wxPython的一些基本使用</p><p>小工具最终是下面这个样子，将文件拖到上面会自动计算其md5与size</p><p><a href="/image/2015/06/1.png"><img src="/image/2015/06/1_thumb.png" alt="1" title="1"></a><br> <a id="more"></a><br>下面是全部的代码</p><pre><code class="python">#coding:gbkimport wximport optparseimport time,hashlibimport threadingimport osdef checkMD5(pefile):    try:        f = open(pefile,&#39;rb&#39;)        data = f.read()        m = hashlib.md5()        m.update(data)        f.close()        return m.hexdigest()    except:        return &#39;error&#39;def getFileSize(filename):    try:        size = int(os.path.getsize(filename))        return size    except:        return &#39;error&#39;#线程函数class FuncThread(threading.Thread):    def __init__(self, func, *params, **paramMap):        threading.Thread.__init__(self)        self.func = func        self.params = params        self.paramMap = paramMap        self.rst = None        self.finished = False    def run(self):        self.rst = self.func(*self.params, **self.paramMap)        self.finished = True    def getResult(self):        return self.rst    def isFinished(self):        return self.finisheddef doInThread(func, *params, **paramMap):    t_setDaemon = None    if &#39;t_setDaemon&#39; in paramMap:        t_setDaemon = paramMap[&#39;t_setDaemon&#39;]        del paramMap[&#39;t_setDaemon&#39;]    ft = FuncThread(func, *params, **paramMap)    if t_setDaemon != None:        ft.setDaemon(t_setDaemon)    ft.start()    return ftclass FileDropTarget(wx.FileDropTarget):    def __init__(self, filetext,md5tx,filesizetx):        wx.FileDropTarget.__init__(self)        self.filepath = filetext        self.md5tx = md5tx        self.filesizetx = filesizetx    def OnDropFiles(self,  x,  y, fileNames):        filename = fileNames[0].encode(&#39;gbk&#39;)        print filename        print type(filename)        self.filepath.SetValue(filename)        md5 = doInThread(checkMD5,filename)        filesize = doInThread(getFileSize,filename)        while True:            if not md5.isFinished():                time.sleep(0.5)            else:                self.md5tx.SetValue(md5.getResult())                break        while True:            if not filesize.isFinished():                time.sleep(0.5)            else:                self.filesizetx.SetValue(str(filesize.getResult()))                breakclass Frame(wx.Frame): #Frame 进行初始化    def __init__(self,title):        wx.Frame.__init__(self,None,title=title,size = (400,300))        boxSizer = wx.BoxSizer(wx.VERTICAL)        self.panel = wx.Panel(self)        # boxSizer.Add(self.panel,1,wx.EXPAND|wx.ALL) #wx.ALL 周围的距离，EXPAND扩充到全部        filepath = wx.StaticText(self.panel,-1,&quot;FileDir(请将文件拖到本对话框中)&quot;)        filetext = wx.TextCtrl(self.panel,-1,&quot;&quot;,size=(350,20))        md5st = wx.StaticText(self.panel,-1,&quot;MD5&quot;)        md5tx = wx.TextCtrl(self.panel,-1,size=(250,20))        filesizest = wx.StaticText(self.panel,-1,&#39;FileSize&#39;)        filesizetx = wx.TextCtrl(self.panel,-1,size=(250,20))        # hashst = wx.StaticText(self.panel,-1,&#39;Hash&#39;)        # hashtx = wx.TextCtrl(self.panel,-1,size=(250,20))        boxSizer.Add(filepath,0,wx.EXPAND|wx.LEFT|wx.TOP,border=10)        boxSizer.Add(filetext,0,wx.LEFT|wx.TOP,border=10)        boxSizer.Add((-1,20))        boxSizer.Add(md5st,0,wx.LEFT|wx.TOP,border=10)        boxSizer.Add(md5tx,0,wx.LEFT|wx.TOP,border=10)        boxSizer.Add((-1,10))        boxSizer.Add(filesizest,0,wx.LEFT|wx.TOP,border=10)        boxSizer.Add(filesizetx,0,wx.LEFT|wx.TOP,border=10)        # boxSizer.Add((-1,10))        # boxSizer.Add(hashst,0,wx.LEFT|wx.TOP,border=10)        # boxSizer.Add(hashtx,0,wx.LEFT|wx.TOP,border=10)        dropTarget = FileDropTarget(filetext,md5tx,filesizetx)        self.panel.SetDropTarget( dropTarget )        self.panel.SetSizer(boxSizer)class App(wx.App): ##继承wx.App    def OnInit(self): ##还没有调起来的时候读取初始化        self.frame = Frame(&#39;MD5&amp;size信息&#39;)        self.frame.Centre()        self.frame.Show(True)        return Truedef killSelf(evt = None):    os.system(&#39;taskkill /F /T /PID %d &gt;NUL 2&gt;NUL&#39; % win32process.GetCurrentProcessId())if __name__ == &#39;__main__&#39;:    parser = optparse.OptionParser()    parser.add_option(&#39;-x&#39;, &#39;--no-update&#39;, dest = &#39;test&#39;, action = &#39;store_true&#39;, help = &#39;start without update&#39;)    parser.add_option(&#39;-t&#39;, &#39;--no-update-test&#39;, dest = &#39;test2&#39;, action = &#39;store_true&#39;, help = &#39;start without update debug&#39;)    options, args = parser.parse_args()    if options.test:        print(&quot;-x param&quot;)    if options.test2:        print(&quot;-t param&quot;)</code></pre><p>一点点的解释</p><p>class App与App().MainLoop()是固定写法，在class App下有一个def OnInit方法来初始化主的Frame，将其居中并且Show()出来，没什么好说的，主要看一下Frame的定义</p><p>这个小工具使用的是boxSizer来布局，为了简单我只使用了一个boxSizer，将里面的所有控件采用VERTICAL(垂直)的方式来布局，如果想要将MD5与后面的文本框放在同一行，那么就需要添加一个水平的boxSizer，然后那将这个水平的boxSizer再放入主的boxSizer</p><p>boxSizer = wx.BoxSizer(wx.VERTICAL) #初始化一个垂直的boxSizer，也是整个框架的主Sizer</p><p>self.panel = wx.Panel(self) #初始化一个panel，这个panel是放了放之后的控件的</p><p>filepath = wx.StaticText(self.panel,-1,”FileDir(请将文件拖到本对话框中)”)</p><p>filetext = wx.TextCtrl(self.panel,-1,””,size=(350,20))</p><p>md5st = wx.StaticText(self.panel,-1,”MD5”)</p><p>md5tx = wx.TextCtrl(self.panel,-1,size=(250,20))</p><p>filesizest = wx.StaticText(self.panel,-1,’FileSize’)</p><p>filesizetx = wx.TextCtrl(self.panel,-1,size=(250,20))</p><p>上面是初始化相应的静态文本与文本框，方法中的第一个参数是其所在的父类窗口，这里也就是self.panel，其实也可以不用panel，而是将其直接放入到boxSizer中</p><p>boxSizer.Add(filepath,0,wx.EXPAND|wx.LEFT|wx.TOP,border=10) 将filepath加入到主的boxSizer中，这里一开始我有一些困惑，一开始我一直以为先将所有的控件放入到panel中，然后再将panel放入到boxSizer中，但是这样是不对的，而应该是直接就入到boxSizer中，将该控件的父类设置为panel，之后就没有将panel放入boxSizer这一步操作，wx.LEFT|wx.TOP,border=10 这个参数表示的是该控件距离上来左各有10个像素的距离，再使用wx.EXPAND来使其充分的填充其所在的区域，我曾经想，可否设置成距离上10px,左20px，但是貌似不能这样设置，Add函数里只能有一个border参数，换句话说只能设置相同的数值，之后我再找找是否可以实现。</p><p>boxSizer.Add((-1,20)) #这个是添加一个空距离，距离上20px</p><p>dropTarget = FileDropTarget(filetext,md5tx,filesizetx)</p><p>self.panel.SetDropTarget( dropTarget )</p><p>这个是放该窗口类添加一个拖拽方法，也是比较固定的写法</p><p>上面的class FileDropTarget中的<strong>init</strong>与OnDropFiles方法也是固定的方法，只是里面的处理函数不同。</p><p>wxPython中的一些style与flag等参数在布局中使用需要一些经验，还有它的很多控件和与之绑定的方法，要想熟练掌握还需要下一些工夫，下面两个网站算是介绍比较详细，要多多查阅</p><p><a href="http://wxpython.org/Phoenix/docs/html/1classindex.html" title="http://wxpython.org/Phoenix/docs/html/1classindex.html" target="_blank" rel="noopener">http://wxpython.org/Phoenix/docs/html/1classindex.html</a></p><p><a href="http://docs.wxwidgets.org/2.8.9/wx_classref.html" title="http://docs.wxwidgets.org/2.8.9/wx_classref.html" target="_blank" rel="noopener">http://docs.wxwidgets.org/2.8.9/wx_classref.html</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>笨方法实现webpy的表单校验功能</title>
      <link href="/article/1340.html"/>
      <url>/article/1340.html</url>
      <content type="html"><![CDATA[<p>最近在写一个小的demo，简单的用户注册与登录，检查在注册的时候要先检测用户名是否已经存在了，还要检查一下密码长度要不得小于3个字符</p><p>检查用户是否存在我是写在了一个单独的model.py里</p><pre><code class="python">def check(uname):info = db.select(&#39;pytest&#39;,where=&quot;username=$uname&quot;,vars=locals())if len(info)&gt;0:return Falseelse:return True</code></pre><a id="more"></a><p>这里的return True与False与实际的是相反的，这里后面做校验操作的时候做说明</p><p>官方的<a href="http://webpy.org/cookbook/forms.zh-cn" target="_blank" rel="noopener">文档</a>中有写校验的说明，但写的比较笼统，但是有一点写到了表单的校验</p><pre><code class="python">vpass = form.regexp(r&quot;.{3,20}$&quot;, &#39;must be between 3 and 20 characters&#39;)vemail = form.regexp(r&quot;.*@.*&quot;, &quot;must be a valid email address&quot;)validators = [        form.Validator(&quot;Passwords did&#39;t match&quot;, lambda i: i.password == i.password2)]</code></pre><p>vpass 是通过正则表达式来校验密码长度在3-20位，</p><p>vmail是校验邮箱格式的正确性，要有一个@符</p><p>而下面的validators则是由一个form.Validator生成的列表类</p><p>我通过这里的lambda函数想到了对表单的校验</p><pre><code class="python">validators=[        form.Validator(u&#39;用户名不能为空&#39;,lambda i:len(i.username)&gt;0),        form.Validator(u&#39;用户名已经存在&#39;,lambda i:model.check(i.username)),        form.Validator(u&#39;两次输入的密码不一致&#39;,lambda i:i.pwd==i.pwd2),    ]</code></pre><p>这里的model.check就是调用上面写的函数，如果有，则返回False，触发’用户名已经存在’条件</p><p>另外，我看form.py里有一个变量 notnull = Validator(“Required”, bool)，也可以直接调用这个变量，但是它的提示文字是Required，这里可以初始化一个中文的提示</p><pre class="brush:python">form.Textbox('username',form.Validator(u"必填", bool),description=u'用户名(*)')</pre><p>最终我写的这个表单是这个样子的</p><pre class="brush:python">##表单校验vpass = form.regexp(r".{3,20}$", u'密码长度不得小于3位')reg_form = form.Form(    # form.Textbox('username',form.Validator(u"必填", bool),description=u'用户名(*)'),    form.Textbox('username',description=u'用户名(*)'),    form.Password('pwd',vpass,description=u'密码'),    form.Password('pwd2',description=u'重复密码'),    form.Button('submit',type='submit',html=u'注册'),    validators=[        form.Validator(u'用户名不能为空',lambda i:len(i.username)>0),        form.Validator(u'用户名已经存在',lambda i:model.check(i.username)),        form.Validator(u'两次输入的密码不一致',lambda i:i.pwd==i.pwd2),    ]    )</pre><p>validators里我不知道还是否有别的调用接收表单值的方法，我尝试过</p><p><pre class="brush:python">form.Validator(u’用户名不能为空’,len(web.input().get(‘username’))&gt;0)</pre></p><p><br>但是这个在模板form.render()中就会报错，所以现在还是先以这种笨方式简单的调用表单校验吧！</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>那天遇到一个杀马特</title>
      <link href="/article/1329.html"/>
      <url>/article/1329.html</url>
      <content type="html"><![CDATA[<p>上小学的时候对于别人如果能有零花钱就感觉很羡慕<br>因为他们可以买到自已喜欢的吃的<br>但是我不会去奢求渴望父母也给我<br>到了初中，我会觉得那些染着黄毛，成天不上学开着大摩托的人比较牛气<br>因为他们可以不用上学，不用写作业，想打认谁就打谁，可以为别人拔份儿<br>可以我也不羡慕他们，我也不会去搞个彩毛儿，穿个喇叭裤<br>到了高中，我觉得那些长的帅气，会打篮球，会弹吉他，会讨女孩子开心的人很好<br>于是我也会在学习之于搞些自已喜欢的东西<br>到了大学，那种八面玲珑，左右逢源的人很好<br><a id="more"></a><br>工作后觉得有真正本事的人很好<br>上学的时候，一天10块钱的伙食自已也能过得好好的<br>现在偶尔回趟学校吃个餐厅都觉得太值了<br>随着年龄与见识的增长，心智也根着变化<br>以前觉得那么美好值得追求的东西，像以前的黄毛大喇叭裤，打架，帅气，才华<br>现在觉得都是那么稀松平常<br>但是每个时间里有着自已的追求，有着自已的理想<br>突破枷锁，实现理想，得到自已想要的<br>其实结果看起来那么不值一文，重要的是享受这段过程<br>现在我又想要什么呢？我为之付出与奋斗了吗？<br>有感于今天下班路上看一个杀马特骑个大摩托<br>其实现在看起来挺可笑的，大冷天的还开个摩托，为了显摆杀马特，还不戴头盔……<br>而想想以前我不也想这个样子吗？</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>成就感，一种很久违了的感觉</title>
      <link href="/article/1327.html"/>
      <url>/article/1327.html</url>
      <content type="html"><![CDATA[<p>以前看到的文字，看到之时已泪流满面</p><blockquote><p>我的孩子,我希望你好好学习,不是因为我要你跟别人比,而是因为我希望你将来会拥有选择的权利,选择有意义你又喜爱的工作,而不是被迫谋生。<br>当你的工作在你心中有意义,你就有成就感，成就感会给你带去快乐。无论工作贵贱，只要你是快乐的，妈妈就支持你，因为腰缠万贯也换不得一个真心的幸福。</p></blockquote><p>每天早起晚归的做着一份看不清未来但又不得不去做的工作，因为要谋生，本来应该朝气蓬勃的年纪却变得暮气沉沉，早起挤地铁，挤电梯，下班还要和中介斗智斗勇，<br>我现在之所以没法选择我想要过的生活也是因为早年没有认真的学习，成就感，一种很久违了的感觉。</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android stadio上使用robotium初体验</title>
      <link href="/article/1320.html"/>
      <url>/article/1320.html</url>
      <content type="html"><![CDATA[<p>在Android Stadio(as)上创建一个app的时候默认会自动创建相应的test类，可以直接在里面写单元测试用例</p><p><a href="/image/2015/03/image.png"><img src="/image/2015/03/image_thumb.png" alt="image" title="image"></a> </p><p>一、在项目(module)中导入robotium的jar包，右键app-&gt;new-&gt;directory,输入libs</p><p>然后将robotium-solo-5.3.1.jar复制进去，然后右键robotium-solo-5.3.1.jar选择add as library,之后就可以写测试用例了</p><p>如果还有问题，看一下项目的build gradle</p><pre><code>dependencies {    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)     compile &#39;com.android.support:appcompat-v7:21.0.3&#39;     compile files(&#39;libs/robotium-solo-5.3.1.jar&#39;)    }</code></pre><a id="more"></a><p>加入 compile files(‘libs/robotium-solo-5.3.1.jar’)   </p><p>以下是我简单的写了一个小的测试app和其单元测试,非常简单，没什么实际意义，只是为了演示，其目录结构如下</p><p><a href="/image/2015/03/image1.png"><img src="/image/2015/03/image_thumb1.png" alt="image" title="image"></a> </p><p>app代码</p><pre><code class="java">package com.example.kevin.helloword;import android.support.v7.app.ActionBarActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends ActionBarActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button button = (Button) findViewById(R.id.button);        final TextView tx = (TextView)findViewById(R.id.textView);        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                Toast.makeText(MainActivity.this,&quot;helloWorld&quot;,Toast.LENGTH_SHORT).show();                Toast.makeText(MainActivity.this,&quot;杨彦星&quot;,Toast.LENGTH_LONG).show();                tx.setText(&quot;hello yyx&quot;);            }        });    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        // Handle action bar item clicks here. The action bar will        // automatically handle clicks on the Home/Up button, so long        // as you specify a parent activity in AndroidManifest.xml.        int id = item.getItemId();        //noinspection SimplifiableIfStatement        if (id == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(item);    }}</code></pre><p>&#160;</p><p>其单元的测试代码如下</p><pre><code class="java">package com.example.kevin.helloword;import android.test.ActivityInstrumentationTestCase2;import com.robotium.solo.Solo;public class helloTest extends ActivityInstrumentationTestCase2&lt;MainActivity&gt; {    private Solo solo;    public helloTest() {        super(MainActivity.class);    }    @Override    public void setUp() throws Exception {        //setUp() is run before a test case is started.        //This is where the solo object is created.        solo = new Solo(getInstrumentation(), getActivity());    }    @Override    public void tearDown() throws Exception {        //tearDown() is run after a test case has finished.        //finishOpenedActivities() will finish all the activities that have been opened during the test execution.        solo.finishOpenedActivities();    }    public void testclickMe() throws Exception{        solo.unlockScreen();        solo.clickOnButton(&quot;click me&quot;);        boolean expected = true;        boolean actual = solo.searchText(&quot;hello yyx&quot;);        assertEquals(&quot;word not change&quot;, expected, actual);    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sql注入初步</title>
      <link href="/article/1314.html"/>
      <url>/article/1314.html</url>
      <content type="html"><![CDATA[<p>自已用php+mysql写了一个登录页面。其中包含多个sql注入漏洞，在mysql中创建一个表，其中有username password email一个列，添加三个数据</p><p>+————-+————-+—————–+<br>| username    | password    | email           |<br>+————-+————-+—————–+<br>| admin       | admin       | admin@admin.com |<br>| yangyanxing | yangyanxing | yyx@yyx.com     |<br>+————-+————-+—————–+</p><p>在phpmyadmin中使用一条sql命令</p><p>SELECT * FROM <code class="text">admin</code> WHERE 1 </p><p>where 1 是一个永真，这样它会把admin表中的所有数据返回</p><p>写一个testsql.php文件来尝试使用sql注入的方式登录这个系统<a id="more"></a></p><pre><code class="php">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;?phpdefine(&#39;DB_HOST&#39;, &#39;localhost&#39;);define(&#39;DB_USER&#39;, &#39;root&#39;);define(&#39;DB_PWD&#39;, &#39;123456&#39;);define(&#39;DB_NAME&#39;, &#39;test&#39;);_connect(); //连接数据库_select_db();//选择数据库_set_names();//设置字符集//连接数据库function _connect(){//$coon这个变量是全局的，它可以使得其在函数外面也可以访问到。 这里用global修饰global $conn;if(!$conn = mysql_connect(DB_HOST,DB_USER,DB_PWD)){exit(&#39;数据库连接失败&#39;);}}function _select_db(){if (!mysql_select_db(DB_NAME)){exit(&#39;找不到指定的数据库&#39;);}}function _set_names(){if (!mysql_query(&quot;SET NAMES UTF8&quot;)){exit(&#39;设置字符集错误！&#39;);}}/** * @param $_sql */function _query($_sql){if(!$checkResult = mysql_query($_sql)){exit(&#39;SQL语句执行失败&#39;.mysql_error());}return $checkResult;}/** * * @param unknown $sql * @return multitype: */function _fetch_array($sql){return mysql_fetch_array(_query($sql),MYSQL_ASSOC);}/** * @return int */function _mysql_affected_rows(){return mysql_affected_rows();}/** * @param $username * @param $info */function checkUserUni($username,$info){$sql = &quot;SELECT tg_username FROM tg_user WHERE tg_username=&#39;$username&#39; LIMIT 1&quot;;if(_fetch_array($sql)){go_back($info);}}if(isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])){    $username = $_POST[&#39;username&#39;];    $password = $_POST[&#39;password&#39;];    $query = &quot;select * from admin where username = &#39;$username&#39; and password=&#39;$password&#39;&quot;;    echo $query.&#39;&lt;br&gt;&#39;;    $result = _fetch_array($query);    if($result){        echo &quot;登录成功&quot;;    }else{        echo &quot;登录失败&quot;;    }    mysql_close();    print_r($result);}?&gt;&lt;body&gt;&lt;form action=&#39;&#39; name=&#39;login&#39; method=&quot;post&quot;&gt;    &lt;dd&gt;用 户 名：&lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;text&quot; /&gt;&lt;/dd&gt;    &lt;dd&gt;密　　码：&lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;text&quot; /&gt;&lt;/dd&gt;    &lt;dd&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot; class=&quot;button&quot; /&gt;&lt;/dd&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><p>其中</p><p>$query = “select * from admin where username = ‘$username’ and password=’$password’”; </p><p>这里的$username与$password未经过任何过滤，而是用户输入什么就是什么</p><p>首先在用户名里输入一个单引号（’） 来看看返回什么错误</p><p>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’’’ and password=’’’ at line 1</p><p>如果有类似于这样的错误则说明程序没有将单引号过滤掉，可能有sql注入漏洞,接着再看sql查询语句</p><p>$query = “select * from admin where username = ‘$username’ and password=’$password’”; </p><p>只要构造一个where后面是一个永真的条件就可以了，由于后面用了一个and逻辑，要构造两边都为true才行</p><p>username=’’ 可以构造一个username=’’ or ‘1’ = ‘1’ </p><p>password=’’ 也可以构造一个password=’’ or ‘1’=’1’</p><p>那么其实只要在用户名与密码处都填写’or ‘1’=’1 就可以了</p><p><a href="/image/2015/02/image13.png"><img src="/image/2015/02/image_thumb13.png" alt="image" title="image"></a> </p><p>&#160;</p><p>或者在用户名里输入admin’or ‘1’=’1 密码不输入，这个是在猜测其有一个叫admin的用户</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spinner和适配器模式</title>
      <link href="/article/1310.html"/>
      <url>/article/1310.html</url>
      <content type="html"><![CDATA[<p>原文 <a href="http://www.cnblogs.com/UUUP/p/3983394.html" title="http://www.cnblogs.com/UUUP/p/3983394.html" target="_blank" rel="noopener">http://www.cnblogs.com/UUUP/p/3983394.html</a></p><p>spinner相当于html表单中的select下拉列表。</p><h1 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h1><p>在string.xml中添加一个数组spinner_data：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;string-array name=&quot;spinner_data&quot;&gt; &lt;item &gt;北京&lt;/item&gt; &lt;item &gt;湖南&lt;/item&gt; &lt;item &gt;湖北&lt;/item&gt; &lt;/string-array&gt; &lt;/resources&gt;</code></pre><a id="more"></a><p>拖拽一个spinner：</p><pre><code class="xml">&lt;Spinner android:id=&quot;@+id/spinner1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:entries=&quot;@array/spinner_data&quot; android:spinnerMode=&quot;dialog&quot; /&gt;&lt;!-- entries 显示spinner当中的数据项 spinnerMode=&quot;dropdown&quot;是默认值下拉列表，spinnerMode=&quot;dialog&quot;是以对话框的形式显示--!&gt;</code></pre><h1 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h1><p>BaseAdapter就Android应用程序中经常用到的基础数据适配器，它的主要用途是将一组数据传到像ListView、Spinner、Gallery、GridView等UI显示组件，它是自动继承接口类Adapter。<br>假如要往spinner中添加string[]或List。<br>a）string[]<br>在MainActivity主类中定义一个字符串数组：<br>private String[] str = new String[] {<br> “山东”,”山西”,”北京”<br>};</p><p>定义一个继承BaseAdapter的类：<br>private class MyAdapter extends BaseAdapter {</p><p>@Override<br>public int getCount() {<br> // TODO Auto-generated method stub<br> return str.length;//重要方法<br>}</p><p>@Override<br>public Object getItem(int arg0) {<br> // TODO Auto-generated method stub<br> return null;<br>}</p><p>@Override<br>public long getItemId(int arg0) {<br> // TODO Auto-generated method stub<br> return 0;<br>}</p><p>@Override<br>public View getView(int position, View view, ViewGroup group) {//重要方法<br> // TODO Auto-generated method stub<br> //str.length多长此方法就执行几次<br> TextView textView = new TextView(MainActivity.this);<br> textView.setText(str[position]);<br> return textView;<br>}<br>}</p><p>在onCreate方法中：<br>Spinner spinner = (Spinner) findViewById(R.id.spinner1);<br>spinner.setAdapter(new MyAdapter());<br>b)List<br>在MainActivity主类中定义一个List：<br>private List list = new ArrayList();</p><p>并在onCreate方法中添加内容：<br>list.add(“上海”);<br>list.add(“天津”);<br>list.add(“浙江”);</p><p>MyAdapter类则只需要修改几处即可：<br>1. public int getCount() {</p><p> return list.size();<br>}</p><p>2. public View getView(int position, View view, ViewGroup group) {</p><p> TextView textView = new TextView(MainActivity.this);<br> textView.setText((CharSequence) list.get(position));<br> return textView;<br>}</p><p>3.还可以继续给spinner添加事件OnItemSelectedListener：<br>spinner.setOnItemSelectedListener(new OnItemSelectedListener() {</p><p>@Override<br>public void onItemSelected(AdapterView&lt;?&gt; parent, View view,<br>int position, long id) {<br>// TODO Auto-generated method stub<br> Toast.makeText(MainActivity.this, (CharSequence) list.get(position), 0).show();<br>}</p><p>@Override<br>public void onNothingSelected(AdapterView&lt;?&gt; parent) {<br>// TODO Auto-generated method stub<br>}<br>});</p><p>&#160;</p><p>&#160;</p><h1 id="利用ArrayAdapter构造adapter"><a href="#利用ArrayAdapter构造adapter" class="headerlink" title="利用ArrayAdapter构造adapter"></a>利用ArrayAdapter构造adapter</h1><pre><code class="java">//第一步：添加一个下拉列表项的数据源ss，这里添加的项就是下拉列表的菜单项private String[] ss = new String[] { &quot;云南&quot;, &quot;北京&quot;, &quot;香港&quot; };Spinner spinner=(Spinner) findViewById(R.id._spinner1_);//第二步：为下拉列表定义一个适配器，这里就用到里前面定义的ss。ArrayAdapter&lt;String&gt; adapter= new ArrayAdapter&lt;String&gt;(this,android.R.layout._simple_spinner_item_, ss);//其中，第一个是conetxt，也就是application的环境，第二个参数是spinner未展开的布局方式，第三个参数是数据源//第三步：为适配器设置下拉列表下拉时的菜单样式。adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);//第四步：将适配器添加到下拉列表上spinner.setAdapter(adapter);//第五步：为下拉列表设置各种事件的响应，这个事响应菜单被选中spinner.setOnItemSelectedListener(new OnItemSelectedListener){publicvoid onItemSelected(AdapterView&lt;?&gt; parent,View view, int position, long id) {Toast._makeText_(MainActivity.this,ss[position], 0).show();}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中的UI线程阻塞</title>
      <link href="/article/1308.html"/>
      <url>/article/1308.html</url>
      <content type="html"><![CDATA[<p>当一个应用程序启动之后，android系统会为这个应用程序创建一个主线程，这个线程非常重要，它负责渲染视图，分发事件到响应监听器并执行，对界面进行轮询的监听，一般叫做“UI主线程”</p><p>Android系统不会给应用程序的多个元素组件建立多个线程来执行，一个视图(activity)中的多个view组件运行在同一个UI线程当中，因此，多个view组件的监听器的执行可能会相互影响。</p><p>如有以下两个button，其中一个在会在主view中进行移动动画，另外一个button在点击以后将线程sleep 5秒<br><a id="more"></a></p><pre><code class="android">Button moveButton = (Button) findViewById(R.id.button5); //添加一个animation TranslateAnimation animation = new TranslateAnimation(0, 150, 0, 0); animation.setRepeatCount(30); animation.setDuration(2000); moveButton.setAnimation(animation);//将moveButton绑定到这个animation中button4.setOnClickListener(new OnClickListener() {             public void onClick(View v) {                 try {                     Thread.sleep(5000);                 } catch (InterruptedException e) {                                        e.printStackTrace();                 }             }});</code></pre><p>此时由于button4与moveButton处在同一个UI线程中，button4的Thread.sleep会影响到moveButton的animation，如果UI线程阻塞时间过长，Android系统可能就会干预</p><p><a href="/image/2015/02/image12.png"><img src="/image/2015/02/image_thumb12.png" alt="image" title="image"></a> </p><p>而用户也基本上会选择OK来关闭程序。</p><p>&#160;</p><p>解决线程阻塞问题可以通过将耗时的操作放入一个新的线程中进行，但是会有一个新的问题，在新的线程中又不能对UI线程进行UI操作，于是android官方提供一个post方法来解决这个问题</p><pre><code class="java">button4.setOnClickListener(new OnClickListener() {             public void onClick( final View v) {                 //方法一，新建一个线程，把耗时操作放在这个新线程中进行，而不影响UI线程                 new Thread(new Runnable() {                     public void run() {                         try {                             Thread.sleep(500);                         } catch (InterruptedException e) {                                                e.printStackTrace();                         }                         //当新线程中试图改变主UI进程的表现时，可以使用view.post()方法                         v.post(new Runnable() {                             public void run() {                                 TextView textView = (TextView) v;                                 textView.setText(&quot;yangyanxing&quot;);                             }                         });                     }                 }).start();             }         });</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发初步</title>
      <link href="/article/1303.html"/>
      <url>/article/1303.html</url>
      <content type="html"><![CDATA[<p>绑定单击事件有两种方法，一种是通过绑定android:onClick属性，一种是绑定一个setOnClickListener回调函数</p><h1 id="通过绑定onClick属性"><a href="#通过绑定onClick属性" class="headerlink" title="通过绑定onClick属性"></a>通过绑定onClick属性</h1><p>在activity_main.xml对应的组件上设置android:onClick=”test” 属性，然后再Java文件里定义一个test方法来实现，这个test方法是MainActivity类的一个方法</p><pre><code class="javascript">public void test(View view){        Toast.makeText(MainActivity.this, &quot;你还真敢点啊！&quot;, Toast.LENGTH_LONG).show();    }</code></pre><p>这里的view就是要使用的控件，如果是绑定的是个button，那么view就是这个button<br><a id="more"></a></p><h1 id="通过setOnClickListener"><a href="#通过setOnClickListener" class="headerlink" title="通过setOnClickListener"></a>通过setOnClickListener</h1><p>此时需要将这个setOnClickListener回调函数写在onCreate()函数里</p><pre><code class="javascript">protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button button = (Button)findViewById(R.id.button1);        button.setOnClickListener(new OnClickListener() {                       public void onClick(View v) {                Toast.makeText(MainActivity.this, &quot;我是被点击的&quot;, Toast.LENGTH_LONG).show();                           }        });    }</code></pre><!-- more --><p>可以看到setOnClickListener不属于某个控件，在使用的时候要先通过findViewById方法找到要进行onClick方法的控件。</p><h1 id="将2中的onClickListener方法分离出来"><a href="#将2中的onClickListener方法分离出来" class="headerlink" title="将2中的onClickListener方法分离出来"></a>将2中的onClickListener方法分离出来</h1><p>这个方式将OnClickListener分离出来写在MainActibity类方法</p><pre><code class="javascript">private View.OnClickListener myListener = new OnClickListener() {        @Override        public void onClick(View v) {            switch (v.getId()) {            case R.id.button1:                Toast.makeText(MainActivity.this, &quot;button1被点击了&quot;, Toast.LENGTH_LONG).show();                   break;            case R.id.button2:                Toast.makeText(MainActivity.this, &quot;button2被点击了&quot;, Toast.LENGTH_LONG).show();                   break;            case R.id.button3:                Toast.makeText(MainActivity.this, &quot;button3被点击了&quot;, Toast.LENGTH_LONG).show();                   break;            default:                break;            }        }    };</code></pre><p>然后在onCreate方法中使用</p><p>Button button1 = (Button)findViewById(R.id.button1);<br>Button button2 = (Button)findViewById(R.id.button2);<br>Button button3 = (Button)findViewById(R.id.button3);<br>button1.setOnClickListener(myListener);<br>button2.setOnClickListener(myListener);<br>button3.setOnClickListener(myListener);</p><p>这种方法可以复用方法，也可以多些判断，比较灵活</p><h1 id="长按与短按"><a href="#长按与短按" class="headerlink" title="长按与短按"></a>长按与短按</h1><p>长按有一个返回值，当一个控件既绑定了一个长铵同时又绑定了一个短按，如果长按的返回值是false时，那么在长按以后同时也会触发短按事件</p><pre><code class="javascript">button4.setOnLongClickListener(new OnLongClickListener() {                       public boolean onLongClick(View v) {                System.out.println(&quot;按钮进行了长按&quot;);                return true; //返回true后就不会再触发短按事件            }        });        button4.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                System.out.println(&quot;按钮进行了短按&quot;);                           }        });</code></pre><h1 id="setOnTouchListener事件，滑动事件"><a href="#setOnTouchListener事件，滑动事件" class="headerlink" title="setOnTouchListener事件，滑动事件"></a>setOnTouchListener事件，滑动事件</h1><pre><code class="javascript">final Button button4 = (Button)findViewById(R.id.button4);        ViewGroup viewGroup = (ViewGroup) findViewById(R.id.vg1);        viewGroup.setOnTouchListener(new OnTouchListener() {                   public boolean onTouch(View v, MotionEvent event) {                int eventType = event.getAction();                if (eventType == MotionEvent.ACTION_DOWN) {                    button4.setX(event.getX());                    button4.setY(event.getY());                    System.out.println(&quot;down…&quot;);                }else if (eventType == MotionEvent.ACTION_MOVE) {                    button4.setX(event.getX());                    button4.setY(event.getY());                    System.out.println(&quot;move…&quot;);                }else if (eventType==MotionEvent.ACTION_UP) {             &amp;#160;      System.out.println(&quot;up…&quot;);                }                return true;            }        });</code></pre><h1 id="setOnKeyListener-监听键盘按键操作"><a href="#setOnKeyListener-监听键盘按键操作" class="headerlink" title="setOnKeyListener 监听键盘按键操作"></a>setOnKeyListener 监听键盘按键操作</h1><pre><code class="javascript">button4.setOnKeyListener(new OnKeyListener() {            @Override            public boolean onKey(View v, int keyCode, KeyEvent event) {                //a:29 s:47 d:32 w:51                if (keyCode == 29) {                    button4.setX(button4.getX()-10);                }else if (keyCode == 47) {                    button4.setY(button4.getY()+10);                }else if (keyCode == 32) {                    button4.setX(button4.getX()+10);                }else if (keyCode == 51) {                    button4.setY(button4.getY()-10);                }else {                }                return false;            }        });</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>没事别蹭wifi-告诉你公共的wifi有多不安全</title>
      <link href="/article/1298.html"/>
      <url>/article/1298.html</url>
      <content type="html"><![CDATA[<p>经常看到一些朋友每到一个地方就先找wifi，没有密码就直接上了！汗……</p><p>今天通过两个小工具来显示一下公共wifi的安全隐患（爱蹭网的代价）</p><h1 id="工具：wireshark与cain"><a href="#工具：wireshark与cain" class="headerlink" title="工具：wireshark与cain"></a>工具：wireshark与cain</h1><h1 id="下载：wireshark"><a href="#下载：wireshark" class="headerlink" title="下载：wireshark"></a>下载：wireshark</h1><blockquote><p><a href="https://www.wireshark.org/download.html" title="https://www.wireshark.org/download.html" target="_blank" rel="noopener">https://www.wireshark.org/download.html</a><br>Cain &amp; Abel <a href="http://www.oxid.it/cain.html" title="http://www.oxid.it/cain.html" target="_blank" rel="noopener">http://www.oxid.it/cain.html</a> (被墙) 百度网盘链接：<a href="http://pan.baidu.com/s/18kshg" target="_blank" rel="noopener">http://pan.baidu.com/s/18kshg</a> 密码：9owu</p><p>md5:EA2EF30C99ECECB1EDA9AA128631FF31 sha1:82407EAF6437D6956F63E85B28C0EC6CA58D298A  </p></blockquote><p>如果没有校验工具，我写了一个python脚本来校验 链接：<a href="http://pan.baidu.com/s/1i3j93sp" target="_blank" rel="noopener">http://pan.baidu.com/s/1i3j93sp</a> 密码：h6gz<br><a id="more"></a></p><h1 id="使用Cain进行arp欺骗"><a href="#使用Cain进行arp欺骗" class="headerlink" title="使用Cain进行arp欺骗"></a>使用Cain进行arp欺骗</h1><p>&#160;&#160;&#160; 打开Cain主界面，先点击上面的小网卡标识，然后再点击那个’+’ 号</p><p><a href="/image/2015/02/image.png"><img src="/image/2015/02/image.png" alt="image" title="image"></a> </p><p>默认就行了，它会根据网关进行扫描活动的主机</p><p><a href="/image/2015/02/image1.png"><img src="/image/2015/02/image1.png" alt="image" title="image"></a> </p><p>&#160;</p><p>可以看到，在和我电脑同网段的有两个三星手机（其中一个是我的）和一台电脑</p><p><a href="/image/2015/02/image2.png"><img src="/image/2015/02/image2.png" alt="image" title="image"></a></p><p>&#160;</p><p>点击下面的arp图标</p><p><a href="/image/2015/02/image3.png"><img src="/image/2015/02/image3.png" alt="image" title="image"></a>&#160; </p><p>接着先点击上面的列表的空白地方，再点击’+ ’号，左边选择要监听的IP，右边选择网关的IP，这里是192.168.1.1（也就是路由器的地址）</p><p><a href="/image/2015/02/image4.png"><img src="/image/2015/02/image4.png" alt="image" title="image"></a> </p><p>点击OK，回到主界面，这时点击那个小雷达标识开始进行arp欺骗</p><p><a href="/image/2015/02/image5.png"><img src="/image/2015/02/image5.png" alt="image" title="image"></a> </p><h1 id="打开wireshark进行抓包"><a href="#打开wireshark进行抓包" class="headerlink" title="打开wireshark进行抓包"></a>打开wireshark进行抓包</h1><p>选择capture-&gt;interfaces…</p><p><a href="/image/2015/02/image6.png"><img src="/image/2015/02/image6.png" alt="image" title="image"></a> </p><p>选择进行监听的网卡（也就是你进行上网的网卡），点击strat</p><h1 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h1><p>我这里抓了我手机上网的包，刷了下微博，看了眼朋友圈，并且用手机里的浏览器访问了我的个人博客<a href="http://static.yangyanxing.com" target="_blank" rel="noopener">http://static.yangyanxing.com</a> 并且登录了下后台</p><p>现在来看看这些信息</p><p>在wireshark的显示过滤里写下过滤ip.addr eq 192.168.1.102 &amp;&amp; !dns &amp;&amp; http</p><p>找啊找，找到一条</p><p>125&#160;&#160;&#160; 2015-02-11 21:25:25.275021000&#160;&#160;&#160; 192.168.1.102&#160;&#160;&#160; 180.149.139.248&#160;&#160;&#160; HTTP&#160;&#160;&#160; 916&#160;&#160;&#160; POST /2/push/active?c=android&amp;i=5f61746&amp;s=2602e25d&amp;ua=samsung-GT-I9502<strong>weibo</strong>4.6.2<strong>android</strong>android4.4.2&amp;wm=4209_8001&amp;v_f=2&amp;from=1046295010&amp;gsid=4up8f9e93Tw5PZz2EqMCx8xEv9p&amp;lang=zh_CN&amp;skin=default&amp;oldwm=2468_1001 HTTP/1.1&#160; (application/x-www-form-urlencoded)</p><p>看下它的packet details</p><p>打开HTML Form URL Encoded: application/x-www-form-urlencoded，很多信息，但其实没太多的用，顶多那个uid:2035987583 这个是我的微博ID，</p><p>打开<a href="http://weibo.com/2035987583" title="http://weibo.com/2035987583" target="_blank" rel="noopener">http://weibo.com/2035987583</a> 就到达了我的微博主页了（如果你是个PLMM的话，闷骚的屌丝会通过这样的方式搞到你的微博账号）</p><p><a href="/image/2015/02/image7.png"><img src="/image/2015/02/image7.png" alt="image" title="image"></a> </p><p>如果得到微博账号不算什么的话（毕竟微博还算是个开放的平台，加个粉对于博主来说也不算什么坏事），那么如果能够看到你朋友圈的图片呢？</p><p>继续往下找抓包信息</p><p>会看到这样的包</p><p><a href="/image/2015/02/image8.png"><img src="/image/2015/02/image8.png" alt="image" title="image"></a> </p><p>打开这个包的Hypertext Transfer Protocol</p><p>拖到下面</p><p><a href="/image/2015/02/image9.png"><img src="/image/2015/02/image9.png" alt="image" title="image"></a> </p><p>试着在浏览器里打开这个网址，这个地址就是你朋友圈里朋友发的图片……（汗！）</p><p>如果可以看到朋友圈里的图片也无所谓的话，那么如果能看到你登录的用户与密码呢？</p><p>继续往下看抓到的包，看到我登录我个人博客后台的包</p><p>11695&#160;&#160;&#160; 2015-02-11 21:27:19.177156000&#160;&#160;&#160; 192.168.1.102&#160;&#160;&#160; 118.123.116.226&#160;&#160;&#160; HTTP&#160;&#160;&#160; 121&#160;&#160;&#160; POST /wp-login.php?redirect_to=http%3A%2F%2Fstatic.yangyanxing.com%2F%3Fp%3D1266 HTTP/1.1&#160; (application/x-www-form-urlencoded)</p><p><a href="/image/2015/02/image10.png"><img src="/image/2015/02/image10.png" alt="image" title="image"></a> </p><p>打开packet detail 里面的HTML Form URL Encoded: application/x-www-form-urlencoded</p><p><a href="/image/2015/02/image11.png"><img src="/image/2015/02/image11.png" alt="image" title="image"></a> </p><p>username 与password已经明文获得到了。。。</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>如果仔细分析包，还能分析出更多有用的信息，在进行arp过程中，手机上没有任何异常，这下知道免费蹭网有多大的隐患了吧？所以没事别想着瞎蹭网，除非你对你要连接的wifi充分的了解与信任。</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>appium简明教程(转)</title>
      <link href="/article/1266.html"/>
      <url>/article/1266.html</url>
      <content type="html"><![CDATA[<h3 id="乙醇的自动化教程写的挺好的，以下是转自他的cnblogs上面的博客"><a href="#乙醇的自动化教程写的挺好的，以下是转自他的cnblogs上面的博客" class="headerlink" title="乙醇的自动化教程写的挺好的，以下是转自他的cnblogs上面的博客"></a><a href="http://www.cnblogs.com/nbkhic/" target="_blank" rel="noopener">乙醇</a>的自动化教程写的挺好的，以下是转自他的cnblogs上面的博客</h3><h3 id="appium简明教程（1）——appium和它的哲学世界"><a href="#appium简明教程（1）——appium和它的哲学世界" class="headerlink" title="appium简明教程（1）——appium和它的哲学世界"></a><a href="http://www.cnblogs.com/nbkhic/p/3803804.html" target="_blank" rel="noopener">appium简明教程（1）——appium和它的哲学世界</a></h3><h3 id="什么是appium？"><a href="#什么是appium？" class="headerlink" title="什么是appium？"></a>什么是appium？</h3><p>下面这段介绍来自于appium的官网。</p><blockquote><p>Appium is an open-source tool you can use to automate mobile native, mobile web, and mobile hybrid applications on iOS and Android platforms. “Mobile native apps” are those written using the iOS or Android SDKs. “Mobile web apps” are web apps accessed using a mobile browser (Appium supports Safari on iOS and Chrome on Android). “Mobile hybrid apps” have a native wrapper around a “webview” – a native control that enables interaction with web content. Projects like <a href="http://phonegap.com/" target="_blank" rel="noopener">Phonegap</a>, for example, make it easy to build apps using web technologies that are then bundled into a native wrapper – these are hybrid apps.</p><p>Importantly, Appium is “cross-platform”: it allows you to write tests against multiple platforms (iOS, Android), using the same API. This enables a large or total amount of code reuse between iOS and Android testsuites.<br>我们可以从上面的介绍里获得这样的一些信息：</p></blockquote><ul><li>1，appium是开源的移动端自动化测试框架；</li><li>2，appium可以测试原生的、混合的、以及移动端的web项目；</li><li>3，appium可以测试ios，android应用（当然了，还有firefox os）；</li><li><p>4，appium是跨平台的，可以用在osx，windows以及linux桌面系统上；<br>appium的哲学<a id="more"></a></p><blockquote><p>Appium was designed to meet mobile automation needs according to a certain philosophy. The key points of this philosophy can be stated as 4 requirements:</p><ol><li>You shouldn’t have to recompile your app or modify it in any way in order to automate it.</li><li>You shouldn’t be locked into a specific language or framework to write and run your tests.</li><li>A mobile automation framework shouldn’t reinvent the wheel when it comes to automation APIs.</li><li>A mobile automation framework should be open source, in spirit and practice as well as in name!<br>appium的设计哲学是这样的：</li></ol></blockquote></li><li><p>1，不需要为了自动化而且重新编译或修改测试app；</p></li><li>2，不应该让移动端自动化测试限定在某种语言和某个具体的框架；也就是说任何人都可以使用自己最熟悉最顺手的语言以及框架来做移动端自动化测试；</li><li>3，不要为了移动端的自动化测试而重新发明轮子，重新写一套惊天动地的api；也就是说webdriver协议里的api已经够好了，拿来改进一下就可以了；</li><li>4，移动端自动化测试应该是开源的；</li></ul><h3 id="appium的技术架构"><a href="#appium的技术架构" class="headerlink" title="appium的技术架构"></a>appium的技术架构</h3><ul><li>OS: Apple’s <a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/UIAutomationRef/_index.html" target="_blank" rel="noopener">UIAutomation</a></li><li>Android 4.2+: Google’s <a href="http://developer.android.com/tools/help/uiautomator/index.html" target="_blank" rel="noopener">UiAutomator</a></li><li>Android 2.3+: Google’s <a href="http://developer.android.com/reference/android/app/Instrumentation.html" target="_blank" rel="noopener">Instrumentation</a>. (Instrumentation support is provided by bundling a separate project, <a href="http://selendroid.io/" target="_blank" rel="noopener">Selendroid</a>)</li></ul><h3 id="appium的设计思想"><a href="#appium的设计思想" class="headerlink" title="appium的设计思想"></a>appium的设计思想</h3><blockquote><p>We meet requirement #2 by wrapping the vendor-provided frameworks in one API, the<a href="http://docs.seleniumhq.org/projects/webdriver/" target="_blank" rel="noopener">WebDriver</a> API. WebDriver (aka “Selenium WebDriver”) specifies a client-server protocol (known as the <a href="https://code.google.com/p/selenium/wiki/JsonWireProtocol" target="_blank" rel="noopener">JSON Wire Protocol</a>). Given this client-server architecture, a client written in any language can be used to send the appropriate HTTP requests to the server. There are already clients written in every popular programming language. This also means that you’re free to use whatever test runner and test framework you want; the client libraries are simply HTTP clients and can be mixed into your code any way you please. In other words, Appium &amp; WebDriver clients are not technically “test frameworks” – they are “automation libraries”. You can manage your test environment any way you like!</p><p>We meet requirement #3 in the same way: WebDriver has become the de facto standard for automating web browsers, and is a <a href="https://dvcs.w3.org/hg/webdriver/raw-file/tip/webdriver-spec.html" target="_blank" rel="noopener">W3C Working Draft</a>. Why do something totally different for mobile? Instead we have <a href="https://code.google.com/p/selenium/source/browse/spec-draft.md?repo=mobile" target="_blank" rel="noopener">extended the protocol</a> with extra API methods useful for mobile automation.</p><p>It should be obvious that requirement #4 is a given – you’re reading this because <a href="https://github.com/appium/appium" target="_blank" rel="noopener">Appium is open source</a>.<br>首先，为了能够实现哲学里描述的第2条，也就是<strong>不应该让移动端自动化测试限定在某种语言和某个具体的框架；也就是说任何人都可以使用自己最熟悉最顺手的语言以及框架来做移动端自动化测试</strong>；appium选择了client-server的设计模式。只要client能够发送http请求给server，那么的话client用什么语言来实现都是可以的，这就是appium及webdriver如何做到支持多语言的；</p></blockquote><p>其次，为了能够实现<strong>不要为了移动端的自动化测试而重新发明轮子，重新写一套惊天动地的api；也就是说webdriver协议里的api已经够好了，拿来改进一下就可以了；</strong>这个思想，appium扩展了webdriver的协议，没有自己重新去实现一套。这样的好处是以前的webdriver api能够直接被继承过来，以前的webdriver各种语言的binding都可以拿来就用，省去了为每种语言开发一个client的工作量；</p><p>最后appium当然是开源的，这也实现了哲学思想里的最后一点。</p><h3 id="appium简明教程（2）——appium的基本概念"><a href="#appium简明教程（2）——appium的基本概念" class="headerlink" title="appium简明教程（2）——appium的基本概念"></a><a href="http://www.cnblogs.com/nbkhic/p/3803830.html" target="_blank" rel="noopener">appium简明教程（2）——appium的基本概念</a></h3><h3 id="Client-Server-Architecture"><a href="#Client-Server-Architecture" class="headerlink" title="Client/Server Architecture"></a><strong>Client/Server Architecture</strong></h3><p>appium的核心其实是一个暴露了一系列REST API的server。</p><p>这个server的功能其实很简单：监听一个端口，然后接收由client发送来的command。翻译这些command，把这些command转成移动设备可以理解的形式发送给移动设备，然后移动设备执行完这些command后把执行结果返回给appium server，appium server再把执行结果返回给client。</p><p>在这里client其实就是发起command的设备，一般来说就是我们代码执行的机器，执行appium测试代码的机器。狭义点理解，可以把client理解成是代码，这些代码可以是java/ruby/python/js的，只要它实现了webdriver标准协议就可以。</p><p>这样的设计思想带来了一些好处：</p><ul><li>1，可以带来多语言的支持；</li><li>2，可以把server放在任意机器上，哪怕是云服务器都可以；（是的，appium和webdriver天生适合云测试）</li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a><strong>Session</strong></h3><p>session就是一个会话，在webdriver/appium，你的所有工作永远都是在session start后才可以进行的。一般来说，通过POST /session这个URL，然后传入<strong>Desired Capabilities</strong>就可以开启session了。</p><p>开启session后，会返回一个全局唯一的session id，以后几乎所有的请求都必须带上这个session id，因为这个seesion id代表了你所打开的浏览器或者是移动设备的模拟器。</p><p>进一步思考一下，由于session id是全局唯一，那么在同一台机器上启动多个session就变成了可能，这也就是selenium gird所依赖的具体理论根据。</p><p>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</p><p><strong>Desired Capabilities</strong></p><p>Desired Capabilities携带了一些配置信息。从本质上讲，这个东东是key-value形式的对象。你可以理解成是java里的map，python里的字典，ruby里的hash以及js里的json对象。实际上Desired Capabilities在传输时就是json对象。</p><p>Desired Capabilities最重要的作用是告诉server本次测试的上下文。这次是要进行浏览器测试还是移动端测试？如果是移动端测试的话是测试android还是ios，如果测试android的话那么我们要测试哪个app？ server的这些疑问Desired Capabilities都必须给予解答，否则server不买账，自然就无法完成移动app或者是浏览器的启动。</p><p>具体例子如下：</p><blockquote><p>For example, we might set the <code class="text">platformName</code> capability to <code class="text">iOS</code> to tell Appium that we want an iOS session, rather than an Android one. Or we might set the <code class="text">safariAllowPopups</code>capability to <code class="text">true</code> in order to ensure that, during a Safari automation session, we’re allowed to use JavaScript to open up new windows. See the <a href="http://appium.io/slate/en/v1.1.0/?ruby#caps.md" target="_blank" rel="noopener">capabilities doc</a> for the complete list of capabilities available for Appium</p></blockquote><h3 id="Appium-Server"><a href="#Appium-Server" class="headerlink" title="Appium Server"></a><strong>Appium Server</strong></h3><p>这就是每次我们在命令行用appium命令打开的东西。</p><h3 id="Appium-Clients"><a href="#Appium-Clients" class="headerlink" title="Appium Clients"></a><strong>Appium Clients</strong></h3><p>由于原生的webdriver api是为web端设计的，因此在移动端用起来会有点不伦不类。appium官方提供了一套appium client，涵盖多种语言ruby/java/python，在我看来ruby client是实现最好的。在测试的时候，一般要使用这些client库去替换原生的webdriver库。这实际上不是替换，算是client对原生webdriver进行了一些移动端的扩展，加入了一些方便的方法，比如swipe之类，appium client让我们可以更方便的写出可读性更好的测试用例。</p><h3 id="Appium-app-Appium-exe"><a href="#Appium-app-Appium-exe" class="headerlink" title="Appium.app, Appium.exe"></a><strong>Appium.app, Appium.exe</strong></h3><p>appium server的GUI版本，前者用在osx上，后者是windows上。可视化、不需要装node，可以看app的UI结构是这个东东的卖点。</p><h3 id="appium简明教程（3）——appium的安装windows版"><a href="#appium简明教程（3）——appium的安装windows版" class="headerlink" title="appium简明教程（3）——appium的安装windows版"></a><a href="http://www.cnblogs.com/nbkhic/p/3803883.html" target="_blank" rel="noopener">appium简明教程（3）——appium的安装windows版</a></h3><p>appium的哲学里有一条就是不重新发明轮子。同样，官方已经有明确的安装步骤了，因此在这里纯属搬砖。</p><p><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md" target="_blank" rel="noopener">原文地址</a></p><p>感谢testerhome的辛勤翻译。</p><p>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</p><h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>如果你在windows上安装appium，你没法使用预编译专用于OS X的.app文件，你也将不能测试IOS apps，因为appium依赖OS X专用的库来支持IOS测试。这意味着你只能通过在mac上来运行IOS的app测试。这点限制挺大。</p><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md#%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85" target="_blank" rel="noopener"></a>开始安装</h4><ol><li>安装<a href="http://nodejs.org/download/" target="_blank" rel="noopener">nodejs</a> 0.8版本及以上, 通过官方的安装程序来安装。</li><li>安装android的sdk包，(<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="noopener">http://developer.android.com/sdk/index.html</a>), 运行依赖sdk中的’android’工具。并确保你安装了Level17或以上的版本api。设置<code class="text">ANDROID_HOME</code>系统变量为你的Android SDK路径，并把tools platform-tools两个目录加入到系统的Path路径里。因为这里面包含有一些执行命令</li><li>安装java的JDK，并设置<code class="text">JAVA_HOME</code> 变量为你的JDK目录。</li><li>安装<a href="http://ant.apache.org/bindownload.cgi" target="_blank" rel="noopener">Apache Ant</a> 或者直接使用Android Windows SDK自带的ant，地址在eclipseplugins目录，你需要把这个目录加到你的系统PATH变量中</li><li>安装<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Apache Maven</a>. 并且设置M2HOME和M2环境变量，把M2环境变量添加到你的系统PATH变量中。</li><li>安装<a href="http://git-scm.com/download/win" target="_blank" rel="noopener">Git</a>. 确保你安装了windows下的Git，以便可以运行常用的command命令<br>现在，你已经下载安装了所有的依赖，开始运行 reset.bat</li></ol><h5 id="运行Appium"><a href="#运行Appium" class="headerlink" title="运行Appium"></a><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md#%E8%BF%90%E8%A1%8Cappium" target="_blank" rel="noopener"></a>运行Appium</h5><p>要在windows上运行测试用例，你需要先启动Android模拟器或者连接上一个API Level17以上的android真机。 然后在命令行运行appium node .</p><h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md#%E5%A4%87%E6%B3%A8" target="_blank" rel="noopener"></a>备注</h5><ul><li>你必须带上–no-reset和–full-reset标记，以用于windows上的android</li><li>有一个硬件加速模拟器用于android，但是它有自己的一些限制，如果你想了解更多，请参考<a href="https://github.com/appium/appium/blob/master/docs/cn/android-hax-emulator.cn.md" target="_blank" rel="noopener">页面</a></li><li>确保在你的AVD的<code class="text">config.ini</code>中有一个配置项为<code class="text">hw.battery=yes</code></li></ul><h5 id="最简略的安装方式"><a href="#最简略的安装方式" class="headerlink" title="最简略的安装方式"></a><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md#%E6%9C%80%E7%AE%80%E7%95%A5%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener"></a>最简略的安装方式</h5><p>出于对官方文档的尊重，我按照原文翻译，如下介绍我的安装心得。官方提到的一些工具，其实并不需要安装。 下面介绍我已经测试过的安装和使用过程</p><h5 id="安装appium"><a href="#安装appium" class="headerlink" title="安装appium"></a><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md#%E5%AE%89%E8%A3%85appium" target="_blank" rel="noopener"></a>安装appium</h5><ol><li>安装nodejs<br>2、使用npm安装appium，npm install -g appium</li></ol><p><strong>注意：在某些情况下，appium安装的时候并不会把appium的路径放进系统的PATH里，这时候需要手工去加一下。</strong></p><h5 id="运行appium"><a href="#运行appium" class="headerlink" title="运行appium"></a><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md#%E8%BF%90%E8%A1%8Cappium-1" target="_blank" rel="noopener"></a>运行appium</h5><p>启动appium，直接运行appium 即可。</p><h5 id="更新appium"><a href="#更新appium" class="headerlink" title="更新appium"></a><a href="https://github.com/appium/appium/blob/master/docs/cn/running-on-windows.cn.md#%E6%9B%B4%E6%96%B0appium" target="_blank" rel="noopener"></a>更新appium</h5><p>通过<code class="text">npm install -g appium</code> 来更新appium即可</p><h3 id="appium简明教程（4）——appium-client的安装"><a href="#appium简明教程（4）——appium-client的安装" class="headerlink" title="appium简明教程（4）——appium client的安装"></a><a href="http://www.cnblogs.com/nbkhic/p/3804592.html" target="_blank" rel="noopener">appium简明教程（4）——appium client的安装</a></h3><p>appium client是对webdriver原生api的一些扩展和封装。它可以帮助我们更容易的写出用例，写出更好懂的用例。</p><p>appium client是配合原生的webdriver来使用的，因此二者必须配合使用缺一不可。</p><p>从本节开始，教程的内容将涵盖3个语言，ruby/python/java。</p><p>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</p><h3 id="安装appium-client"><a href="#安装appium-client" class="headerlink" title="安装appium client"></a>安装appium client</h3><h5 id="ruby篇（一定要在线安装）"><a href="#ruby篇（一定要在线安装）" class="headerlink" title="ruby篇（一定要在线安装）"></a>ruby篇（一定要在线安装）</h5><p>ruby的appium client叫做appium lib，为什么是这样就不解释了，总之是历史原因。</p><p>首先update rubygem和bundler(说老实话，真的不需要，但官方文档上这么写)</p><blockquote><p>gem update –system ;<br>gem update bundler</p></blockquote><p>然后使用gem安装</p><blockquote><p>gem uninstall -aIx appium_lib ;(这个也不是必须的)<br>gem install –no-rdoc –no-ri appium_lib</p></blockquote><h5 id="python篇（尽量在线安装）"><a href="#python篇（尽量在线安装）" class="headerlink" title="python篇（尽量在线安装）"></a>python篇（尽量在线安装）</h5><p>推荐使用pip安装</p><blockquote><p>pip install Appium-Python-Client</p></blockquote><p>当然了也可以在Pipy上<a href="https://pypi.python.org/pypi/Appium-Python-Client" target="_blank" rel="noopener">下载源码安装</a></p><blockquote><p>tar -xvf Appium-Python-Client-X.X.tar.gz（windows上用7zip可以解压）<br>cd Appium-Python-Client-X.X<br>python setup.py install</p></blockquote><p>最后，也可以通过github安装（要git客户端）</p><blockquote><p>git clone git@github.com:appium/python-client.git<br>cd python-client<br>python setup.py install</p></blockquote><h5 id="java篇（在线安装）"><a href="#java篇（在线安装）" class="headerlink" title="java篇（在线安装）"></a>java篇（在线安装）</h5><p>java的话用maven安装就可以了</p><blockquote><dependency><br>  <groupid>io.appium</groupid><br>  <artifactid>java-client</artifactid><br>  <version>1.3.0</version><br></dependency></blockquote><p>当然了，也可以自己<a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22io.appium%22%20AND%20a%3A%22java-client%22" target="_blank" rel="noopener">下载jar包</a>，请自行选择最新版本。</p><h3 id="appium简明教程（5）——appium-client方法一览"><a href="#appium简明教程（5）——appium-client方法一览" class="headerlink" title="appium简明教程（5）——appium client方法一览"></a><a href="http://www.cnblogs.com/nbkhic/p/3804611.html" target="_blank" rel="noopener">appium简明教程（5）——appium client方法一览</a></h3><p>appium client扩展了原生的webdriver client方法</p><p>下面以java代码为例，简单过一下appium client提供的适合移动端使用的新方法</p><ul><li>resetApp()</li><li>getAppString()</li><li>sendKeyEvent()</li><li>currentActivity()</li><li>pullFile()</li><li>pushFile()</li><li>pullFolder()</li><li>hideKeyboard()</li><li>runAppInBackground()</li><li>performTouchAction()</li><li>performMultiTouchAction()</li><li>tap()</li><li>swipe()</li><li>pinch()</li><li>zoom()</li><li>getNamedTextField()</li><li>isAppInstalled()</li><li>installApp()</li><li>removeApp()</li><li>launchApp()</li><li>closeApp()</li><li>endTestCoverage()</li><li>lockScreen()</li><li>shake()</li><li>complexFind()</li><li>scrollTo()</li><li>scrollToExact()</li><li>openNotifications()</li><li><p>Context Switching: .context(), .getContextHandles(), getContext())<br>新增的locator</p></li><li><p>findElementByAccessibilityId()</p></li><li>findElementsByAccessibilityId()</li><li>findElementByIosUIAutomation()</li><li>findElementsByIosUIAutomation()</li><li>findElementByAndroidUIAutomator()</li><li><p>findElementsByAndroidUIAutomator()<br>这些方法主要覆盖了3大类：</p></li><li><p>driver扩展：比如增加了resetApp等操作app的方法</p></li><li>action扩展：增加一些移动端的特有的action（怎么描述呢，相当于是移动端 特有的操作），比如swipe，shake(嗯，有了这个方法就可以让代码帮你摇一摇了)等；</li><li>locator扩展：增加了一些移动端专属的定位策略<br>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</li></ul><p>下一节我们开始介绍使用appium启动android模拟器</p><h3 id="appium简明教程（6）——启动appium及android模拟器"><a href="#appium简明教程（6）——启动appium及android模拟器" class="headerlink" title="appium简明教程（6）——启动appium及android模拟器"></a><a href="http://www.cnblogs.com/nbkhic/p/3804637.html" target="_blank" rel="noopener">appium简明教程（6）——启动appium及android模拟器</a></h3><p>一般情况下，我们都从命令行启动appium。</p><p>windows下，dos命令窗口输入</p><blockquote><p>appium</p></blockquote><p>如果该命令报错，那么请重装appium</p><blockquote><p>npm install -g appium</p></blockquote><p>如果安装出错，请自行更换npm源。</p><blockquote><p>npm -g –registry <a href="http://registry.cnpmjs.org" target="_blank" rel="noopener">http://registry.cnpmjs.org</a>  install appium</p></blockquote><p><strong>然后请打开android的模拟器，如果没有请新建一个虚拟设备。请自行解除设备锁定（手动把屏幕解锁了），以防万一。</strong></p><p>下面的代码以启动android原生的计算器程序为例</p><h3 id="ruby篇"><a href="#ruby篇" class="headerlink" title="ruby篇"></a>ruby篇</h3><pre><code class="ruby">require &#39;appium_lib&#39;caps   = { caps:{ platformName: &#39;Android&#39;, appActivity: &#39;.Calculator&#39;, appPackage: &#39;com.android.calculator2&#39; },           appium_lib: { sauce_username: nil, sauce_access_key: nil } }driver = Appium::Driver.new(caps).start_driver</code></pre><p>讨论：可以看出ruby lib里面的Appium::Driver类实际上就是原生的webdriver类的子类，当然了，由于ruby语法灵活，也可以使用monkey patch来实现类似功能。</p><h3 id="python篇"><a href="#python篇" class="headerlink" title="python篇"></a>python篇</h3><pre><code class="python">from appium import webdriverdesired_caps = {}desired_caps[&#39;platformName&#39;] = &#39;Android&#39;desired_caps[&#39;platformVersion&#39;] = &#39;4.2&#39;desired_caps[&#39;deviceName&#39;] = &#39;Android Emulator&#39;desired_caps[&#39;appPackage&#39;] = &#39;com.android.calculator2&#39;desired_caps[&#39;appActivity&#39;] = &#39;.Calculator&#39;driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)</code></pre><p>讨论：webdriver.Remote实际上就是原生webdriver的子类，另外Remote()构造函数的第一个参数中需要显示指定appium server监听的端口</p><h3 id="java篇"><a href="#java篇" class="headerlink" title="java篇"></a>java篇</h3><p><strong>新建java项目时候，请注意将selenium-webdriver以及appium client的jar包导入</strong></p><pre><code class="java">import io.appium.java_client.AppiumDriver;import org.openqa.selenium.By;import org.openqa.selenium.WebElement;import org.openqa.selenium.remote.CapabilityType;import org.openqa.selenium.remote.DesiredCapabilities;DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(CapabilityType.BROWSER_NAME, &quot;&quot;);//这句不是必须的capabilities.setCapability(&quot;deviceName&quot;,&quot;Android Emulator&quot;);capabilities.setCapability(&quot;platformVersion&quot;, &quot;4.4&quot;);capabilities.setCapability(&quot;platformName&quot;,&quot;Android&quot;);capabilities.setCapability(&quot;appPackage&quot;, &quot;com.android.calculator2&quot;);capabilities.setCapability(&quot;appActivity&quot;, &quot;.Calculator&quot;);AppiumDriver driver = new AppiumDriver(new URL(&quot;http://127.0.0.1:4723/wd/hub&quot;), capabilities);</code></pre><p>讨论:AppiumDrvier是原生webdriver的子类。</p><p>在这里我们可以看到，新建driver的时候必须要指定一个DesiredCapabilities 对象，该对象究竟是何方神圣，我们下一节会仔细讲解。</p><h3 id="appium简明教程（7）——Desired-Capabilities详解"><a href="#appium简明教程（7）——Desired-Capabilities详解" class="headerlink" title="appium简明教程（7）——Desired Capabilities详解"></a><a href="http://www.cnblogs.com/nbkhic/p/3805805.html" target="_blank" rel="noopener">appium简明教程（7）——Desired Capabilities详解</a></h3><p>Desired Capabilities在启动session的时候是必须提供的。</p><p>Desired Capabilities本质上是key value的对象，它告诉appium server这样一些事情：</p><ul><li>本次测试是启动浏览器还是启动移动设备？</li><li>是启动andorid还是启动ios？</li><li>启动android时，app的package是什么？</li><li>启动android时，app的activity是什么？<br>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</li></ul><h5 id="Appium的Desired-Capabilities是扩展了webdriver的Desired-Capabilities的，下面的一些通用配置是需要指定的："><a href="#Appium的Desired-Capabilities是扩展了webdriver的Desired-Capabilities的，下面的一些通用配置是需要指定的：" class="headerlink" title="Appium的Desired Capabilities是扩展了webdriver的Desired Capabilities的，下面的一些通用配置是需要指定的："></a>Appium的Desired Capabilities是扩展了webdriver的Desired Capabilities的，下面的一些通用配置是需要指定的：</h5><ul><li>automationName：使用哪种自动化引擎。appium（默认）还是Selendroid？</li><li>platformName：使用哪种移动平台。<code class="text">iOS</code>, <code class="text">Android</code>, or<code class="text">FirefoxOS？</code></li><li>deviceName：启动哪种设备，是真机还是模拟器？<code class="text">iPhone Simulator</code>, <code class="text">iPad Simulator</code>, <code class="text">iPhone Retina 4-inch</code>, <code class="text">Android Emulator</code>, <code class="text">Galaxy S4</code>, etc…</li><li>app：应用的绝对路径，注意一定是绝对路径。如果指定了appPackage和appActivity的话，这个属性是可以不设置的。另外这个属性和browserName属性是冲突的。</li><li>browserName：移动浏览器的名称。比如Safari’ for iOS and ‘Chrome’, ‘Chromium’, or ‘Browser’ for Android；与app属性互斥。</li><li>udid：物理机的id。比如1ae203187fc012g。</li></ul><h5 id="下面这些属性是android平台特定的："><a href="#下面这些属性是android平台特定的：" class="headerlink" title="下面这些属性是android平台特定的："></a>下面这些属性是android平台特定的：</h5><ul><li>appActivity：待测试的app的Activity名字。比如MainActivity, .Settings。注意，原生app的话要在activity前加个”.”。</li><li>appPackage：待测试的app的java package。比如com.example.android.myApp, com.android.settings。<br>本文主要讨论android平台的appium测试方法和技巧，因此在这里就不列出ios设备特定的属性了。</li></ul><p>更多信息请参考<a href="https://github.com/appium/appium/blob/master/docs/en/caps.md" target="_blank" rel="noopener">官方文档</a></p><p>在这里我们发现，我们经常要获取app的package和activity名字，那么有什么工具可以让我们方便的获取到这些信息呢？下一节讲回答这个问题。</p><h3 id="appium简明教程（8）——那些工具"><a href="#appium简明教程（8）——那些工具" class="headerlink" title="appium简明教程（8）——那些工具"></a><a href="http://www.cnblogs.com/nbkhic/p/3806886.html" target="_blank" rel="noopener">appium简明教程（8）——那些工具</a></h3><h4 id="monitor-bat（hierarchyviewer-bat已经不赞成继续使用了）"><a href="#monitor-bat（hierarchyviewer-bat已经不赞成继续使用了）" class="headerlink" title="monitor.bat（hierarchyviewer.bat已经不赞成继续使用了）"></a>monitor.bat（hierarchyviewer.bat已经不赞成继续使用了）</h4><p>该文件位于your_andriod_sdk_pathtools下面。以乙醇的机器为例，其位于E:adt-bundle-windows-x86-20131030sdktools下。</p><p>该工具可以帮我们找到android控件的content-description，为以后的<code class="text">find_element_by_accessibility_id</code> 定位方法做参数使用。</p><p>关于什么是content-description，可以参考<a href="http://developer.android.com/training/accessibility/accessible-app.html" target="_blank" rel="noopener">官方文档</a>。</p><p><strong>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</strong></p><p>好，露个脸。</p><p><img src="/image/appium1.png" alt=""></p><h4 id="uiautomatorviewer-bat"><a href="#uiautomatorviewer-bat" class="headerlink" title="uiautomatorviewer.bat"></a>uiautomatorviewer.bat</h4><p>该文件位于your_andriod_sdk_pathtools下面。以乙醇的机器为例，其位于E:adt-bundle-windows-x86-20131030sdktools下。</p><p>该工具主要用来查看控件的属性，比如resource id，class name等。</p><p>该工具也可查看被测app的appPackage（Desired Capabilities中使用）。</p><p>爆照。</p><p><img src="/imageappium2.png" alt=""></p><p>好了，是不是感觉还缺了点什么呢？</p><p>确实如此，被测app的appActivity怎么获取呢？</p><p>下一讲我们详细讲解如何获取被测app的appActivity。</p><h3 id="appium简明教程（9）——如何获取android-app的Activity"><a href="#appium简明教程（9）——如何获取android-app的Activity" class="headerlink" title="appium简明教程（9）——如何获取android app的Activity"></a><a href="http://www.cnblogs.com/nbkhic/p/3806951.html" target="_blank" rel="noopener">appium简明教程（9）——如何获取android app的Activity</a></h3><p>有时候在appium的Desired Capabilities中需要指定被测app的appActivity，下面的方法可能会对你有所帮助。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>如有你有待测项目的源码，那么直接查看源码就好。如果没有，那么请联系有源码的同学，这是推荐方法。</p><p><strong>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</strong></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>如果你没有代码，那么可以反编译该app。</p><p>这里将用到2个工具，分别是dex2jar和jd-gui。你可以在<a href="http://pan.baidu.com/s/1bnlHYyz" target="_blank" rel="noopener">这里下载</a>目前为止的最新版本以及示例apk。</p><p>我们以工具包里的ContactManager.apk为例，简单介绍一下反编译的流程。</p><ul><li>1，重命名ContactManager.apk为ContactManager.zip并解压得到文件classes.dex；</li><li>2，解压dex2jar-0.0.9.15.zip，并从命令行进入该文件夹；</li><li><p>3，运行命令<br><pre>d2j-dex2jar.bat path_toclasses.dex</pre><br>在当前文件夹下得到classes-dex2jar.jar；</p></li><li><p>4，解压jd-gui-0.3.6.windows.zip得到文件jd-gui.exe；</p></li><li>5，使用jd-gui.exe打开classes-dex2jar.jar；<br>嗯，好了，可以尽情欣赏了。上图。</li></ul><p><img src="/image/appium3.png" alt=""></p><p>上图所示的ContactManager就是待测app的main activity。</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>参考testerhome的<a href="http://testerhome.com/topics/1030" target="_blank" rel="noopener">这个帖子</a></p><p>使用log查看大法(嗯，windows上没grep不幸福，好在有powershell的Select-String，可以拿来勉强一用)，直接搬砖。</p><blockquote><p>a、启动待测apk</p><p>b、开启日志输出：adb logcat&gt;D:/log.txt<br>c、关闭日志输出：ctrl+c</p><p>d、查看日志</p><p>找寻：</p><p><pre>Displayed com.mm.android.hsy/.ui.LoginActivity: +3s859ms<br>appPackage = com.mm.android.hsy<br>appActivity = .ui.LoginActivity</pre><br>好了，准备活动做的差不多了。下一节乙醇带大家进行控件定位之旅。</p></blockquote><h3 id="appium简明教程（10）——控件定位基础"><a href="#appium简明教程（10）——控件定位基础" class="headerlink" title="appium简明教程（10）——控件定位基础"></a><a href="http://www.cnblogs.com/nbkhic/p/3807871.html" target="_blank" rel="noopener">appium简明教程（10）——控件定位基础</a></h3><p>狭义上讲，UI级的自动化测试就是让机器代替人去点来点去的过程。</p><p>但机器去点什么（点上面还是点左边），怎么点（是长按还是轻触），这些东西是必须由代码的编写者所指示清楚的。</p><p>控件定位就是解决机器点什么的问题的。</p><p>一般说来，我们可以这样告诉机器：去点<strong>登陆按钮</strong>。</p><p>机器很笨，它并不知道什么是<strong>登陆按钮</strong>。因为<strong>登陆按钮</strong>是自然语言的描述。</p><p>如果你让一个人去点登陆按钮，那么他其实也是要经过一系列的脑补以后才可以做这件事的。</p><p>这个脑补的过程还原如下：</p><blockquote><p>这个一定是个按钮</p><p>这个按钮一定在被测的应用上</p><p>这个按钮大概上面有<strong>登陆</strong>这个文字信息</p><p>嗯，还真有一个，那么点吧。<br>这就是人探索性测试的一个简单过程。一般来说，如果你给出的信息不太充分，人类还是可以通过一系列的探索性思维去理解你的描述的。这个属于心理学的问题，不展开解释。</p></blockquote><p>但是机器并不是人，如果你给出的描述不精确的话，机器是不会自发性的进行探索和脑补的。</p><p>因此控件定位就是精确的描述控件特征并告诉机器的过程。</p><p><strong>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</strong></p><p>控件的特征就是控件的属性，我们可以通过上一讲中的uiautomatorviewer去获取。</p><p>在appium的定位世界里，下面这些方法是可以为我们使用的。也就是说，我们通过下面几个约定好的方式，按照webdriver和appium的DSL（自行搜索并理解）进行控件特征的描述和定位。</p><p>继承自webdriver的方法，也就是通过这3个特征可以定位控件</p><ul><li>find by “class” (i.e., ui component type，andorid上可以是android.widget.TextView)</li><li>find by “xpath” (i.e., an abstract representation of a path to an element, with certain constraints，由于appium的xpath库不完备的原因，这个不太推荐)</li><li><p>find by “id”(android上是控件的resource id)<br>由<a href="https://code.google.com/p/selenium/source/browse/spec-draft.md?repo=mobile" target="_blank" rel="noopener">Mobile JSON Wire Protocol</a> 协议中定义的方法，更适合移动设备上的控件定位</p></li><li><p><code class="text">-ios uiautomation</code>: a string corresponding to a recursive element search using the UIAutomation library (iOS-only)</p></li><li><code class="text">-android uiautomator</code>: a string corresponding to a recursive element search using the UiAutomator Api (Android-only)</li><li><code class="text">accessibility id</code>: a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize.<br>在appium 的client对<a href="https://code.google.com/p/selenium/source/browse/spec-draft.md?repo=mobile" target="_blank" rel="noopener">Mobile JSON Wire Protocol</a>中定义的方法进行了封装，使其调用起来更加方便</li></ul><h4 id="ruby篇-1"><a href="#ruby篇-1" class="headerlink" title="ruby篇"></a>ruby篇</h4><pre><code class="ruby">find_element :accessibility_id, &#39;Animation&#39;find_elements :accessibility_id, &#39;Animation&#39;find_element :uiautomator, &#39;new UiSelector().clickable(true)&#39;find_elements :uiautomator, &#39;new UiSelector().clickable(true)&#39;</code></pre><p>当然了，你也可以使用原生的webdriver方法</p><blockquote><p>find_element id: ‘resource_id’</p></blockquote><p>另外，ruby lib里提供了一些非常好用的简便方法来进行控件的定位，好写，好读。</p><ul><li>text(value_or_index) :Find the first TextView that contains value or by index. If int then the TextView at that index is returned.</li><li>button(value_or_index):Find the first button that contains value or by index. If int then the button at that index is returned<br>更多请看<a href="https://github.com/appium/ruby_lib/blob/master/docs/android_docs.md" target="_blank" rel="noopener">这里</a></li></ul><h4 id="python篇-1"><a href="#python篇-1" class="headerlink" title="python篇"></a>python篇</h4><pre><code class="python">el = self.driver.find_element_by_android_uiautomator(&#39;new UiSelector().description(&quot;Animation&quot;)&#39;)self.assertIsNotNone(el)els = self.driver.find_elements_by_android_uiautomator(&#39;new UiSelector().clickable(true)&#39;)self.assertIsInstance(els, list)el = self.driver.find_element_by_accessibility_id(&#39;Animation&#39;)self.assertIsNotNone(el)els = self.driver.find_elements_by_accessibility_id(&#39;Animation&#39;)self.assertIsInstance(els, list)</code></pre><p>总的来说就是在driver里增加了</p><ul><li>find_element_by_accessibility_id</li><li>find_elements_by_accessibility_id</li><li>find_element_by_android_uiautomator</li><li>find_element_by_android_uiautomator<br>等方法</li></ul><h4 id="java篇-1"><a href="#java篇-1" class="headerlink" title="java篇"></a>java篇</h4><p>前面也讲过了，新增了这些方法</p><pre><code class="java">findElementByAccessibilityId()findElementsByAccessibilityId()findElementByIosUIAutomation()findElementsByIosUIAutomation()findElementByAndroidUIAutomator()findElementsByAndroidUIAutomator()</code></pre><p>讨论：从上面可以看出来，python 和 java client对移动端控件定位的封装是比较初级的。ruby lib中封装了很多方便和简洁的方法，因此可以看出，使用ruby lib是优于python和java的选择。当然，如果忽略性能的话。</p><p>下一节我们开始具体看下如何用resource id去定位控件。</p><h3 id="appium简明教程（11）——使用resource-id定位"><a href="#appium简明教程（11）——使用resource-id定位" class="headerlink" title="appium简明教程（11）——使用resource id定位"></a><a href="http://www.cnblogs.com/nbkhic/p/3813792.html" target="_blank" rel="noopener">appium简明教程（11）——使用resource id定位</a></h3><p>上一节乙醇带大家了解了appium的定位策略。实际上appium的控件定位方式是完全遵守webdriver的mobile扩展协议的。</p><p>这一节将分享一下如何使用resource id来定位android策略。</p><p>什么是resource id，这个不属于本文的范畴，大家可以点<a href="http://developer.android.com/guide/topics/resources/accessing-resources.html" target="_blank" rel="noopener">这里</a>了解。</p><p>我们可以有两种方式来使用resource id进行定位：</p><ul><li>使用 findElement(By.id(“resourceId”)) 的方式。这也是原生的webdriver定义的方法，不过竟然在appium的官方文档里没有提及，属于隐藏技；</li><li>使用 find_elements_by_android_uiautomator(‘new UiSelector().resourceId(“the_id”)’) 的方式；关于uiautomator定位后面的教程会展开讲解；<br>从上面的代码片段可以看到，使用 find_element_by_id 的方式进行定位是最简便的。</li></ul><p>那么怎么获取控件的resource id呢，使用uiautomatorviewer就可以了。具体方法如下图所示。</p><p><img src="/image/appium4.gif" alt=""></p><p>现在就以上图所示的android原生计算器程序为例，看一下每种语言是如何实现点击【9】这个按钮的。</p><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p>点击计算器上的【9】这个按钮。该按钮的id是<code class="text">com.android.calculator2:id/digit6</code> 。先甜后苦，从ruby开始。</p><p><strong>本文版权归乙醇所有，欢迎转载，但请注明作者与出处，严禁用于任何商业用途</strong></p><h5 id="Ruby篇"><a href="#Ruby篇" class="headerlink" title="Ruby篇"></a>Ruby篇</h5><pre><code class="ruby">require &#39;appium_lib&#39;caps   = { caps:{ platformName: &#39;Android&#39;, appActivity: &#39;.Calculator&#39;, appPackage: &#39;com.android.calculator2&#39; },           appium_lib: { sauce_username: nil, sauce_access_key: nil, debug: true} }dr = Appium::Driver.new(caps).start_driverdr.find_element(id: &#39;com.android.calculator2:id/digit9&#39;).click</code></pre><h5 id="Python篇"><a href="#Python篇" class="headerlink" title="Python篇"></a>Python篇</h5><pre><code class="python">#coding:utf-8from appium import webdriverfrom time import sleepdesired_caps = {}desired_caps[&#39;platformName&#39;] = &#39;Android&#39;desired_caps[&#39;platformVersion&#39;] = &#39;4.4&#39;desired_caps[&#39;deviceName&#39;] = &#39;Android Emulator&#39;desired_caps[&#39;app&#39;] = &#39;Calculator.apk&#39;desired_caps[&#39;appPackage&#39;] = &#39;com.android.calculator2&#39;desired_caps[&#39;appActivity&#39;] = &#39;.Calculator&#39;dr = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)sleep(3)dr.find_element_by_id(&#39;com.android.calculator2:id/digit9&#39;).click()</code></pre><h5 id="Java篇"><a href="#Java篇" class="headerlink" title="Java篇"></a>Java篇</h5><pre><code class="java">//新建一个FindById类位于info.itest.www package下面package info.itest.www;import io.appium.java_client.AppiumDriver;import java.net.MalformedURLException;import java.net.URL;import org.openqa.selenium.remote.CapabilityType;import org.openqa.selenium.remote.DesiredCapabilities;public class FindById {    public static void main(String args[]) throws MalformedURLException {        DesiredCapabilities cap = new DesiredCapabilities();        cap.setCapability(CapabilityType.BROWSER_NAME, &quot;&quot;);        cap.setCapability(&quot;platformName&quot;, &quot;Android&quot;);        cap.setCapability(&quot;deviceName&quot;, &quot;Android Emulator&quot;);        cap.setCapability(&quot;platformVersion&quot;, &quot;4.4&quot;);        cap.setCapability(&quot;appPackage&quot;, &quot;com.android.calculator2&quot;);        cap.setCapability(&quot;appActivity&quot;, &quot;.Calculator&quot;);        AppiumDriver dr = new AppiumDriver(new URL(&quot;http://127.0.0.1:4723/wd/hub&quot;), cap);        dr.findElement(By.id(&quot;com.android.calculator2:id/digit9&quot;)).click();    }}</code></pre><p>如果读者对webdriver很熟悉的话，那么掌握这个方法是非常简单的。如果对webdriver不熟悉，那么可以参考<a href="https://github.com/easonhan007/webdriver_guide/blob/master/README.md" target="_blank" rel="noopener">乙醇的webdriver实用指南</a>，先学习一下webdriver的基础知识。</p><p>这一节我们写了一些脚本去进行控件定位，在实际的项目中，这些没有任何断言的脚本是基本上无法完成测试用例的功能的。</p><p>先卖个关子，下下一节乙醇将会带大家写第一个appium的测试用例。</p><p>那么下一节我们将学习如何使用class name进行定位。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android官方的uiautomator例子的实现</title>
      <link href="/article/1264.html"/>
      <url>/article/1264.html</url>
      <content type="html"><![CDATA[<p>Android的自动化测试有很多框架，其中uiautomator是google官方提供的黑盒UI相关的自动化测试工具，case使用java写，今天实践了一下<a href="http://developer.android.com/tools/help/uiautomator/UiDevice.html" target="_blank" rel="noopener">官方文档</a>中样例程序，其中还是有一些小问题需要总结一下的。<br>前几天试着使用uiautoamtor在真实的项目中写了一个简单的测试<br><a href="http://www.yangyanxing.com/article/use-uiautomator-for-uitest.html">使用Uiautomator做基于UI界面的测试</a></p><h1 id="使用ADT创建一个java的项目"><a href="#使用ADT创建一个java的项目" class="headerlink" title="使用ADT创建一个java的项目"></a>使用ADT创建一个java的项目</h1><pre><code>在创建项目的时候要加上JUnit与你使用的Android platforms中对应的android.jar与uiautomator.jar</code></pre><p><a href="/image/2014/12/image16.png"><img src="/image/2014/12/image16.png" alt="image" title="image"></a><br><a id="more"></a></p><h1 id="新建一个包-我这里就只叫com"><a href="#新建一个包-我这里就只叫com" class="headerlink" title="新建一个包(我这里就只叫com)"></a>新建一个包(我这里就只叫com)</h1><h1 id="再这个包下创建一个class"><a href="#再这个包下创建一个class" class="headerlink" title="再这个包下创建一个class"></a>再这个包下创建一个class</h1><p>输入以下java代码,代码全是官方文档上的代码，除了最上面的package</p><pre><code class="java">package com;import com.android.uiautomator.core.UiObject;import com.android.uiautomator.core.UiObjectNotFoundException;import com.android.uiautomator.core.UiScrollable;import com.android.uiautomator.core.UiSelector;import com.android.uiautomator.testrunner.UiAutomatorTestCase;public class Runer extends UiAutomatorTestCase {   public void testDemo() throws UiObjectNotFoundException {      // Simulate a short press on the HOME button.      getUiDevice().pressHome();      // We’re now in the home screen. Next, we want to simulate      // a user bringing up the All Apps screen.      // If you use the uiautomatorviewer tool to capture a snapshot      // of the Home screen, notice that the All Apps button’s      // content-description property has the value “Apps”.  We can      // use this property to create a UiSelector to find the button.      UiObject allAppsButton = new UiObject(new UiSelector()         .description(&quot;Apps&quot;));      // Simulate a click to bring up the All Apps screen.      allAppsButton.clickAndWaitForNewWindow();      // In the All Apps screen, the Settings app is located in      // the Apps tab. To simulate the user bringing up the Apps tab,      // we create a UiSelector to find a tab with the text      // label “Apps”.      UiObject appsTab = new UiObject(new UiSelector()         .text(&quot;Apps&quot;));      // Simulate a click to enter the Apps tab.      appsTab.click();      // Next, in the apps tabs, we can simulate a user swiping until      // they come to the Settings app icon.  Since the container view      // is scrollable, we can use a UiScrollable object.      UiScrollable appViews = new UiScrollable(new UiSelector()         .scrollable(true));      // Set the swiping mode to horizontal (the default is vertical)      appViews.setAsHorizontalList();      // Create a UiSelector to find the Settings app and simulate      // a user click to launch the app.      UiObject settingsApp = appViews.getChildByText(new UiSelector()         .className(android.widget.TextView.class.getName()),         &quot;Settings&quot;);      settingsApp.clickAndWaitForNewWindow();      // Validate that the package name is the expected one      UiObject settingsValidation = new UiObject(new UiSelector()         .packageName(&quot;com.android.settings&quot;));      assertTrue(&quot;Unable to detect Settings&quot;,         settingsValidation.exists());      UiObject reportBug = new UiObject(new UiSelector().text(&quot;Sound&quot;));      reportBug.clickAndWaitForNewWindow();      UiObject soundValidation = new UiObject(new UiSelector()      .text(&quot;Volumes&quot;));   assertTrue(&quot;Unable to detect Sound&quot;,   soundValidation.exists());      getUiDevice().pressHome();  }</code></pre><h1 id="使用ant工具生成build-xml"><a href="#使用ant工具生成build-xml" class="headerlink" title="使用ant工具生成build.xml"></a>使用ant工具生成build.xml</h1><p>我这里在使用ADT自已的ant插件时提示</p><pre><code>  Class not found: javac1.8  </code></pre><p>网上查了查，是插件与我java环境不符，下载最新的ant插件就可以了<br><a href="http://ant.apache.org/bindownload.cgi" title="http://ant.apache.org/bindownload.cgi" target="_blank" rel="noopener">http://ant.apache.org/bindownload.cgi</a><br><a href="/image/2014/12/image17.png"><img src="/image/2014/12/image17.png" alt="image" title="image"></a><br>下载这个tar.gz包，解压，然后将apache-ant-1.9.4bin目录添加到环境变量PATH中<br>然后cmd到android sdk的tools目录，使用andrlid list命令，记住你将要在模拟器中运行的(也是你刚刚导入android.jar与uiautomator.jar包时所在的platforms)<br><a href="/image/2014/12/image18.png"><img src="/image/2014/12/image18.png" alt="image" title="image"></a><br>在cmd下使用android create uitest-project -n <name> -t <android-sdk-id> -p <path></path><br>-n 为生成的jar包名称，自已任意定义，<br>-t 为上面查看到的值，我这里是1<br>-p 为输出路径，这里就是刚才创建的java项目所在的路径<br>android create uitest-project -n AutoRunner -t 1 -p D:myAndroidStudyandroidTest<br>然后再cmd进入D:myAndroidStudyandroidTest，使用ant build命令生成AutoRunner.jar文件</android-sdk-id></name></p><h1 id="将这个AutoRunner-jar文件push到模拟器中"><a href="#将这个AutoRunner-jar文件push到模拟器中" class="headerlink" title="将这个AutoRunner.jar文件push到模拟器中"></a>将这个AutoRunner.jar文件push到模拟器中</h1><pre><code>adb push AutoRunner.jar /data/local/tmp</code></pre><h1 id="使用adb-shell-uiautomator-runtest-AutoRunner-jar-–c-com-Runer-使Runer类运行"><a href="#使用adb-shell-uiautomator-runtest-AutoRunner-jar-–c-com-Runer-使Runer类运行" class="headerlink" title="使用adb shell uiautomator runtest AutoRunner.jar –c com.Runer 使Runer类运行"></a>使用adb shell uiautomator runtest AutoRunner.jar –c com.Runer 使Runer类运行</h1><p><a href="/image/2014/12/image19.png"><img src="/image/2014/12/image19.png" alt="image" title="image"></a><br>我的代码里又在官方基础上多了一个点击”sound”的操作与点击Home键操作</p><pre><code class="java">UiObject reportBug = new UiObject(new UiSelector().text(&quot;Sound&quot;));      reportBug.clickAndWaitForNewWindow();      UiObject soundValidation = new UiObject(new UiSelector()      .text(&quot;Volumes&quot;));   assertTrue(&quot;Unable to detect Sound&quot;,   soundValidation.exists());</code></pre>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++获取系统信息与拷贝文件到windows目录下</title>
      <link href="/article/1220.html"/>
      <url>/article/1220.html</url>
      <content type="html"><![CDATA[<pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;void main(){char szSelfName[MAX_PATH] = {0};//定义存储文件的名字的变量char szWindowsPath[MAX_PATH] = {0};//定义winsows路径的变量char szSystemPath[MAX_PATH] = {0};//定义存储system的变量char szTmpPath[MAX_PATH] = {0};GetModuleFileName(NULL,szSelfName,MAX_PATH);//得到文件的名字，NULL的时候是文件自身GetWindowsDirectory(szWindowsPath,MAX_PATH);//得到windows目录GetSystemDirectory(szSystemPath,MAX_PATH);//得到system目录cout&lt;&lt;szSelfName&lt;&lt;endl&lt;&lt;szWindowsPath&lt;&lt;endl&lt;&lt;szSystemPath&lt;&lt;endl;strcat(szWindowsPath,&quot;\123.exe&quot;);//定义拷贝后的名字cout&lt;&lt;szWindowsPath&lt;&lt;endl;cout&lt;&lt;CopyFile(szSelfName,szWindowsPath,FALSE);char szComputerName[MAXBYTE] = {0};//定义存储computer的变量char szUserName[MAXBYTE] = {0};//定义userName存储的变量unsigned long nSize = MAXBYTE;OSVERSIONINFO OsVer;//Before calling the GetVersionEx function, set the dwOSVersionInfoSize member of the OSVERSIONINFO data structure to sizeof(OSVERSIONINFO).OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);GetVersionEx(&amp;OsVer);//将得到的系统信息存储在OsVer中cout&lt;&lt;OsVer.dwMajorVersion&lt;&lt;&quot;.&quot;&lt;&lt;OsVer.dwMinorVersion&lt;&lt;&quot; &quot;&lt;&lt;OsVer.dwPlatformId&lt;&lt;endl;if(OsVer.dwMajorVersion == 6 &amp;&amp; OsVer.dwMinorVersion == 1){cout&lt;&lt;&quot;你的系统是win7&quot;&lt;&lt;endl;}else{cout&lt;&lt;&quot;你的系统不是win7&quot;&lt;&lt;endl;}GetComputerName(szComputerName,&amp;nSize);GetUserName(szUserName,&amp;nSize);cout&lt;&lt;szComputerName&lt;&lt;endl;cout&lt;&lt;szUserName&lt;&lt;endl;</code></pre><a id="more"></a>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++中windows编程基础</title>
      <link href="/article/1216.html"/>
      <url>/article/1216.html</url>
      <content type="html"><![CDATA[<pre><code class="cpp">一、宽字符与多字节字符#include &quot;tchar.h&quot;void main(){TCHAR p[] = _T(&quot;IT学吧&quot;);int l1 = sizeof(p);//I1 T1 学2 吧2 1int l2 = _tcslen(p);int l4 = wcslen(p);//int l3 = strlen(p);return;}</code></pre><p>在多字节字符集中，每个汉字占两个字节，英文字母占一个字节，sizeof(p) = 7 _tcslen(p)=6(字符串长度等于6，I1 T1 学2 吧2)</p><p>在宽字节（unicode）字符集中，所有有字符都是占两个字节 sizeof(p) = 10 _tcslen(p)=4(I1 T1 学1 吧1)<br><a id="more"></a><br>在_tcslen函数中 英文字母每一个都只占一个长度，多字节中，中文占两个，宽字节中，中文占一个</p><p>#define _tcslen&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; wcslen&#160; （宽字节定义 unicode）</p><p>#define _tcslen&#160;&#160;&#160;&#160; strlen （多字节定义）</p><p>总体来说 使用_tcslen可以兼容多字节与宽字节</p><p>一般由_t与_tcs开头的都是兼容的</p><pre><code class="cpp">// ca02windows.cpp : 定义应用程序的入口点。//#include &quot;stdafx.h&quot;#include &quot;ca02windows.h&quot;#include &quot;tchar.h&quot;#include &lt;Windows.h&gt;LRESULT CALLBACK WndProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam){switch (uMsg){case WM_CLOSE:::MessageBox(hwnd, _T(&quot;确认关闭吗？&quot;), _T(&quot;确认关闭吗？&quot;), MB_YESNO);::DestroyWindow(hwnd);break;case WM_DESTROY:::PostQuitMessage(0);break;default:break;}return DefWindowProc(hwnd, uMsg, wParam, lParam);//不自已定义处理函数，使用系统自已的处理方法}int WINAPI _tWinMain(IN HINSTANCE hInstance,IN HINSTANCE hPrevInstance,IN LPTSTR lpCmdLine,IN int nShowCmd){const TCHAR* pszClassName = _T(&quot;ITWnd&quot;);WNDCLASSEX wcex;wcex.cbSize = sizeof(WNDCLASSEX);wcex.style = CS_HREDRAW | CS_VREDRAW;//水平与垂直变化重绘wcex.lpfnWndProc = WndProc;//回调函数wcex.cbClsExtra = 0;wcex.cbWndExtra = 0;wcex.hInstance = hInstance;//handlewcex.hIcon = (HICON)::LoadIcon(NULL, IDI_HAND);//大图标wcex.hIconSm = (HICON)::LoadIcon(NULL, IDI_APPLICATION);//小图标wcex.hbrBackground = (HBRUSH)::GetStockObject(WHITE_BRUSH);//背景wcex.hCursor = (HCURSOR)::LoadCursor(NULL, IDC_ARROW);//光标wcex.lpszMenuName = NULL;//是否有菜单wcex.lpszClassName = pszClassName;//注册的类名，不能重复的BOOL bRet = ::RegisterClassEx(&amp;wcex);//开始注册这个类if (!bRet){::MessageBox(NULL, _T(&quot;注册窗口失败&quot;), _T(&quot;注册窗口&quot;), MB_OK);return FALSE;}HWND hwnd = ::CreateWindowEx(0, pszClassName, _T(&quot;杨彦星kevin&quot;), WS_VISIBLE | WS_OVERLAPPEDWINDOW,CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,NULL, NULL, hInstance, NULL); //开始创建窗口if (!hwnd){::MessageBox(NULL, _T(&quot;创建窗口失败&quot;), _T(&quot;创建窗口&quot;), MB_OK);return FALSE;}::ShowWindow(hwnd, SW_NORMAL);//创建窗口 SW_NORMAL最大化::UpdateWindow(hwnd);//更新窗口//::DestroyWindow()MSG msg;while (::GetMessage(&amp;msg,NULL,NULL,NULL)){::TranslateMessage(&amp;msg);//翻译消息::DispatchMessage(&amp;msg);//调试消息，将消息传给回调函数进行处理}return TRUE;}</code></pre>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>c++语言基础(hello world,数据类型,构造方法,指针的常见错误,常量指针,指针与引用)</title>
      <link href="/article/1212.html"/>
      <url>/article/1212.html</url>
      <content type="html"><![CDATA[<pre><code class="cpp">一、hello world#include&lt;iostream&gt;  这里可以用#include&lt;iostream.h&gt; 加载一个非标准的库，由于.h还没有名字空间的概念，所以之后也就没有使用std的操作using namespace std; 声明定义使用std 名字空间namespace a{     int b = 5;}namespace c{     int b = 8;}int main(){     std::cout&lt;&lt;&quot;我喜欢C++n&quot;;     std::cout&lt;&lt;&quot;五年一班数学成绩n&quot;;     std::cout&lt;&lt;&quot;第一名许凡的成绩t&quot;&lt;&lt;100;     std::cout&lt;&lt;std::endl;     std::cout&lt;&lt;&quot;第二名许凡的成绩t&quot;&lt;&lt;90+8;     std::cout&lt;&lt;std::endl;     std::cout&lt;&lt;&quot;第三名许凡的成绩t&quot;&lt;&lt;(float)5/8;     std::cout&lt;&lt;std::endl;     cout&lt;&lt;&quot;我是没有使用std的&quot;&lt;&lt;endl;     int b = 10;     cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a::b&lt;&lt;&quot; &quot;&lt;&lt;c::b&lt;&lt;endl;     return 0;}</code></pre><a id="more"></a><p>二、数据类型<br>     1. 常量 使用const 关键字定义 const name = “yangyanxing”;<br>     2. 枚举型常量 enum num{zero,one,two,three,four};</p><pre><code class="cpp">     int main(){     enum day{Sunday,Monday,Tuesday,Wednesday,Thurday,Friday,Saturday};     day today; // 使用枚举类型day 创建一个today对象     today = Monday;// 相当于today=1     if (today == Sunday||today == Saturday){          cout&lt;&lt;&quot;今天休息&quot;;     }     else{          cout&lt;&lt;&quot;今天工作&quot;&lt;&lt;endl;     }     return 0;}</code></pre><p>三、构造方法</p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;class rectangel{     public:          //下面这个是构造函数，它没有返回值，也就不用反回值类型          rectangel(int l,int w){length = l;width = w;}          //构造函数可以有多个，以参数不同为区分          rectangel(){cout&lt;&lt;&quot;这里调用无参的构造参数n&quot;;}          //下面定义析构函数，析构函数也是没有返回值，且只能有一个没有参数的，使用~ 与构造函数进行区分          ~rectangel(){cout&lt;&lt;&quot;对象使用完毕，该说bye-bye啦！n&quot;;}          int area(){return length*width;}          int getLength(){return length;}          int getWitdth(){return width;}     private: //私有成员属性不能直接访问，要通过一个公有(public)的方法来返回          int length;          int width;};int main(){     rectangel a(3,4);     cout&lt;&lt;&quot;这个长方形a的长为&quot;&lt;&lt;a.getLength()&lt;&lt;endl;     cout&lt;&lt;&quot;这个长方形a的宽为&quot;&lt;&lt;a.getWitdth()&lt;&lt;endl;     cout&lt;&lt;&quot;这个长方形a的面积为&quot;&lt;&lt;a.area()&lt;&lt;endl;     //这里创建另外一个对象，以无参的形式创建 ,这时它的长和宽将不确定     rectangel b;     cout&lt;&lt;&quot;这个长方形b的长为&quot;&lt;&lt;b.getLength()&lt;&lt;endl;     cout&lt;&lt;&quot;这个长方形b的宽为&quot;&lt;&lt;b.getWitdth()&lt;&lt;endl;     cout&lt;&lt;&quot;这个长方形b的面积为&quot;&lt;&lt;b.area()&lt;&lt;endl;     return 0;}</code></pre><p>四、指针的常见错误</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int main(){     int *p = new int;     *p = 3;     cout&lt;&lt;&quot;初始化p时所指向的内存地址为：&quot;&lt;&lt;p&lt;&lt;endl;     cout&lt;&lt;&quot;将3赋给p的地址后，指针p读取的值为：&quot;&lt;&lt;*p&lt;&lt;endl;     delete p;//将p指针删除，但是并没有将其指向空。删除掉指针其实并没有删除掉该指针               //而是告诉编译器该指针所指向的这块内存区域我不用了，可以被别的变量所使用               //而此时该指针所保存的地址在没有指向空之前还是原来指向的地址     cout&lt;&lt;&quot;删除指针后p所保存的内存地址为：&quot;&lt;&lt;p&lt;&lt;endl;     long *p1 =new long;//这里重新开辟一块新的内存区域，也就是刚才释放掉的内存区域}</code></pre><pre><code class="cpp">将delete应用于指针时,它指向的内存将被释放,如果再一次对该指针使用delete,程序将崩溃,因为删除指针后要将其值设置为0或者NULL(即空指针),将delete用于空指针是安全的.#include &lt;iostream&gt;using namespace std;int main(){    int* p = 0;//初始化时应该将指针赋值为空指针    p = new int;    *p = 9;    cout&lt;&lt;&quot;*p = &quot;&lt;&lt;*p&lt;&lt;endl;    delete p;    p = 0;//or p = NULL;    delete p;//delete p again,不会发生错误    int n;//为了不让屏幕一闪而消失    cin&gt;&gt;n;    return 0;}</code></pre><p>如果delete p后未将p赋值为空指针的话,将会出现迷途指针,这个错误在C++中最难发现,最难解决的问题.迷途指针是指将delete用于指针p后,释放它所指向的内存,但是没有把指针赋值为空指针,这时候p所指向的内存可能供其他程序使用,一旦再一次调用p,因为p所指向的依然是那一块内存,那块内存又被其他程序已经用来,这个导致的结果不可预料,所以在C++中这个迷途指针才是麻烦.</p><p>就好比,我要订一个快餐,在手机上设置了快捷键2,按2就可以拨打400-517-517,快餐电话订快餐,但是后来这个电话号码有其他用途了,例如被设置为投诉电话,或者某人的家庭电话,又或者这个电话变成空号了,我按2快捷键的时候或者拨打到别人家里,别人公司,或者是空号,如果危险的话这个电话就被恐怖分子设置为启动炸弹的电话,一旦有电话打入,某地方的炸弹立刻爆炸,非常危险.所以在400-517-517这个号码变更好,我要把快捷键设置为空,等以后想用时再设置.</p><p>所以呢,delete p之后要将p赋值为空指针</p><p>五、常量指针</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;class A {public:     int get(){return this-&gt;i;}     void set(int x){this-&gt;i=x;}private:     int i;};int main(){     int a = 3;     int *const p = &amp;a;//常量指针，指针所指向的内存地址不能改变，但是内存地址上的值可以改变,定义的时候必须要初始化     a = 4;     A *const p1 = new A;//指向A对象的一个常量指针     //指针为常量，不可改变，但是指针所指的变量或者对象是可以改变的     //p1 = p1+1;     p1-&gt;set(11);     cout&lt;&lt;p1-&gt;get();     return 0;}</code></pre><p>六、指针与引用</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;void swap(int &amp;m,int &amp;n){ //这里的参数是地址     cout&lt;&lt;&quot;交换前m的值为&quot;&lt;&lt;m&lt;&lt;&quot; n的值为:&quot;&lt;&lt;n&lt;&lt;endl;     int c;     c=m;     m=n;     n=c;     cout&lt;&lt;&quot;交换后m的值为&quot;&lt;&lt;m&lt;&lt;&quot; n的值为:&quot;&lt;&lt;n&lt;&lt;endl;}int func(int a,float *b,int *c){     if(a&gt;200||a&lt;=0){          a=0;     }else{          *b = a*a*3.14;          *c = a*a;          a = 1;     }     return a;}//使用按址传递的方式int func2(int a,float &amp;b,int &amp;c){     if(a&gt;200||a&lt;=0){          a=0;     }else{          b = a*a*3.14;          c = a*a;          a = 1;     }     return a;}int main(){     int num = 0;     int &amp;mum = num;//引用即别名，这里是将num取了另外一个名字叫mum     num = 99;     cout&lt;&lt;&quot;mum的值为：&quot;&lt;&lt;mum&lt;&lt;endl;     mum = 100;     cout&lt;&lt;&quot;num的值为:&quot;&lt;&lt;num&lt;&lt;endl;     cout&lt;&lt;&quot;&amp;num:&quot;&lt;&lt;&amp;num&lt;&lt;endl;     cout&lt;&lt;&quot;&amp;mum:&quot;&lt;&lt;&amp;mum&lt;&lt;endl;//它们的内存地址是一样的     cout&lt;&lt;&quot;###################n&quot;;     int b = 999;     mum = b; //其实只是将b的值赋给了mum与num     cout&lt;&lt;&quot;将b赋给mun后的内存地址情况&quot;&lt;&lt;endl;     cout&lt;&lt;&quot;&amp;num:&quot;&lt;&lt;&amp;num&lt;&lt;&quot;:&quot;&lt;&lt;num&lt;&lt;endl;     cout&lt;&lt;&quot;&amp;mum:&quot;&lt;&lt;&amp;mum&lt;&lt;&quot;:&quot;&lt;&lt;mum&lt;&lt;endl;     cout&lt;&lt;&quot;&amp;b  :&quot;&lt;&lt;&amp;b&lt;&lt;&quot;:&quot;&lt;&lt;b&lt;&lt;endl;     cout&lt;&lt;&quot;改变num的值后内存与值的情况&quot;&lt;&lt;endl;     num = 10;     cout&lt;&lt;&quot;&amp;num:&quot;&lt;&lt;&amp;num&lt;&lt;&quot;:&quot;&lt;&lt;num&lt;&lt;endl;     cout&lt;&lt;&quot;&amp;mum:&quot;&lt;&lt;&amp;mum&lt;&lt;&quot;:&quot;&lt;&lt;mum&lt;&lt;endl;     cout&lt;&lt;&quot;&amp;b  :&quot;&lt;&lt;&amp;b&lt;&lt;&quot;:&quot;&lt;&lt;b&lt;&lt;endl; //b的值是不受影响的     cout&lt;&lt;&quot;*******************n&quot;;     int m = 3;     int n = 4;     cout&lt;&lt;&quot;主程序中m的值为：&quot;&lt;&lt;m&lt;&lt;&quot; n的值为：&quot;&lt;&lt;n&lt;&lt;endl;     swap(m,n);//这里传的是m与n的地址     cout&lt;&lt;&quot;swap后m的值为：&quot;&lt;&lt;m&lt;&lt;&quot; n的值为：&quot;&lt;&lt;n&lt;&lt;endl;     cout&lt;&lt;&quot;*******************n&quot;;     cout&lt;&lt;&quot;请输入一个数，将会求出圆的面积与正方形的面积n&quot;;     int r,br;     float cr;     int check;     cin&gt;&gt;r;     check = func(r,&amp;cr,&amp;br);//这样可以通过一个函数来改变三个值 cr br a     if(check){          cout&lt;&lt;&quot;圆的面积为：&quot;&lt;&lt;cr&lt;&lt;&quot;正方形的面积为:&quot;&lt;&lt;br&lt;&lt;endl;     }else{          cout&lt;&lt;&quot;您输入的数字有误n&quot;;          cout&lt;&lt;r&lt;&lt;&quot;   &quot;&lt;&lt;cr&lt;&lt;&quot;   &quot;&lt;&lt;br&lt;&lt;endl;     }     cout&lt;&lt;&quot;请再次输入一个数，将会求出圆的面积与正方形的面积n&quot;;     int x,z;     float y;     cin&gt;&gt;x;     check = func2(x,y,z);//按址传递     if(check){          cout&lt;&lt;&quot;圆的面积为：&quot;&lt;&lt;y&lt;&lt;&quot;正方形的面积为:&quot;&lt;&lt;z&lt;&lt;endl;     }else{          cout&lt;&lt;&quot;您输入的数字有误n&quot;;     }     /*     总的来说，使用按址传递的方法代码上看起来再简洁一些，指针容易写错     */     return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>dev c++安装使用</title>
      <link href="/article/1208.html"/>
      <url>/article/1208.html</url>
      <content type="html"><![CDATA[<p>最近开始接触C++，在练习基本的语法的时候，不想使用臃肿的VS，于是查了下，dev c++为个挺小巧，但麻雀虽小五脏具全，对于基本语法的学习使用已经足够了。</p><p>下载安装，下载还是挺麻烦的，我下载好了共享在360云盘上了，<a href="http://yunpan.cn/cAaf826jiSdie" target="_blank" rel="noopener">http://yunpan.cn/cAaf826jiSdie</a> （提取码：7b0a）这个是有minGW的，安装的时候选择full</p><p>在翻译的时候输出debug，当然你不这样设置的话在以后要调试的时候也会提示你是否设置的 工具–翻译选项</p><a id="more"></a><p>写一个简单的hello world吧</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int main(){cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;return 0;</code></pre><p><a href="/image/2014/12/QQ20141206220554.png"><img src="/image/2014/12/QQ20141206220554_thumb.png" alt="QQ截图20141206220554" title="QQ截图20141206220554"></a></p>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>被潜意识蒙蔽的理性</title>
      <link href="/article/1199.html"/>
      <url>/article/1199.html</url>
      <content type="html"><![CDATA[<p>最近在观察一些事情，发现很多时候我们的理性往往都被潜意识所蒙蔽。</p><p>公司内网中有段时间经常有人发表一些自已的东西被“偷”的帖子，于是在人们脑海中就有一个公司里有很多小偷的意识，自已的东西一旦找不到了，首先想到的就是被别人偷走了，甚至一些人还总发表一些放在冰箱里的食物饮料等被莫名的拿走的帖子，这些人无疑首先说的就是“偷”，遇到这样的事情首先想到的也是被别人拿走了，被别人吃掉了。<br><a id="more"></a><br>后来有一天终于抓到了这个“小偷”，公司的保洁阿姨将冰箱里的看着长时间不吃的甚至变质的东西给仍了，这当中的误会也因此解除，之后也就很少有人再发些自已的吃的被“偷”的帖子。</p><p>另一件事是在公司十一放假前一天，有个人发了个帖子，那天是个周二，在我们公司那天下午是可以领办公用品的，当那个人去行政部领东西的时候，发现没有人，于是回来就在论坛里抱怨说“公司的行政部是不是已经提前放假了？”。</p><p>简单有两件小事，反映出我们在判断一件事的时候，总是先假定事情是一个什么的结果与原因，一旦表象所反映的内容达到某个状态，于是我们就更加确定脑海里的潜意识的判断，你到行政部没有看到人，那么你为什么不等一等，或者她只是去厕所了呢，或者只是出去接个电话了呢，为什么一定要认为她们提前下班了呢？</p><p>生活中这样的例子也挺多，看到一个美女，潜意识里认为她一定得是一个高冷的人，当你想要和她接触她对你爱搭不理或者表现出讨厌的时候，你会不会到处去说她是个高攀不起的人。</p><p>两个相恋的人在一起，男的脑海里一直认为女方家里在未来一定要房子与车子，哪天真的分开了，男的未免在心里会认为一定是她家里看不起他这样的穷小子。</p><p>生活在一起的两个人，当一个人总是在潜意识里认识老公有外遇了，那么真有一天男的回来晚了或者一夜未归，第二天肯定免不了一通吵架。</p><p>工作中，你脑海里一开始认为另外一个同事总和你过不去，找你岔，哪天你可能真的因为你的错误，他说了你什么，你心里想的可能会是他怎么总和我过不去呢，我非得整他一次。</p><p>潜意识里官员就应该腐败，公务员就应该靠关系。</p><p>脑海中里的潜意识行为真是可怕，它蒙蔽了太多的真实，蒙蔽了太多的理性。</p><p>其实只要内心强大，你也可以拥有一双慧眼，透到现象看到事情的本质。</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>七牛cdn缓存导致ajax评论失效</title>
      <link href="/article/1151.html"/>
      <url>/article/1151.html</url>
      <content type="html"><![CDATA[<p>在使用了七牛的CDN后，发现在评论的时候会出现405错误</p><blockquote><p>{“error”:”get from image source failed: E405”} </p></blockquote><p>在网上查了查，这个问题出现的还挺多的，解决办法是改<span style="color: #000000;">comments-ajax.js这个文件</span></p><p>1.在comments-ajax.js文件中下面这段程序的后面（参考<a href="http://www.tennfy.com/503.html" target="_blank" rel="noopener">cdn缓存导致ajax评论失效</a>）：</p><pre><code class="javascript">var i = 0, got = -1, len = document.getElementsByTagName(&#39;script&#39;).length;while ( i &lt;= len &amp;&amp; got == -1){    var js_url = document.getElementsByTagName(&#39;script&#39;)[i].src,            got = js_url.indexOf(&#39;comments-ajax.js&#39;); i++ ;}</code></pre><a id="more"></a><p>添加一句话：</p><blockquote><p>js_url = js_url.replace(‘static.yangyanxing.com’,www.yangyanxing.com’);</p></blockquote><p>其中，chengchunjie.qiniu.com换成自己的七牛云存储提供的二级域名，chengchunjie.com替换成自己的域名。</p><p>2.登陆七牛云存储，进入自己的网站静态存储的空间，打开内容，找到自己已经缓存的原来的comments-ajax.js文件，将修改过的comments-ajax.js上传上去。（这个最主要是解决，自己网站上comments-ajax.js更改，但七牛的CDN上并没有更改导致的一段时间评论还是无法提交成功的问题）</p><p>注意：上传的时候，在设置路径前缀处，一定要自定义前缀，wp-content/themes/你的主题名称/，否则上传无效。</p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql与mongodb命令对比</title>
      <link href="/article/1128.html"/>
      <url>/article/1128.html</url>
      <content type="html"><![CDATA[<p>之前一直在使用mysql,最近开始接触mongodb，觉得还是有一些相似的地方，只是相应的命令不大一样，这里做下记录，对比记应该相对简单一些,mongodb使用的是python的接口</p><p>连接：<br>mysql: mysql -h localhost -u username -p<br>mongodb:con = pymongo.Connection(‘localhost’,27017)<br>显示数据库<br>mysql:show databases;<br>mongodb:con.database_names()<br>使用某个数据库<br>mysql:use database;<br>mongodb:db = con[‘database’] or con.database 没有将会创建<br>显示所有的表<br>mysql:show tables;<br>mongodb:db.collection_names()<br>使用某个表(mongodb中称为colection)<br>mysql: use table;<br>mongodb:col = db.collection or db[‘collection’] 没有将会创建<br>遍历表中的内容<br>mysql: select * from table[where…]<br>mongodb: for i in col.find():print i<br>for i in col.find_one({‘key’:’value’}):print i 返回值是字典<br>向表中插入值<br>mysql: insert into table valuses(……)<br>mongodb:col.insert({‘key’:’value’,…})<br>d = {‘key’:’value’}<br>col.insert(d)</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修改Gwibber脚本成功添加新浪微博账户（解决一直正在认证的问题）</title>
      <link href="/article/1115.html"/>
      <url>/article/1115.html</url>
      <content type="html"><![CDATA[<p>Gwibber是linux下使用python基于 WebKit 和 GTK的客户端，其实本身功能大大陆基本上都用不了，只有一个新浪微博能用，但是里面的api认证还是用的几年前的oauth1,新浪早就将其停用了，现在 都采用的是oauth2认证，但是这个客户端还没有更新，在使用的时候会显示一直在认证页面。</p><p>其实本来也不想用它来发看微博，只是想完成认证，后面经过修改以后主界面报异常，不管了，这个客户端总之太挫了……</p><p>使用官方推荐的由@<a href="http://weibo.com/206069909" target="_blank" rel="noopener">廖雪峰</a> 写的python SDK，<a href="https://github.com/michaelliao/sinaweibopy/wiki/OAuth2-HOWTO" target="_blank" rel="noopener">https://github.com/michaelliao/sinaweibopy/wiki/OAuth2-HOWTO</a></p><p>将python SDK中的weibo.py放到<strong>init</strong>.py同级目录下<br> <a id="more"></a></p><p>修改/usr/share/gwibber/plugins/sina/gtk/sina 下的<strong>init</strong>.py</p><pre><code class="python">from gi.repository.Gtk import Builderimport urllib, urllib2, json, urlparse, uuidfrom oauth import oauthfrom weibo import APIClientfrom gwibber.microblog.util import resourcesfrom gwibber.microblog.util.keyring import get_from_keyringimport gettextfrom gettext import gettext as _if hasattr(gettext, &#39;bind_textdomain_codeset&#39;):    gettext.bind_textdomain_codeset(&#39;gwibber&#39;,&#39;UTF-8&#39;)gettext.textdomain(&#39;gwibber-service-sina&#39;)import sina.utilsGdk.threads_init()sigmeth = oauth.OAuthSignatureMethod_HMAC_SHA1()class AccountWidget(Gtk.VBox):  &quot;&quot;&quot;AccountWidget: A widget that provides a user interface for configuring sina accounts in Gwibber  &quot;&quot;&quot;  def __init__(self, account=None, dialog=None):    &quot;&quot;&quot;Creates the account pane for configuring Sina accounts&quot;&quot;&quot;    Gtk.VBox.__init__( self, False, 20 )    self.ui = Gtk.Builder()    self.ui.set_translation_domain (&quot;gwibber&quot;)    self.ui.add_from_file (resources.get_ui_asset(&quot;gwibber-accounts-sina.ui&quot;))    self.ui.connect_signals(self)    self.vbox_settings = self.ui.get_object(&quot;vbox_settings&quot;)    self.pack_start(self.vbox_settings, False, False, 0)    self.show_all()    self.account = account or {}    self.dialog = dialog    self.window = dialog.dialog    has_access_token = False    has_secret_key = False    if self.account.has_key(&quot;id&quot;):      has_secret_key = get_from_keyring(self.account[&#39;id&#39;], &#39;secret_token&#39;) is not None    try:      if self.account.has_key(&quot;access_token&quot;) and self.account.has_key(&quot;secret_token&quot;) and self.account.has_key(&quot;username&quot;) and has_secret_key and not self.dialog.condition:        self.ui.get_object(&quot;hbox_sina_auth&quot;).hide()        self.ui.get_object(&quot;sina_auth_done_label&quot;).set_label(_(&quot;%s has been authorized by Sina&quot;) % self.account[&quot;username&quot;])        self.ui.get_object(&quot;hbox_sina_auth_done&quot;).show()      else:        self.ui.get_object(&quot;hbox_sina_auth_done&quot;).hide()        if self.dialog.ui:          self.dialog.ui.get_object(&#39;vbox_create&#39;).hide()    except:      self.ui.get_object(&quot;hbox_sina_auth_done&quot;).hide()      if self.dialog.ui:        self.dialog.ui.get_object(&quot;vbox_create&quot;).hide()  def on_sina_auth_clicked(self, widget, data=None):    client = APIClient(app_key=&#39;1472971394&#39;,app_secret=&#39;49443ea72f7545486143f3f074b0b66e&#39;,redirect_uri=&quot;http://gwibber.com/0/auth.html&quot;)    url = client.get_authorize_url()    self.winsize = self.window.get_size()    web = WebKit.WebView()    web.get_settings().set_property(&quot;enable-plugins&quot;, False)    web.get_settings().set_property(&quot;enable-developer-extras&quot;, False)    web.load_html_string(_(&quot;&lt;p&gt;Please wait...&lt;/p&gt;&quot;), &quot;file:///&quot;)    self.consumer = oauth.OAuthConsumer(*sina.utils.get_sina_keys())    request = oauth.OAuthRequest.from_consumer_and_token(self.consumer, http_method=&quot;POST&quot;,        callback=&quot;http://gwibber.com/0/auth.html&quot;,        http_url=&quot;http://api.t.sina.com.cn/oauth/request_token&quot;)    request.sign_request(sigmeth, self.consumer, token=None)    tokendata = urllib2.urlopen(request.http_url, request.to_postdata()).read()    self.token = oauth.OAuthToken.from_string(tokendata)    # url = &quot;http://api.t.sina.com.cn/oauth/authorize?oauth_token=&quot; + self.token.key    web.load_uri(url)    web.set_size_request(550, 400)    web.connect(&quot;title-changed&quot;, self.on_sina_auth_title_change)    self.scroll = Gtk.ScrolledWindow()    self.scroll.add(web)    self.scroll.set_size_request(550, 400)    self.pack_start(self.scroll, True, True, 0)    self.show_all()    self.dialog.infobar.hide()    self.ui.get_object(&quot;vbox1&quot;).hide()    self.ui.get_object(&quot;vbox_advanced&quot;).hide()    self.dialog.infobar.set_message_type(Gtk.MessageType.INFO)  def on_sina_auth_title_change(self, web=None, title=None, data=None):    saved = False    if title.get_title() == &quot;Success&quot;:      if hasattr(self.dialog, &quot;infobar_content_area&quot;):        for child in self.dialog.infobar_content_area.get_children(): child.destroy()      self.dialog.infobar_content_area = self.dialog.infobar.get_content_area()      self.dialog.infobar_content_area.show()      self.dialog.infobar.show()      message_label = Gtk.Label(_(&quot;Verifying&quot;))      message_label.set_use_markup(True)      message_label.set_ellipsize(Pango.EllipsizeMode.END)      self.dialog.infobar_content_area.add(message_label)      self.dialog.infobar.show_all()      self.scroll.destroy()      url = web.get_main_frame().get_uri()      #use code for get token      code = url.split(&#39;=&#39;)[1]#获得code值      client = APIClient(app_key=&#39;1472971394&#39;,app_secret=&#39;49443ea72f7545486143f3f074b0b66e&#39;,redirect_uri=&quot;http://gwibber.com/0/auth.html&quot;)      r = client.request_access_token(code)      self.ui.get_object(&quot;vbox1&quot;).show()      self.ui.get_object(&quot;vbox_advanced&quot;).show()      self.access_token = r.access_token      self.expires_in = r.expires_in      client.set_access_token(self.access_token,self.expires_in)      # verifier = data[&quot;oauth_verifier&quot;][0]      # request = oauth.OAuthRequest.from_consumer_and_token(      #   self.consumer, self.token, http_method=&quot;POST&quot;,      #   http_url=&quot;http://api.t.sina.com.cn/oauth/access_token&quot;,      #   parameters={&quot;oauth_verifier&quot;: str(verifier)})      # request.sign_request(sigmeth, self.consumer, self.token)      # tokendata = urllib2.urlopen(request.http_url, request.to_postdata()).read()      # data = urlparse.parse_qs(tokendata)      # atok = oauth.OAuthToken.from_string(tokendata)      # self.account[&quot;access_token&quot;] = data[&quot;oauth_token&quot;][0]      print &quot;11111111111111111111&quot; #这里打印一些信息来看看是否能正常获得token      for k in r:        print k,        print &#39;===============&gt;&#39;,        print r[k]      print &quot;11111111111111111111&quot;      self.account[&quot;access_token&quot;] = r.access_token      self.account[&quot;secret_token&quot;] = code#oauth2中的secret_token也就是code的值      # apireq = oauth.OAuthRequest.from_consumer_and_token(      #   self.consumer, atok,      #   http_method=&quot;GET&quot;,      #   http_url=&quot;http://api.t.sina.com.cn/account/verify_credentials.json&quot;, parameters=None)      # apireq.sign_request(sigmeth, self.consumer, atok)      # account_data = json.loads(urllib2.urlopen(apireq.to_url()).read())      # userinfo = client.users.show.get(access_token=access_token)      useruid = client.account.get_uid.get()      print useruid      userinfo = client.users.show.get(uid=useruid[&#39;uid&#39;])      for k in userinfo:        print k,        print &#39;=======&gt;&#39;,        print userinfo[k]      self.account[&quot;username&quot;] = userinfo[&quot;screen_name&quot;].encode(&quot;utf-8&quot;)      self.account[&quot;user_id&quot;] = userinfo[&quot;id&quot;]      client.statuses.update.post(status=&#39;send from gwibber!&#39;)#这里试着发了一条微博，证明还是挺好用的！      if isinstance(userinfo, dict):        if userinfo.has_key(&quot;id&quot;):          saved = self.dialog.on_edit_account_save()        else:          print &quot;Failed&quot;          self.dialog.infobar.set_message_type(Gtk.MessageType.ERROR)          message_label.set_text(_(&quot;Authorization failed. Please try again.&quot;))      else:        print &quot;Failed&quot;        self.dialog.infobar.set_message_type(Gtk.MessageType.ERROR)        message_label.set_text(_(&quot;Authorization failed. Please try again.&quot;))      if saved:        message_label.set_text(_(&quot;Successful&quot;))        self.dialog.infobar.set_message_type(Gtk.MessageType.INFO)        self.dialog.infobar.hide()      self.ui.get_object(&quot;hbox_sina_auth&quot;).hide()      self.ui.get_object(&quot;sina_auth_done_label&quot;).set_label(_(&quot;%s has been authorized by Sina&quot;) % str(self.account[&quot;username&quot;]))      self.ui.get_object(&quot;hbox_sina_auth_done&quot;).show()      if self.dialog.ui and self.account.has_key(&quot;id&quot;) and not saved:        self.dialog.ui.get_object(&quot;vbox_save&quot;).show()      elif self.dialog.ui and not saved:        self.dialog.ui.get_object(&quot;vbox_create&quot;).show()    self.window.resize(*self.winsize)    if title.get_title() == &quot;Failure&quot;:      self.dialog.infobar.set_message_type(Gtk.MessageType.ERROR)      message_label = Gtk.Label (_(&quot;Authorization failed. Please try again.&quot;))      message_label.set_use_markup(True)      message_label.set_ellipsize(Pango.EllipsizeMode.END)      self.dialog.infobar_content_area.add(message_label)      self.dialog.infobar.show_all()      self.ui.get_object(&quot;vbox1&quot;).show()      self.ui.get_object(&quot;vbox_advanced&quot;).show()      self.scroll.destroy()      self.window.resize(*self.winsize)      self.dialog.select_account ()</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java中面向对象的一点学习总结</title>
      <link href="/article/1108.html"/>
      <url>/article/1108.html</url>
      <content type="html"><![CDATA[<p>最近开始看java的一些东西，感觉比python麻烦些，今天学习了面向对象的一些东西，觉得挺多挺复杂，这里做个知识总结</p><p>以一个简单的例子来说明java面向对象的三大特性，封装，继承，多态，有一个动物(Animal)基类，定义了run与eat方法，然后有一个猫(Cat)与狗(Dog)的子类继承了动物这个父类，子类重写(override)了父类的run与eat方法，同步又重载(overload)了run与eat方法，同时又定义了一个交配(Icopulation)的接口，让狗来implements交配接口，同时又创建一个Human类来专门implements交配接口</p><p><a href="/image/2014/08/795ab47fjw1ejo4u6epeoj20ab083jrh.jpg"><img src="/image/2014/08/795ab47fjw1ejo4u6epeoj20ab083jrh_thumb.jpg" alt="795ab47fjw1ejo4u6epeoj20ab083jrh" title="795ab47fjw1ejo4u6epeoj20ab083jrh"></a> </p><p>下面是具体的实现代码，没有什么实际的应用，只是作为学习用<br><a id="more"></a><br>Animal.java 这个是父类</p><pre><code class="java">package com.yangyanxing.www;//这里是定义了一个Animal的基类public class Animal {public void run(){System.out.println(&quot;我是所有动物的跑&quot;);}public void eat(){System.out.println(&quot;我是所有动物在吃&quot;);}}</code></pre><p>Icopulation.java 交配的接口</p><pre><code class="java">package com.yangyanxing.www;//这里定义了一个接口类，动物应该都具有交配public interface Icopulation {public void copulation();//这里是一个规范，要有交配方法，具体怎么实现要子类去实现}</code></pre><p>&#160;</p><p>Dog.java Dog的子类</p><pre><code class="java">package com.yangyanxing.www;//这里定义了一个狗的类继承Animal基类public class Dog extends Animal implements Icopulation {//对父类的方法进行重写(override) 方法的返回值类型与参数都不能变public void run(){System.out.println(&quot;我是一条狗在跑&quot;);}//方法的重载(overload)只是参数的数量与类型不同，返回值与权限都要相同//这里由于父类里的run方法没有重载，所以使用多态创建的子类引用也不能使用带参数的run(5)public void run(int a){System.out.printf(&quot;我是只狗，已经跑了%d公里了n&quot;,a);}public void eat(){System.out.println(&quot;我是一条狗是吃&quot;);}//这里是狗自已的方法，不是从基类继承的public void creame(){System.out.println(&quot;这是一条狗在叫&quot;);}public void copulation(){System.out.println(&quot;狗在交配&quot;);}}</code></pre><p>&#160;</p><p>Cat.java Cat子类</p><pre><code class="java">package com.yangyanxing.www;public class Cat extends Animal {public void run(){System.out.println(&quot;我是一只猫在跑&quot;);}public void eat(){System.out.println(&quot;我是一条猫是吃&quot;);}public void eat(String food){System.out.printf(&quot;我是只猫，我正在吃%sn&quot;,food);}//这里是猫自已的方法，不是从基类继承的public void creame(){System.out.println(&quot;这是一条猫在叫&quot;);}}</code></pre><p>&#160;</p><p>Human.java 实现了交配的Human类</p><pre><code class="java">package com.yangyanxing.www;public class Human implements Icopulation {@Overridepublic void copulation() {// TODO Auto-generated method stubSystem.out.println(&quot;人在交配&quot;);}}</code></pre><p>Testoob.java 具体的测试代码</p><pre><code class="java">package com.yangyanxing.www;//这里不用import 引用，在同一个包里public class Testoob {public static void main(String[] args) {// TODO Auto-generated method stubAnimal a  = new Animal();Animal a1 = new Dog();//多态，使用父类创建子类的引用Animal a2 = new Cat();Dog dog = new Dog();Cat cat = new Cat();a.run();a.eat();a1.run();a1.eat();//a1.creame();//多态父类创建的子类不能使用子类自已的方法a2.run();a2.eat();dog.creame();//不是通过多态创建的子类可以使用自已的方法cat.creame();cat.eat(&quot;鱼&quot;);dog.run(5);//a2.eat(&quot;fish&quot;);//这里会出错，因为父类里没有定义带参数的eat()方法Icopulation idog = new Dog();idog.copulation();Icopulation ihuman = new Human();ihuman.copulation();}}</code></pre><p>以下是程序运行的输出结果</p><p>我是所有动物的跑</p><p>我是所有动物在吃</p><p>我是一条狗在跑</p><p>我是一条狗是吃</p><p>我是一只猫在跑</p><p>我是一条猫是吃</p><p>这是一条狗在叫</p><p>这是一条猫在叫</p><p>我是只猫，我正在吃鱼</p><p>我是只狗，已经跑了5公里了</p><p>狗在交配</p><p>人在交配</p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中国男人形象气质差配不上中国女人?</title>
      <link href="/article/1106.html"/>
      <url>/article/1106.html</url>
      <content type="html"><![CDATA[<p>前段时间网络上有人撰文说中国男人形象气质差配不上中国女人<a href="http://news.qq.com/a/20140723/062566.htm" title="http://news.qq.com/a/20140723/062566.htm" target="_blank" rel="noopener">http://news.qq.com/a/20140723/062566.htm</a>&#160;</p><p>其实很久之前我也有过同样的感受，中国女人，无论气质谈吐似乎都要比身边的男士要更加优雅，偶尔遇到一些炸毛女，但观其身边的男人也无非是一些洗剪吹之流，女人如果出口成脏的话她身边的男人也更是流毒之辈。</p><p>男人如果能在形象气质上达到某个层次以后，也会刻意的寻找一些使自已进步的，同样的，如果你只是一个洗剪吹，那么在你的生活里接触到的也无非是一个炸毛女。<br> <a id="more"></a><br>就我的工作环境而言，几乎不会接触到穿西装革履的男人，普遍还是以休闲运动为主，可能是程序员的生活比较随便，总体气质上不能说很高，但也不是很低，可是我身边能够看得到的女性形象上都要比男性要好一些。</p><p>如果真的要以外形来评判男性的话，大多数的男人在30以后身体开始发福，肚子开始变大，脸开始走形，会发现惭惭合不上的嘴，牙齿一天比一天黄，肤色开始变的暗淡，外形上越来越雷政富，但随着个人经历与财富已经有了一些积累，如果可以达到其欲望，那么他会在50，60甚至80还是要选择年轻貌美的，有时一个不成还要两个三个，这样就造成了一个恶果，男人形象上气质上要远远的差于身边的女性。</p><p>但是并不是所有的男性都有这样的本事，大多数的人还只是个普普通通的人，过着规律的每一天，但是生活是两个人的事，如果找了一个像李安夫人的女性为伴，肯在你什么都不成事的时候不抛弃你而是一直在鼓励你做事，相信你最终会有成功的那一天，可是事实并非如此，在一个急功近利的社会，在很多女性眼中，在你有年轻身体与容貌的时候，要求你要有这个有那个，她不关心你活的累不累，只关心她自已生活的好不好，你能给她带来什么，本来应是年少轻狂的年纪做事畏手畏脚，眼神中透露出胆小畏世的神情，想要让他有什么好气质？于是放弃了，开始身材走形的成熟大叔那种淡淡的忧郁，可是在外人看你，你们依然是那么的不般配，甚至更多的人认为是老黄牛吃嫩草。</p><p>但是有一个好的趋向，随着现代大都市的成熟女性越来越独立，她们也不再说依靠男人怎样怎样，自已有自已的独立经济来源，自已赚钱来装扮自已，买自已喜欢的东西，不再是嫁汉嫁汉，穿衣吃饭，有着自已的生活圈子，但是对于外貌气质的追求却从来不见减少，且会随着年龄增长要求会越来越高，这也使得她们看上去年纪越大气质越好的原因，年轻的时候谈貌美如花，年经大了谈高贵优雅，而男人似乎一直在想着赚钱养家或者基于动物本能的下身思考，无论你是什么政坛新星商界大佬，影视常春藤，都会想一个问题，找一个什么样的人渡过一生。</p><p>我们经常说的一个词叫“女神”，女人可能活的像神一样，而大多数的男人只能活的像条狗一样。</p><p>有时觉得女人的高冷与并非其所愿，身边的装逼男多了，你稍微对他好一点，多说一两句话，自我感觉良好的贱男就开始意淫“她是不是喜欢我？”，有时真想过去骂丫一句，就你那德形，想泡姑娘，还是先撒泡尿照照你自已吧！</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python中的Queue与多进程（multiprocessing）</title>
      <link href="/article/1103.html"/>
      <url>/article/1103.html</url>
      <content type="html"><![CDATA[<p>最近接触一个项目，要在多个虚拟机中运行任务，参考别人之前项目的代码，采用了多进程来处理，于是上网查了查python中的多进程</p><p>一、先说说Queue（队列对象）</p><p>Queue是python中的标准库，可以直接import 引用，之前学习的时候有听过著名的“先吃先拉”与“后吃先吐”，其实就是这里说的队列，队列的构造的时候可以定义它的容量，别吃撑了，吃多了，就会报错,构造的时候不写或者写个小于1的数则表示无限多</p><p>import Queue</p><p>q = Queue.Queue(10)</p><p>向队列中放值(put)</p><p>q.put(‘yang’)</p><p>q.put(4)</p><p>q.put([‘yan’,’xing’])</p><p>在队列中取值get()</p><p>默认的队列是先进先出的<br><a id="more"></a></p><pre><code>&gt;&gt;&gt; q.get()&#39;yang&#39;&gt;&gt;&gt; q.get()4&gt;&gt;&gt; q.get()[&#39;yan&#39;, &#39;xing&#39;]&gt;&gt;&gt;</code></pre><p>当一个队列为空的时候如果再用get取则会堵塞，所以取队列的时候一般是用到</p><p>get_nowait()方法，这种方法在向一个空队列取值的时候会抛一个Empty异常</p><p>所以更常用的方法是先判断一个队列是否为空，如果不为空则取值</p><p>队列中常用的方法</p><p>Queue.qsize() 返回队列的大小<br>Queue.empty() 如果队列为空，返回True,反之False<br>Queue.full() 如果队列满了，返回True,反之False<br>Queue.get([block[, timeout]]) 获取队列，timeout等待时间<br>Queue.get_nowait() 相当Queue.get(False)<br>非阻塞 Queue.put(item) 写入队列，timeout等待时间<br>Queue.put_nowait(item) 相当Queue.put(item, False)</p><p>二、<code class="text">multiprocessing中使用子进程概念</code></p><p>from multiprocessing import Process</p><p>可以通过Process来构造一个子进程</p><p>p = Process(target=fun,args=(args))</p><p>再通过p.start()来启动子进程</p><p>再通过p.join()方法来使得子进程运行结束后再执行父进程</p><pre><code class="python">import os# 子进程要执行的代码def run_proc(name):    print &#39;Run child process %s (%s)...&#39; % (name, os.getpid())if __name__==&#39;__main__&#39;:    print &#39;Parent process %s.&#39; % os.getpid()    p = Process(target=run_proc, args=(&#39;test&#39;,))    print &#39;Process will start.&#39;    p.start()    p.join()    print &#39;Process end.&#39;&lt;/pre&gt;</code></pre><p>三、在<code class="text">multiprocessing</code>中使用pool</p><p>如果需要多个子进程时可以考虑使用进程池(pool)来管理</p><pre><code class="python">from multiprocessing import Poolimport os, timedef long_time_task(name):    print &#39;Run task %s (%s)...&#39; % (name, os.getpid())    start = time.time()    time.sleep(3)    end = time.time()    print &#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start))if __name__==&#39;__main__&#39;:    print &#39;Parent process %s.&#39; % os.getpid()    p = Pool()    for i in range(5):        p.apply_async(long_time_task, args=(i,))    print &#39;Waiting for all subprocesses done...&#39;    p.close()    p.join()    print &#39;All subprocesses done.&#39;&lt;/pre&gt;</code></pre><p>pool创建子进程的方法与Process不同，是通过</p><p>p.apply_async(func,args=(args))实现，一个池子里能同时运行的任务是取决你电脑的cpu数量，如我的电脑现在是有4个cpu，那会子进程task0,task1,task2,task3可以同时启动，task4则在之前的一个某个进程结束后才开始</p><p><a href="/image/2014/07/image1.png"><img src="/image/2014/07/image1.png" alt="image" title="image"></a></p><p>上面的程序运行后的结果其实是按照上图中1，2，3分开进行的，先打印1，3秒后打印2，再3秒后打印3</p><p>代码中的p.close()是关掉进程池子，是不再向里面添加进程了，对<code class="text">Pool</code>对象调用<code class="text">join()</code>方法会等待所有子进程执行完毕，调用<code class="text">join()</code>之前必须先调用<code class="text">close()</code>，调用<code class="text">close()</code>之后就不能继续添加新的<code class="text">Process</code>了。</p><p>当时也可以是实例pool的时候给它定义一个进程的多少</p><p>如果上面的代码中p=Pool(5)那么所有的子进程就可以同时进行</p><p>三、多个子进程间的通信</p><p>多个子进程间的通信就要采用第一步中说到的Queue，比如有以下的需求，一个子进程向队列中写数据，另外一个进程从队列中取数据，</p><pre><code class="python">from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q):    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:        print &#39;Put %s to queue...&#39; % value        q.put(value)        time.sleep(random.random())# 读数据进程执行的代码:def read(q):    while True:        if not q.empty():            value = q.get(True)            print &#39;Get %s from queue.&#39; % value            time.sleep(random.random())        else:            breakif __name__==&#39;__main__&#39;:    # 父进程创建Queue，并传给各个子进程：    q = Queue()    pw = Process(target=write, args=(q,))    pr = Process(target=read, args=(q,))    # 启动子进程pw，写入:    pw.start()    # 等待pw结束:    pw.join()    # 启动子进程pr，读取:    pr.start()    pr.join()    # pr进程里是死循环，无法等待其结束，只能强行终止:    print    print &#39;所有数据都写入并且读完&#39;&lt;/pre&gt;</code></pre><p>四、关于上面代码的几个有趣的问题</p><pre><code class="python">    # 父进程创建Queue，并传给各个子进程：    q = Queue()    p = Pool()    pw = p.apply_async(write,args=(q,))    pr = p.apply_async(read,args=(q,))    p.close()    p.join()    print    print &#39;所有数据都写入并且读完&#39;&lt;/pre&gt;</code></pre><p>如果main函数写成上面的样本，本来我想要的是将会得到一个队列，将其作为参数传入进程池子里的每个子进程，但是却得到</p><p>RuntimeError: Queue objects should only be shared between processes through inheritance</p><p>的错误，查了下，大意是队列对象不能在父进程与子进程间通信，这个如果想要使用进程池中使用队列则要使用multiprocess的Manager类</p><pre><code class="python">    manager = multiprocessing.Manager()    # 父进程创建Queue，并传给各个子进程：    q = manager.Queue()    p = Pool()    pw = p.apply_async(write,args=(q,))    time.sleep(0.5)    pr = p.apply_async(read,args=(q,))    p.close()    p.join()    print    print &#39;所有数据都写入并且读完&#39;&lt;/pre&gt;</code></pre><p>这样这个队列对象就可以在父进程与子进程间通信，不用池则不需要Manager，以后再扩展multiprocess中的Manager类吧</p><p>关于锁的应用，在不同程序间如果有同时对同一个队列操作的时候，为了避免错误，可以在某个函数操作队列的时候给它加把锁，这样在同一个时间内则只能有一个子进程对队列进行操作，锁也要在manager对象中的锁</p><pre><code class="python">from multiprocessing import Process,Queue,Poolimport multiprocessingimport os, time, random# 写数据进程执行的代码:def write(q,lock):    lock.acquire() #加上锁    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:        print &#39;Put %s to queue...&#39; % value        q.put(value)    lock.release() #释放锁# 读数据进程执行的代码:def read(q):    while True:        if not q.empty():            value = q.get(False)            print &#39;Get %s from queue.&#39; % value            time.sleep(random.random())        else:            breakif __name__==&#39;__main__&#39;:    manager = multiprocessing.Manager()    # 父进程创建Queue，并传给各个子进程：    q = manager.Queue()    lock = manager.Lock() #初始化一把锁    p = Pool()    pw = p.apply_async(write,args=(q,lock))    pr = p.apply_async(read,args=(q,))    p.close()    p.join()    print    print &#39;所有数据都写入并且读完&#39;</code></pre><p>参考文章：</p><p><a href="http://blog.csdn.net/yatere/article/details/6668006" title="http://blog.csdn.net/yatere/article/details/6668006" target="_blank" rel="noopener">python Queue模块</a></p><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000" title="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000" target="_blank" rel="noopener">多进程</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python操作selenium的基本操作</title>
      <link href="/article/1085.html"/>
      <url>/article/1085.html</url>
      <content type="html"><![CDATA[<pre><code class="python">#coding:utf-8from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChains #引入ActionChains鼠标操作类from selenium.webdriver.common.keys import Keys #引入keys类操作import timedef s(int):    time.sleep(int)browser = webdriver.Chrome()browser.get(&#39;http://www.baidu.com&#39;)print &#39;现在将浏览器最大化&#39;browser.maximize_window()text = browser.find_element_by_name(&#39;tj_duty&#39;).textprint text #打印备案信息browser.find_element_by_id(&#39;kw1&#39;).send_keys(u&#39;杨彦星&#39;)print browser.find_element_by_id(&#39;kw1&#39;).get_attribute(&#39;type&#39;)print browser.find_element_by_id(&#39;kw1&#39;).size #打印输入框的大小browser.find_element_by_id(&#39;su1&#39;).click()time.sleep(3)print &#39;现在我将设置浏览器为宽480，高800显示&#39;browser.set_window_size(480,800)browser.get(&#39;http://m.mail.10086.cn&#39;)time.sleep(3)print &#39;现在我将回到刚才的页面&#39;browser.maximize_window()browser.back()time.sleep(3)print &#39;现在我将回到之前的页面&#39;browser.forward()time.sleep(5)print &#39;现在我将打开杨彦星的网站进行json搜索&#39;browser.get(&#39;http://static.yangyanxing.com&#39;)browser.find_element_by_xpath(&quot;.//*[@id=&#39;ls&#39;]&quot;).send_keys(u&#39;json&#39;)browser.find_element_by_xpath(&quot;.//*[@id=&#39;header&#39;]/div[1]/div/form/input[2]&quot;).click()time.sleep(5)browser.quit()browser = webdriver.Chrome()print &#39;以下将以登录人人网来进行上面的综合应用&#39;browser.get(&#39;http://www.renren.com/SysHome.do&#39;)browser.find_element_by_id(&#39;email&#39;).clear()#这个是以id选择元素browser.find_element_by_id(&#39;email&#39;).send_keys(&#39;email&#39;)browser.find_element_by_id(&#39;email&#39;).send_keys(Keys.BACK_SPACE)time.sleep(2)browser.find_element_by_id(&#39;email&#39;).send_keys(&#39;m&#39;)s(2)browser.find_element_by_id(&#39;email&#39;).send_keys(Keys.CONTROL,&#39;a&#39;)s(2)browser.find_element_by_id(&#39;email&#39;).send_keys(Keys.CONTROL,&#39;x&#39;)#剪切掉里面的内容s(2)browser.find_element_by_id(&#39;email&#39;).send_keys(Keys.CONTROL,&#39;v&#39;) #重新输入进去s(2)browser.find_element_by_name(&#39;password&#39;).clear()#这个是以name选择元素browser.find_element_by_name(&#39;password&#39;).send_keys(&#39;password&#39;)#browser.find_element_by_xpath(&quot;.//*[@id=&#39;login&#39;]&quot;).click()#这个是以xpath选择元素browser.find_element_by_xpath(&quot;.//*[@id=&#39;login&#39;]&quot;).send_keys(Keys.ENTER) #这里通过点击Enter键来登录browser.maximize_window()article = browser.find_element_by_link_text(u&#39;周碧华：社科院出现内鬼意味着什么？&#39;)ActionChains(browser).move_to_element(article).perform()#将鼠标移动到这里，但是这里不好用ActionChains(browser).context_click(article).perform()time.sleep(5)browser.quit()</code></pre><p>开始接触selenium，其在web自动化上应用非常广，上面是一些最基本的操作，启动浏览器，打开网页，前进与后退，定位元素，键盘输入与鼠标点击操作，其中xpath可以在firefox下应用firepath插件来获取，但是局限性比较大，也会有一些兼容性的问题，像上面的代码在chrome下可以运行，但是在firefox下一些元素就找不到，很郁闷。。。继续再探索吧</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python的requests初步使用</title>
      <link href="/article/1079.html"/>
      <url>/article/1079.html</url>
      <content type="html"><![CDATA[<p>早就听说requests的库的强大，只是还没有接触，今天接触了一下，发现以前使用urllib，urllib2等方法真是太搓了……</p><p>这里写些简单的使用初步作为一个记录<br><a id="more"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="http://cn.python-requests.org/en/latest/user/install.html#install" target="_blank" rel="noopener">http://cn.python-requests.org/en/latest/user/install.html#install</a></p><h1 id="发送无参数的get请求"><a href="#发送无参数的get请求" class="headerlink" title="发送无参数的get请求"></a>发送无参数的get请求</h1><pre><code class="python">r = requests.get(&#39;http://httpbin.org/get&#39;)print r.text&#39;&#39;&#39;{  &quot;args&quot;: {},  &quot;headers&quot;: {    &quot;Accept&quot;: &quot;*/*&quot;,    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,    &quot;Connection&quot;: &quot;close&quot;,    &quot;Host&quot;: &quot;httpbin.org&quot;,    &quot;User-Agent&quot;: &quot;python-requests/2.3.0 CPython/2.6.6 Windows/7&quot;,    &quot;X-Request-Id&quot;: &quot;8a28bbea-55cd-460b-bda3-f3427d66b700&quot;  },  &quot;origin&quot;: &quot;124.192.129.84&quot;,  &quot;url&quot;: &quot;http://httpbin.org/get&quot;&#39;&#39;&#39;# 发送带参数的get请求,将key与value放入一个字典中，通过params参数来传递,其作用相当于urllib.urlencode``` python&gt;&gt;&gt; import requests&gt;&gt;&gt; pqyload = {&#39;q&#39;:&#39;杨彦星&#39;}&gt;&gt;&gt; r = requests.get(&#39;http://www.so.com/s&#39;,params = pqyload)&gt;&gt;&gt; r.urlu&#39;http://www.so.com/s?q=%E6%9D%A8%E5%BD%A6%E6%98%9F&#39;</code></pre><h1 id="发送post请求，通过data参数来传递"><a href="#发送post请求，通过data参数来传递" class="headerlink" title="发送post请求，通过data参数来传递,"></a>发送post请求，通过data参数来传递,</h1><pre><code class="html">&gt;&gt;&gt; payload = {&#39;a&#39;:&#39;杨&#39;,&#39;b&#39;:&#39;hello&#39;}&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)&gt;&gt;&gt; print r.text{  &quot;args&quot;: {},  &quot;data&quot;: &quot;&quot;,  &quot;files&quot;: {},  &quot;form&quot;: {    &quot;a&quot;: &quot;u6768&quot;,    &quot;b&quot;: &quot;hello&quot;  },  &quot;headers&quot;: {    &quot;Accept&quot;: &quot;*/*&quot;,    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,    &quot;Connection&quot;: &quot;close&quot;,    &quot;Content-Length&quot;: &quot;19&quot;,    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,    &quot;Host&quot;: &quot;httpbin.org&quot;,    &quot;User-Agent&quot;: &quot;python-requests/2.3.0 CPython/2.6.6 Windows/7&quot;,    &quot;X-Request-Id&quot;: &quot;c81cb937-04b8-4a2d-ba32-04b5c0b3ba98&quot;  },  &quot;json&quot;: null,  &quot;origin&quot;: &quot;124.192.129.84&quot;,  &quot;url&quot;: &quot;http://httpbin.org/post&quot;}&gt;&gt;&gt;</code></pre><p>可以看到，post参数已经传到了form里,data不光可以接受字典类型的数据，还可以接受json等格式</p><pre><code class="html">&gt;&gt;&gt; payload = {&#39;a&#39;:&#39;杨&#39;,&#39;b&#39;:&#39;hello&#39;}&gt;&gt;&gt; import json&gt;&gt;&gt; r = requests.post(&#39;http://httpbin.org/post&#39;, data=json.dumps(payload))</code></pre><h1 id="发送文件的post类型"><a href="#发送文件的post类型" class="headerlink" title="发送文件的post类型"></a>发送文件的post类型</h1><p>这个相当于向网站上传一张图片，文档等操作，这时要使用files参数</p><pre><code class="html">&gt;&gt;&gt; url = &#39;http://httpbin.org/post&#39;&gt;&gt;&gt; files = {&#39;file&#39;: open(&#39;touxiang.png&#39;, &#39;rb&#39;)}&gt;&gt;&gt; r = requests.post(url, files=files)</code></pre><h2 id="定制headers，使用headers参数来传递"><a href="#定制headers，使用headers参数来传递" class="headerlink" title="定制headers，使用headers参数来传递"></a>定制headers，使用headers参数来传递</h2><pre><code class="html">&gt;&gt;&gt; import json&gt;&gt;&gt; url = &#39;https://api.github.com/some/endpoint&#39;&gt;&gt;&gt; payload = {&#39;some&#39;: &#39;data&#39;}&gt;&gt;&gt; headers = {&#39;content-type&#39;: &#39;application/json&#39;}&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload), headers=headers)</code></pre><h1 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h1><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>r = requests.get(‘<a href="http://httpbin.org/get" target="_blank" rel="noopener">http://httpbin.org/get</a>‘)<br>print r.status_code</p><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><pre><code class="html">&gt;&gt;&gt; print r.headers{&#39;content-length&#39;: &#39;519&#39;, &#39;server&#39;: &#39;gunicorn/18.0&#39;, &#39;connection&#39;: &#39;keep-alive&#39;, &#39;date&#39;: &#39;Sun, 15 Jun 2014 14:19:52 GMT&#39;, &#39;access-control-allow-origin&#39;: &#39;*&#39;, &#39;content-type&#39;: &#39;application/json&#39;}</code></pre><p>也可以取到这个个别的响应头用来做一些判断，这里的参数是不区分大小写的</p><p>r.headers[‘Content-Type’]</p><p>r.headers.get(‘Content-Type’)</p><h2 id="响应内容，前面已经在应用了"><a href="#响应内容，前面已经在应用了" class="headerlink" title="响应内容，前面已经在应用了"></a>响应内容，前面已经在应用了</h2><p>r.text</p><p>r.content</p><h1 id="获取响应中的cookies"><a href="#获取响应中的cookies" class="headerlink" title="获取响应中的cookies"></a>获取响应中的cookies</h1><pre><code class="html">&gt;&gt;&gt; r = requests.get(&#39;http://www.baidu.com&#39;)&gt;&gt;&gt; r.cookies[&#39;BAIDUID&#39;]&#39;D5810267346AEFB0F25CB0D6D0E043E6:FG=1&#39;</code></pre><p>也可以自已定义请求的COOKIES</p><pre><code class="html">&gt;&gt;&gt; url = &#39;http://httpbin.org/cookies&#39;&gt;&gt;&gt; cookies = {&#39;cookies_are&#39;:&#39;working&#39;}&gt;&gt;&gt; r = requests.get(url,cookies = cookies)&gt;&gt;&gt;&gt;&gt;&gt; print r.text{  &quot;cookies&quot;: {    &quot;cookies_are&quot;: &quot;working&quot;  }}&gt;&gt;&gt;</code></pre><p>cookies还有很多，因为目前我也还不是很多，以后再扩充吧</p><h1 id="使用timeout参数设置超时时间"><a href="#使用timeout参数设置超时时间" class="headerlink" title="使用timeout参数设置超时时间"></a>使用timeout参数设置超时时间</h1><pre><code class="html">&gt;&gt;&gt; requests.get(&#39;http://github.com&#39;, timeout=1)&lt;Response [200]&gt;</code></pre><p>如果将时间设置成非常小的数，如requests.get(‘<a href="http://github.com" target="_blank" rel="noopener">http://github.com’</a>, timeout=0.001)，那么如果在timeout的时间内没有连接，那么将会抛出一个Timeout的异常</p><h1 id="访问中使用session"><a href="#访问中使用session" class="headerlink" title="访问中使用session"></a>访问中使用session</h1><p>先初始化一个session对象，s = requests.Session()</p><p>然后使用这个session对象来进行访问，r = s.post(url,data = user)</p><p>参考文章 <a href="http://blog.csdn.net/iloveyin/article/details/21444613" target="_blank" rel="noopener">http://blog.csdn.net/iloveyin/article/details/21444613</a> 基本上都是从这扒的代码</p><p>以下通过访问人人网来获取首页中的最近来访问，然后再访问查看更多的来访来读取更多的最近来访</p><p>20151029更新，和美女刘巍进行讨论，由于很久没有登录人人网，它的登录页面与获得最近来访的页面都有所变动，登录时的url是<a href="http://www.renren.com/ajaxLogin/login" target="_blank" rel="noopener">http://www.renren.com/ajaxLogin/login</a> 获取最近来访是<a href="http://www.renren.com/myfoot/whoSeenMe" target="_blank" rel="noopener">http://www.renren.com/myfoot/whoSeenMe</a></p><p>更多的来访就是以带session的访问<a href="http://www.renren.com/myfoot/whoSeenMe" target="_blank" rel="noopener">http://www.renren.com/myfoot/whoSeenMe</a></p><pre><code class="python">#coding:utf-8import requestsimport reurl = r&#39;http://www.renren.com/ajaxLogin/login&#39;user = {&#39;email&#39;:&#39;email&#39;,&#39;password&#39;:&#39;pass&#39;}s = requests.Session()r = s.post(url,data = user)html = r.textvisit = []first = re.compile(r&#39;&lt;/span&gt;&lt;span class=&quot;time-tip first-tip&quot;&gt;&lt;span class=&quot;tip-content&quot;&gt;(.*?)&lt;/span&gt;&#39;)second = re.compile(r&#39;&lt;/span&gt;&lt;span class=&quot;time-tip&quot;&gt;&lt;span class=&quot;tip-content&quot;&gt;(.*?)&lt;/span&gt;&#39;)third = re.compile(r&#39;&lt;/span&gt;&lt;span class=&quot;time-tip last-second-tip&quot;&gt;&lt;span class=&quot;tip-content&quot;&gt;(.*?)&lt;/span&gt;&#39;)last = re.compile(r&#39;&lt;/span&gt;&lt;span class=&quot;time-tip last-tip&quot;&gt;&lt;span class=&quot;tip-content&quot;&gt;(.*?)&lt;/span&gt;&#39;)visit.extend(first.findall(html))visit.extend(second.findall(html))visit.extend(third.findall(html))visit.extend(last.findall(html))for i in visit:    print iprint &#39;以下是更多的最近来访&#39;vm = s.get(&#39;http://www.renren.com/myfoot/whoSeenMe&#39;)fm = re.compile(r&#39;&quot;name&quot;:&quot;(.*?)&quot;&#39;)visitmore = fm.findall(vm.text)for i in visitmore:    print i</code></pre><p><a href="/image/2014/06/renren.png"><img src="/image/2014/06/renren_thumb.png" alt="renren" title="renren"></a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> requests </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>与wordpress垃圾评论斗争到底</title>
      <link href="/article/1069.html"/>
      <url>/article/1069.html</url>
      <content type="html"><![CDATA[<p>由于本人个人博客小站的空间与mysql空间有限，共享服务器资源也有限，所以这些垃圾评论一定要拦截在写入数据库之外。</p><p>更可气的是看到空间的统计，很几千的IP访问，但基本上都是这个垃圾评论的IP，所以实在不能忍</p><p>网上找了一些方法，主要有三个，如果将这三个一块使用基本上就可以拦截绝大多数垃圾评论<br> <a id="more"></a></p><h1 id="使用Akismet插件"><a href="#使用Akismet插件" class="headerlink" title="使用Akismet插件"></a>使用Akismet插件</h1><p>后台申请一个免费的key，可以拦截99%的垃圾评论，但是这个插件还是会将垃圾评论写入数据库的，一会几千条甚至上万条垃圾评论，虽说可以设置15天后自动删除，但是看着也别扭，于是加上第二种方法。</p><h1 id="更改wp-comments-post-php名称"><a href="#更改wp-comments-post-php名称" class="headerlink" title="更改wp-comments-post.php名称"></a>更改wp-comments-post.php名称</h1><p>这种方法是先将wp-comments-post.php改为随便的名字，然后在你主题文件的comments.php中将wp-comments-post.php改为你刚才改过的名字<br>但是现在的spam机器人太强了，这种方法基本上没有任何作用，垃圾评论还是会进入到后台的垃圾评论里，于是采取第三种方法，过滤掉纯英语的垃圾评论，这种评论占了垃圾评论的很大一部分  </p><h1 id="过滤纯英文垃圾评论"><a href="#过滤纯英文垃圾评论" class="headerlink" title="过滤纯英文垃圾评论"></a>过滤纯英文垃圾评论</h1><p>在你主题的functions.php中添加以下代码</p><pre><code class="php">     function refused_spam_comments( $comment_data ) {     $pattern = &#39;/[一-龥]/u&#39;;     if(!preg_match($pattern,$comment_data[&#39;comment_content&#39;])) {     wp_die(&#39;评论必须含中文！&#39;); }     return( $comment_data ); }</code></pre><p>其中[一-龥]这个正则表达式代表所有中文，这时纯英文的垃圾评论算是过滤掉了，但是还有另外一种垃圾评论，日文的……</p><p>日文的采用同样的方法，请几个常出现的日文假名写入到正则表达式中ッ、の、ン、優、業、グ、貿 </p><pre><code class="php">   function fuckjp_comment_post( $incoming_comment ) {     $http = &#39;/[&lt;|=|.|友|夜|KTV|ッ|の|ン|優|業|グ|貿|]/u&#39;;     if(preg_match($http, $incoming_comment[&#39;comment_content&#39;])) {     wp_die( &quot;小日本滚蛋!&quot; );   }    return( $incoming_comment ); }</code></pre><p>将这三点综合起来使用，终于清净多了……</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.v7v3.com/wpjiaocheng/201308215.html" target="_blank" rel="noopener">http://www.v7v3.com/wpjiaocheng/201308215.html</a></p><p><a href="http://www.pzboy.com/soft/php/english-comments/" target="_blank" rel="noopener">http://www.pzboy.com/soft/php/english-comments/</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>切换google的公共库缓解网站访问慢的问题</title>
      <link href="/article/1052.html"/>
      <url>/article/1052.html</url>
      <content type="html"><![CDATA[<p>近期谷(zheng)歌(fu)抽疯，很多google的公共库文件访问缓慢或者根本就是无法访问，很多网站前端以前都是直接引用google的地址，这会或多或少的影响网站打开速度。本人博客也“不幸”引入了一些google的公共库，换了几个服务器，无论是BAE还是SAE或者国外的服务器再或者是国内的服务器，都很慢，今天查了查，将其换为360网站卫士提供的公共库资源（<a href="http://libs.useso.com/" target="_blank" rel="noopener">http://libs.useso.com/</a>），效果果然提高不少。</p><p>这个是由360网站卫士CDN驱动的常用前端公共库以及和谐使用Google公共库&amp;字体库的调用方法。</p><p>打开Chrome开发者工具(F12),打开网站，查看到一些引用都是error，其中一个是 <a id="more"></a></p><p><a href="http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js</a>&#160;</p><p>这个我检查了下，发现是我主题模板里的footer.php里的一句引用，于是替换成了以下。</p><p><a href="http://ajax.useso.com/ajax/libs/jquery/1.4.3/jquery.min.js" target="_blank" rel="noopener">http://ajax.useso.com/ajax/libs/jquery/1.4.3/jquery.min.js</a>&#160;</p><p>之后还有一个fonts.googleapis.com/css?family=Open+Sans 没有找到，找这个文件可以费了点劲，我在主题模板里没有找到这句话，查找见面源代码根据位置也找不到，在用notepad++搜了几个wordpree的文件夹以后还是没有发现，无奈文件太多，没想到藏这么深，于自已写个脚本来搜索wordpress所有文件。。。</p><pre><code class="python">#coding:utf-8import os,sysdef listFile(path, isDeep=True):    _list = []    if isDeep:        try:            for root, dirs, files in os.walk(path):                for fl in files:                    _list.append(&#39;%s%s&#39; % (root, fl))        except:            pass    else:        for fn in glob.glob( path + os.sep + &#39;*&#39; ):            if not os.path.isdir(fn):                _list.append(&#39;%s&#39; % path + os.sep + fn[fn.rfind(&#39;&#39;)+1:])    return _listpwd = os.getcwd()print pwdcut = listFile(pwd)flag = 1for i in cut:    filename = os.path.split(i)[1]    ext = os.path.splitext(i)[1]    if ext == &#39;.php&#39; or ext == &#39;.js&#39;:        f = open(i)        for j in f.readlines():            if &#39;fonts.googleapis.com&#39; in j:                print i                print j                flag = 0if flag:    print &#39;TT&#39;</code></pre><p>将它放到wordpress目录下运行，不一会就找到了原来是wp-includes目录下的script-loader.php，而且只有这一个文件，大概在602行左右</p><p>$open_sans_font_url = “//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,300,400,600&amp;subset=$subsets”;</p><p>将其改为<br>$open_sans_font_url = “//fonts.useso.com/css?family=Open+Sans:300italic,400italic,600italic,300,400,600&amp;subset=$subsets”;</p><p>```</p><p>保存之后上传，这两个文件，再打开网站试下，果真比原来快了不少！希望对于有类似问题的朋友有帮助。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python中的中文编码问题</title>
      <link href="/article/1050.html"/>
      <url>/article/1050.html</url>
      <content type="html"><![CDATA[<p>在编程领域中，中文编码问题一向是个很头疼的问题，今天写点总结一下解决的方法</p><p>unicode与utf-8和gbk之间的转换，涉及到的函数有decode与encode</p><p>首先明确一下，python中的字符串都是以某种编码来存储的，就中文来说，以gbk与utf-8的，你虽然可以这样定义一个变量 s = u’杨彦星’,但是你可以用type(s) 来看一下它的类型，此时这个s 不是字符串，而是unicode类型，当你定义s = ‘杨彦星’的时候，这时type(s)才是str类型，但是当你直接定义s = ‘杨彦星’时会在不同的场景下出现不同的问题，windows下的cmd还好，换到一个utf-8的解析器里就是乱码，所以最好的方式是在定义有中文（或者说非英文的）字符串时以unicode来定义，然后再去解码输出。</p><p>将字符串decode成unicode</p><p>s = ‘杨彦星’</p><p>s_uni = s.decode(‘gbk’) #将s转换成unicode，decode的时候就加上这个字符原来的编码类型</p><p>s_utf8 = s_uni.encode(‘utf-8’)</p><p>s_gbk = s_uni.encode(‘gbk’)</p><a id="more"></a> <p>decode() 函数需要字符本来的编码作为参数，encode()函数需要字符想要转换成的编码</p><p>当想要保存成特定编码的文件时，就需要使用codecs库</p><p>import codecs</p><p>s =u ‘杨彦星’</p><p>f = codecs.open(‘test.txt’,’w’,’utf-8’)</p><p>f.write(s)</p><p>f.close()</p><p>这时可以打开test.txt查看文件的编码，这时就会是utf-8的，写入的中文要是unicode</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu从安装到设置的一点记录</title>
      <link href="/article/1032.html"/>
      <url>/article/1032.html</url>
      <content type="html"><![CDATA[<p>1.硬盘安装：<a href="http://www.linuxidc.com/Linux/2013-10/91565.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-10/91565.htm</a></p><p>2.Nvidia显卡的安装，<a href="http://blog.csdn.net/wzcqr0501/article/details/8498659" target="_blank" rel="noopener">http://blog.csdn.net/wzcqr0501/article/details/8498659</a> 曾尝试安装，但第一次失败且改不回来，于是不准备安装了，自带的Nvidia显卡已经很好了</p><p>3.修改hosts改变google的解析 sudo gedit /etc/hosts</p><p>4.默认启动ubuntu后自动挂载windows分区 <a href="http://www.linuxidc.com/Linux/2013-02/79679.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-02/79679.htm</a></p><p>创建挂载目录 sudo mkdir  /media/windows 等等</p><p>查看磁盘分区的UUID sudo  blkid  记录UUID</p><p>编辑fstab sudo gedit  /etc/fstab 写入如下内容</p><p>UUID=D06ABBA96ABB8AAC /media/windows ntfs default 0 0</p><p>5.解决中文乱码问题</p><p>sudo gedit /etc/profile<br><a id="more"></a><br>在最后添加：</p><p>export PATH=$PATH GST_ID3_TAG_ENCODING=GBK:UTF-8:GB18030<br>export PATH=$PATH GST_ID3V2_TAG_ENCODING=GBK:UTF-8:GB18030</p><p>6.导入windows字体 <a href="http://www.cnblogs.com/zhj5chengfeng/p/3251009.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhj5chengfeng/p/3251009.html</a></p><blockquote><p>sudo mkdir /usr/share/fonts/winfonts<br>sudo cp ~/WinFonts/<em> /usr/share/fonts/winfonts<br>cd /usr/share/fonts/winfonts<br>sudo chmod 744 </em><br>sudo mkfontscale<br>sudo mkfontdir<br>sudo fc-cache -f -v</p></blockquote><p>重启电脑</p><p>7.安装fcitx小企鹅输入法 <a href="http://www.cnblogs.com/yuemengke/archive/2013/04/09/3010207.html" target="_blank" rel="noopener">http://www.cnblogs.com/yuemengke/archive/2013/04/09/3010207.html</a></p><blockquote><p>sudo apt-get install fcitx fcitx-config-gtk fcitx-sunpinyin fcitx-table-wbpy</p></blockquote><p>8.安装qq <a href="http://www.ubuntusoft.com/thread-225-1-1.html" target="_blank" rel="noopener">http://www.ubuntusoft.com/thread-225-1-1.html</a></p>]]></content>
      
      <categories>
          
          <category> Linux相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javascript DOM初学(一)</title>
      <link href="/article/994.html"/>
      <url>/article/994.html</url>
      <content type="html"><![CDATA[<p>开始学习javacript，这里做个总结<br><a id="more"></a></p><pre><code class="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#div1 {width:200px;height:200px;background:#CCC;position:relative}#div2 {width:100px;height:100px;background:red;position:absolute;left:50px;top:50px;}&lt;/style&gt;&lt;script&gt;window.onload=function(){    var oul = document.getElementById(&#39;ul1&#39;)    //alert (oUL.childNodes.length)    for(var i=0;i&lt;oul.childNodes.length;i++) //childNodes属性随着浏览器的不同而不同，高级点的回车换行等也算一个    {        if (oul.childNodes[i].nodeType == 1) //这里就解决了只选用元素属性节点，文本属性的节点就不算了，也就排除了回车换行等问题        {            oul.childNodes[i].style.background = &#39;red&#39;        }    }    for(var i=0;i&lt;oul.children.length;i++)    {        oul.children[i].style.background = &#39;blue&#39; //children属性直接只选取元素属性，不算文本元素    }    var oa = document.getElementsByTagName(&#39;a&#39;)    for(var i = 0;i&lt;oa.length;i++)    {        oa[i].onclick=function() //为某个元素添加某些方法        {            //获取父节点            this.parentNode.style.display=&#39;none&#39;    //使得父节点设置为隐藏        }    }    var od=document.getElementById(&#39;div2&#39;)    od.onclick=function()    {        alert(od.offsetParent)//获取该元素用于定位的元素    }    var oul3=document.getElementById(&quot;ul3&quot;)    //oul3.firstElementChild.style.background = &#39;red&#39;    if (oul3.firstElementChild)//处理兼容问题    {        oul3.firstElementChild.style.background = &#39;blue&#39;    }    else    {        oul3.firstChild.style.background = &#39;red&#39;    }    var osub = document.getElementById(&#39;sub&#39;)    var otext = document.getElementById(&#39;text&#39;)    var ouser = document.getElementById(&quot;userType&quot;)    var yyx = document.getElementsByTagName(&#39;p&#39;)[0]//返回是列表，所以得取其中之一    osub.onclick = function()    {        //1.otext.value = &#39;hahaha&#39;        //2.otext[&#39;value&#39;] = &#39;hahaha&#39;        var text = ouser.getAttribute(&#39;value&#39;)        var text2 = yyx.firstChild.nodeValue //获得该节点的值，也就是文本元素        otext.setAttribute(&#39;value&#39;,text2)    }    function getClassName(parent,classname)    {        classnamelist = []        var d = document.getElementById(parent)        var c = d.getElementsByTagName(&#39;*&#39;)        for (var i=0;i&lt;c.length;i++)        {            if (c[i].className == classname)            {                classnamelist.push(c[i])            }        }        return classnamelist    }    var oul4 = document.getElementById(&quot;ul4&quot;)    var oli4 = oul4.getElementsByTagName(&#39;li&#39;)    //var dli4 = document.getElementsByTagName(&#39;li&#39;) 会选取整个文档内的元素，并不是我们想要的，我们想要的是从某个父级元素下面选元素    needRed = getClassName(&#39;ul4&#39;,&#39;red&#39;)    for(var i = 0;i&lt;needRed.length;i++)    {        needRed[i].style.background = &#39;red&#39;    }};&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id=&quot;ul1&quot;&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;ul id=&quot;ul2&quot;&gt;    &lt;li&gt;adfadf &lt;a href=&quot;#&quot;&gt;隐藏&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;aadfaddf &lt;a href=&quot;#&quot;&gt;隐藏&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;233df &lt;a href=&quot;#&quot;&gt;隐藏&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;fafadf &lt;a href=&quot;#&quot;&gt;隐藏&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;div id=&quot;div1&quot;&gt;    &lt;div id=&quot;div2&quot;&gt;sdasdfafasd&lt;/div&gt;&lt;/div&gt;&lt;ul id=&quot;ul3&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;我是杨彦星&lt;/p&gt;&lt;input type=&quot;text&quot; id=&quot;userType&quot; value=&quot;adfadfadf&quot;/&gt;&lt;input type=&quot;text&quot; id=&quot;text&quot; /&gt;&lt;input type=&quot;submit&quot; id=&quot;sub&quot; value=&quot;点击&quot; /&gt;&lt;br /&gt;&lt;ul id=&quot;ul4&quot;&gt;    &lt;li class=&quot;red&quot;&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li class=&quot;red&quot;&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li class=&quot;red&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的logging模块应用</title>
      <link href="/article/963.html"/>
      <url>/article/963.html</url>
      <content type="html"><![CDATA[<p>python中有系统自带的logging模块，使用起来非常方便，并且要在程序中经常要使用这个模块，这样出了问题可以通过日志很方便的查找在哪里出了问题，比直接找代码要方便些</p><p>我记录了一些经常用到的，不是很常用的可以到python文档中去查看 <a href="http://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">http://docs.python.org/2/library/logging.html</a><br><a id="more"></a><br>1. 初始化 logger = logging.getLogger(“endlesscode”)，getLogger()方法后面最好加上所要日志记录的模块名字，后面的日志格式中的%(name)s 对应的是这里的模块名字</p><p>2. 设置级别 logger.setLevel(logging.DEBUG),Logging中有NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL这几种级别，日志会记录设置级别以上的日志</p><p>3. Handler，常用的是StreamHandler和FileHandler，windows下你可以简单理解为一个是console和文件日志，一个打印在CMD窗口上，一个记录在一个文件上</p><p>4. formatter，定义了最终log信息的顺序,结构和内容，我喜欢用这样的格式 ‘[%(asctime)s] [%(levelname)s] %(message)s’, ‘%Y-%m-%d %H:%M:%S’，</p><p><strong>%(name)s Logger的名字</strong></p><p><strong>%(levelname)s 文本形式的日志级别</strong></p><p><strong>%(message)s 用户输出的消息</strong></p><p><strong>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</strong></p><p>%(levelno)s 数字形式的日志级别</p><p>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</p><p>%(filename)s 调用日志输出函数的模块的文件名</p><p>%(module)s&#160; 调用日志输出函数的模块名</p><p>%(funcName)s 调用日志输出函数的函数名</p><p>%(lineno)d 调用日志输出函数的语句所在的代码行</p><p>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</p><p>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</p><p>%(thread)d 线程ID。可能没有</p><p>%(threadName)s 线程名。可能没有</p><p>%(process)d 进程ID。可能没有</p><p>5. 记录 使用object.debug(message)来记录日志</p><p>下面来写一个实例，在CMD窗口上只打出error以上级别的日志，但是在日志中打出debug以上的信息</p><pre><code class="python">import logginglogger = logging.getLogger(&quot;simple_example&quot;)logger.setLevel(logging.DEBUG)# 建立一个filehandler来把日志记录在文件里，级别为debug以上fh = logging.FileHandler(&quot;spam.log&quot;)fh.setLevel(logging.DEBUG)# 建立一个streamhandler来把日志打在CMD窗口上，级别为error以上ch = logging.StreamHandler()ch.setLevel(logging.ERROR)# 设置日志格式formatter = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)ch.setFormatter(formatter)fh.setFormatter(formatter)#将相应的handler添加在logger对象中logger.addHandler(ch)logger.addHandler(fh)# 开始打日志logger.debug(&quot;debug message&quot;)logger.info(&quot;info message&quot;)logger.warn(&quot;warn message&quot;)logger.error(&quot;error message&quot;)logger.critical(&quot;critical message&quot;)</code></pre><p>运行一下将会看到CMD窗口只记录两条，spam.log中记录了五条日志</p><p><a href="/image/2013/11/log.png"><img src="/image/2013/11/log_thumb.png" alt="log" title="log"></a> </p><p>&#160;</p><p>当一个项目比较大的时候，不同的文件中都要用到Log,可以考虑将其封装为一个类来使用</p><pre><code class="python">#! /usr/bin/env python#coding=gbkimport logging,osclass Logger:    def __init__(self, path,clevel = logging.DEBUG,Flevel = logging.DEBUG):        self.logger = logging.getLogger(path)        self.logger.setLevel(logging.DEBUG)        fmt = logging.Formatter(&#39;[%(asctime)s] [%(levelname)s] %(message)s&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)        #设置CMD日志        sh = logging.StreamHandler()        sh.setFormatter(fmt)        sh.setLevel(clevel)        #设置文件日志        fh = logging.FileHandler(path)        fh.setFormatter(fmt)        fh.setLevel(Flevel)        self.logger.addHandler(sh)        self.logger.addHandler(fh)    def debug(self,message):        self.logger.debug(message)    def info(self,message):        self.logger.info(message)    def war(self,message):        self.logger.warn(message)    def error(self,message):        self.logger.error(message)    def cri(self,message):        self.logger.critical(message)if __name__ ==&#39;__main__&#39;:    logyyx = Logger(&#39;yyx.log&#39;,logging.ERROR,logging.DEBUG)    logyyx.debug(&#39;一个debug信息&#39;)    logyyx.info(&#39;一个info信息&#39;)    logyyx.war(&#39;一个warning信息&#39;)    logyyx.error(&#39;一个error信息&#39;)    logyyx.cri(&#39;一个致命critical信息&#39;)</code></pre><p>这样每次使用的时候只要实例化一个对象就可以了</p><p>logobj = Logger(‘filename’,clevel,Flevel)</p><p>如果想在CMD窗口中对于error的日志标红，warning的日志标黄，那么可以使用ctypes模块</p><p><a href="/image/2013/11/color.png"><img src="/image/2013/11/color_thumb.png" alt="color" title="color"></a> </p><pre><code class="python">#! /usr/bin/env python#coding=gbkimport logging,osimport ctypesFOREGROUND_WHITE = 0x0007FOREGROUND_BLUE = 0x01 # text color contains blue.FOREGROUND_GREEN= 0x02 # text color contains green.FOREGROUND_RED  = 0x04 # text color contains red.FOREGROUND_YELLOW = FOREGROUND_RED | FOREGROUND_GREENSTD_OUTPUT_HANDLE= -11std_out_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)def set_color(color, handle=std_out_handle):    bool = ctypes.windll.kernel32.SetConsoleTextAttribute(handle, color)    return boolclass Logger:    def __init__(self, path,clevel = logging.DEBUG,Flevel = logging.DEBUG):        self.logger = logging.getLogger(path)        self.logger.setLevel(logging.DEBUG)        fmt = logging.Formatter(&#39;[%(asctime)s] [%(levelname)s] %(message)s&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)        #设置CMD日志        sh = logging.StreamHandler()        sh.setFormatter(fmt)        sh.setLevel(clevel)        #设置文件日志        fh = logging.FileHandler(path)        fh.setFormatter(fmt)        fh.setLevel(Flevel)        self.logger.addHandler(sh)        self.logger.addHandler(fh)    def debug(self,message):        self.logger.debug(message)    def info(self,message):        self.logger.info(message)    def war(self,message,color=FOREGROUND_YELLOW):        set_color(color)        self.logger.warn(message)        set_color(FOREGROUND_WHITE)    def error(self,message,color=FOREGROUND_RED):        set_color(color)        self.logger.error(message)        set_color(FOREGROUND_WHITE)    def cri(self,message):        self.logger.critical(message)if __name__ ==&#39;__main__&#39;:    logyyx = Logger(&#39;yyx.log&#39;,logging.WARNING,logging.DEBUG)    logyyx.debug(&#39;一个debug信息&#39;)    logyyx.info(&#39;一个info信息&#39;)    logyyx.war(&#39;一个warning信息&#39;)    logyyx.error(&#39;一个error信息&#39;)    logyyx.cri(&#39;一个致命critical信息&#39;)</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用web.py在BAE建立自已的电影网站</title>
      <link href="/article/953.html"/>
      <url>/article/953.html</url>
      <content type="html"><![CDATA[<p>最近在网上看了一篇文章使用web.py在BAE上建立电影网站，<a href="http://www.51bigfool.com/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8bae%E5%92%8Cweb-py%E6%89%93%E9%80%A0%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1top100%E7%9A%84.html" target="_blank" rel="noopener">http://www.51bigfool.com/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8bae%E5%92%8Cweb-py%E6%89%93%E9%80%A0%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1top100%E7%9A%84.html</a> 我自已也在此基础上做了一些改进，也在一点点的熟悉使用web.py这个框架，可以看一下我弄了一半的应用 <a href="http://movie.yangyanxing.com" target="_blank" rel="noopener">http://movie.yangyanxing.com</a></p><p>准备 BAE web.py</p><h1 id="在BAE上建立一个python的应用"><a href="#在BAE上建立一个python的应用" class="headerlink" title="在BAE上建立一个python的应用"></a>在BAE上建立一个python的应用</h1><p>快速创建即可，选择Iframe</p><p><a href="/image/2013/11/create.jpg"><img src="/image/2013/11/create_thumb.jpg" alt="create" title="create"></a><br> <a id="more"></a><br>之后进入云引擎将环境类型设置为python</p><p><a href="/image/2013/11/python.png"><img src="/image/2013/11/python_thumb.png" alt="python" title="python"></a> </p><p>先简单看一下目录结构如下</p><p>│&#160; index.py<br>│&#160; model.py<br>│<br>├─static<br>│&#160; └─images<br>│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; lg_movie_a12_2.png<br>│<br>└─templates<br>&#160;&#160;&#160; │&#160; add.html<br>&#160;&#160;&#160; │&#160; base.html<br>&#160;&#160;&#160; │&#160; index.html<br>&#160;&#160;&#160; │&#160; play.html<br>&#160;&#160;&#160; │&#160; show.html<br>&#160;&#160;&#160; │&#160; top250style.css</p><p>新建一个Mysql，进入phpmyadmin导入所需的表</p><p>&#160;</p><pre><code class="html">    CREATE TABLE DoubanTop250(    id INT AUTO_INCREMENT ,    moviename TEXT,    score FLOAT,    url TEXT,    PRIMARY KEY ( id )</code></pre><p>我先按照原来的教程添加了相应的代码<br>model.py</p><pre><code class="python"># _*_ coding:utf-8 _*_import webimport web.dbfrom bae.core import constdbname = &quot;数据库名字&quot;db = web.database(    dbn=&#39;mysql&#39;,    host=const.MYSQL_HOST,    port=int(const.MYSQL_PORT),    user=const.MYSQL_USER,    passwd=const.MYSQL_PASS,    db=dbname)def additem(name, rating, address):    return db.insert(&#39;DoubanTop250&#39;, moviename=name, score=rating, url=address)def get_items():    return db.select(&#39;DoubanTop250&#39;, order=&#39;id&#39;)def get_item(id):    return db.select(&#39;DoubanTop250&#39;, where=&#39;id=$id&#39;, vars=locals())[0]</code></pre><p>index.py</p><pre><code class="python">#_*_ coding:utf-8 _*_import webimport modelimport osimport reurls = (    &quot;/&quot;, &quot;Index&quot;,    &quot;/play/(d+)&quot;, &quot;Play&quot;)t_globals = {    &#39;datestr&#39;: web.datestr}app_root = os.path.dirname(__file__)template_root = os.path.join(app_root, &#39;templates/&#39;)render = web.template.render(template_root, base=&#39;base&#39;, globals=t_globals)class Index:    def GET(self):        items = model.get_items()#       return render.test(items)        return render.index(items)class Play:    def POST(self, id):        id = int(id)        item = model.get_item(id)        return render.play(item)app = web.application(urls, globals()).wsgifunc()from bae.core.wsgi import WSGIApplicationapplication = WSGIApplication(app)</code></pre><p>base.html</p><pre><code class="html">$def with (page)&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html  xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;        &lt;title&gt; 杨彦星的自娱自乐&lt;/title&gt;        &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/templates/top250style.css&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;a target=&quot;_blank&quot; href=&quot;http://movie.douban.com/chart&quot; title=&quot;豆瓣电影排行旁&quot;&gt;&lt;img src=&quot;/static/images/lg_movie_a12_2.png&quot; &gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div id=&quot;main&quot;&gt;          &lt;h1&gt; 这是瞎写的我会乱说吗|&lt;a target=&quot;_blank&quot; href = &quot;/addmovie/&quot;&gt;添加电影&lt;/a&gt;&lt;/h1&gt;            $:page        &lt;/div&gt;        &lt;div id=&quot;footer&quot;&gt;            &lt;div id=&quot;copyright&quot;&gt;                &lt;p&gt;本站纯属自娱自乐与学习python之用，电影啥的全是网上收集&lt;/p&gt;              &lt;a href = &quot;/&quot;&gt;返回首页&lt;/a&gt;                &lt;p&gt;&lt;em&gt;Proudly powered by Web.py&lt;/em&gt;&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>index.html</p><pre><code class="html">$def with(items)        &lt;table&gt;            &lt;tr&gt;                &lt;th&gt;排名&lt;/th&gt;                &lt;th&gt;影片名&lt;/th&gt;                &lt;th&gt;得分&lt;/th&gt;                &lt;th&gt;百度影音播放&lt;/th&gt;            &lt;/tr&gt;            $for item in items:            &lt;tr&gt;                &lt;td id=&quot;tdstyle&quot;&gt;$item.id&lt;/td&gt;                &lt;td id=&quot;tdstyle&quot;&gt;$item.moviename&lt;/td&gt;                &lt;td id=&quot;tdstyle&quot;&gt;$item.score&lt;/td&gt;                &lt;td id=&quot;tdstyle&quot;&gt;                    &lt;form action=&quot;/play/$item.id&quot; method=&quot;post&quot;&gt;                      &lt;input type=&quot;submit&quot; value=&quot;播放&quot; /&gt;                    &lt;/form&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;</code></pre><p>play.html</p><pre><code class="html">$def with(item)&lt;h2&gt;$item.id $item.moviename&lt;/h2&gt;&lt;blockquote&gt;        &lt;object classid=&quot;clsid:02E2D748-67F8-48B4-8AB4-0A085374BB99&quot; width=&quot;600&quot; height=&quot;400&quot; id=&quot;BaiduPlayer&quot; name=&quot;BaiduPlayer&quot; onError=if(window.confirm(&#39;请您先安装百度影音软件,然后刷新本页才可以正常播放.&#39;)){window.open(&#39;http://player.baidu.com&#39;)}else{self.location=&#39;http://player.baidu.com&#39;}&gt;        &lt;PARAM NAME=&#39;URL&#39; VALUE=$item.url&gt;        &lt;PARAM NAME=&#39;Autoplay&#39; VALUE=&#39;1&#39;&gt;        &lt;/object&gt;&lt;a title=&quot;返回首页&quot; href=&quot;http://kanimdb.duapp.com&quot;&gt; 返回首页 &lt;/a&gt;&lt;/blockquote&gt;</code></pre><p>top250style.css</p><pre><code class="css">body{  background-image: url(tw.jpg);  background-position:right;  background-color: #fff;  margin-left:15%;  margin-right:15%;  border: 2px dotted gray;  padding: 20px 20px 20px 20px;  font-family: sans-serif;}h1 {  font-family: sans-serif;  font-weight: bolder;;  color: green;  border-bottom: 2px solid gray;  text-align: center;}table {  width: 500px;  text-align: center;  margin-top: 30px;  margin-left: 20%;  margin-right: 20%;  border: thin solid black;  border-collapse: collapse;}th, #tdstyle {  border: thin dotted gray;  padding: 5px;  background-color: silver;}th {  background-color: #fcba7a;}#main {  padding-top: 20px;  padding-bottom: 20px;}#bdplaer {  padding-left: 10px;  padding-right: 10px;}#header {  text-align: center;}#footer {  padding: 10px, 10px, 10px, 10px;  text-align: center;}#copyright {  padding: 10px, 10px, 10px, 10px;  font-size: small;}</code></pre><p>修改app.conf</p><pre><code class="python">handlers:  - url : /static/images/(.*)    script: /static/images/$1  - url : /templates/(.*)    script: /templates/$1  - url : /(.*)    script: index.py  - expire : .jpg modify 10 years  - expire : .swf modify 10 years  - expire : .png modify 10 years  - expire : .gif modify 10 years  - expire : .JPG modify 10 years</code></pre><p>好了，现在这个应用基本上就可以看了，不过现在请忘了以上的代码。因为我们要为其添加一些自已的想要的东西</p><p>首先我们要添加“添加影片”功能</p><p>修改urls配置</p><pre><code class="python">urls = (    &quot;/&quot;,&quot;Index&quot;,    &quot;/play/(d+)&quot;,&quot;Play&quot;,    &quot;/add/&quot;,&quot;Add&quot;,    &quot;/addmovie/&quot;,&quot;addmovie&quot;)</code></pre><p>这里的addmovie 其实只是想render到一个模板中</p><p>添加class addmovie实现</p><pre><code class="python">class addmovie:  def GET(self):    return render.add()</code></pre><p>添加add.html</p><pre><code class="html">&lt;form action=&quot;/add/&quot; method=&quot;post&quot;&gt;电影名:&lt;input type=&quot;text&quot; name = &quot;name&quot;&gt;&lt;br&gt;得分:&lt;input type=&quot;text&quot; name = &quot;rating&quot;&gt;&lt;br&gt;播放地址:&lt;input type=&quot;text&quot; name = &quot;address&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;&lt;/form&gt;</code></pre><p>很简单的表单，我前端不会，只会写简单的html</p><p>这里name值可以随便写，有意义或者你自已认识即可，反正后面的python代码会做处理</p><p>这里将movie的信息post到/add/中</p><p>转为urls里已经配置了</p><p>“/add/“,”Add”,</p><p>下面来写class Add实现</p><pre><code class="python">class Add:  def POST(self):    movieinfo = web.data()    #model.additem(movieinfo)    #return render.show(movieinfo)    postlist = movieinfo.split(&#39;&amp;&#39;)    movie = []    for i in postlist:      movie.append(i.split(&#39;=&#39;)[1])    model.additem(urllib.unquote(movie[0]),movie[1],urllib.unquote(movie[2]))    web.seeother(&quot;/&quot;)</code></pre><p>这里的代码写的太ugly了，但是可以满足需要，如果有更好的实现可以和我说下</p><p>先将post来的数据使用&amp;分割，将会得到name=xxx,rating=xxx,address=xxx的列表</p><p>接着来获取相应的值，也就是再将列表中的各个项再用‘=’进行分割，然后将值append到一个新的列表中</p><p>然后将新的列表中的各个值进行unquote，要不你插入到数据库中的将不是中文等，而是quote过的数据</p><p>插件结束后跳转到首页 web.seeother(“/”)</p><p>好了，现在我们完成了添加电影的操作</p><h1 id="完成后你现在就去找些电影和百度影音地址来添加看看"><a href="#完成后你现在就去找些电影和百度影音地址来添加看看" class="headerlink" title="完成后你现在就去找些电影和百度影音地址来添加看看"></a>完成后你现在就去找些电影和百度影音地址来添加看看</h1><p>但是我发现一个新的问题，百度影音在非IE浏览器上是不好用的，这还了得……</p><p>在网上找方法，有一个通过 javacsript先判断浏览器的appname来决定使用哪个，<a href="http://pcbbs.baidu.com/thread-62871-1-1.html" target="_blank" rel="noopener">http://pcbbs.baidu.com/thread-62871-1-1.html</a></p><p>这个是我试过了，可以实现在chrome与FF下调用百度影音，但是我要传的$item.url不能传入javascrip中，传入后就是$item.url，在网上查找说可以要写两个$，我也试过了，但是还是不能播放，于是我决定放弃IE用户，让所有播放都走非IE的方法中，爱咋地咋地。</p><p>百度这点做的就不如qvod，人家官方都出了在非IE浏览器上调用的方法，而百度还在使用IE，真是不思进取，我也决定在网页上调用qvod播放接口</p><p>那么新的问题又来了，程序怎么知道你是要用qvod还是百度来播放？其实很简单，你在添加播放地址的时候，qvod的地址是以qvod开始的，百度影音是以bdhd开始的，只要判断一下$item.url是以哪个开头的就可以了</p><p>但是网上更多的还是thunder,edk等协议的影视资源，这些无论是百度还是qvod都无法播放，于是我想到了现在很流行的云点播，迅雷的云点播可以播放，但是非白金会员只能播放一段时间，随便找了几个提供在线云点播的，有弹出式广告的占大多数，于是找了一个没有广告的，okdvd，其接口调用也挺简单的</p><pre><code class="html">&lt;iframe scrolling=&quot;no&quot; frameborder=&quot;0&quot; name=&quot;win_vod&quot; id=&quot;win_vod&quot; border=&quot;0&quot; style=&quot;width: 950px; height: 550px&quot; src=&quot;http://www.okdvd.com/api.php#!url=后面加上播放地址&quot;&gt;&lt;/iframe&gt;</code></pre><p>所以最终修改我的play.html为</p><pre><code class="html">$def with(item)&lt;h2&gt;$item.id $item.moviename&lt;/h2&gt;&lt;blockquote&gt;&lt;div align = &quot;center&quot;&gt;$if item.url.startswith(&#39;qvod&#39;):    &lt;object classid=&quot;clsid:F3D0D36F-23F8-4682-A195-74C92B03D4AF&quot; width=&quot;860&quot; height=&quot;460&quot;                    id=&quot;QvodPlayer&quot; name=&quot;QvodPlayer&quot; onerror=&quot;document.getElementById(&#39;QvodPlayer&#39;).style.display=&#39;none&#39;;document.getElementById(&#39;iframe_down&#39;).style.display=&#39;&#39;;document.getElementById(&#39;iframe_down&#39;).src=&#39;http://error2.qvod.com/error4.htm&#39;;&quot;&gt;                    &lt;param name=&#39;Showcontrol&#39; value=&#39;2&#39;&gt;                    &lt;param name=&#39;URL&#39; value=$item.url&gt;                    &lt;param name=&#39;Autoplay&#39; value=&#39;1&#39;&gt;                    &lt;embed id=&quot;QvodPlayer2&quot; name=&quot;QvodPlayer2&quot; width=&quot;860&quot; height=&quot;460&quot; URL=$item.url type=&#39;application/qvod-plugin&#39; Autoplay=&#39;1&#39; Showcontrol=&#39;1&#39; &gt;&lt;/embed&gt;   &lt;/object&gt;$elif item.url.startswith(&#39;bdhd&#39;):&lt;object id=&quot;BaiduPlayer&quot; name=&quot;BaiduPlayer&quot; type=&quot;application/player-activex&quot; width=&quot;860&quot; height=&quot;460&quot; progid=&quot;Xbdyy.PlayCtrl.1&quot; param_URL=$item.url param_OnPlay=&quot;onPlay&quot; param_OnPause=&quot;onPause&quot; param_OnFirstBufferingStart=&quot;onFirstBufferingStart&quot; param_OnFirstBufferingEnd=&quot;onFirstBufferingEnd&quot; param_OnPlayBufferingStart=&quot;onPlayBufferingStart&quot; param_OnPlayBufferingEnd=&quot;onPlayBufferingEnd&quot; param_OnComplete=&quot;onComplete&quot; param_Autoplay=&quot;1&quot;&gt;&lt;/object&gt;$else:&lt;iframe scrolling=&quot;no&quot; frameborder=&quot;0&quot; name=&quot;win_vod&quot; id=&quot;win_vod&quot; border=&quot;0&quot; style=&quot;width: 860px; height: 460px&quot; src=&quot;http://www.okdvd.com/okapi.php#!url=$item.url&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/blockquote&gt;</code></pre><p>这里有一个问题困扰了我很长时间，原来这里的模板如果有python代码的话也是要遵循其缩进原则的，如$if 下面的<object>如果和$if同级，那么也会报错，BAE提供错误日志，可以很快的查看到哪里出错了</object></p><h1 id="首页上播放按钮现在还都是“播放”字样"><a href="#首页上播放按钮现在还都是“播放”字样" class="headerlink" title="首页上播放按钮现在还都是“播放”字样"></a>首页上播放按钮现在还都是“播放”字样</h1><p>我想让它显示是百度还是qvod播放，其实方法和上面一样，判断$item.url的startswith()方法，另外我又有了新的需求，因为网上有些电影的资源实在不好找到百度或者qvod与thunder或者edk资源，但是优酷或者土豆上有，那我可以让其跳转到相应的网址上播放</p><p>所以最终的index.html修改成这样</p><pre><code class="html">$def with(items)        &lt;table&gt;            &lt;tr&gt;                &lt;th&gt;排名&lt;/th&gt;                &lt;th&gt;影片名&lt;/th&gt;                &lt;th&gt;得分&lt;/th&gt;                &lt;th&gt;播放&lt;/th&gt;            &lt;/tr&gt;            $for item in items:            &lt;tr&gt;                &lt;td id=&quot;tdstyle&quot;&gt;$item.id&lt;/td&gt;                &lt;td id=&quot;tdstyle&quot;&gt;$item.moviename&lt;/td&gt;                &lt;td id=&quot;tdstyle&quot;&gt;$item.score&lt;/td&gt;                &lt;td id=&quot;tdstyle&quot;&gt;                  $if item.url.startswith(&quot;http&quot;):                    &lt;form action=&quot;$item.url&quot; method=&quot;get&quot; target=&quot;_blank&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;新页面播放&quot; /&gt;                    &lt;/form&gt;                  $elif item.url.startswith(&#39;bdhd&#39;):                    &lt;form action=&quot;/play/$item.id&quot; method=&quot;post&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;百度影音播放&quot; /&gt;                    &lt;/form&gt;                  $elif item.url.startswith(&#39;qvod&#39;):                    &lt;form action=&quot;/play/$item.id&quot; method=&quot;post&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;qvod播放&quot; /&gt;                    &lt;/form&gt;                  $else:                    &lt;form action=&quot;/play/$item.id&quot; method=&quot;post&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;云点播播放&quot; /&gt;                    &lt;/form&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;</code></pre><p>而最终的index.py修改成这样</p><pre><code class="python">#-*- coding:utf-8 -*-import webimport modelimport osimport reimport urlliburls = (    &quot;/&quot;,&quot;Index&quot;,    &quot;/play/(d+)&quot;,&quot;Play&quot;,    &quot;/add/&quot;,&quot;Add&quot;,    &quot;/addmovie/&quot;,&quot;addmovie&quot;)t_globals = {    &#39;datestr&#39;: web.datestr}app_root = os.path.dirname(__file__)template_root = os.path.join(app_root, &#39;templates/&#39;)render = web.template.render(template_root, base=&#39;base&#39;, globals=t_globals)class Index:    def GET(self):        items = model.get_items()#       return render.test(items)        return render.index(items)class Play:    def POST(self, id):        id = int(id)        item = model.get_item(id)        return render.play(item)class Add:  def POST(self):    movieinfo = web.data()    #model.additem(movieinfo)    #return render.show(movieinfo)    postlist = movieinfo.split(&#39;&amp;&#39;)    movie = []    for i in postlist:      movie.append(i.split(&#39;=&#39;)[1])    model.additem(urllib.unquote(movie[0]),movie[1],urllib.unquote(movie[2]))    web.seeother(&quot;/&quot;)class addmovie:  def GET(self):    return render.add()app = web.application(urls, globals()).wsgifunc()from bae.core.wsgi import WSGIApplicationapplication = WSGIApplication(app)</code></pre><h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>现在没有权限限制，谁都可以添加，也没有修改与删除选项，所以后面我将添加相应的权限管理，另外总不能自已都去手工添加电影，考虑使用爬虫来自动添加电影</p><h1 id="献给热爱的电影的同胞们"><a href="#献给热爱的电影的同胞们" class="headerlink" title="献给热爱的电影的同胞们"></a>献给热爱的电影的同胞们</h1><p>向<a href="http://zh.wikipedia.org/zh-cn/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener">亚伦·斯沃茨</a> 致敬</p><p><a href="/image/2013/11/Aaron_Swartz_at_Boston_Wikipedia_Meetup_20090818_.jpg"><img src="/image/2013/11/Aaron_Swartz_at_Boston_Wikipedia_Meetup_20090818__thumb.jpg" alt="Aaron_Swartz_at_Boston_Wikipedia_Meetup,_2009-08-18_" title="Aaron_Swartz_at_Boston_Wikipedia_Meetup,_2009-08-18_"></a> </p><p>&#160; 向<a href="http://dianying.fm/category/key_%E6%B1%A4%E5%94%AF" target="_blank" rel="noopener">汤唯</a>致敬</p><p><a href="/image/2013/11/357pxTang_Wei2.jpg"><img src="/image/2013/11/357pxTang_Wei2_thumb.jpg" alt="357px-Tang_Wei2" title="357px-Tang_Wei2"></a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> webpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web.py中关于url的总结</title>
      <link href="/article/932.html"/>
      <url>/article/932.html</url>
      <content type="html"><![CDATA[<p>网页中的数据在传递的时候有GET和POST两种方式，GET是以网址的形式传参数，在web.py中有着很好的匹配，如果我们配置以下的urls</p><pre><code class="python">  urls =(    &#39;/&#39;,&#39;index&#39;,    &#39;/weixin/(.*?)&#39;,&#39;WeixinInterface&#39;</code></pre><p>先不考虑/weixin/后面的东西，现在我们来写index的类</p><pre><code class="python">class index:    def GET(self):        i = web.input(name = &#39;kevinkelin&#39;,age = 100)</code></pre><a id="more"></a><p>随便写一个index.html模板文件</p><pre><code class="html">$def with(name,age)$if name:I just want to say &lt;em&gt;hello&lt;/em&gt; to $name, he is $age years old$else:&lt;em&gt;hello&lt;/em&gt;,world!</code></pre><p>当访问<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 此时没有传递name与age的值，由于我的GET函数里定义了默认的name与age的值，所以程序会将kevinkelin与26传递到模板中去得到以下的输出</p><p>I just want to say <em>hello</em> to kevinkelin, he is 100 years old</p><p>当访问<a href="http://127.0.0.1:8080/?name=yyx&amp;age=26" target="_blank" rel="noopener">http://127.0.0.1:8080/?name=yyx&amp;age=26</a> 即向GET函数中传递name = yyx and age = 26的时候得到以下的输出</p><p>I just want to say <em>hello</em> to yyx, he is 26 years old</p><p>&#160;</p><p>我们也可以不定义默认的的参数，即定义为空</p><p>i = web.input(name = None,age = None)</p><p>当访问<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 的时候将会得到 <em>hello</em>,world!的输出即模板中的else</p><p>但是如果你不定义name和age将会出错</p><p>i = web.input()</p><p>这是因为后面你将i.name与i.age分配到模板当中去，但是全局变量里又没有这两个变量，所以会报错</p><p>但有时我们想这样传递参数，不想加那个“？”这时我们得要更改urls规则</p><pre><code class="python">urls =(    &#39;/name=(.*)&amp;age=(.*)&#39;,&#39;index&#39;,    &#39;/weixin/(.*?)&#39;,&#39;WeixinInterface&#39;</code></pre><p>重新写class index</p><pre><code class="python">class index:    def GET(self,name,age):</code></pre><p>这里是将url的参数通过正则匹配然后传递到index类中的GET的参数中</p><p>当访问<a href="http://127.0.0.1:8080/name=yyx&amp;age=26" target="_blank" rel="noopener">http://127.0.0.1:8080/name=yyx&amp;age=26</a> 时将得到</p><p>I just want to say <em>hello</em> to yyx, he is 26 years old</p><p>第二种方法看似简单，但其实不好控制，要求写的正则工作量加大了</p><p>如果我想知道到底有多少参数通过GET方式传递过来，我可以直接return 来看一下到底有哪些传递过来了</p><p>&#160;</p><p>接下来看一下post来的数据</p><p>我们可以制作一个简单的表单或者直接使用fiddler来构造数据进行POST传值</p><pre><code class="python">def POST(self):        data = web.data()</code></pre><p>&#160;</p><p>我想看一下得到的数据类型</p><p>return type(data)</p><p>得到的是<type 'str'="">，也就是说web.py已经将post的数据转换成了str类型</type></p><p>那么我来试一下传递xml</p><pre><code class="xml">&lt;xml&gt;&lt;ToUserName&gt;yanxingyang&lt;/ToUserName&gt;&lt;FromUserName&gt;study_python&lt;/FromUserName&gt;&lt;CreateTime&gt;123456&lt;/CreateTime&gt;&lt;MsgType&gt;text&lt;/MsgType&gt;&lt;Content&gt;Just a test&lt;/Content&gt;&lt;/xml&gt;</code></pre><p>其实这个微信的XML格式做了一些更改，我来试着使用lxml对它进行解析</p><p>from lxml import etree </p><p>data = web.data()</p><p>xml = etree.fromstring(data)</p><p>content = xml.find(‘Content’).text</p><p>return content</p><p>得到的结果很好</p><p>关于python解析XML以前也有总结过（<a href="http://my.oschina.net/yangyanxing/blog/159212" target="_blank" rel="noopener">http://my.oschina.net/yangyanxing/blog/159212</a>），在我的脑子里总感觉解析XML是件头痛的事情……</p><p>今天先总结到这，明天接着搞LXML进行解析xml操作。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> webpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在中文windows下使用pywinauto进行窗口操作（一）</title>
      <link href="/article/926.html"/>
      <url>/article/926.html</url>
      <content type="html"><![CDATA[<p>这两天开始接触pywinauto，听说百度的自动化QA也用这个模块，于是来了兴趣，但网上的教程很少，而且基本上都是拿官方的notepad来说，首先中文菜单的支持是问题，其次各种操作也没有写清楚，阅读官方的文档，发现这个东西使用起来还真是非常方便，下面我也以notepad为例来说明一下它的简单操作。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="pywinauto"><a href="#pywinauto" class="headerlink" title="pywinauto;"></a>pywinauto;</h2><p> <a href="https://sourceforge.net/project/showfiles.php?group_id=157379" target="_blank" rel="noopener">https://sourceforge.net/project/showfiles.php?group_id=157379</a></p><h2 id="Sendkeys"><a href="#Sendkeys" class="headerlink" title="Sendkeys"></a>Sendkeys</h2><p><a href="http://www.rutherfurd.net/python/sendkeys/index.html" target="_blank" rel="noopener">http://www.rutherfurd.net/python/sendkeys/index.html</a></p><h2 id="ctypes-如果你是python2-3或者2-4"><a href="#ctypes-如果你是python2-3或者2-4" class="headerlink" title="ctypes (如果你是python2.3或者2.4)"></a>ctypes (如果你是python2.3或者2.4)</h2><p>检测你是否安装正确</p><blockquote><p>from pywinauto import application<br>app = application.Application.start(“notepad.exe”)<br>app.notepad.TypeKeys(“%FX”)</p></blockquote><a id="more"></a><p>都安装好了以后，我们来正式进入pywinauto的世界</p><h1 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h1><pre><code class="python">from pywinauto import applicationapp = application.Application.start(&#39;notepad.exe&#39;)</code></pre><p>start() 函数里也可以接路径+程序名</p><p>使用spy++lite查看notepad的信息</p><p><a href="/image/2013/10/1.png"><img src="/image/2013/10/1_thumb.png" alt="1" title="1"></a> </p><p>里面的窗口类名与标题文本相关重要，以后的查找窗口基本上都要用的到</p><p>现在我们来点击“帮助-&gt;关于记事本”操作</p><pre><code class="python">app.Notepad.MenuSelect(&#39;帮助-&gt;关于记事本&#39;.decode(&#39;gb2312&#39;))</code></pre><p>这里的app是你刚才实例的对象，Notepad是类名，可以从spy++lite中看到,MenuSelect方法可以自动检索Notepad上的菜单选项，</p><p>decode(‘gb2312’)方法是把中文强制转换为unicode编码，对于非英文的操作系统都是要转换的，后面还有更简单的方法</p><h1 id="查找“关于记事本”的窗口"><a href="#查找“关于记事本”的窗口" class="headerlink" title="查找“关于记事本”的窗口"></a>查找“关于记事本”的窗口</h1><p>还是使用spy++lite来查看“关于记事本”的信息</p><p><a href="/image/2013/10/2.png"><img src="/image/2013/10/2_thumb.png" alt="2" title="2"></a> </p><p>窗口类名：#32770</p><p>标题文字：关于“记事本”</p><p>官方法文档中有以下两个方法</p><p>1. 通过top_dlg = app.top<em>window</em>() 来获得最上面的window，但是官方并不推荐这种方式，目前来说这个“关于记事本”是最上面，但是也不能保证在测试的进程当中有什么意外的进程跑到了上面，一旦有新的进程，那么得到的就是一个错误的对象</p><p>2.通过find<em>dlg = app.window</em>(title_re = ‘’, class_name = ‘’) 方法获得，这也是为什么我上面说标题文本与窗口类名非常重要的原因，title_re和 class_name这两个可以单独使用也可以一块使用，因为有时没有标题文本，也有时一个窗口类名有多个对象，比如“Edit”有时当一个对话框中有多个输入框时会有多个Edit类名，对于“关于记事本”我们可以通过以下代码获得</p><p>中文要进行unicode编码，这里也可以通过decode(‘gb2312’)方法实现，但是不如输入一个U省事~ 呵呵</p><p>我们print一下得到的about_dlg</p><pywinauto.application.windowspecification object="" at="" 0x01f0a530=""><p>说明我们得到的是一个application.WindowSpecification对象</p><h1 id="在”关于记事本”窗口上找到“确定”按钮-button"><a href="#在”关于记事本”窗口上找到“确定”按钮-button" class="headerlink" title="在”关于记事本”窗口上找到“确定”按钮(button)"></a>在”关于记事本”窗口上找到“确定”按钮(button)</h1><p>在pywinauto中，对话框下面的是controller，button,checkbox,textbox等都是controller</p><p>我们可以使用print_control_identifiers() 方法来打印出该窗口中所有的controller</p><p>会得到以下的输出</p><pre><code class="html">Control Identifiers:Static - &#39;&#39;   (L312, T265, R738, B267)&#39;&#39; &#39;0&#39; &#39;1&#39; &#39;Static&#39; &#39;Static0&#39; &#39;Static1&#39;Static - &#39;&#39;   (L308, T280, R340, B313)&#39;2&#39; &#39;Static2&#39;Static - &#39;Microsoft Windows&#39;   (L350, T280, R695, B295)&#39;Microsoft Windows&#39; &#39;Microsoft WindowsStatic&#39; &#39;Static3&#39;Static - &#39;u7248u672c 6.1 (u5185u90e8u7248u672c 7601: Service Pack 1)&#39;   (L350, T295, R748, B310)&#39;Static4&#39; &#39;u7248u672c 6.1 (u5185u90e8u7248u672c 7601: Service Pack 1)&#39; &#39;u7248u672c 6.1 (u5185u90e8u7248u672c 7601: Service Pack 1)Static&#39;Static - &#39;u7248u6743u6240u6709 xa9 2009 Microsoft Corporationu3002u4fddu7559u6240u6709u6743u5229u3002&#39;   (L350, T310, R710, B325)&#39;Static5&#39; &#39;u7248u6743u6240u6709 xa9 2009 Microsoft Corporationu3002u4fddu7559u6240u6709u6743u5229u3002&#39; &#39;u7248u6743u6240u6709 xa9 2009 Microsoft Corporationu3002u4fddu7559u6240u6709u6743u5229u3002Static&#39;Static - &#39;Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002&#39;   (L350, T325, R710, B385)&#39;Static6&#39; &#39;Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002&#39; &#39;Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static&#39; &#39;Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static0&#39; &#39;Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static1&#39;Static - &#39;&#39;   (L350, T385, R665, B415)&#39;Static7&#39; &#39;Windows 7 u65d7u8230u7248 u64cdu4f5cu7cfbu7edfu53cau5176u7528u6237u754cu9762u53d7u7f8eu56fdu548cu5176u4ed6u56fdu5bb6/u5730u533au7684u5546u6807u6cd5u548cu5176u4ed6u5f85u9881u5e03u6216u5df2u9881u5e03u7684u77e5u8bc6u4ea7u6743u6cd5u4fddu62a4u3002Static2&#39;SysLink - &#39;u6839u636e &lt;A&gt;Microsoft u8f6fu4ef6u8bb8u53efu6761u6b3e&lt;/A&gt;uff0cu672cu4ea7u54c1u4f7fu7528u6743u5c5eu4e8e:&#39;   (L350, T415, R665, B445)&#39;SysLink&#39; &#39;u6839u636e &lt;A&gt;Microsoft u8f6fu4ef6u8bb8u53efu6761u6b3e&lt;/A&gt;uff0cu672cu4ea7u54c1u4f7fu7528u6743u5c5eu4e8e:&#39; &#39;u6839u636e &lt;A&gt;Microsoft u8f6fu4ef6u8bb8u53efu6761u6b3e&lt;/A&gt;uff0cu672cu4ea7u54c1u4f7fu7528u6743u5c5eu4e8e:SysLink&#39;Static - &#39;kevin&#39;   (L365, T445, R680, B460)&#39;Static8&#39; &#39;kevin&#39; &#39;kevinStatic&#39; &#39;kevinStatic0&#39; &#39;kevinStatic1&#39;Static - &#39;&#39;   (L365, T460, R680, B475)&#39;Static9&#39; &#39;kevinStatic2&#39;Button - &#39;u786eu5b9a&#39;   (L672, T503, R747, B524)&#39;Button&#39; &#39;u786eu5b9a&#39; &#39;u786eu5b9aButton&#39;</code></pre><p>static，SysLink,button等是它类型，后面接的是title，都是unicode的，这里面就有没有title的controller，再后面的（L,T,R,B）是这个控件的位置，分别对应着左上右下</p><p>在”关于记事本”窗口上找到“确定”按钮，可以通过app.window_()方法，传入的参数可以是title,也可以是class_name,所以我说这两个值相当重要，一直在用，这里的title支持正则表达式，非常方便</p><p>在app上先找到about_dlg,然后再about_dlg上找确定button</p><p>app.window_(title<em>re = u’关于“记事本”’).window</em>(title_re = u’确定’)，然后通过Click()方法来单击这个button</p><p>另外一种方法也是官方推荐的在非英文系统下的方法</p><pre><code class="python">OK = u&#39;确定&#39;about_dlg[OK].Click()</code></pre><p>这个的意思就是在about_dlg下找到u’确定’，看起来比上面要简练好理解，理解了这种方式，接下来还有更简单的，都不用找about_dlg</p><p>直接 app[u’关于“记事本”’][u’确定’].Click()</p><h1 id="在记事本里写点东西"><a href="#在记事本里写点东西" class="headerlink" title="在记事本里写点东西"></a>在记事本里写点东西</h1><p>这个其实在校验pywinauto的时候已经做过了全用TypeKeys函数，但是这里如果要输入中文还是要u一下</p><pre><code class="python">app.notepad.TypeKeys(u&quot;杨彦星&quot;)</code></pre><h1 id="一个比较恶心的问题"><a href="#一个比较恶心的问题" class="headerlink" title="一个比较恶心的问题"></a>一个比较恶心的问题</h1><p>在MenuSelect函数中不支持正则，完全是全文匹配，如我输入</p><p>dig = app.Notepad.MenuSelect(“编辑-&gt;替换”.decode(‘gb2312’)) 是找不到对象的</p><p>必须要</p><p>dig = app.Notepad.MenuSelect(“编辑(E)-&gt;替换(R)”.decode(‘gb2312’)) 这样才行，得把(R) (E)写上才行，但是奇怪的是上面的“帮助-&gt;关于记事本”就不用输入，所以说是一个挺恶心的问题，我也不知道这是为什么…… </p><p>最后把上面的函数合并一下，跑下来应该会很快</p><pre><code class="python">#! /usr/bin/env python#coding=gbkimport timefrom pywinauto import applicationapp = application.Application.start(&#39;notepad.exe&#39;)app.Notepad.MenuSelect(&#39;帮助-&gt;关于记事本&#39;.decode(&#39;gb2312&#39;))time.sleep(.5)#这里有两种方法可以进行定位“关于记事本”的对话框#top_dlg = app.top_window_() 不推荐这种方式，因为可能得到的并不是你想要的about_dlg = app.window_(title_re = u&quot;关于&quot;, class_name = &quot;#32770&quot;)#这里可以进行正则匹配title#about_dlg.print_control_identifiers()app.window_(title_re = u&#39;关于“记事本”&#39;).window_(title_re = u&#39;确定&#39;).Click()app.Notepad.MenuSelect(&#39;帮助-&gt;关于记事本&#39;.decode(&#39;gb2312&#39;))time.sleep(.5) #停0.5s 否则你都看不出来它是否弹出来了！ABOUT = u&#39;关于“记事本”&#39;OK = u&#39;确定&#39;#about_dlg[OK].Click()#app[ABOUT][OK].Click()app[u&#39;关于“记事本”&#39;][u&#39;确定&#39;].Click()app.Notepad.TypeKeys(u&quot;杨彦星&quot;)dig = app.Notepad.MenuSelect(&quot;编辑(E)-&gt;替换(R)&quot;.decode(&#39;gb2312&#39;))Replace = u&#39;替换&#39;Cancle = u&#39;取消&#39;time.sleep(.5)app[Replace][Cancle].Click()dialogs = app.windows_()</code></pre><p>先写这么多，以后再写点更多的应用~</p></pywinauto.application.windowspecification>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用python进行windows自动化测试（1）</title>
      <link href="/article/920.html"/>
      <url>/article/920.html</url>
      <content type="html"><![CDATA[<p>最近开始学习整理python在windows自动化测试中的使用，觉得挺有意思的</p><p>主要思路，在windows下，主要通过启进程，然后查找进程的句柄，然后再操作这个句柄，包括点击，填写文字，关闭，获取文字等操作</p><p>下面以一个简单的校验文件md5值的操作来介绍一个python的应用，当然python中有校验md5的函数，不用非要使用工具来校验，这里只是练习使用python来自动化操作</p><p>所用的工具有SpyLite，用于查看窗口ID，句柄等信息<br> <a id="more"></a><br>工具下载 </p><p><a href="http://www.xiazaiba.com/html/358.html" target="_blank" rel="noopener">http://www.xiazaiba.com/html/358.html</a>&#160;</p><p><a href="http://www.xiazaiba.com/html/5861.html" target="_blank" rel="noopener">http://www.xiazaiba.com/html/5861.html</a></p><p>我们要达到的目的是通过md5校验工具将文件的md5值保存到一个log文档中</p><p>测试的目录结构</p><p>–automd5–</p><p>&#160;&#160;&#160; –needCheck–</p><p>&#160;&#160;&#160; checkmd5.py</p><p>&#160;&#160;&#160; SpyLite24.exe</p><p>&#160;&#160;&#160; Hash.exe</p><p>needCheck目录放需要检查md5的文件</p><p>&#160;</p><p>&#160;</p><pre><code class="python">#! /usr/bin/env python#coding=gbkimport time,re,ctypesimport os,sys,subprocess,win32gui,win32con,win32apiimport glob,time#启进程函数def createProcess(cmd, wait = False):    if wait:        proc = tryExcept(subprocess.Popen, cmd, stdout = subprocess.PIPE, stderr = subprocess.PIPE)    else:        proc = tryExcept(subprocess.Popen, cmd)    if isExcept(proc):        return    if not wait:        return proc.pid    proc.communicate()def tryExcept(func, *params, **paramMap):    try:        return func(*params, **paramMap)    except Exception, e:        return edef isExcept(e, eType = Exception):    return isinstance(e, eType)class BaseWindow:    @staticmethod    def parseClickConfig(clkCfg):        if clkCfg == None:            return None, None, False, 0        if type(clkCfg) == bool:            return None, None, clkCfg, 0        if type(clkCfg) == int:            return None, None, False, clkCfg        if len(clkCfg) == 2:            if type(clkCfg[0]) == int and type(clkCfg[1]) == int:                return clkCfg[0], clkCfg[1], False, 0            return None, None, clkCfg[0], clkCfg[1]        if len(clkCfg) == 3:            if type(clkCfg[2]) == bool:                return clkCfg[0], clkCfg[1], clkCfg[2], 0            return clkCfg[0], clkCfg[1], False, clkCfg[2]        return clkCfg#点击窗口#clkCfg:byDrv|mode|(x,y)|(byDrv,mode)|(x,y,byDrv)|(x,y,mode)|(x,y,byDrv,mode)def clickWindow(hwnd, clkCfg = None):    if isRawWindow(hwnd):        return    topWindow(hwnd)    rect = getWindowRect(hwnd)    if not rect:        return    x, y, byDrv, mode = BaseWindow.parseClickConfig(clkCfg)    if x == None:        x = (rect[0] + rect[2]) / 2    elif x &lt; 0:        x += rect[2]    else:        x += rect[0]    if y == None:        y = (rect[1] + rect[3]) / 2    elif y &lt; 0:        y += rect[3]    else:        y += rect[1]    clickMouse(x, y, byDrv, mode)#点击鼠标CLICK_MOUSE = 0CLICK_MOUSE_DOUBLE = 1CLICK_MOUSE_RIGHT = 2def clickMouse(x, y, byDrv = False, mode = CLICK_MOUSE):    moveMouse(x, y, byDrv)    downMsg, upMsg = win32con.MOUSEEVENTF_LEFTDOWN, win32con.MOUSEEVENTF_LEFTUP    if mode == CLICK_MOUSE_RIGHT:        downMsg, upMsg = win32con.MOUSEEVENTF_RIGHTDOWN, win32con.MOUSEEVENTF_RIGHTUP    win32api.mouse_event(downMsg, 0, 0, 0, 0)    win32api.mouse_event(upMsg, 0, 0, 0, 0)    if mode == CLICK_MOUSE_DOUBLE:        win32api.mouse_event(downMsg, 0, 0, 0, 0)        win32api.mouse_event(upMsg, 0, 0, 0, 0)#移动鼠标def moveMouse(x, y, byDrv = False):    w, h = win32api.GetSystemMetrics(0), win32api.GetSystemMetrics(1)    x, y = int(float(x) / w * 65535), int(float(y) / h * 65535)    win32api.mouse_event(win32con.MOUSEEVENTF_MOVE | win32con.MOUSEEVENTF_ABSOLUTE, x, y, 0, 0)#获得窗口尺寸def getWindowRect(hwnd):    rect = tryExcept(win32gui.GetWindowRect, hwnd)    if not isExcept(rect):        return rect#置顶窗口def topWindow(hwnd):    fgHwnd = win32gui.GetForegroundWindow()    if fgHwnd == hwnd:        return True    rst = tryExcept(win32gui.SetForegroundWindow, hwnd)    if not isExcept(rst):        return True    return getWindowClass(fgHwnd) == &#39;Progman&#39; and getWindowText(fgHwnd) == &#39;Program Manager&#39;##获取窗口文字def getWindowText(hwnd, buf = ctypes.c_buffer(1024)):    size = ctypes.sizeof(buf)    ctypes.memset(buf, 0, size)    tryExcept(win32gui.SendMessageTimeout, hwnd, win32con.WM_GETTEXT, size, buf, win32con.SMTO_ABORTIFHUNG, 10)    return buf.value.strip()#获取窗口类名def getWindowClass(hwnd, buf = ctypes.c_buffer(1024)):    size = ctypes.sizeof(buf)    ctypes.memset(buf, 0, size)    ctypes.windll.user32.GetClassNameA(hwnd, ctypes.addressof(buf), size)    return buf.value.strip()#查找第一个窗口#title:text,class,ctrlid#parentTitle:None,hwnd,text,classdef findWindow(title, parentTitle = None, isRaw = False):    hwndList = findWindows(title, parentTitle, isRaw)    if hwndList:        return hwndList[0]def findRawWindows(title, parentTitle = None):    return findWindows(title, parentTitle, True)#判断是否为非正常窗口def isRawWindow(hwnd):    return not win32gui.IsWindowVisible(hwnd) or not win32gui.IsWindowEnabled(hwnd) or ctypes.windll.user32.IsHungAppWindow(hwnd)#查找窗口#title:text,class,ctrlid#parentTitle:None,hwnd,text,classdef findWindows(title, parentTitle = None, isRaw = False):    def __enumWindowHandler__(hwnd, wndList):        text = re.split(&#39;[r|n]+&#39;, getWindowText(hwnd))[0].strip()        clazz = getWindowClass(hwnd).strip()        ctrlId = win32gui.GetDlgCtrlID(hwnd)        wndList.append((hwnd, text, clazz, ctrlId))    if not parentTitle:        parentHwndList = [None]    elif type(parentTitle) == int:        parentHwndList = [parentTitle]    else:        parentHwndList = findRawWindows(parentTitle)    hwndSet = set()    for parentHwnd in parentHwndList:        wndList = []        #EnumWindows        if parentHwnd:            tryExcept(win32gui.EnumChildWindows, parentHwnd, __enumWindowHandler__, wndList)        else:            win32gui.EnumWindows(__enumWindowHandler__, wndList)        #FindWindowEx        hwnd, foundHwndList = None, []        while True:            hwnd = tryExcept(win32gui.FindWindowEx, parentHwnd, hwnd, None, None)            if not hwnd or isExcept(hwnd) or hwnd in foundHwndList:                break            __enumWindowHandler__(hwnd, wndList)            foundHwndList.append(hwnd)        #GetWindow        if parentHwnd:            hwnd = tryExcept(win32gui.GetWindow, parentHwnd, win32con.GW_CHILD)        else:            hwnd = tryExcept(win32gui.GetWindow, win32gui.GetDesktopWindow(), win32con.GW_CHILD)        while hwnd and not isExcept(hwnd):            __enumWindowHandler__(hwnd, wndList)            hwnd = tryExcept(win32gui.GetWindow, hwnd, win32con.GW_HWNDNEXT)        #Combine        for hwnd, text, clazz, ctrlId in set(wndList):            if type(title) == int:                if ctrlId == title:                    hwndSet.add(hwnd)            elif text == title or re.match(&#39;^&#39; + title + &#39;$&#39;, text, re.S) or clazz == title or re.match(&#39;^&#39; + title + &#39;$&#39;, clazz, re.S):                hwndSet.add(hwnd)            if parentHwnd:                hwndSet.update(findRawWindows(title, hwnd))    if isRaw:        return list(hwndSet)    hwndList = []    for hwnd in hwndSet:        if not isRawWindow(hwnd):            hwndList.append(hwnd)    return hwndList#设置窗口文字def setWindowText(hwnd, text):    rst = tryExcept(win32gui.SendMessageTimeout, hwnd, win32con.WM_SETTEXT, 0, text, win32con.SMTO_ABORTIFHUNG, 10)    return not isExcept(rst)#杀掉指定name的进程def killProcessByName(pname, user = None):    killProcessByNames([pname], user)def listFile(path, isDeep=True):    _list = []    if isDeep:        try:            for root, dirs, files in os.walk(path):                for fl in files:                    _list.append(&#39;%s%s&#39; % (root, fl))        except:            pass    else:        for fn in glob.glob( path + os.sep + &#39;*&#39; ):            if not os.path.isdir(fn):                _list.append(&#39;%s&#39; % path + os.sep + fn[fn.rfind(&#39;&#39;)+1:])    return _list#杀掉指定name的进程列表def killProcessByNames(pnameList, user = None):    cmd = &#39;taskkill /F /T&#39;    if user:        cmd += &#39; /FI &quot;USERNAME eq %s&quot;&#39; % user    for pname in pnameList:        cmd += &#39; /IM %s&#39; % pname    createProcess(cmd, True)#超时设置def handleTimeout(func, timeout, *params, **paramMap):    interval = 0.8    if type(timeout) == tuple:        timeout, interval = timeout    while timeout &gt; 0:        t = time.time()        rst = func(*params, **paramMap)        if rst and not isExcept(rst):            break        time.sleep(interval)        timeout -= time.time() - t    return rst#写文件def setFileData(filename, data, mode):    f = open(filename, mode)    f.write(data)    f.close()if __name__ == &#39;__main__&#39;:    if os.path.isfile(&#39;md5.log&#39;):        os.system(&#39;del md5.log&#39;)    parentHwnd = r&#39;Hash.*?&#39;    #setWindowText(textblack,&#39;123&#39;)    filedir = os.path.join(os.getcwd(),&#39;needCheck&#39;)    filelist = listFile(filedir)    #os.chdir(filedir)    for file in filelist:        #启进程        createProcess(&#39;Hash.exe&#39;)        #查找浏览按钮        browse_button = findWindow(r&#39;浏览.*?&#39;,parentHwnd)        #点击浏览按钮        clickWindow(browse_button)        textblack = findWindow(0x47C,&#39;#32770&#39;)        handleTimeout(setWindowText,10,textblack,file)        open_hwnd = findWindow(&#39;打开.*?&#39;,&#39;#32770&#39;)        #点击打开按钮        clickWindow(open_hwnd)        #获取文件md5信息        #需要内容的行号        expect_content_id = [0,4]        content_hwnd = findWindow(0x3EA,r&#39;Hash.*?&#39;)        content_text = handleTimeout(getWindowText,20,content_hwnd)        content = content_text.split(&#39;rn&#39;)        md5content = [i.split(&#39;: &#39;)[1].strip() for ind, i in enumerate(content) if ind in expect_content_id]        print md5content        filename,md5value = md5content        setFileData(&#39;md5.log&#39;,&#39;文件名:&#39;+filename+&#39;n&#39;+&#39;md5:&#39;+ md5value+&#39;nn&#39;,&#39;a&#39;)        killProcessByName(&#39;Hash.exe&#39;)    os.system(&#39;pause&#39;)</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过hello world程序判断你的虚拟主机是否支持python</title>
      <link href="/article/897.html"/>
      <url>/article/897.html</url>
      <content type="html"><![CDATA[<p>今天在RC上买了台虚拟主机玩玩，看它上面说支持python语言，于是试了下</p><p>写一个hello world的小程序</p><pre><code class="shell">#!/usr/bin/pythonprint &#39;Content-Type: text/plainn&#39;</code></pre><p>以二进制方式上传到自已的空间上，访问 <a href="http://static.yangyanxing.com/test.py" target="_blank" rel="noopener">http://static.yangyanxing.com/test.py</a></p><p>居然一次性成功了，完美地显示hello world<br><a id="more"></a></p><p>可是在网上查了一下，发现大部分还是出现500服务器错误，主要是以下几个原因</p><p>RC的python路径为/usr/bin/python 所以要在python文件首行加上</p><p>有时还要改.htaccess，在上面添加对python的解析</p><p>AddHandler cgi-script .py</p><p>没有以二进制方式上传</p><p>上传后有时要改下这个文件的权限为755，我的是744也可以执行</p><p>还是500服务器错误，请检查代码写是否有问题，别少一个引号多加一个分号什么的</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python中的urllib2库的使用</title>
      <link href="/article/911.html"/>
      <url>/article/911.html</url>
      <content type="html"><![CDATA[<p>今天研究了下urllib2这个库的使用，才发现以前有很多不明白的东西，现在写下来也做个记录</p><h1 id="最基础的应用"><a href="#最基础的应用" class="headerlink" title="最基础的应用"></a>最基础的应用</h1><pre><code class="python">import urllib2url = r&#39;http://www.baidu.com&#39;html = urllib2.urlopen(url).read()</code></pre><p>客户端与服务器端通过request与response来沟通，客户端先向服务端发送request，然后接收服务端返回的response</p><p>urllib2提供了request的类，可以让用户在发送请求前先构造一个request的对象，然后通过urllib2.urlopen方法来发送请求</p><pre><code class="python">import urllib2url = r&#39;http://www.baidu.com&#39;req = urllib2.Request(url)html = urllib2.urlopen(req).read()</code></pre><a id="more"></a><p>上例中先使用req = urllib2.Request(url)实例化一个resquest对象，接下来使用urllib2.urlopen(req)来打开这个网页</p><p>我们注意到在实例化Request对象的时候，队了url是必须的，还有几个默认的参数</p><p><a href="/image/2013/09/attars.png"><img src="/image/2013/09/attars_thumb.png" alt="attars" title="attars"></a> </p><p>基中data与header也是使用的比较多的，一些需要登录的才能浏览的网站经常需要这两个参数</p><pre><code class="python">import urllibimport urllib2url = &#39;http://www.baidu.com/&#39;values = {&#39;name&#39; : &#39;Michael Foord&#39;, &#39;location&#39; : &#39;Northampton&#39;,&#39;language&#39; : &#39;Python&#39; }data = urllib.urlencode(values)req = urllib2.Request(url,data)response = urllib2.urlopen(req)the_page = response.read()</code></pre><p>这个例子是向百度发送几个数据，这个例子是会返回一个错误页面，很正常，因为我们在访问百度的时候并不需要post什么信息，post了倒是会出错</p><p>百度是找不到相应的网页就会报错。</p><p>当然这个是POST数据，也可以用在GET方法，稍将上面的代码进行改造</p><p>百度是通过<a href="http://www.baidu.com/s?wd=XXX" target="_blank" rel="noopener">http://www.baidu.com/s?wd=XXX</a> 来进行查询的，这样我们需要将{‘wd’:’xxx’}这个字典进行urlencode</p><pre><code class="python">#coding:utf-8import urllibimport urllib2url = &#39;http://www.baidu.com/s&#39;values = {&#39;wd&#39;:&#39;杨彦星&#39;}data = urllib.urlencode(values)print dataurl2 = url+&#39;?&#39;+dataresponse = urllib2.urlopen(url2)the_page = response.read()</code></pre><p>以下以模拟登录人人网然后再显示首页内容为例来详细说明一下cookie的使用，以下是文档中给的例子，我们就通过改造这个例子来实现我们想要的功能</p><pre><code class="python">import cookielib, urllib2cj = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))r = opener.open(&quot;http://example.com/&quot;)</code></pre><p>&#160;</p><pre><code class="python">#coding:utf-8import urllib2,urllibimport cookieliburl = r&#39;http://www.renren.com/ajaxLogin&#39;#创建一个cj的cookie的容器cj = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))#将要POST出去的数据进行编码data = urllib.urlencode({&quot;email&quot;:email,&quot;password&quot;:pass})r = opener.open(url,data)</code></pre><p>当你看到有cj的时候,说明你已经访问了登录页面,是否正常登录你现在还看不出来,可以通过访问<a href="http://www.renren.com/home" target="_blank" rel="noopener">http://www.renren.com/home</a> 来查看</p><p>上面的代码有两点要说明,我也是看了很长时间才明白</p><p>r = opener.open(url,data) 这句,为什么要使用opener这个对象来open,而不是用utllib2,urlopen?不光是例子里这么写,我们才这么写,通过改造我们也可以使用urllib2.urlopen,其实是因为opener是urllib2.bulid_opener创造出来的, 但是你可以这样理解,他build出来后,自已却并没有安装使用它,也没有它的属性与方法,如果想使urllib2也具有opener的属性与方法,可以先使用urllib2.install_opener(opener)来”安装”这个opener,安装完以后就可以使用urllib2来操作了</p><pre><code class="python">#coding:utf-8import urllib2,urllibimport cookieliburl = r&#39;http://www.renren.com/ajaxLogin&#39;#创建一个cj的cookie的容器cj = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))urllib2.install_opener(opener)#将要POST出去的数据进行编码data = urllib.urlencode({&quot;email&quot;:email,&quot;password&quot;:pass})#r = opener.open(url,data)如果没有上面的urllib2.install_opener方法，就必须这样写了r = urllib2.urlopen(url,data)html = urllib2.urlopen(&#39;http://www.renren.com/home&#39;).read()</code></pre><p>同样urllib2还有proxy相关的handle,基本的思路和这个差不多</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python处理网页中的cookie</title>
      <link href="/article/908.html"/>
      <url>/article/908.html</url>
      <content type="html"><![CDATA[<p>最近想要搭建个小黄鸡的微信应用，但是一路来发现，现在很多的方法都已经不能用了，我在本地试过，也试用过requests获取session的方法也不行，但是这经过这次折腾，倒是对cookie有了更多的了解，以下以python登录人人网的例子来介绍cookie的使用。<br>cookie的定义可以参考百度百科，<a href="http://baike.baidu.com/subview/835/5062332.htm" target="_blank" rel="noopener">http://baike.baidu.com/subview/835/5062332.htm</a> 但是里面说的乱七八糟的，而且好多重复，使用firefox或者fiddler等工具来抓取cookie<br>在firefox下使用httpFox插件来查到人人网的登录时需要POST的地址是<a href="http://www.renren.com/ajaxLogin" title="http://www.renren.com/ajaxLogin" target="_blank" rel="noopener">http://www.renren.com/ajaxLogin</a>&#160;<br><a href="/image/2013/09/getUrl.png"><img src="/image/2013/09/getUrl_thumb.png" alt="getUrl" title="getUrl"></a><br><a id="more"></a><br>而且查看到需要POST的DATA有email和password </p><p>python通过cookielib来处理cookie，以下是简单的代码</p><pre><code class="python">&gt;&gt;&gt; import urllib&gt;&gt;&gt; import urllib2,cookielib&gt;&gt;&gt; login_page = &quot;http://www.renren.com/ajaxLogin&quot;&gt;&gt;&gt; cj = cookielib.CookieJar()&gt;&gt;&gt; opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))&gt;&gt;&gt; opener.add_handler = [(&#39;User-agent&#39;,&#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#39;)]&gt;&gt;&gt; data = urllib.urlencode({&quot;email&quot;:&#39;username&#39;,&quot;password&quot;:&#39;password&#39;})&gt;&gt;&gt; opener.open(login_page,data)&lt;addinfourl at 53653216 whose fp = &lt;socket._fileobject object at 0x03307B70&gt;&gt;&gt;&gt;&gt; if cj:... for index,cookie in enumerate(cj):... print index,&#39;:&#39;,cookie...0 : &lt;Cookie _de=90D533AE20EB964CA96710977F452897 for .renren.com/&gt;1 : &lt;Cookie anonymid=hlehtdzg-8359yw for .renren.com/&gt;2 : &lt;Cookie first_login_flag=1 for .renren.com/&gt;3 : &lt;Cookie id=224967207 for .renren.com/&gt;4 : &lt;Cookie loginfrom=null for .renren.com/&gt;5 : &lt;Cookie p=9beb60859c004bcaf0a32ff2c973473d7 for .renren.com/&gt;6 : &lt;Cookie societyguester=86b6a6006002ab6316f708521ab50bfc7 for .renren.com/&gt;7 : &lt;Cookie t=86b6a6006002ab6316f708521ab50bfc7 for .renren.com/&gt;8 : &lt;Cookie xnsid=fa53da51 for .renren.com/&gt;9 : &lt;Cookie t=30af9ffe774f4d6f242e92da1ccd6670 for .renren.com/xtalk/&gt;10 : &lt;Cookie feedType=224967207_hot for .www.renren.com/&gt;11 : &lt;Cookie JSESSIONID=abc3IP9kEhTExblxcRfeu for www.renren.com/&gt;&gt;&gt;&gt;</code></pre><p>可以和firebug或者httpFox中得到的cookie进行对比，值可能不一致，但key基本上是一致的，你每次登录应该都不一致</p><p><a href="/image/2013/09/getCookie.png"><img src="/image/2013/09/getCookie_thumb.png" alt="getCookie" title="getCookie"></a> </p><p>&#160;</p><p>我也尝试过使用fidder模拟发送没有cookie的POST数据，但是没有得到想要的返回值</p><p><a href="/image/2013/09/withoutcookie.png"><img src="/image/2013/09/withoutcookie_thumb.png" alt="withoutcookie" title="withoutcookie"></a> </p><p>而加上cookie信息以后就可以正常的跳转到自己的主页了</p><p><a href="/image/2013/09/withcookie.png"><img src="/image/2013/09/withcookie_thumb.png" alt="withcookie" title="withcookie"></a> </p><p><a href="/image/2013/09/pg.png"><img src="/image/2013/09/pg_thumb.png" alt="pg" title="pg"></a> </p><p>好了，基本上了解了python中使用cookie来发送登录信息，现在我们来写一个小脚本来登录自己人人网。</p><pre><code class="python">#encoding=utf-8import urllib2import urllibimport cookielibdef renrenBrower(url,user,password):    login_page = &quot;http://www.renren.com/ajaxLogin&quot;    try:        cj = cookielib.CookieJar()        opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))        opener.addheaders = [(&#39;User-agent&#39;,&#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#39;)]        data = urllib.urlencode({&quot;email&quot;:&#39;user&#39;,&quot;password&quot;:&#39;password&#39;})        opener.open(login_page,data)        op=opener.open(url)        data= op.read()        return data    except Exception,e:        print str(e)print renrenBrower(&quot;http://www.renren.com/home&quot;,&quot;用户名&quot;,&quot;密码&quot;)</code></pre><p>&#160;</p><p>这样就可以将自己首页的信息显示出来了，其实在登录完以后，还可以接着写脚本来获取自己想要的信息，如朋友的新鲜事，</p><p>这里重点是使用SGMLParser来解析html代码</p><p>以下代码参考<a href="http://www.oschina.net/code/snippet_148170_10661" target="_blank" rel="noopener">http://www.oschina.net/code/snippet_148170_10661</a>&#160;</p><pre><code class="python">from sgmllib import SGMLParserimport sys,urllib2,urllib,cookielibclass spider(SGMLParser):    def __init__(self,email,password):        SGMLParser.__init__(self)        self.h3=False        self.h3_is_ready=False        self.div=False        self.h3_and_div=False        self.a=False        self.depth=0        self.names=&quot;&quot;        self.dic={}        self.email=email        self.password=password        self.domain=&#39;renren.com&#39;        try:            cookie=cookielib.CookieJar()            cookieProc=urllib2.HTTPCookieProcessor(cookie)        except:            raise        else:            opener=urllib2.build_opener(cookieProc)            urllib2.install_opener(opener)    def login(self):        url=&#39;http://www.renren.com/PLogin.do&#39;        postdata={                  &#39;email&#39;:self.email,                  &#39;password&#39;:self.password,                  &#39;domain&#39;:self.domain                  }        req=urllib2.Request(                            url,                            urllib.urlencode(postdata)                            )        self.file=urllib2.urlopen(req).read()        #print self.file    def start_h3(self,attrs):        self.h3 = True    def end_h3(self):        self.h3=False        self.h3_is_ready=True    def start_a(self,attrs):        if self.h3 or self.div:            self.a=True    def end_a(self):        self.a=False    def start_div(self,attrs):        if self.h3_is_ready == False:            return        if self.div==True:            self.depth += 1        for k,v in attrs:            if k == &#39;class&#39; and v == &#39;content&#39;:                self.div=True;                self.h3_and_div=True   #h3 and div is connected    def end_div(self):        if self.depth == 0:            self.div=False            self.h3_and_div=False            self.h3_is_ready=False            self.names=&quot;&quot;        if self.div == True:            self.depth-=1    def handle_data(self,text):        #record the name        if self.h3 and self.a:            self.names+=text        #record says        if self.h3 and (self.a==False):            if not text:pass            else: self.dic.setdefault(self.names,[]).append(text)            return        if self.h3_and_div:            self.dic.setdefault(self.names,[]).append(text)    def show(self):        type = sys.getfilesystemencoding()        for key in self.dic:            print ( (&#39;&#39;.join(key)).replace(&#39; &#39;,&#39;&#39;)).decode(&#39;utf-8&#39;).encode(type),                  ( (&#39;&#39;.join(self.dic[key])).replace(&#39; &#39;,&#39;&#39;)).decode(&#39;utf-8&#39;).encode(type)if __name__ ==&#39;__main__&#39;:    renrenspider=spider(&#39;email&#39;,&#39;password&#39;)    renrenspider.login()    renrenspider.feed(renrenspider.file)    renrenspider.show()</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用python抓取360搜索联想词</title>
      <link href="/article/877.html"/>
      <url>/article/877.html</url>
      <content type="html"><![CDATA[<p>几乎所有的搜索引擎都提供联想词提示，这个小脚本其实功能性不大，只当作使用urllib2发http请求和如何使用代理来访问</p><p>参考文章</p><p><a href="http://video.sina.com.cn/v/b/113293169-1631501663.html" target="_blank" rel="noopener">http://video.sina.com.cn/v/b/113293169-1631501663.html</a><br> <a id="more"></a><br><a href="http://obmem.info/?p=47" target="_blank" rel="noopener">http://obmem.info/?p=47</a></p><pre><code class="python">#coding:utf-8import urllib,urllib2，cookielibimport re,timefrom random import choiceiplist = [&#39;1.93.21.147:2222&#39;,&#39;42.96.129.66:80&#39;,&#39;59.57.15.71:80&#39;]#代理的列表，可以到网上搜，有好多wordlist = [&#39;生活&#39;,&#39;杨&#39;,&#39;彦&#39;,&#39;星&#39;]#想要搜索的关键词列表for w in wordlist:    ip = choice(iplist)    word = urllib.quote(w)#使用urllib库中的quite方法将关键词进行编码    url = r&#39;http://sug.so.360.cn/suggest/word?callback=suggest_so&amp;encodein=utf-8&amp;encodeout=utf-8&amp;word=%s&#39;% word    #用一个字典来存储header里的内容，这样做主要是为了不让360搜索来屏蔽机器人的采集    #可以使用firebug等工具来查看    header = {            &#39;GET&#39;:url,            &#39;Host&#39;:&#39;sug.so.360.cn&#39;,            &#39;Referer&#39;:r&#39;http://www.so.com/&#39;,            &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36&#39;            }    #以下是采用代理方式来访问360搜索    proxy_support = urllib2.ProxyHandler({&#39;http&#39;:&#39;http://&#39;+ip})    opener = urllib2.build_opener(proxy_support,urllib2.HTTPHandler)    urllib2.install_opener(opener)##    cookie_support= urllib2.HTTPCookieProcessor(cookielib.CookieJar())##    opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler)##    urllib2.install_opener(opener)##    如果想要即要cookies又要代理，可以使用以下结构##    opener = urllib2.build_opener(proxy_support, cookie_support, urllib2.HTTPHandler)####    content = urllib2.urlopen(&#39;url&#39;).read()req = urllib2.Request(url) #创建一个请求#把header元素加入到请求中for key in header:req.add_header(key,header[key])html = urllib2.urlopen(req).read()ss = re.findall(&quot;&quot;(.*?)&quot;&quot;,html) #使用正则将联想词匹配出来for item in ss:print item        time.sleep(3)</code></pre><p><a href="/image/2013/09/360.png"><img src="/image/2013/09/360.png" alt="360"></a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python解析json</title>
      <link href="/article/874.html"/>
      <url>/article/874.html</url>
      <content type="html"><![CDATA[<p>相对于python解析XML来说，我还是比较喜欢json的格式返回，现在一般的api返回都会有json与XML格式的选择，json的解析起来个人觉得相对简单些</p><p>先看一个简单的豆瓣的图书查询的api返回<a id="more"></a></p><p><a href="http://api.douban.com/v2/book/isbn/9787218087351" target="_blank" rel="noopener">http://api.douban.com/v2/book/isbn/9787218087351</a></p><blockquote><p>{“rating”:{“max”:10,”numRaters”:79,”average”:”9.1”,”min”:0},”subtitle”:””,”author”:[“野夫”],”pubdate”:”2013-9”,”tags”:[{“count”:313,”name”:”野夫”,”title”:”野夫”},{“count”:151,”name”:”散文随笔”,”title”:”散文随笔”},{“count”:83,”name”:”身边的江湖”,”title”:”身边的江湖”},{“count”:82,”name”:”土家野夫”,”title”:”土家野夫”},{“count”:70,”name”:”散文”,”title”:”散文”},{“count”:44,”name”:”中国文学”,”title”:”中国文学”},{“count”:43,”name”:”随笔”,”title”:”随笔”},{“count”:38,”name”:”中国现当代文学”,”title”:”中国现当代文学”}],”origin_title”:””,”image”:”<a href="http://img5.douban.com/mpic/s27008269.jpg&quot;,&quot;binding&quot;:&quot;&quot;,&quot;translator&quot;:[],&quot;catalog&quot;:&quot;自序" target="_blank" rel="noopener">http://img5.douban.com/mpic/s27008269.jpg&quot;,&quot;binding&quot;:&quot;&quot;,&quot;translator&quot;:[],&quot;catalog&quot;:&quot;自序</a> 让记忆抵抗n001 掌瓢黎爷n024 遗民老谭n039 乱世游击：表哥的故事n058 绑赴刑场的青春n076 风住尘香花已尽n083 “酷客”李斯n100 散材毛喻原n113 颓世华筵忆黄门n122 球球外传：n一个时代和一只小狗的际遇n141 童年的恐惧与仇恨n151 残忍教育n167 湖山一梦系平生n174 香格里拉散记n208 民国屐痕”,”pages”:”256”,”images”:{“small”:”<a href="http://img5.douban.com/spic/s27008269.jpg&quot;,&quot;large&quot;:&quot;http://img5.douban.com/lpic/s27008269.jpg&quot;,&quot;medium&quot;:&quot;http://img5.douban.com/mpic/s27008269.jpg&quot;},&quot;alt&quot;:&quot;http://book.douban.com/subject/25639223/&quot;,&quot;id&quot;:&quot;25639223&quot;,&quot;publisher&quot;:&quot;广东人民出版社&quot;,&quot;isbn10&quot;:&quot;7218087353&quot;,&quot;isbn13&quot;:&quot;9787218087351&quot;,&quot;title&quot;:&quot;身边的江湖&quot;,&quot;url&quot;:&quot;http://api.douban.com/v2/book/25639223&quot;,&quot;alt_title&quot;:&quot;&quot;,&quot;author_intro&quot;:&quot;郑世平，笔名野夫，网名土家野夫。毕业于武汉大学，曾当过警察、囚徒、书商。曾出版历史小说《父亲的战争》、散文集《江上的母亲》（获台北2010国际书展非虚构类图书大奖，是该奖项第一个大陆得主）、散文集《乡关何处》（被新浪网、凤凰网、新华网分别评为2012年年度好书）。&quot;,&quot;summary&quot;:&quot;1.野夫书稿中被删减最少，最能体现作者观点、情感的作品。n2.文字凝练，具有极强的感染力。以一枝孤笔书写那些就在你我身边的大历史背景下普通人的生活变迁。n3\" target="_blank" rel="noopener">http://img5.douban.com/spic/s27008269.jpg&quot;,&quot;large&quot;:&quot;http://img5.douban.com/lpic/s27008269.jpg&quot;,&quot;medium&quot;:&quot;http://img5.douban.com/mpic/s27008269.jpg&quot;},&quot;alt&quot;:&quot;http://book.douban.com/subject/25639223/&quot;,&quot;id&quot;:&quot;25639223&quot;,&quot;publisher&quot;:&quot;广东人民出版社&quot;,&quot;isbn10&quot;:&quot;7218087353&quot;,&quot;isbn13&quot;:&quot;9787218087351&quot;,&quot;title&quot;:&quot;身边的江湖&quot;,&quot;url&quot;:&quot;http://api.douban.com/v2/book/25639223&quot;,&quot;alt_title&quot;:&quot;&quot;,&quot;author_intro&quot;:&quot;郑世平，笔名野夫，网名土家野夫。毕业于武汉大学，曾当过警察、囚徒、书商。曾出版历史小说《父亲的战争》、散文集《江上的母亲》（获台北2010国际书展非虚构类图书大奖，是该奖项第一个大陆得主）、散文集《乡关何处》（被新浪网、凤凰网、新华网分别评为2012年年度好书）。&quot;,&quot;summary&quot;:&quot;1.野夫书稿中被删减最少，最能体现作者观点、情感的作品。n2.文字凝练，具有极强的感染力。以一枝孤笔书写那些就在你我身边的大历史背景下普通人的生活变迁。n3\</a>. 柴静口中“一半像警察，一半像土匪”的野夫，以其特有的韵律表达世间的欢笑和悲苦。”,”price”:”32元”}</p></blockquote><p>看起来别提多乱了，现在我们将其格式进行简单的整理</p><p><pre class="brush:other">{<br>rating: {<br>max: 10,<br>numRaters: 79,<br>average: “9.1”,<br>min: 0<br>},<br>subtitle: “”,<br>author: [<br>“野夫”<br>],<br>pubdate: “2013-9”,<br>tags: [<br>{<br>count: 313,<br>name: “野夫”,<br>title: “野夫”<br>},<br>{<br>count: 151,<br>name: “散文随笔”,<br>title: “散文随笔”<br>},<br>{<br>count: 83,<br>name: “身边的江湖”,<br>title: “身边的江湖”<br>},<br>{<br>count: 82,<br>name: “土家野夫”,<br>title: “土家野夫”<br>},<br>{<br>count: 70,<br>name: “散文”,<br>title: “散文”<br>},<br>{<br>count: 44,<br>name: “中国文学”,<br>title: “中国文学”<br>},<br>{<br>count: 43,<br>name: “随笔”,<br>title: “随笔”<br>},<br>{<br>count: 38,<br>name: “中国现当代文学”,<br>title: “中国现当代文学”<br>}<br>],<br>origin_title: “”,<br>image: “<a href="http://img5.douban.com/mpic/s27008269.jpg" target="_blank" rel="noopener">http://img5.douban.com/mpic/s27008269.jpg</a>“,<br>binding: “”,<br>translator: [ ],<br>catalog: “自序 让记忆抵抗 001 掌瓢黎爷 024 遗民老谭 039 乱世游击：表哥的故事 058 绑赴刑场的青春 076 风住尘香花已尽 083 “酷客”李斯 100 散材毛喻原 113 颓世华筵忆黄门 122 球球外传： 一个时代和一只小狗的际遇 141 童年的恐惧与仇恨 151 残忍教育 167 湖山一梦系平生 174 香格里拉散记 208 民国屐痕”,<br>pages: “256”,<br>images: {<br>small: “<a href="http://img5.douban.com/spic/s27008269.jpg" target="_blank" rel="noopener">http://img5.douban.com/spic/s27008269.jpg</a>“,<br>large: “<a href="http://img5.douban.com/lpic/s27008269.jpg" target="_blank" rel="noopener">http://img5.douban.com/lpic/s27008269.jpg</a>“,<br>medium: “<a href="http://img5.douban.com/mpic/s27008269.jpg" target="_blank" rel="noopener">http://img5.douban.com/mpic/s27008269.jpg</a>“<br>},<br>alt: “<a href="http://book.douban.com/subject/25639223/" target="_blank" rel="noopener">http://book.douban.com/subject/25639223/</a>“,<br>id: “25639223”,<br>permalink: “25639223”,<br>publisher: “广东人民出版社”,<br>isbn10: “7218087353”,<br>isbn13: “9787218087351”,<br>title: “身边的江湖”,<br>url: “<a href="http://api.douban.com/v2/book/25639223" target="_blank" rel="noopener">http://api.douban.com/v2/book/25639223</a>“,<br>alt_title: “”,<br>author_intro: “郑世平，笔名野夫，网名土家野夫。毕业于武汉大学，曾当过警察、囚徒、书商。曾出版历史小说《父亲的战争》、散文集《江上的母亲》（获台北2010国际书展非虚构类图书大奖，是该奖项第一个大陆得主）、散文集《乡关何处》（被新浪网、凤凰网、新华网分别评为2012年年度好书）。”,<br>summary: “1.野夫书稿中被删减最少，最能体现作者观点、情感的作品。 2.文字凝练，具有极强的感染力。以一枝孤笔书写那些就在你我身边的大历史背景下普通人的生活变迁。 3. 柴静口中“一半像警察，一半像土匪”的野夫，以其特有的韵律表达世间的欢笑和悲苦。”,<br>price: “32元”<br>}</pre><br>下面我们通过python来取出想要的信息，比如我们想要rating,images里的large和summary</p><blockquote><p>import urllib2<br>import json<br>html = urllib2.urlopen(r’<a href="http://api.douban.com/v2/book/isbn/9787218087351" target="_blank" rel="noopener">http://api.douban.com/v2/book/isbn/9787218087351</a>‘)<br>hjson = json.loads(html.read())<br>print hjson[‘rating’]<br>print hjson[‘images’][‘large’]<br>print hjson[‘summary’]</p></blockquote><p>是不是很简单，其实只要把返回的json格式嵌套搞清楚，json还是比较简单的</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python解析XML文档</title>
      <link href="/article/872.html"/>
      <url>/article/872.html</url>
      <content type="html"><![CDATA[<p>解析XML主要用到pytohn自带的XML库，其次还是lxml库</p><h1 id="XML结构"><a href="#XML结构" class="headerlink" title="XML结构"></a>XML结构</h1><p>先以一个相对简单但功能比较全的XML文档为例</p><pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;  &lt;title&gt;dive into mark&lt;/title&gt;  &lt;subtitle&gt;currently between addictions&lt;/subtitle&gt;  &lt;id&gt;tag:diveintomark.org,2001-07-29:/&lt;/id&gt;  &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt;  &lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39; href=&#39;http://diveintomark.org/&#39;/&gt;  &lt;entry&gt;    &lt;author&gt;      &lt;name&gt;Mark&lt;/name&gt;      &lt;uri&gt;http://diveintomark.org/&lt;/uri&gt;    &lt;/author&gt;    &lt;title&gt;Dive into history, 2009 edition&lt;/title&gt;    &lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39;      href=&#39;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;/&gt;    &lt;id&gt;tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id&gt;    &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt;    &lt;published&gt;2009-03-27T17:20:42Z&lt;/published&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;diveintopython&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;docbook&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;html&#39;/&gt;    &lt;summary type=&#39;html&#39;&gt;Putting an entire chapter on one page sounds      bloated, but consider this &amp;mdash; my longest chapter so far      would be 75 printed pages, and it loads in under 5 seconds&amp;hellip;      On dialup.&lt;/summary&gt;  &lt;/entry&gt;  &lt;entry&gt;    &lt;author&gt;      &lt;name&gt;Mark&lt;/name&gt;      &lt;uri&gt;http://diveintomark.org/&lt;/uri&gt;    &lt;/author&gt;    &lt;title&gt;Accessibility is a harsh mistress&lt;/title&gt;    &lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39;      href=&#39;http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress&#39;/&gt;    &lt;id&gt;tag:diveintomark.org,2009-03-21:/archives/20090321200928&lt;/id&gt;    &lt;updated&gt;2009-03-22T01:05:37Z&lt;/updated&gt;    &lt;published&gt;2009-03-21T20:09:28Z&lt;/published&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;accessibility&#39;/&gt;    &lt;summary type=&#39;html&#39;&gt;The accessibility orthodoxy does not permit people to      question the value of features that are rarely useful and rarely used.&lt;/summary&gt;  &lt;/entry&gt;  &lt;entry&gt;    &lt;author&gt;      &lt;name&gt;Mark&lt;/name&gt;    &lt;/author&gt;    &lt;title&gt;A gentle introduction to video encoding, part 1: container formats&lt;/title&gt;    &lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39;      href=&#39;http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats&#39;/&gt;    &lt;id&gt;tag:diveintomark.org,2008-12-18:/archives/20081218155422&lt;/id&gt;    &lt;updated&gt;2009-01-11T19:39:22Z&lt;/updated&gt;    &lt;published&gt;2008-12-18T15:54:22Z&lt;/published&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;asf&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;avi&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;encoding&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;flv&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;GIVE&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;mp4&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;ogg&#39;/&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;video&#39;/&gt;    &lt;summary type=&#39;html&#39;&gt;These notes will eventually become part of a      tech talk on video encoding.&lt;/summary&gt;  &lt;/entry&gt;&lt;/feed&gt;</code></pre><p>先简单的看一下这个XML的结构<a id="more"></a></p><pre><code class="xml">&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt; #这里定义了命名空间(namespace) http://www.w3.org/2005/Atom  &lt;title&gt;&lt;/title&gt;  &lt;subtitle&gt;&lt;/subtitle&gt;  &lt;id&gt;&lt;/id&gt;  &lt;updated&gt;&lt;/updated&gt;  &lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39; href=&#39;http://diveintomark.org/&#39;/&gt; #这里的&lt;link&gt;没有text，但是里面有相应的属性  &lt;entry&gt;    &lt;author&gt;      &lt;name&gt;&lt;/name&gt;      &lt;uri&gt;&lt;/uri&gt;    &lt;/author&gt;    &lt;title&gt;&lt;/title&gt;    &lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39;      href=&#39;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;/&gt;    &lt;id&gt;&lt;/id&gt;    &lt;updated&gt;&lt;/updated&gt;    &lt;published&gt;&lt;/published&gt;    &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;diveintopython&#39;/&gt;    &lt;summary type=&#39;html&#39;&gt;&lt;/summary&gt;  &lt;/entry&gt;&lt;/feed&gt;</code></pre><p>首先有一个全局的根元素<feed></feed></p><p>在根元素下面有title,subtitle,id,update,link,entry子元素</p><p>在entry元素下面还有author,title,link,id,updated,published,category,summary子元素 （姑且称为孙元素）</p><p>在author元素下面还有name,uri子元素（这该称为曾孙元素了吧~ 哈哈）</p><p>结构还是挺清晰的</p><p>下面我们用python的方法来一步步的取出在元素&lt;&gt;&lt;/&gt;这间的content以为元素内的属性</p><p>使用的方法主要有</p><p>tree = etree.parse() 解析XML</p><p>root = tree.getroot() 得到根元素</p><p>root.tag 根元素名称</p><p>root.attrib 显示元素的属性</p><p>root.findall() 查找元素</p><h1 id="下面请看代码，都已经将注释与结果写在里面"><a href="#下面请看代码，都已经将注释与结果写在里面" class="headerlink" title="下面请看代码，都已经将注释与结果写在里面"></a>下面请看代码，都已经将注释与结果写在里面</h1><pre><code class="python">import xml.etree.ElementTree as etree #将xml.etree.ElementTree引入tree = etree.parse(&#39;feed.xml&#39;) #解析XMLroot = tree.getroot()print root# &lt;Element {http://www.w3.org/2005/Atom}feed at cd1eb0&gt;#元素即列表print root.tag#{http://www.w3.org/2005/Atom}feed# ElementTree使用{namespace}localname来表达xml元素for child in root:    print child    # &lt;Element {http://www.w3.org/2005/Atom}title at e2b5d0&gt;    # &lt;Element {http://www.w3.org/2005/Atom}subtitle at e2b4e0&gt;    # &lt;Element {http://www.w3.org/2005/Atom}id at e2b6c0&gt;    # &lt;Element {http://www.w3.org/2005/Atom}updated at e2b6f0&gt;    # &lt;Element {http://www.w3.org/2005/Atom}link at e2b4b0&gt;    # &lt;Element {http://www.w3.org/2005/Atom}entry at e2b720&gt;    # &lt;Element {http://www.w3.org/2005/Atom}entry at e2b510&gt;    # &lt;Element {http://www.w3.org/2005/Atom}entry at e2b750&gt;    # 这里只显示一级子元素，而子元素的子元素将不会被遍历#属性即字典print root.attrib#{&#39;{http://www.w3.org/XML/1998/namespace}lang&#39;: &#39;en&#39;}#我们注意到feed下面的link这个元素有属性print root[4].attrib#{&#39;href&#39;: &#39;http://diveintomark.org/&#39;, &#39;type&#39;: &#39;text/html&#39;, &#39;rel&#39;: &#39;alternate&#39;}print root[3].attrib#{} 将会得到一个空字典，因为updated元素内没有属性值#查找元素entrylist = root.findall(&#39;{http://www.w3.org/2005/Atom}entry&#39;)print entrylist# [&lt;Element {http://www.w3.org/2005/Atom}entry at 18423a0&gt;, &lt;Element {http://www.w# 3.org/2005/Atom}entry at 18425d0&gt;, &lt;Element {http://www.w3.org/2005/Atom}entry a# t 1842968&gt;]print root.findall(&#39;{http://www.w3.org/2005/Atom}author&#39;)# 这里将得到一个空列表，因为author不是feed的直接子元素#查找子元素entries = tree.findall(&#39;{http://www.w3.org/2005/Atom}entry&#39;) #先找到entry元素·title = entries[0].find(&#39;{http://www.w3.org/2005/Atom}title&#39;)#接着再找title元素print title.text#&#39;Dive into history, 2009 edition&#39;all_links = tree.findall(&#39;//{http://www.w3.org/2005/Atom}link&#39;) #在元素前面加&#39;//&#39; 则可以在所有元素里查找包括子元素和孙元素# [&lt;Element {http://www.w3.org/2005/Atom}link at e181b0&gt;, # &lt;Element {http://www.w3.org/2005/Atom}link at e2b570&gt;, # &lt;Element {http://www.w3.org/2005/Atom}link at e2b480&gt;, # &lt;Element {http://www.w3.org/2005/Atom}link at e2b5a0&gt;]print all_links[0].attrib #将会得到这个Link的属性字典 # {&#39;href&#39;: &#39;http://diveintomark.org/&#39;, # &#39;type&#39;: &#39;text/html&#39;, # &#39;rel&#39;: &#39;alternate&#39;}</code></pre><p>关于XML库解析与查找XML文档基本的方法就这些了，现在通过一个实例来学以至用下</p><h1 id="还是回到微信的XML解析上"><a href="#还是回到微信的XML解析上" class="headerlink" title="还是回到微信的XML解析上"></a>还是回到微信的XML解析上</h1><p>微信将用户的信息POST到你的服务器上，基本形式如下</p><pre><code class="xml">&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;</code></pre><p>现在我们来通过上面介绍的方法来获得<content>元素中的‘this is a test’字段</content></p><pre><code class="python">import xml.etree.ElementTree as etreeweixinxml = etree.parse(&#39;weixinpost.xml&#39;)wroot = weixinxml.getroot()print wroot.tagfor child in wroot:    print child.tagif wroot.find(&#39;Content&#39;) is not None:    print wroot.find(&#39;Content&#39;).textelse:    print &#39;Nothing found&#39;</code></pre><p>这样简单几步就可以把想要的内容取出来了</p><p>参考文章 <a href="http://woodpecker.org.cn/diveintopython3/xml.html" target="_blank" rel="noopener">http://woodpecker.org.cn/diveintopython3/xml.html</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用python一步一步搭建微信公众平台（一）</title>
      <link href="/article/871.html"/>
      <url>/article/871.html</url>
      <content type="html"><![CDATA[<p>最近无聊，想玩玩微信的公众平台，后来发现乐趣无穷啊~</p><p>使用的工具，python 新浪SAE平台，微信的公众平台</p><p>你需要先在微信的公众平台与新浪SAE平台上各种注册，微信平台注册的时候需要你拍张手持身份证的照片，还有几天的审核期</p><p>微信公众平台：<a href="http://mp.weixin.qq.com/" title="微信公众平台" target="_blank" rel="noopener">http://mp.weixin.qq.com</a><br> <a id="more"></a><br>新浪SAE：<a href="http://sae.sina.com.cn/" target="_blank" rel="noopener">http://sae.sina.com.cn/</a></p><p>等待微信公众审核通过后，登录公众平台后，点击高级功能。将会看到需要提供一个接入信息：</p><p><img src="http://static.oschina.net/uploads/img/201309/04223229_FNSJ.jpg" alt="微信接口配置"> 微信接口配置[/caption]</p><p>那么我们需要一个网址作为接口（这时就需要SAE上搭建Python的一个应用），Token呢，就是相当于我们和微信之间约定的“密码”，这里可以随便填写英文或者数字，但实测输入纯数字有时会有问题，所以还是字符串比较靠谱。</p><h1 id="第一步，在SAE上搭建python的应用"><a href="#第一步，在SAE上搭建python的应用" class="headerlink" title="第一步，在SAE上搭建python的应用"></a>第一步，在SAE上搭建python的应用</h1><p>在下图的应用里选择python应用。</p><p><a href="/image/2013/08/iELK05K8pJTk2.jpg"><img src="/image/2013/08/iELK05K8pJTk2.jpg" alt="iELK05K8pJTk2"></a></p><p>填好二级域名和应用名称等，选择好语言。这里我们使用Python开发选择web应用。创建好应用之后，在代码管理中创建一个新的版本。而后我们可以选择编辑代码。能够实现在线编辑，根本用不着配置本地环境，SVN等等。当然像这种轻量级的应用在线编辑器就可以了，SVN的话还不如在线编辑好用</p><h1 id="第二步，编写index-wsgi"><a href="#第二步，编写index-wsgi" class="headerlink" title="第二步，编写index.wsgi"></a>第二步，编写index.wsgi</h1><p>因为我们使用的是web.py框架，因为其良好的xml解析，想了解web.py的童鞋可以移步 <a href="http://webpy.org/docs/0.3/tutorial.zh-cn" target="_blank" rel="noopener">http://webpy.org/docs/0.3/tutorial.zh-cn</a></p><p>首先编写config.yaml</p><pre><code class="python">name: yangyanxingversion: 1libraries:- name: webpy  version: &quot;0.36&quot;- name: lxml  version: &quot;2.3.4&quot;</code></pre><p>注意严格的缩进，差一个空格你就废了！而且调试的时候很不好发现问题。。。</p><p>接着我们继续编写index.wgsi</p><pre><code class="python"># coding: UTF-8import osimport saeimport webfrom weixinInterface import WeixinInterfaceurls = (&#39;/weixin&#39;,&#39;WeixinInterface&#39;)app_root = os.path.dirname(__file__)templates_root = os.path.join(app_root, &#39;templates&#39;)render = web.template.render(templates_root)app = web.application(urls, globals()).wsgifunc()application = sae.create_wsgi_app(app)&lt;/pre&gt;</code></pre><p>简单解释一下，</p><blockquote><p>from weixinInterface import WeixinInterface<br>这里我们需要再创建一个weixinIterface的py文件，你也可以将这个类写在index.wgsi文件中，只是这样看起来会乱乱的</p></blockquote><p>新建一个weixinIterface.py文件，注意大小写，写入以下代码</p><pre><code class="python"># -*- coding: utf-8 -*-import hashlibimport webimport lxmlimport timeimport osimport urllib2,jsonfrom lxml import etreeclass WeixinInterface:    def __init__(self):        self.app_root = os.path.dirname(__file__)        self.templates_root = os.path.join(self.app_root, &#39;templates&#39;)        self.render = web.template.render(self.templates_root)    def GET(self):        #获取输入参数        data = web.input()        signature=data.signature        timestamp=data.timestamp        nonce=data.nonce        echostr=data.echostr        #自己的token        token=&quot;yangyanxing&quot; #这里改写你在微信公众平台里输入的token        #字典序排序        list=[token,timestamp,nonce]        list.sort()        sha1=hashlib.sha1()        map(sha1.update,list)        hashcode=sha1.hexdigest()        #sha1加密算法        #如果是来自微信的请求，则回复echostr        if hashcode == signature:            return echostr</code></pre><p>这里定义了一个GET方法，是根据微信公众平台的要求，进行的token验证，因为这里我们定义了templates_root为根目录下的templates，所以还要在根目录下创建一个目录teplatest的目录<br>开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，否则接入失败。</p><p>signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</p><p>加密/校验流程：<br>1. 将token、timestamp、nonce三个参数进行字典序排序<br>2. 将三个参数字符串拼接成一个字符串进行sha1加密<br>3. 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信<br>因为微信是将验证信息GET发出去的，所以这里使用了GET方法来取得值并且返回相应用值</p><p>保存全部，现在回到微信的公众平台高级管理界面</p><p><img src="http://static.oschina.net/uploads/img/201309/04223229_FNSJ.jpg" alt="微信接口配置"></p><p>在url里面填写你在新浪SAE里应用名称并且加上/weixin，如：<a href="http://XXXX.sinaapp.com/weixin" target="_blank" rel="noopener">http://XXXX.sinaapp.com/weixin</a> token随便输入，只要注意更改weixinInterface.py中的token就行了，输入好了以后点击提交，如果没有什么问题的话就会通过验证！</p><h1 id="第三步，新建一个简单的自动回复的方法"><a href="#第三步，新建一个简单的自动回复的方法" class="headerlink" title="第三步，新建一个简单的自动回复的方法"></a>第三步，新建一个简单的自动回复的方法</h1><p>鹦鹉学舌，就是用户说什么，它也回复什么，没什么用，只是随便玩玩！</p><p>在weixinInterface.py里继续添加代码</p><pre><code class="python">def POST(self):    str_xml = web.data() #获得post来的数据    xml = etree.fromstring(str_xml)#进行XML解析    content=xml.find(&quot;Content&quot;).text#获得用户所输入的内容    msgType=xml.find(&quot;MsgType&quot;).text    fromUser=xml.find(&quot;FromUserName&quot;).text    toUser=xml.find(&quot;ToUserName&quot;).text    return self.render.reply_text(fromUser,toUser,int(time.time()),u&quot;我现在还在开发中，还没有什么功能，您刚才说的是：&quot;+content)</code></pre><p>这个def 是和上一个GET同级的，注意缩进</p><p>接着我们在templates目录下创建reply_text.xml模板文件，写入以下代码</p><pre><code class="xml">$def with (toUser,fromUser,createTime,content)&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[$toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[$fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;$createTime&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[$content]]&gt;&lt;/Content&gt;&lt;/xml&gt;</code></pre><p>注意这里的toUser与fromUser是刚才post的是相反的，因为这里的toUser也就是POST函数里的fromUser，这里的fromUser也就是POST函数里的toUser,msgType是text</p><p>全部保存，现在就在用你的个人微信关注一下你创建的公众微信号，然后随便输入些内容，如果没有什么问题，你将会收到一条鹦鹉学舌的回复内容！</p><p>参考文章：<a href="http://www.nilday.com/%E5%88%A9%E7%94%A8sae%E6%90%AD%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89web-py%E5%AE%9E%E7%8E%B0%E7%9A%84sae-hello-world/" target="_blank" rel="noopener">http://www.nilday.com/%E5%88%A9%E7%94%A8sae%E6%90%AD%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89web-py%E5%AE%9E%E7%8E%B0%E7%9A%84sae-hello-world/</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python发邮件是件很简单的事情</title>
      <link href="/article/870.html"/>
      <url>/article/870.html</url>
      <content type="html"><![CDATA[<p>利用python的smtplib，发邮件将是一件非常简单的事情，下文以用163邮箱来发邮件为例，说明smtplib的应用</p><pre><code class="python">#coding:utf-8import smtplibdef sendMail(mail_to):    mail_server = &#39;smtp.163.com&#39;    mail_port = &#39;25&#39;    username = &#39;soar_1987@163.com&#39;    password = &#39;XXXXXXXX&#39;    mail_title = &#39;python Test&#39;    mail_content = &#39;This is a test from python for sending email&#39;    if type(mail_to) == str:#之所以要有这样的判断是为了收件人是多个人或者传入的的收件人列表是以list的方式        mail_list = mail_to.split(&#39;;&#39;) #将str类型的数据转换为list    elif type(mail_to) == list:        mail_list = mail_to    else:        print &quot;你输入的收件人格式有误&quot;    try:        handle = smtplib.SMTP(mail_server,mail_port)        handle.login(username,password)        msg = &quot;From:%srn To:%srnContent-Type: text/html;charset=gb2312rnSubject:%srnrn %s&quot;%(&quot;杨彦星&quot;,&quot;;&quot;.join(mail_list),mail_title,mail_content) #这里的msg其实就是一种固定的格式，From:To:Subject        handle.sendmail(username,mail_list,msg)        print &quot;Send email sucess&quot;    except Exception,e:        print &quot;Send email failed because %s&quot; % eif __name__ ==&quot;__main__&quot;:    sendMail(&#39;yanxingyang@gmail.com&#39;)</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>可爱的python中的一个与递归相关的小问题</title>
      <link href="/article/821.html"/>
      <url>/article/821.html</url>
      <content type="html"><![CDATA[<p>可爱的python一书中有一个练习题，是在一个目录中查找特定扩展名的文件，并且读取里面的内容，然后用户输入一个关键词，在这些文件中进行搜索，如果找到后就把这一行内容打印出来，他提出的问题是如果里面还有目录，目录里面还有更深的目录，解决这个问题，我想到的只能是递归。。。</p><pre><code class="python">#coding:utf-8import os,sysdef cdGrep(keyword,filepath):    filelist = os.listdir(filepath)    for cdc in filelist:        if os.path.isdir(cdc):            filepath2 = os.path.join(filepath,cdc)            cdGrep(keyword,filepath2)        elif &#39;.txt&#39; in cdc:#            print filepath+cdc            f = open(filepath+&#39;&#39;+ cdc)            for line in f.readlines():                linelower = line.lower()                if keyword in linelower:                    print &#39;您查找的关键词在%s中找到&#39;% (filepath+&#39;&#39;+cdc)                    print line                f.close()if __name__ == &#39;__main__&#39;:    keword = raw_input(&#39;请输入想要查询的关键字&#39;)    pw = os.getcwd()    cdGrep(keword,pw)</code></pre><a id="more"></a><p>但是这里出现一个问题，就是目录只能进行底下一层，再深的目录就不进行遍历了，很是郁闷，于是在德问网上问了下，很快就有人指出了我的错误出在哪了</p><blockquote><p>if os.path.isdir(cdc):<br>这里不应该写成cdc，如果是cdc的话如果他是一个目录的话，再到下一层系统是不能再识别的，应该是<br>if os.path.isdir(os.path.join(filepath,cdc)):<br>将cdc与之前的目录进行结合，这样系统才能正常的识别目录</p></blockquote><p>这样，程序就可以很好的遍历目录了</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通过一个python小脚本来下载最新的360杀毒安装程序</title>
      <link href="/article/817.html"/>
      <url>/article/817.html</url>
      <content type="html"><![CDATA[<p>小脚本很简单，主要是练习一下正则匹配，与简单的urllib库的应用</p><pre><code class="python">#coding: utf8import urllib,reimport osdef getLastinstall():    page = urllib.urlopen(r&#39;http://sd.360.cn/download_center.html&#39;)    html = page.read()    page.close()    rematch = r&#39;http://down.360.cn/360sd/360sd_se_(.*?)exe&#39;    replusmatch = r&#39;http://down.360.cn/360sd/360sd_plus_(.*?)exe&#39;    stdname = &#39;360sd_&#39;+(str(re.compile(rematch).findall(html)[0]))+&#39;exe&#39;    downurlstd = r&#39;http://down.360.cn/360sd/360sd_&#39;+(str(re.compile(rematch).findall(html)[0]))+&#39;exe&#39;    powname = &#39;360sd_plus_&#39;+(str(re.compile(replusmatch).findall(html)[0]))+&#39;exe&#39;    downurlpow = r&#39;http://down.360.cn/360sd/360sd_plus_&#39;+(str(re.compile(replusmatch).findall(html)[0]))+&#39;exe&#39;    localpath = os.getcwd()+r&#39;/installpack&#39;    if not (os.path.isfile(stdname) and os.path.isfile(powname)):        if not os.path.isdir(&#39;installpack&#39;):            os.makedirs(&#39;installpack&#39;)        urllib.urlretrieve(downurlstd,localpath+&#39;/&#39;+stdname)        urllib.urlretrieve(downurlpow,localpath+&#39;/&#39;+powname)    else:        print &#39;目录中已经是线上最新版杀毒安装程序&#39;if __name__ ==&#39;__main__&#39;:    getLastinstall()</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的OOP</title>
      <link href="/article/813.html"/>
      <url>/article/813.html</url>
      <content type="html"><![CDATA[<p>直接上代码，已经在后面有注释了</p><pre><code class="python">#coding:utf8name = &#39;yangyanxing&#39;class Test():    class kevin():        var1 = &#39;我是内部类&#39;    name = &#39;kvein&#39;    gae = &#39;26&#39;    def fun1(self):        print self.name        print &#39;我是公共方法&#39;        self.__fun2() #可以通过公有就去来调用私有方法，在调用的过程中可以进行更改    def __fun2(self):        print &#39;我是私有方法&#39;    @classmethod    def fun3(self): #可以不通过实例来访问这个类方法        print &#39;#&#39;*40        print self.name        print &#39;我是类方法&#39;    @staticmethod #静态方法，也是可以不通过实例对象就可以访问的方法但是在定义的时候不用加self    def fun4():        print Test.name        print name #这里的name是全局变量        Test.fun3()        print &#39;我是静态方法&#39;print Test.name #公有属性可以直接方法，不用实例化对象yang = Test() #实例化一个类interyang = Test.kevin() #实例化一个内部类yang.fun1() #方法类里面的公共属性print interyang.var1 # 访问内部类里的属性Test.fun3()#访问类方法Test.fun4()</code></pre><pre><code class="python">#coding:utf8class Test():    var1 = &#39;类的公有属性&#39;    __var2 = &#39;类的私有属性&#39;    def fun(self):        self.var2 = &#39;对象的公有属性&#39; # 这里定义了一个对象的公有属性        self.__var3 = &#39;对象的私有属性&#39;# 这里定义了一个对象的私有属性        var4 = &#39;函数的局部变量&#39; #这里定义了一个函数的局部变量，这里面的var4只有在函数内部使用kevin = Test() #实例了一个对象yang = Test() #又实例了另外一个对象print kevin.var1##print kevin.__var2 #这里将无法访问kevin.fun()print kevin.var2 #在没有调用fun函数之前是没有var2的##print kevin.__var3 对象的私有属性是无法调用的##print yang.var2 #这里因为没有调用yang的fun方法，所以还是无法访问yang里的var2</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个python的小脚本登录人人并抓取新鲜事</title>
      <link href="/article/806.html"/>
      <url>/article/806.html</url>
      <content type="html"><![CDATA[<pre><code class="python">from sgmllib import SGMLParserimport sys,urllib2,urllib,cookielibclass spider(SGMLParser):    def __init__(self,email,password):        SGMLParser.__init__(self)        self.h3=False        self.h3_is_ready=False        self.div=False        self.h3_and_div=False        self.a=False        self.depth=0        self.names=&quot;&quot;        self.dic={}        self.email=email        self.password=password        self.domain=&#39;renren.com&#39;        try:            cookie=cookielib.CookieJar()            cookieProc=urllib2.HTTPCookieProcessor(cookie)        except:            raise        else:            opener=urllib2.build_opener(cookieProc)            urllib2.install_opener(opener)    def login(self):        url=&#39;http://www.renren.com/PLogin.do&#39;        postdata={                  &#39;email&#39;:self.email,                  &#39;password&#39;:self.password,                  &#39;domain&#39;:self.domain                  }        req=urllib2.Request(                            url,                            urllib.urlencode(postdata)                            )        self.file=urllib2.urlopen(req).read()        #print self.file    def start_h3(self,attrs):        self.h3 = True    def end_h3(self):        self.h3=False        self.h3_is_ready=True    def start_a(self,attrs):        if self.h3 or self.div:            self.a=True    def end_a(self):        self.a=False    def start_div(self,attrs):        if self.h3_is_ready == False:            return        if self.div==True:            self.depth += 1        for k,v in attrs:            if k == &#39;class&#39; and v == &#39;content&#39;:                self.div=True;                self.h3_and_div=True   #h3 and div is connected    def end_div(self):        if self.depth == 0:            self.div=False            self.h3_and_div=False            self.h3_is_ready=False            self.names=&quot;&quot;        if self.div == True:            self.depth-=1    def handle_data(self,text):        #record the name        if self.h3 and self.a:            self.names+=text        #record says        if self.h3 and (self.a==False):            if not text:pass            else: self.dic.setdefault(self.names,[]).append(text)            return        if self.h3_and_div:            self.dic.setdefault(self.names,[]).append(text)    def show(self):        type = sys.getfilesystemencoding()        for key in self.dic:            print ( (&#39;&#39;.join(key)).replace(&#39; &#39;,&#39;&#39;)).decode(&#39;utf-8&#39;).encode(type),                  ( (&#39;&#39;.join(self.dic[key])).replace(&#39; &#39;,&#39;&#39;)).decode(&#39;utf-8&#39;).encode(type)if __name__ ==&#39;__main__&#39;:    renrenspider=spider(&#39;email&#39;,&#39;password&#39;)    renrenspider.login()    renrenspider.feed(renrenspider.file)    renrenspider.show()</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(转)抛砖引玉 正则表达式完成电话号码的匹配</title>
      <link href="/article/779.html"/>
      <url>/article/779.html</url>
      <content type="html"><![CDATA[<p>原来地址：<a href="http://www.diveintopython.net/regular_expressions/phone_numbers.html" target="_blank" rel="noopener">http://www.diveintopython.net/regular_expressions/phone_numbers.html</a></p><p>迄今为止，你主要是匹配整个模式，不论是匹配上，还是没有匹配上。但是正则表达式还有比这更为强大的功能。当一个模式确实 匹配上时，你可以获取模式中特定的片断，你可以发现具体匹配的位置。 这个例子来源于我遇到的另一个现实世界的问题，也是在以前的工作中遇到的。问题是：解析一个美国电话号码。客户要能 (在一个单一的区域中) 输入任何数字，然后存储区号、干线号、电话号和一个可选的独立的分机号到公司数据库里。为此，我通过网络找了很多正则表达式的例子，但是没有一个能够完全满足我的要求。 这里列举了我必须能够接受的电话号码：<br> 800-555-1212<br> 800 555 1212<br> 800.555.1212<br> (800) 555-1212<br> 1-800-555-1212<br> 800-555-1212-1234<br> 800-555-1212x1234<br> 800-555-1212 ext. 1234<br> work 1-(800) 555.1212 #1234<br>格式可真够多的！我需要知道区号是 800，干线号是 555，电话号的其他数字为 1212。对于那些有分机号的，我需要知道分机号为 1234。 让我们完成电话号码解析这个工作，这个例子展示第一步。<br>例 7.10. 发现数字</p><blockquote><p>phonePattern = re.compile(r’^(d{3})-(d{3})-(d{4})$’) (1)<br>phonePattern.search(‘800-555-1212’).groups() (2)</p></blockquote><a id="more"></a><p>(‘800’, ‘555’, ‘1212’)</p><blockquote><p>phonePattern.search(‘800-555-1212-1234’) (3)</p></blockquote><p>&gt;<br>(1)<br>我们通常从左到右阅读正则表达式。这个正则表达式匹配字符串的开始，接着匹配 (d{3})。d{3} 是什么呢？好吧，{3} 的含义是“精确匹配三个数字”；这是曾在前面见到过的 {n,m} 语法的一种变形。d 的含义是 “任何一个数字” (0 到 9)。把它们放大括号中意味着要“精确匹配三个数字位，接着把它们作为一个组保存下来，以便后面的调用”。接着匹配一个连字符，接着是另外一个精确匹配三个数字位的组，接着另外一个连字符，接着另外一个精确匹配四个数字为的组，接着匹配字符串的结尾。<br>(2)<br>为了访问正则表达式解析过程中记忆下来的多个组，我们使用 search 函数返回对象的 groups() 函数。这个函数将返回一个元组，元组中的元素就是正则表达式中定义的组。在这个例子中，定义了三个组，第一个组有三个数字位，第二个组有三个数字位，第三个组有四个数字位。<br>(3)<br>这个正则表达式不是最终的答案，因为它不能处理在电话号码结尾有分机号的情况，为此，我们需要扩展这个正则表达式。<br>例 7.11. 发现分机号</p><blockquote><p>phonePattern = re.compile(r’^(d{3})-(d{3})-(d{4})-(d+)$’) (1)<br>  phonePattern.search(‘800-555-1212-1234’).groups() (2)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘800 555 1212 1234’) (3)<br>  phonePattern.search(‘800-555-1212’) (4)</p></blockquote><p>(1)<br>这个正则表达式和上一个几乎相同，正像前面的那样，匹配字符串的开始，接着匹配一个有三个数字位的组并记忆下来，接着是一个连字符，接着是一个有三个数字位的组并记忆下来，接着是一个连字符，接着是一个有四个数字位的组并记忆下来。不同的地方是你接着又匹配了另一个连字符，然后是一个有一个或者多个数字位的组并记忆下来，最后是字符串的结尾。<br>(2)<br>函数 groups() 现在返回一个有四个元素的元组，由于正则表达式中定义了四个记忆的组。<br>(3)<br>不幸的是，这个正则表达式也不是最终的答案，因为它假设电话号码的不同部分是由连字符分割的。如果一个电话号码是由空格符、逗号或者点号分割呢？你需要一个更一般的解决方案来匹配几种不同的分割类型。<br>(4)<br>啊呀！这个正则表达式不仅不能解决你想要的任何问题，反而性能更弱了，因为现在你甚至不能解析一个没有分机号的电话号码了。这根本不是你想要的，如果有分机号，你要知道分机号是什么，如果没有分机号，你仍然想要知道主电话号码的其他部分是什么。<br>下一个例子展示正则表达式处理一个电话号码内部，采用不同分隔符的情况。<br>例 7.12. 处理不同分隔符</p><blockquote><p>phonePattern = re.compile(r’^(d{3})D+(d{3})D+(d{4})D+(d+)$’) (1)<br>phonePattern.search(‘800 555 1212 1234’).groups() (2)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘800-555-1212-1234’).groups() (3)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘80055512121234’) (4)<br>phonePattern.search(‘800-555-1212’) (5)</p></blockquote><p>(1)<br>当心啦！你首先匹配字符串的开始，接着是一个三个数字位的组，接着是 D+，这是个什么东西？好吧，D 匹配任意字符，除了 数字位，+ 表示“1 个或者多个”，因此 D+ 匹配一个或者多个不是数字位的字符。这就是你替换连字符为了匹配不同分隔符所用的方法。<br>(2)<br>使用 D+ 代替 - 意味着现在你可以匹配中间是空格符分割的电话号码了。<br>(3)<br>当然，用连字符分割的电话号码也能够被识别。<br>(4)<br>不幸的是，这个正则表达式仍然不是最终答案，因为它假设电话号码一定有分隔符。如果电话号码中间没有空格符或者连字符的情况会怎样哪？<br>(4)<br>我的天！这个正则表达式也没有达到我们对于分机号识别的要求。现在你共有两个问题，但是你可以利用相同的技术来解决它们。<br>下一个例子展示正则表达式处理没有 分隔符的电话号码的情况。<br>例 7.13. 处理没有分隔符的数字</p><blockquote><p>phonePattern = re.compile(r’^(d{3})D<em>(d{3})D</em>(d{4})D<em>(d</em>)$’) (1)<br>phonePattern.search(‘80055512121234’).groups() (2)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘800.555.1212 x1234’).groups() (3)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘800-555-1212’).groups() (4)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘’)</p><blockquote><p>phonePattern.search(‘(800)5551212 x1234’) (5)</p></blockquote><p>(1)<br>和上一步相比，你所做的唯一变化就是把所有的 + 变成 <em>。在电话号码的不同部分之间不再匹配 D+，而是匹配 D</em> 了。还记得 + 的含义是“1 或者多个”吗? 好的，* 的含义是“0 或者多个”。因此，现在你应该能够解析没有分隔符的电话号码了。<br>(2)<br>你瞧，它真的可以胜任。为什么？首先匹配字符串的开始，接着是一个有三个数字位 (800) 的组，接着是 0 个非数字字符，接着是一个有三个数字位 (555) 的组，接着是 0 个非数字字符，接着是一个有四个数字位 (1212) 的组，接着是 0 个非数字字符，接着是一个有任意数字位 (1234) 的组，最后是字符串的结尾。<br>(3)<br>对于其他的变化也能够匹配：比如点号分隔符，在分机号前面既有空格符又有 x 符号的情况也能够匹配。<br>(4)<br>最后，你已经解决了长期存在的一个问题：现在分机号是可选的了。如果没有发现分机号，groups() 函数仍然返回一个有四个元素的元组，但是第四个元素只是一个空字符串。<br>(5)<br>我不喜欢做一个坏消息的传递人，此时你还没有完全结束这个问题。还有什么问题呢？当在区号前面还有一个额外的字符时，而正则表达式假设区号是一个字符串的开始，因此不能匹配。这个不是问题，你可以利用相同的技术“0或者多个非数字字符”来跳过区号前面的字符。<br>下一个例子展示如何解决电话号码前面有其他字符的情况。<br>例 7.14. 处理开始字符</p><blockquote><p>phonePattern = re.compile(r’^D<em>(d{3})D</em>(d{3})D<em>(d{4})D</em>(d*)$’) (1)<br>phonePattern.search(‘(800)5551212 ext. 1234’).groups() (2)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘800-555-1212’).groups() (3)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘’)</p><blockquote><p>phonePattern.search(‘work 1-(800) 555.1212 #1234’) (4)</p></blockquote><p>(1)<br>这个正则表达式和前面的几乎相同，但它在第一个记忆组 (区号) 前面匹配 D<em>，0 或者多个非数字字符。注意，此处你没有记忆这些非数字字符 (它们没有被括号括起来)。如果你发现它们，只是跳过它们，接着只要匹配上就开始记忆区号。<br>(2)<br>你可以成功地解析电话号码，即使在区号前面有一个左括号。(在区号后面的右括号也已经被处理，它被看成非数字字符分隔符，由第一个记忆组后面的 D</em> 匹配。)<br>(3)<br>进行仔细的检查，保证你没有破坏前面能够匹配的任何情况。由于首字符是完全可选的，这个模式匹配字符串的开始，接着是 0 个非数字字符，接着是一个有三个数字字符的记忆组 (800)，接着是 1 个非数字字符 (连字符)，接着是一个有三个数字字符的记忆组 (555)，接着是 1 个非数字字符 (连字符)，接着是一个有四个数字字符的记忆组 (1212)，接着是 0 个非数字字符，接着是一个有 0 个数字位的记忆组，最后是字符串的结尾。<br>(4)<br>此处是正则表达式让我产生了找一个硬东西挖出自己的眼睛的冲动。为什么这个电话号码没有匹配上？因为在它的区号前面有一个 1，但是你认为在区号前面的所有字符都是非数字字符 (D*)。唉！让我们往回看一下。迄今为止，正则表达式总是从一个字符串的开始匹配。但是现在你看到了，有很多不确定的情况需要你忽略。与其尽力全部匹配它们，还不如全部跳过它们，让我们采用一个不同的方法：根本不显式地匹配字符串的开始。下面的这个例子展示这个方法。<br>例 7.15. 电话号码，无论何时我都要找到它</p><blockquote><p>phonePattern = re.compile(r’(d{3})D<em>(d{3})D</em>(d{4})D<em>(d</em>)$’) (1)<br>phonePattern.search(‘work 1-(800) 555.1212 #1234’).groups() (2)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘800-555-1212’) (3)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘’)</p><blockquote><p>phonePattern.search(‘80055512121234’) (4)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)<br>(1)<br>注意，在这个正则表达式的开始少了一个 ^ 字符。你不再匹配字符串的开始了，也就是说，你需要用你的正则表达式匹配整个输入字符串，除此之外没有别的意思了。正则表达式引擎将要努力计算出开始匹配输入字符串的位置，并且从这个位置开始匹配。<br>(2)<br>现在你可以成功解析一个电话号码了，无论这个电话号码的首字符是不是数字，无论在电话号码各部分之间有多少任意类型的分隔符。<br>(3)<br>仔细检查，这个正则表达式仍然工作的很好。<br>(4)<br>还是能够工作。看看一个正则表达式能够失控得多快？回头看看前面的例子，你还能区别它们么？ 当你还能够理解这个最终答案的时候 (这个正则表达式就是最终答案，即使你发现一种它不能处理的情况，我也真的不想知道它了)，在你忘记为什么你这么选择之前，让我们把它写成松散正则表达式的形式。<br>例 7.16. 解析电话号码 (最终版本)</p><blockquote><p>phonePattern = re.compile(r’’’ # don’t match beginning of string, number can start anywhere (</p></blockquote><p>d{3}) # area code is 3 digits (e.g. ‘800’)</p><p>D* # optional separator is any number of non-digits</p><p>(d{3}) # trunk is 3 digits (e.g. ‘555’)</p><p>D* # optional separator<br>(d{4}) # rest of number is 4 digits (e.g. ‘1212’)</p><p>D* # optional separator</p><p>(d*) # extension is optional and can be any number of digits</p><p>$ # end of string ‘’’</p><p>, re.VERBOSE)</p><blockquote><p>phonePattern.search(‘work 1-(800) 555.1212 #1234’).groups() (1)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘1234’)</p><blockquote><p>phonePattern.search(‘800-555-1212’) (2)</p></blockquote><p>(‘800’, ‘555’, ‘1212’, ‘’)<br>(1)<br>除了被分成多行，这个正则表达式和最后一步的那个完全相同，因此它能够解析相同的输入一点也不奇怪。<br>(2)<br>进行最后的仔细检查。很好，仍然工作。你终于完成了这件任务。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>(转)Python 参数知识（变量前加星号的意义）</title>
      <link href="/article/775.html"/>
      <url>/article/775.html</url>
      <content type="html"><![CDATA[<p>原文地址：<a href="http://blog.csdn.net/qinyilang/article/details/5484415" target="_blank" rel="noopener">http://blog.csdn.net/qinyilang/article/details/5484415</a></p><p>**过量的参数</p><p>**在运行时知道一个函数有什么参数，通常是不可能的。另一个情况是一个函数能操作很多对象。更有甚者，调用自身的函数变成一种api提供给可用的应用。</p><p>对于这些情况，python提供了两种特别的方法来定义函数的参数，允许函数接受过量的参数，不用显式声明参数。这些“额外”的参数下一步再解释。</p><p>注意args和kwargs只是python的约定。任何函数参数，你可以自己喜欢的方式命名，但是最好和python标准的惯用法一致，以便你的代码，其他的程序员也能轻松读懂。<br><strong><br>位置参数</strong></p><p>在参数名之前使用一个星号，就是让函数接受任意多的位置参数。</p><pre><code>&gt;&gt;&gt; def multiply(*args):...     total = 1...     for arg in args:...         total *= arg...     return total...&gt;&gt;&gt; multiply(2, 3)6&gt;&gt;&gt; multiply(2, 3, 4, 5, 6)720</code></pre><a id="more"></a><p>python把参数收集到一个元组中，作为变量args。显式声明的参数之外如果没有位置参数，这个参数就作为一个空元组。</p><p>**关键字参数</p><p>**python在参数名之前使用2个星号来支持任意多的关键字参数。</p><pre><code>&gt;&gt;&gt; def accept(**kwargs):...     for keyword, value in kwargs.items():...         print &quot;%s =&gt; %r&quot; % (keyword, value)...&gt;&gt;&gt; accept(foo=&#39;bar&#39;, spam=&#39;eggs&#39;)foo =&gt; &#39;bar&#39;spam =&gt; &#39;eggs&#39;</code></pre><p>注意：kwargs是一个正常的python字典类型，包含参数名和值。如果没有更多的关键字参数，kwargs就是一个空字典。</p><p><strong>混合参数类型</strong></p><p>任意的位置参数和关键字参数可以和其他标准的参数声明一起使用。混合使用时要加些小心，因为python中他们的次序是重要的。参数归为4类，不是所有的类别都需要。他们必须按下面的次序定义，不用的可以跳过。</p><p>1）必须的参数<br>2）可选的参数<br>3）过量的位置参数<br>4）过量的关键字参数</p><p>def complex_function(a, b=None, <em>c, *</em>d):</p><p>这个次序是必须的，因为<em>args和*</em>kwargs只接受那些没有放进来的其他任何参数。没有这个次序，当你调用一个带有位置参数的函数，python就不知道哪个值是已声明参数想要的，也不知道哪个被作为过量参数对待。</p><p>也要注意的是，当函数能接受许多必须的参数和可选的参数，那它只要定义一个过量的参数类型即可。</p><p>传递参数集合</p><p>除了函数能接受任意参数集合，python代码也可以调用带有任意多数量的函数，像前面说过的用星号。这种方式传递的参数由python扩展成为参数列表。以便被调用的函数<br>不需要为了这样调用而去使用过量参数。python中任何可调用的，都能用这种技法来调用。并且用相同的次序规则和标准参数一起使用。</p><pre><code>&gt;&gt;&gt; def add(a, b, c):...     return a + b + c...&gt;&gt;&gt; add(1, 2, 3)6&gt;&gt;&gt; add(a=4, b=5, c=6)15&gt;&gt;&gt; args = (2, 3)&gt;&gt;&gt; add(1, *args)6&gt;&gt;&gt; kwargs={&#39;b&#39;: 8, &#39;c&#39;: 9}&gt;&gt;&gt; add(a=7, **kwargs)24&gt;&gt;&gt; add(a=7, *args)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: add() got multiple values for keyword argument &#39;a&#39;&gt;&gt;&gt; add(1, 2, a=7)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: add() got multiple values for keyword argument &#39;a&#39;</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迟暮之年，感慨之春</title>
      <link href="/article/760.html"/>
      <url>/article/760.html</url>
      <content type="html"><![CDATA[<p>早上匆匆忙忙的上了拥挤的公交，其实后面还有更拥挤的地铁，麻木的内心其实早已习惯这种乱哄哄的狭小空间，打开手机，习惯性的打开阅读软件，浏览着早已下载好的离线新闻，公交每到一站，任凭司机撕心裂肺的倡导，能动则随着人流动，不能动就当什么都没有听到，当有乘客在拥挤的车厢内挤来挤去，有意无意的一些身体接触摩擦过后，一股想骂人的冲动只因为在转头都困难的环境下就忍了吧。</p><p>怎知每天这时都会有很多老年人来凑热闹，我有时真是由衷的佩服他们，满头白发，却还做着有些年轻人都不想做但不得不做的事情，挤来挤去的，也有不开眼的在座位上的乘客，依然玩着自己的手机或者补着晚上还没有做完的梦，于是老年人在还可以移动的情况下会继续寻找属于自己的“专座”。</p><p>而今天我放下了手机，不再看那些用数据堆起来的专题。只因两位特别的老人。<br><a id="more"></a></p><p>嘈杂的车厢内，看着一位老妪步履蹒跚的上了车，目测有70多岁吧，可能是由于身材矮小的原因吧，再加上乱七八糟的环境，很少有人注意到她，即使她从我后边挤过去，我也没有更多的注意。</p><p>这时另一位坐在专座上的老人，目测60多岁吧，突然喊了一句“阿姨，您坐这里吧”</p><p>于是老妪挪动着不灵巧的身体说了声谢谢后，坐了下来。</p><p>写到这里，不要以为我是想说什么社会道德，这些东西还不足以让我停下手中的手机还静静的注意她们。之后她们开始了交谈，而内容却是我深深的思考中。</p><p>两们老人看到公车外面有人溜狗，于是找到了一个两个人都喜欢的话题，年长的说，我家也有一条小狗，10多年了，前段时间刚没的。</p><p>另一个说，那可够可惜的</p><p>“可不是嘛，我都不敢再养了，那条小狗有次我不想要了，想把它送出去，送了一个亲戚家，结果没几天它居然自己跑回来了，我听到大晚上的外面有挠门声，打开门一看，这小玩意居然自己跑回来了，当时我这眼泪啊，从此以后我就再不想把它送出去了”</p><p>“可不是嘛，狗这东西通人性，也认路”</p><p>我清楚的看到老人摘下自己的老花镜，擦了擦红润的眼睛。</p><p>老人接着说，“我这小狗啊，养了10多年，最后那段日子，见了生人也不叫了，有点打蔫，再后来就不怎么吃食了，到最后眼睛都瞎了，我每天用针管给它喂水喂食”</p><p>“那您可对它真是细心”</p><p>“最后看着太难受了，送医院了，打了针安乐，就这么送走了。。。”</p><p>我注意到周围的乘客很多都在听她讲她和她的小狗的故事。</p><p>那个老妪接着说 “我的一个邻居家的小狗，死了后还给它立了个碑！还提了字”</p><p>听到这里，我心里是觉得很好笑的。</p><p>但笑过之后会开始思考，迟暮的老人，在这么大的岁数下，还要挤公交，想必其儿女是未尽足够的孝道，抑或儿女在远方没有能力，又或者儿女早已不在世上，老人将自己的感情寄托在身边的小生命上，一条小狗的逝去也能让其伤心欲绝。</p><p>当今社会，年轻人都在想着怎么生存，怎么成功，而忽略了在家独处的父母，但父母们的愿望很简单，只希望在晚年多陪陪他们，一家人团团圆圆的，但他们却又不能妨碍翅膀硬了的我们，我们想要振翅高飞，想要干出一番事业，而大多忽略了至亲的亲情，在外面累了，受委屈了，这时才想到家里还有两个一直宠你爱你包容你的人。</p><p>迟暮之年，难免想到死亡，看着身边的小生命逝去，心里想必是和年轻人所不一样的。</p><p>感慨之春，在风赶雾霾，沙逼北京的春天，承载着多少人的成功梦，却也承载着多少年迈的父母对子女的思念。</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python中用print方法向文件中写入内容</title>
      <link href="/article/749.html"/>
      <url>/article/749.html</url>
      <content type="html"><![CDATA[<p>一个小功能，我就是想用print功能实现，不想用write</p><pre><code class="python">import osos.chdir(&quot;/usr/tem&quot;)char=&quot;my name is yangyanxing&quot;f = open(&quot;test.txt&quot;,&quot;w&quot;)print &gt;&gt;f,char</code></pre><p>但是Python3中还可以用以下的方式</p><pre><code class="python">import osos.chdir(&quot;/usr/tem&quot;)char=&quot;my name is yangyanxing&quot;f = open(&quot;test.txt&quot;,&quot;w&quot;)print(char,file=f)</code></pre><a id="more"></a><p>也可以考虑用with as结构，会简单与周全些</p><pre><code class="python">try:    with(&quot;man.txt&quot;,&quot;w&quot;) as data:        print &gt;&gt;data,charexcept IOError as err:    print(&quot;Write error&quot;+ str(err))</code></pre><p>这种可以不用考虑finally情况</p><p>不同版本真是麻烦。。。。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用新浪SAE storage服务做图床</title>
      <link href="/article/460.html"/>
      <url>/article/460.html</url>
      <content type="html"><![CDATA[<p>新浪SAE 为用户提供storage服务，来永久性存储文件，这很好的为用户提供图片等文件存储服务，以下通过方法来建立一个自己的图床</p><p>需求：上传一张照片，返回这张照片的地址</p><p>实现 <a href="http://kevinkelin.sinaapp.com/fileupload.php" target="_blank" rel="noopener">http://kevinkelin.sinaapp.com/fileupload.php</a></p><h1 id="首先在SAE上建立一个storage-的domain"><a href="#首先在SAE上建立一个storage-的domain" class="headerlink" title="首先在SAE上建立一个storage 的domain"></a>首先在SAE上建立一个storage 的domain</h1><p>首先在SAE上建立一个storage 的domain,(其实再之前你需要有一个应用，这里不写了)<br> <a id="more"></a></p><h1 id="新建一个fileupload-php文件"><a href="#新建一个fileupload-php文件" class="headerlink" title="新建一个fileupload.php文件"></a>新建一个fileupload.php文件</h1><p>代码如下</p><pre><code class="php">&lt;?phpsession_start();include_once(&#39;saestorage.class.php&#39;);?&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;fileupload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type = &quot;file&quot; name=&quot;myfile&quot; size=&quot;100&quot; /&gt;&lt;br&gt;&lt;input type = &quot;submit&quot; value= &quot;upload&quot; / &gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$domain=&quot;imagefile&quot;;$file_name = $_FILES[&quot;myfile&quot;][&quot;name&quot;];$temp_arr = explode(&quot;.&quot;, $file_name);$file_ext = array_pop($temp_arr);$file_ext = trim($file_ext);$file_ext = strtolower($file_ext);$new_file_name = date(&quot;YmdHis&quot;) . &#39;_&#39; . rand(10000, 99999).&#39;.&#39;.$file_ext;$s = new SaeStorage();//$s-&gt;upload( &#39;imagefile&#39;,$_FILES[&quot;myfile&quot;][&quot;name&quot;],$_FILES[&quot;myfile&quot;][&quot;name&quot;]);echo $aimage=$s-&gt;upload( &#39;imagefile&#39;,$new_file_name,$_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;]);?&gt;</code></pre><p>得到了图片的地址，你就可以随意的使用了，前提是你在建立domain的时候不要防盗链，新浪SAE也是有限制的<br>运行在SAE上的应用(App)将会消耗平台资源，为保证各App不互相 影响，我们引入了<em>分钟配额</em>的概念，即：在每分钟内每个应用的各个服务所消耗的 资源的速度。当<a href="http://sae.sina.com.cn/?m=devcenter&amp;catId=204" target="_blank" rel="noopener">Storage</a>服务超过分钟配额，我们将会立即禁掉该应用的<a href="http://sae.sina.com.cn/?m=devcenter&amp;catId=204" target="_blank" rel="noopener">Storage</a> 服务，禁用五分钟后，恢复会自动恢复，避免影响到SAE平台的稳定性。服务因为超过“分钟配额”而被禁用时，会在“服务状态”看到该服务被禁用的原因是：<strong>OverMinuteQuota   </strong><br>服务请求数cpu时间流入带宽流出带宽<br>Storage5,000NA80MB400MB<br>今天又将这个页面改了改，实现可以遍历指定domain下所有图片以及下载地址，并且实现后上传先显示，只是实现功能，所以页面太糙了。。。</p><pre><code class="php">&lt;?phpsession_start();include_once( &#39;config.php&#39; );include_once( &#39;saetv2.ex.class.php&#39; );include_once(&#39;saestorage.class.php&#39;);?&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;fileupload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type = &quot;file&quot; name=&quot;myfile&quot; size=&quot;100&quot; /&gt;&lt;br&gt;&lt;input type = &quot;submit&quot; value= &quot;upload&quot; / &gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$domain=&quot;imagefile&quot;;$file_name = $_FILES[&quot;myfile&quot;][&quot;name&quot;];$temp_arr = explode(&quot;.&quot;, $file_name);$file_ext = array_pop($temp_arr);$file_ext = trim($file_ext);$file_ext = strtolower($file_ext);$new_file_name = date(&quot;YmdHis&quot;) . &#39;_&#39; . rand(10000, 99999).&#39;.&#39;.$file_ext;$s = new SaeStorage();//$s-&gt;upload( &#39;imagefile&#39;,$_FILES[&quot;myfile&quot;][&quot;name&quot;],$_FILES[&quot;myfile&quot;][&quot;name&quot;]);echo $aimage=$s-&gt;upload( &#39;imagefile&#39;,$new_file_name,$_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;]);$files = $s-&gt;getList($domain,&quot;&quot;,100);echo &quot;&lt;pre&gt;&quot;;print_r($files);echo &quot;&lt;/pre&gt;&quot;;foreach($files as $name){echo $s-&gt;getUrl($domain,$name).&quot;&lt;br&gt;&quot;;}echo &quot;&lt;br&gt;&quot;;foreach($files as $name){  //echo &quot;&lt;img src=&quot;.$s-&gt;getUrl($domain,$name).&quot; width=&#39;50%&#39;. height=&#39;100%&#39;.&gt;&quot;;  echo &quot;&lt;table border=&#39;5&#39; align=&#39;center&#39;&gt;&quot;;  echo &quot;&lt;tr&gt;&quot;;                echo &quot;&lt;td align=&#39;right&#39;&gt;&quot;;  echo &quot;&lt;a target=&#39;_blank&#39; href=&quot;.$s-&gt;getUrl($domain,$name). &quot;&gt;&lt;img src=&quot;.$s-&gt;getUrl($domain,$name).&quot; width=&#39;30%&#39; height=&#39;30%&#39;&quot;.&quot;&gt;&lt;/a&gt;&quot;;                        echo &quot;&lt;br&gt;&lt;br&gt;&quot;;                        echo $s-&gt;getUrl($domain,$name).&quot;&lt;br&gt;&quot;;  echo &quot;&lt;/td&gt;&quot;;  echo &quot;&lt;/tr&gt;&quot;;  echo &quot;&lt;/table&gt;&quot;;}?&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>解决wordpress后台写日志时编辑器加载慢</title>
      <link href="/article/444.html"/>
      <url>/article/444.html</url>
      <content type="html"><![CDATA[<p>空间放在国外的人基本都有一个感受，有时加载很慢，我最近用wordpress写文章的时候，默认的编辑器加载很慢<br>有时都无法写博客下图中红框圈出来的位置加载太慢，后来网上查了查相应的资料，原来是有一个.js文件导致的，那个文件有200多K<br>所以有时对于主机放在国外的朋友很慢，其实这里只要把这个js文件放到国内服务器，加载速度就能提高很快</p><p><img src="http://ww1.sinaimg.cn/large/795ab47fjw1dzlljowwkkj.jpg" alt="" title="reload"></p><p>到你的wordpress目录 wp-includes/js/tinymce取出tiny_mce.js文件，然后将其放到国内一个访问快的服务器，别说你没有啊，实在没有的话用新浪的SAE。然后找到打开wp-includes/class-wp-editor.php 这个文件，找到大概540行左右<br><a id="more"></a><br>改为</p><pre><code class="php">if ( $tmce_on ) {if ( $compressed )echo &quot;&lt;script type=&#39;text/javascript&#39; src=&#39;{$baseurl}/wp-tinymce.php?c=1&amp;$version&#39;&gt;&lt;/script&gt;n&quot;;elseecho &quot;&lt;script type=&#39;text/javascript&#39; src=&#39;http://kevinkelin.sinaapp.com/tiny_mce.js&#39;&gt;&lt;/script&gt;n&quot;;if ( &#39;en&#39; != self::$mce_locale &amp;&amp; isset($lang) )echo &quot;&lt;script type=&#39;text/javascript&#39;&gt;n$langn&lt;/script&gt;n&quot;;elseecho &quot;&lt;script type=&#39;text/javascript&#39; src=&#39;{$baseurl}/langs/wp-langs-en.js?$version&#39;&gt;&lt;/script&gt;n&quot;;}</code></pre><p>其中<a href="http://kevinkelin.sinaapp.com/tiny_mce.js" target="_blank" rel="noopener">http://kevinkelin.sinaapp.com/tiny_mce.js</a> 是我将这个js文件放到新浪SAE的地址，如果你的版本也是3.4.2的话，你想用也可以引用，前提是你认为我不会对这个js文件做手脚。。。。</p><p>好了，改好后再在后台写篇文章看一下吧，速度是不是有很大的提高呢？</p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>（转）Python装饰器与面向切面编程</title>
      <link href="/article/416.html"/>
      <url>/article/416.html</url>
      <content type="html"><![CDATA[<p>本文用了一个很通俗的例子还一步步的让读者理解Python中的装饰器的概念</p><p>原文地址：<a href="http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html" target="_blank" rel="noopener">http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html</a></p><p>今天来讨论一下装饰器。装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p><h2 id="装饰器入门"><a href="#装饰器入门" class="headerlink" title="装饰器入门"></a>装饰器入门</h2><h3 id="需求是怎么来的？"><a href="#需求是怎么来的？" class="headerlink" title="需求是怎么来的？"></a>需求是怎么来的？</h3><p>装饰器的定义很是抽象，我们来看一个小例子。</p><pre><code class="python">def foo():    print &#39;in foo()&#39;foo()</code></pre><p>这是一个很无聊的函数没错。但是突然有一个更无聊的人，我们称呼他为B君，说我想看看执行这个函数用了多长时间，好吧，那么我们可以这样做：</p><pre><code class="python">import timedef foo():    start = time.clock()    print &#39;in foo()&#39;    end = time.clock()    print &#39;used:&#39;, end - startfoo()</code></pre><p>很好，功能看起来无懈可击。可是蛋疼的B君此刻突然不想看这个函数了，他对另一个叫foo2的函数产生了更浓厚的兴趣。</p><p>怎么办呢？如果把以上新增加的代码复制到foo2里，这就犯了大忌了~复制什么的难道不是最讨厌了么！而且，如果B君继续看了其他的函数呢？</p><p>1.2. 以不变应万变，是变也</p><p>还记得吗，函数在Python中是一等公民，那么我们可以考虑重新定义一个函数timeit，将foo的引用传递给他，然后在timeit中调用foo并进行计时，这样，我们就达到了不改动foo定义的目的，而且，不论B君看了多少个函数，我们都不用去修改函数定义了！</p><pre><code class="python">import timedef foo():    print &#39;in foo()&#39;def timeit(func):    start = time.clock()    func()    end =time.clock()    print &#39;used:&#39;, end - starttimeit(foo)</code></pre><p>看起来逻辑上并没有问题，一切都很美好并且运作正常！……等等，我们似乎修改了调用部分的代码。原本我们是这样调用的：foo()，修改以后变成了：timeit(foo)。这样的话，如果foo在N处都被调用了，你就不得不去修改这N处的代码。或者更极端的，考虑其中某处调用的代码无法修改这个情况，比如：这个函数是你交给别人使用的。</p><p>1.3. 最大限度地少改动！</p><p>既然如此，我们就来想想办法不修改调用的代码；如果不修改调用代码，也就意味着调用foo()需要产生调用timeit(foo)的效果。我们可以想到将timeit赋值给foo，但是timeit似乎带有一个参数……想办法把参数统一吧！如果timeit(foo)不是直接产生调用效果，而是返回一个与foo参数列表一致的函数的话……就很好办了，将timeit(foo)的返回值赋值给foo，然后，调用foo()的代码完全不用修改！</p><pre><code class="python">#-*- coding: UTF-8 -*-import timedef foo():    print &#39;in foo()&#39;# 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法def timeit(func):    # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装    def wrapper():        start = time.clock()        func()        end =time.clock()        print &#39;used:&#39;, end - start    # 将包装后的函数返回    return wrapperfoo = timeit(foo)foo()</code></pre><p>这样，一个简易的计时器就做好了！我们只需要在定义foo以后调用foo之前，加上foo = timeit(foo)，就可以达到计时的目的，这也就是装饰器的概念，看起来像是foo被timeit装饰了。在在这个例子中，函数进入和退出时需要计时，这被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。与传统编程习惯的从上往下执行方式相比较而言，像是在函数执行的流程中横向地插入了一段逻辑。在特定的业务领域里，能减少大量重复代码。面向切面编程还有相当多的术语，这里就不多做介绍，感兴趣的话可以去找找相关的资料。</p><p>这个例子仅用于演示，并没有考虑foo带有参数和有返回值的情况，完善它的重任就交给你了 ：）</p><ol><li>Python的额外支持<br>2.1. 语法糖</li></ol><p>上面这段代码看起来似乎已经不能再精简了，Python于是提供了一个语法糖来降低字符输入量。</p><pre><code class="python">import timedef timeit(func):    def wrapper():        start = time.clock()        func()        end =time.clock()        print &#39;used:&#39;, end - start    return wrapper@timeitdef foo():    print &#39;in foo()&#39;foo()</code></pre><p>重点关注第11行的@timeit，在定义上加上这一行与另外写foo = timeit(foo)完全等价，千万不要以为@有另外的魔力。除了字符输入少了一些，还有一个额外的好处：这样看上去更有装饰器的感觉。</p><p>2.2. 内置的装饰器</p><p>内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。由于模块里可以定义函数，所以静态方法和类方法的用处并不是太多，除非你想要完全的面向对象编程。而属性也不是不可或缺的，Java没有属性也一样活得很滋润。从我个人的Python经验来看，我没有使用过property，使用staticmethod和classmethod的频率也非常低。</p><pre><code class="python">class Rabbit(object):    def __init__(self, name):        self._name = name    @staticmethod    def newRabbit(name):        return Rabbit(name)    @classmethod    def newRabbit2(cls):        return Rabbit(&#39;&#39;)    @property    def name(self):        return self._name这里定义的属性是一个只读属性，如果需要可写，则需要再定义一个setter：@name.setterdef name(self, name):    self._name = name</code></pre><p>functools模块提供了两个装饰器。这个模块是Python 2.5后新增的，一般来说大家用的应该都高于这个版本。但我平时的工作环境是2.4 T-T</p><p>2.3.1. wraps(wrapped[, assigned][, updated]):<br>这是一个很有用的装饰器。看过前一篇反射的朋友应该知道，函数是有几个特殊属性比如函数名，在被装饰后，上例中的函数名foo会变成包装函数的名字wrapper，如果你希望使用反射，可能会导致意外的结果。这个装饰器可以解决这个问题，它能将装饰过的函数的特殊属性保留。</p><pre><code class="python">import timeimport functoolsdef timeit(func):    @functools.wraps(func)    def wrapper():        start = time.clock()        func()        end =time.clock()        print &#39;used:&#39;, end - start    return wrapper@timeitdef foo():    print &#39;in foo()&#39;foo()print foo.__name__</code></pre><p>首先注意第5行，如果注释这一行，foo.<strong>name</strong>将是’wrapper’。另外相信你也注意到了，这个装饰器竟然带有一个参数。实际上，他还有另外两个可选的参数，assigned中的属性名将使用赋值的方式替换，而updated中的属性名将使用update的方式合并，你可以通过查看functools的源代码获得它们的默认值。对于这个装饰器，相当于wrapper = functools.wraps(func)(wrapper)。</p><p>2.3.2. total_ordering(cls):<br>这个装饰器在特定的场合有一定用处，但是它是在Python 2.7后新增的。它的作用是为实现了至少<strong>lt</strong>、<strong>le</strong>、<strong>gt</strong>、<strong>ge</strong>其中一个的类加上其他的比较方法，这是一个类装饰器。如果觉得不好理解，不妨仔细看看这个装饰器的源代码：</p><pre><code class="python">def total_ordering(cls):    &quot;&quot;&quot;Class decorator that fills in missing ordering methods&quot;&quot;&quot;    convert = {        &#39;__lt__&#39;: [(&#39;__gt__&#39;, lambda self, other: other &lt; self),                   (&#39;__le__&#39;, lambda self, other: not other &lt; self),                   (&#39;__ge__&#39;, lambda self, other: not self &lt; other)],        &#39;__le__&#39;: [(&#39;__ge__&#39;, lambda self, other: other &lt;= self),                   (&#39;__lt__&#39;, lambda self, other: not other &lt;= self),                   (&#39;__gt__&#39;, lambda self, other: not self &lt;= other)],        &#39;__gt__&#39;: [(&#39;__lt__&#39;, lambda self, other: other &gt; self),                   (&#39;__ge__&#39;, lambda self, other: not other &gt; self),                   (&#39;__le__&#39;, lambda self, other: not self &gt; other)],        &#39;__ge__&#39;: [(&#39;__le__&#39;, lambda self, other: other &gt;= self),                   (&#39;__gt__&#39;, lambda self, other: not other &gt;= self),                   (&#39;__lt__&#39;, lambda self, other: not self &gt;= other)]    }    roots = set(dir(cls)) &amp; set(convert)    if not roots:        raise ValueError(&#39;must define at least one ordering operation: &lt; &gt; &lt;= &gt;=&#39;)    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__    for opname, opfunc in convert[root]:        if opname not in roots:            opfunc.__name__ = opname            opfunc.__doc__ = getattr(int, opname).__doc__            setattr(cls, opname, opfunc)    return cls</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京工业大学内两个网卡分别访问内网与外网的方法</title>
      <link href="/article/413.html"/>
      <url>/article/413.html</url>
      <content type="html"><![CDATA[<p>相信很多在北京工业大学的童鞋都知道内网有很多资源，但是由于学校内的网络是按流量收费的，所以对于外网拥有的更多好资源有时只能另想办法，于是很多宿舍开始办理201宽带，但是最快的网速也不及内网10M/s下载爽，于是我在网上找了一些方法，结合北工大的网络环境，写了一个批处理文件来解决同时访问内网与外网的方法</p><p>1.网络现状：有线接内网，无线接ADSL宽带。</p><p>2.首先查看自己内网与ADSL的IP与网关</p><p>内网  IP  172.27.28.96 网关 172.27.28.254</p><p>ADSL IP  192.168.1.105 网关 192.168.1.1</p><p>3. 再建一个txt文档，输入以下信息，重新保存为.bat文件， <a id="more"></a></p><pre><code>route delete 0.0.0.0route add 0.0.0.0 mask 0.0.0.0 192.168.1.1route add 172.27.0.0 mask 255.0.0.0 172.27.28.254</code></pre><p>简单解释一下，第一行为删除所以的网关，第二条为所以外网建立新的网关，也就是你的ADSL路由网关，第三条为你的内网建立网关，这里的网关就是你上面内网查到的网关，注意第三条加的时候一定要和你上面查到的网关对应，第二位和上面的相同，如我这里面的172.27 .0.0 而不能是172.0.0.0</p><p>好了保存一下，然后双击运行这个bat文件，此时你就可以既可能访问内网同时也可以访问外网了~</p><p>注意到北工大内网可以访问IPV6的google以及相关的服务，这时你可以修改你的hosts文件，可以把所有的google服务指身向</p><p>2404:6800:4008:c01::69   速度还是不错的，但偶尔也会有阻断,大家上网愉快~</p><p><img src="http://ww2.sinaimg.cn/large/795ab47fjw1dzdeorhxbxj.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>解决新浪开放平台应用（oauth2）网站无法认证的问题</title>
      <link href="/article/407.html"/>
      <url>/article/407.html</url>
      <content type="html"><![CDATA[<p>前些天一直在倒腾新浪微博的开放平台，一开始用的oauth1，利用官方的PHP SDK写了一个简单发微博的应用，但是很遗憾，没有成功，这里简单的写一下</p><pre><code class="php">&lt;?phpsession_start();include_once( &#39;config.php&#39; );include_once( &#39;weibooauth.php&#39; );$c = new WeiboClient( WB_AKEY , WB_SKEY , $_SESSION[&#39;last_key&#39;][&#39;oauth_token&#39;] , $_SESSION[&#39;last_key&#39;][&#39;oauth_token_secret&#39;] );?&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;text&quot; id=&quot;1&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;发表微博&quot;&gt;&lt;/form&gt;&lt;?phpif(isset($_POST[&#39;text&#39;])){$rr=$c-&gt;update($_POST[&#39;text&#39;]);echo &quot;发表成功&quot;;}?&gt;</code></pre><a id="more"></a><p>认证页面我就不写了，就是用的官方的SDK，输入几个字以后，点击发表微，虽然显示 “发表成功”，但我的微博根本没有发表，于是我将$rr显示出来</p><pre><code class="php">if(isset($_POST[&#39;text&#39;])){$rr=$c-&gt;update($_POST[&#39;text&#39;]); echo &quot;&lt;pre&gt;&quot;;print_r($rr); echo &quot;&lt;/pre&gt;&quot;;}</code></pre><p>结果发现了问题</p><p><pre>Array<br>(<br>    [request] =&gt; /statuses/update.json<br>    [error_code] =&gt; 401<br>    [error] =&gt; 40109:consumer_key_refused!<br>)</pre><br>查看官方文档</p><p>“24、OAuth1.0授权方式能否继续使用？</p><ul><li>目前未授权的应用已经禁止使用OAuth1.0授权及V1接口，2012年9月左右将禁止所有应用使用OAuth1.0授权及V1接口。我们推荐更安全、稳定的OAuth2.0授权方式， OAuth1.0授权方式不久后将全面禁止使用。<br>“</li></ul><p>也就是说oauth1的接口新的应用是不能用的。。。汗，使用oauth2的接口吧</p><p>结果却有新的错误</p><p><img src="http://ww1.sinaimg.cn/bmiddle/795ab47fjw1dz36h36b9mj.jpg" alt="fq "></p><p>再继续查看官方文档关于redirect_url_mismatch的解释</p><p>“获取用户授权是出现 error ：redirect_uri_mismatch 怎么解决？</p><ul><li>这是由于回调地址填写错误造成的，解决办法：</li><li>A、站内应用：redirect_uri等于应用信息中的“站内应用地址”而非“应用实际地址”；</li><li>B、其他应用：redirect_uri需与<a href="http://open.weibo.com/apps/30871*****/info/advanced" target="_blank" rel="noopener">http://open.weibo.com/apps/30871<strong>*</strong>/info/advanced</a> （30871<strong>*</strong>替换成你应用的AppKey）应用高级信息中的“应用回调页”完全匹配或在绑定的域名下。</li><li>注意：修改应用回调页或绑定域名后需要约半小时左右时间生效。<br>”</li></ul><p>由于我新建的是其他应用，于是去修改应用高级设置里的回调页</p><p><img src="http://ww4.sinaimg.cn/large/795ab47fjw1dzcb580frbj.jpg" alt=""></p><p>一开始这个回调信息应该是没有的，需要手工输入才可以，于是输入完这个地址后，再来调用此应用，经过受权页面后，一切就OK了~</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通过小程序练习Python中关于os模块的方法</title>
      <link href="/article/397.html"/>
      <url>/article/397.html</url>
      <content type="html"><![CDATA[<p>通过一个小程序来熟悉一下os模块中的方法，OS模块在以后会经常的使用，操作目录与文件等<br><a id="more"></a></p><pre><code class="python">import osprint os.getcwd()for tmpdir in (&#39;/tmp&#39;,r&#39;c:temp&#39;,r&#39;d:temp&#39;):    if os.path.isdir(tmpdir):  ##判断上面元组中的元素是否存在并且为一个目录        breakelse:    print &#39;No temp dir available&#39;    tmpdir = &#39;&#39;    os.chdir(&#39;d:&#39;)    ##我这里直接转到d分区了    os.makedirs(&#39;temp1&#39;)  ##建立temp1文件夹    print os.getcwd()  ## 获得当前目录路径if tmpdir:    os.chdir(tmpdir)  ##切换文件夹    cwd = os.getcwd()    print &#39;Current temp dir is %s &#39; % cwd    print &#39;Now it will create an dir...&#39;    dirname = os.listdir(cwd)  ##显示当前目录下的文件，放到一个列表中    print dirname    os.makedirs(&#39;example1&#39;)  ##建立一个新的文件夹，example    os.chdir(&#39;example1&#39;)    cwd = os.getcwd()    print &#39;Now the current dir is %s &#39; % cwd    print &#39;The original dir listing is:&#39;    print os.listdir(cwd)    print &#39;Now it will create a test file&#39;    fobj = file(&#39;test.txt&#39;,&#39;w&#39;)    fobj.write(&#39;foon&#39;)    fobj.write(&#39;barn&#39;)    fobj.close()    print &#39;Now after create a test file the listing is :&#39;    print os.listdir(cwd)  ##这里会创建一个文件，里面有foo bar 这两行字符    print &#39;Now it will change the test.tex to test.ini&#39;    os.rename(&#39;test.txt&#39;,&#39;test.ini&#39;)  ##rename    print os.listdir(cwd)    path = os.path.join(cwd,os.listdir(cwd)[0])  ##path 此时为 d:tempexample1test.ini    print &#39;The full file pathname is %s&#39; % path    print os.path.split(path)  ## [&#39;d:tempexample1&#39;, &#39;test.ini&#39;]  split() 函数返回 dirname(目录名) 与 basename(文件名+扩展名)的一个元组    print os.path.splitext(os.path.basename(path))  ##(&#39;test&#39;, &#39;.ini&#39;) splittext() 函数返回filename(文件名)</code></pre><p><a href="/image/2012/11/1352999163_9540.png"><img src="/image/2012/11/1352999163_9540.png" alt="1352999163_9540"></a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个Python的小例子来理解字典与while循环</title>
      <link href="/article/393.html"/>
      <url>/article/393.html</url>
      <content type="html"><![CDATA[<p>现在要实现一个需求，弹出一个界面，可以让用户选择是新建用户还是登录已有账户，或者直接退出，在登录账户的时候，密码输入错误不能超过三次，超过三次要回到主界面，用户名输入‘q’的时候也可以退出并回到主界面<br><a id="more"></a></p><pre><code class="python">#-*-coding:utf-8-*-db = {}  #通过使用字典来建立一个以用户名与密码的映射关系def newuser():    prompt = &#39;login desired:&#39;    while True:  #开始第一层循环，一直是True，除非有break        name = raw_input(prompt)        if db.has_key(name):  #判断所输入的用户名是否在已经存在的字典中，也就是字典中的key，如果存在则弹出一个提示            prompt = &#39;name has already please change another&#39;            continue        else:            break  #这里的意思是所输入的用户名不在字典的key里，则循环break掉    pwd = raw_input(&#39;password: &#39;)    db[name] = pwd    #将所输入的密码赋值给用户名所对应的valuedef olduser():    #这里定义一个老用户登录的函数    us = False    #这里定义一个us=False的目的是为了进行检查用户名是否存在的    while not us:        username = raw_input(&#39;username(q for quit): &#39;)        if username in db:    #这处是检查用户名（key）是否是所定义的字典中，如果在的话us = True，则此处循环结束，不再提示输入用户名            us = True            pwded = db.get(username)    #取出用户名的密码            Ntime = 3    #定义最多只能错误输入三次密码            while Ntime != 0:                password = raw_input(&#39;password: &#39;)                if password != pwded:                    print &#39;You password is not correct you have %d times to try again&#39; % Ntime                    Ntime-=1    #次数减1                    if Ntime == 0:                        print &#39;You have tried too much time without right password!&#39;                        break    #循环结束，同时也意味着olduser()函数的结束，程序向下走，程序将调用__main__入口，从而showmenu()函数被调用                elif password == pwded:    #密码正确                    print &#39;welcome back!&#39;                    break        elif username == &#39;q&#39;:    #当用户名输入q 的时候手工定义pwded and password，为了后面的判断            pwded = None            password = 123            break        else:            print &#39;No such user!!! please try again&#39;    #当输入一个不存在的key的时候输入此句    if password == 123:        print &#39;You choice is q so it will back to main menu!&#39;    #这里是前面的当输入为q的用户名时的输出def showmenu():    prompt = &#39;&#39;&#39;    (N)ew user sign    (O)ld user login    (Q)uit    Enter your choice:&#39;&#39;&#39;    done = False    while not done:        chosen = False        while not chosen:            try:                choice = raw_input(prompt).strip()[0].lower()    #取用户所输入字符串第一个字符并将其小写去空格            except (EOFError,KeyboardInterrupt):                choice = &#39;q&#39;            print &#39;nYou picked is [%s]&#39;% choice            if choice not in &#39;noq&#39;:    #判断是否在这三个字母当中                print &#39;choice is invaild,try again&#39;            else:                chosen = True        if choice == &#39;q&#39;:done =True    #done = True 则程序主循环不执行，程序结束        if choice == &#39;o&#39;:olduser()        if choice == &#39;n&#39;:newuser()if __name__ == &#39;__main__&#39;:    showmenu()</code></pre>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Chrome或者极速浏览器屏蔽烦人的广告</title>
      <link href="/article/375.html"/>
      <url>/article/375.html</url>
      <content type="html"><![CDATA[<p>首先得声明，广告做为互联网中一个不可或缺元素，也是网站的主要收益来源，但频繁的广告会使人烦死，如一些垃圾网站的鼠标点击弹出色情游戏广告，有时还不止一个，还有优酷有广告，动辄就45S，实在受不了，基于此，寻找各路大仙</p><p>浏览器，Chrome或者基于Chrome核的浏览器，像360极速浏览器，在Chrome商店中（<a href="https://chrome.google.com/webstore/" target="_blank" rel="noopener">https://chrome.google.com/webstore/</a>）搜索Adblock Plus (<a href="https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb</a>) 最新版的Chrome要必须从Chrome商店中安装应用，如果是极速浏览器的话可以直接点击 <a href="http://adblockplus.org/devbuilds/adblockpluschrome/00latest.crx" target="_blank" rel="noopener">http://adblockplus.org/devbuilds/adblockpluschrome/00latest.crx</a> 这个好处是直接就集成了<a href="https://code.google.com/p/adblock-chinalist/" title="https://easylist-downloads.adblockplus.org/chinalist+easylist.txt" target="_blank" rel="noopener">ChinaList+EasyList</a> ，当中有中国大多数网站中的广告元素，新装的时候会有一段时间的数据下载过程，取决于你的网速，数据请看 <a href="https://easylist-downloads.adblockplus.org/chinalist+easylist.txt" target="_blank" rel="noopener">https://easylist-downloads.adblockplus.org/chinalist+easylist.txt</a></p><p>接下来你就可以轻松的访问各种网站了，注意现在访问的时候在浏览器的地址栏最右边会出现一个红色的ABP标识，因为即使在那个ChianList里面，也不是能把中国所以的网站广告都屏蔽了，有时还需要自己手工的添加，用鼠标点击那个红色标识，接着再点击“轻松建立过滤规则”，接下来把鼠标放到你想屏蔽广告的地方，那个地方会就成半透明的黄色，点击一下即可，在弹出来的对话框点击确定</p><p>当然也有想看网站广告的时候， <a id="more"></a>这时候可以这样做，点击红色的ABP标识，把“对该网站启用过滤”前面的沟去掉。</p><p>接下来说优酷，当你使用这个屏蔽插件的时候，这个孙子开始向你卖萌</p><p><img src="http://ww3.sinaimg.cn/bmiddle/795ab47fjw1dx3fa3oonmj.jpg" alt="" title="Youku卖萌"></p><p>接下来我们使用神器，OpenGG.Clean.Player <a href="http://userscripts.org/scripts/source/120679.user.js" target="_blank" rel="noopener">点击下载</a> 替换本身的播放器，目前这种方法还可以用，不过指不定哪天就不能用了，先用着吧~</p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ThinkPHP之简单的用户增删改查</title>
      <link href="/article/702.html"/>
      <url>/article/702.html</url>
      <content type="html"><![CDATA[<p>此篇文章简单的应用了之前所介绍的CURD</p><p>在IndexAction.class.php中写入以下代码<br><a id="more"></a></p><pre><code class="php">&lt;?phpclass IndexAction extends Action{    /*主页显示*/    public function index(){    $user=M(&#39;user&#39;);    $list=$user-&gt;field(array(&#39;id&#39;,&#39;username&#39;,&#39;createip&#39;))-&gt;select();//查出id username,createip这三个字段    $this-&gt;assign(&#39;title&#39;,&#39;操作练习&#39;);//将操作练习分配给title    $this-&gt;assign(&#39;alist&#39;,$list); //将上面所得到的$list分配给alist    $this-&gt;display(); //这里需要在TPL中创建一个index.html的页面    }    /*删除用户操作*/    function del(){    $user=M(&#39;user&#39;);    if ($user-&gt;delete($_GET[&#39;id&#39;])){//这里采用的是GET传值    $this-&gt;success(&#39;删除用户成功&#39;);    }else{    $this-&gt;error(&#39;删除用户失败&#39;);    }    }    /*添加用户操作*/    function add(){    Load(&#39;extend&#39;);//这里是为了要应用get_client_ip()方法    if ($_POST[&#39;password&#39;]!=$_POST[&#39;repassword&#39;]){    $this-&gt;error(&#39;两次输入的密码不一致&#39;);    }    $user=D(&#39;user&#39;);//使用D方法实例化模型则要在model中创建相应的UserModel.class.php，里面可以什么方法都不写    if ($vo=$user-&gt;create()){    $user-&gt;createtime=time();    $user-&gt;createip=get_client_ip();    $user-&gt;password=md5($user-&gt;password);//将数据压入到$user变量中    if ($user-&gt;add()){    $this-&gt;success(&#39;用户注册成功&#39;);    }else {    $this-&gt;error(&#39;用户注册失败&#39;);    }    }else {    $this-&gt;error($user-getError());    }    }    /*显示用户修改页面，这里不是修改方法*/    function edit(){    $id=$_GET[&#39;id&#39;];    $user=M(&#39;user&#39;);    $list=$user-&gt;where(&quot;id=$id&quot;)-&gt;find();    $this-&gt;assign(title,&#39;用户编辑页面&#39;);    $this-&gt;assign(&#39;list&#39;,$list);    $this-&gt;display();//这在后面还要建立一个edit.html的模板文件    }    /*这里是将用户的数据更新到数据库中* 更新的方法是save而不是update*/    function update(){    $user=D(&#39;user&#39;);    if ($user-&gt;create()){    $user-&gt;password=md5($user-&gt;password);    if ($user-&gt;save()){    $this-&gt;success(&#39;用户更新成功，此次更新的ID为&#39;.$user-&gt;id);    }else{    $this-&gt;error($user-&gt;getError());    }    }else {    $this-&gt;error($user-getError());    }    }}?&gt;</code></pre><p>还要建立两个模板文件index.html和edit.html文件</p><p>index.html</p><pre><code class="php">&lt;html&gt;&lt;head&gt;&lt;title&gt;{$title}&lt;/title&gt; &lt;!-- 这里是收到的标题变量 --&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;__URL__/add&quot; method=&quot;post&quot; &gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密  码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;重复密码：&lt;input type=&quot;password&quot; name=&quot;repassword&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;volist name=&#39;alist&#39; id=&#39;vo&#39;&gt;&lt;li&gt;&lt;span&gt;ID{$vo[&#39;id&#39;]}&lt;/span&gt; &lt;span&gt;用户名{$vo[&#39;username&#39;]}&lt;/span&gt; &lt;span&gt;注册IP{$vo[&#39;createip&#39;]}&lt;/span&gt; &lt;a href=&#39;__URL__/del/id/{$vo[&#39;id&#39;]}&#39;&gt;删除&lt;/a&gt; &lt;a href=&#39;__URL__/edit/id/{$vo[&#39;id&#39;]}&#39;&gt;编辑&lt;/a&gt;&lt;/li&gt;&lt;/volist&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>edit.html</p><pre><code class="php">&lt;html&gt;&lt;head&gt;&lt;title&gt; {$title}&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;__URL__/update&quot; method=&quot;post&quot;&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;{$list[&#39;username&#39;]}&quot;&gt;&lt;br&gt;密    码：&lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;{$list[&#39;password&#39;]}&quot;&gt;&lt;br&gt;注册时间：&lt;input type=&quot;text&quot; name=&quot;createtime&quot; value=&quot;{$list[&#39;createtime&#39;]}&quot;&gt;&lt;br&gt;注册IP：&lt;input type=&quot;text&quot; name=&quot;createip&quot; value=&quot;{$list[&#39;createip&#39;]}&quot;&gt;&lt;br&gt;&lt;input type=&quot;hidden&quot; value=&quot;{$list[&#39;id&#39;]}&quot; name=&#39;id&#39;&gt; &lt;!--这里是一个隐藏表单，用于传递修改的是哪个ID --&gt;&lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt;&lt;a href=&quot;__URL__&quot;&gt;返回&lt;/a&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThinkPHP中的CURD之C</title>
      <link href="/article/373.html"/>
      <url>/article/373.html</url>
      <content type="html"><![CDATA[<p>CURD 增 删 改 查</p><p>C</p><p>create方法</p><p>每当实例化一个数据对象后，当需要接收post来值的时候，要用create方法来创建一个对象，根据表单提交的POST数据创建数据对象，并保存在内存中，可以通过dump($user)查看，返回值是一个数组</p><pre><code class="php">$user=M(&#39;user&#39;);$vo=$user-&gt;create();dupm($vo); //这时会遍历出得到的（post）值</code></pre> <a id="more"></a><pre>array(2) {  ["username"] => string(4) "root"  ["password"] => string(11) "12345678"}</pre><p>写一个add方法，加上一个表单</p><p>在tpl里面建立一个表单</p><pre><code class="php">&lt;html&gt;&lt;body&gt;&lt;form action=&quot;__URL__/add&quot; method=&quot;post&quot;&gt;用户名&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密     码&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在user的控制器里面写上一个方法，这时也可以不写create方法，但是就是单独写上一个对象的赋值方法，create的时候其实就是在接收post而来的数据</p><pre><code class="php">function add(){$user=M(&#39;user&#39;);//$user-&gt;create(); 如果不用create方法，也可以用下面的方法$user-&gt;username=$_POST[&#39;username&#39;];$user-&gt;password=md5($_POST[password]);//将post来的密码进行md5加密                        /*                        如果用create方法可以用这面的方法写                        $user-&gt;create();                        $user-&gt;password=md5($user-&gt;password);                        */                        //add为thinkphp中向数据库中添加数据的方法if ($user-&gt;add()) {$this-&gt;success(&#39;添加用户成功&#39;);}else {$this-&gt;error(&#39;添加用户失败&#39;);}}</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ThinkPHP四种实例化模型的方法</title>
      <link href="/article/372.html"/>
      <url>/article/372.html</url>
      <content type="html"><![CDATA[<p>假设数据库中有一个think_user的数据表</p><h1 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h1><pre><code class="php">$user=new Model(&#39;user&#39;);$user=M(&#39;user&#39;);/*user的U可以大写，也可以小写，当库中还有一个think_user_message等表的时候，可以使用new Model(&#39;userMessage&#39;) 或者new Model(user_message)，也就是说大写的首字母相当于带下划线的单词此方法也可以用快捷方法，M方法*/</code></pre><a id="more"></a><h1 id="当需要继承多个模型的时候，可以用M-‘-‘-’-‘-方法"><a href="#当需要继承多个模型的时候，可以用M-‘-‘-’-‘-方法" class="headerlink" title="当需要继承多个模型的时候，可以用M(‘ ‘,’ ‘)方法"></a>当需要继承多个模型的时候，可以用M(‘ ‘,’ ‘)方法</h1><pre><code class="php">$user=M(&#39;user&#39;,&#39;Common&#39;);$user=new Common(&#39;user&#39;);/*此方法说明$user中既有user中的方法，也可以从自定义的模型中继承方法，比如在Common中写一个常用的方法（公共方法），这种方法比较便捷的实现了一个变量实例化多个模型，也大大的简便了代码的书写,此方法还可以写成$user=new Common(&#39;user&#39;);*/</code></pre><h1 id="D方法"><a href="#D方法" class="headerlink" title="D方法"></a>D方法</h1><pre><code class="php">$user=new UserModel();$user=D(&#39;user&#39;);/*此种方法可以方便实现用户自定义数据库操作类与方法，用户可以在UserModel.class.php中封装自己定义的方法*/</code></pre><h1 id="通过空模型来实例化"><a href="#通过空模型来实例化" class="headerlink" title="通过空模型来实例化"></a>通过空模型来实例化</h1><p>这种方式是通过自定义数据库查询语句来实现查询功能</p><pre><code class="php">$user=new Model();$list=$user-&gt;query(&#39;select * from think_user&#39;)</code></pre><p>总的来说，如果没有继承第三方的类，D与M方法实例出来的是一样的</p><p>$user=M(‘user’);</p><p>$user=D(‘user’);</p><p>而M方法则可以比较方便的继承第三方类（公共类啊等等）</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过新浪SAE搭建自己的个人博客</title>
      <link href="/article/371.html"/>
      <url>/article/371.html</url>
      <content type="html"><![CDATA[<p>新浪SAE是个好东西，对于学习PHP的同学是一个不错的练习空间，（现在已经推出了java了，不过需要邀请码）不用在四处寻找廉价的主机，而且 平台上已经集成了很多现成的应用，博客空间有wordpress，emlog等，PHP框架有thinkPHP,cakephp等，而且还是 ecshop，最土等电子商务系统，更方便的应用于用户，感兴趣的同学可以体验一下，现在我将写一篇关于搭建wordpress博客应用和自己创建一个新 浪微博的简单应用来抛砖引玉，让更多的同学朋友了解SAE。</p><p>SAE地址 <a href="http://rrurl.cn/fzgC5N" target="_blank" rel="noopener">http://sae.sina.com.cn/</a></p><p>需要准备：新浪微博账号（必须），自己注册的域名（可选），SAE提供二级域名的访问，xxx.sinaapp.com 也可以绑定自己的域名，注意这里的域名可以不用备案哦~</p><h1 id="搭建wordpress博客应用"><a href="#搭建wordpress博客应用" class="headerlink" title="搭建wordpress博客应用"></a>搭建wordpress博客应用</h1><p>具体步骤<br><a id="more"></a></p><h2 id="用新浪微博账号授权"><a href="#用新浪微博账号授权" class="headerlink" title="用新浪微博账号授权"></a>用新浪微博账号授权</h2><p>打开SAE地址 <a href="http://rrurl.cn/fzgC5N" target="_blank" rel="noopener">http://sae.sina.com.cn/</a> 点击“用新浪微博账号”登录，用新浪微博账号登录后点击导航条上的“应用仓库”，选择下面的wordpress</p><h2 id="点击安装些应"><a href="#点击安装些应" class="headerlink" title="点击安装些应"></a>点击安装些应</h2><p>点击安装些应，选择基于URL安装，并且在填写二级域名处填写一个独一无二的域名，接着点击“安装到以上位置”</p><h2 id="设置站点信息"><a href="#设置站点信息" class="headerlink" title="设置站点信息"></a>设置站点信息</h2><p>稍等一会，程序会自动安装的，安装完毕后点击提示中的”点击此处进入初始化页面”进行个人博客的初始化，站点名字，管理员及密码等，设置好了以后，点击下面的“安装wordpress”，一切OK了，个人博客搭建完毕。简单吧。</p><h2 id="绑定自己的域名"><a href="#绑定自己的域名" class="headerlink" title="绑定自己的域名"></a>绑定自己的域名</h2><p>绑定自己的域名，在自己的应用列表下选择刚才你创建的应用名字，不是后面的二级域名啊，切换到“应用设置”里面，在独立域名设置那添加一个你自己的域名，这里添加的时候是把自己的域名添加一个CNAME解析，再添加一个A解析，具体是什么，会有提示告诉你的~</p><h2 id="wordpress-的模板添加与修改"><a href="#wordpress-的模板添加与修改" class="headerlink" title="wordpress 的模板添加与修改"></a>wordpress 的模板添加与修改</h2><p>wordpress 的模板添加与修改，这里比用自己的虚拟主机有点麻烦，因为新浪SAE不允许wordpress后台更新模板，所以与下载插件，所以更改模板的时候有两种方 法，SVN或者用SAE的代码编辑器来编辑，推荐使用SVN，比SAE更改要简单方便 SVN的使用方法参见<a href="http://sae.sina.com.cn/?m=devcenter&amp;catId=212" target="_blank" rel="noopener">http://sae.sina.com.cn/?m=devcenter&amp;catId=212</a> 这里就不重复了。添加插件也用同样的方法。</p><h1 id="简单的调用新浪微博API来更新自己的微博"><a href="#简单的调用新浪微博API来更新自己的微博" class="headerlink" title="简单的调用新浪微博API来更新自己的微博"></a>简单的调用新浪微博API来更新自己的微博</h1><p>准备工作，新浪微博账号并且开通新浪微博开发者平台，注册地址 <a href="http://open.weibo.com/" target="_blank" rel="noopener">http://open.weibo.com/</a></p><p>具体步骤</p><ul><li><p>打开新浪微博开放平台 <a href="http://open.weibo.com/" target="_blank" rel="noopener">http://open.weibo.com/</a> 点击下面的“我是开发者” <a href="http://open.weibo.com/development" target="_blank" rel="noopener">http://open.weibo.com/development</a> 进入开发者页面，点击创建应用—&gt;选择第一个“站内应用”</p></li><li><p>填写应用名字，应用介绍等信息（随便写的），域名绑定选择默认的“否”，点击“创建” OK</p></li><li><p>转到刚才你创建的应用的详细页面，其实这里的信息只有两个有用，一个是APP Keys，一个是App Secret,记录好这两个值，以后的应用都要用这两个值</p></li><li><p>由于新浪SAE已经集合了最新的PHP版的SDK，可以不用下载，直接用，但有兴趣的同学可以下载来看看人家的方法是怎么实现的，对于学习者来说还是挺有用的~</p></li><li><p>在本地新建三个php文件，名字随便起，我这里起的是getRequestToken.php（用于请求request token），请求request token（用于获得的request token和token secret来初始化SaeTOAuth对象），config.php（可选，主要用于初始化常量，推荐使用）</p></li><li><p>在config.php中写入以下代码<br>``` php<br>header(‘Content-Type: text/html; charset=UTF-8’);</p></li></ul><p>define( “WB_AKEY” , ‘你自己的APP Keys’ );<br>define( “WB_SKEY” , ‘你自己的App Secret’ );<br>define( “WB_CALLBACK_URL” , ‘<a href="http://kevinweibo.sinaapp.com/getAccess.php" target="_blank" rel="noopener">http://kevinweibo.sinaapp.com/getAccess.php</a>‘ );//稍后介绍这里怎么填写</p><pre><code>* 在getRequestToken.php中写入以下代码``` php&lt;?phpsession_start();include (&#39;config.php&#39;);//我这里是将WB_AKEY和WB_SKEY写入到了一个config.php文件中include (&#39;saet.ex.class.php&#39;);$auth=new SaeTOAuth(WB_AKEY,WB_SKEY);//your app key and app secret//这一步是去sina服务器请求request token$token=$auth-&gt;getRequestToken();//这一步是用request token拼装认证的url,第三个参数是获得用户认证许可后跳转到的url。就是我们在SAE注册应用的二级域名$url=$auth-&gt;getAuthorizeURL($token,true,&quot;http://kevinweibo.sinaapp.com/getAccessToken.php&quot;);$_SESSION[&#39;token&#39;]=$token[&#39;oauth_token&#39;];//记录下来备用$_SESSION[&#39;token_secret&#39;]=$token[&#39;oauth_token_secret&#39;];//最后将$url当成一个链接输出到页面中,用户点击了这个链接就会跳转到认证页面echo &quot;&lt;a href=$url&gt;欢迎光临，请使用微博账号受权登录!&lt;/a&gt;&quot;;?&gt;</code></pre><p>5.3 在getAccessToken.php中写入以下代码</p><pre><code class="php">&lt;?phpsession_start();include (&#39;config.php&#39;);include (&#39;saet.ex.class.php&#39;);//利用第一步获得的request token和token secret来初始化SaeTOAuth对象$auth=new SaeTOAuth(WB_AKEY,WB_SKEY,$_SESSION[&#39;token&#39;],$_SESSION[&#39;token_secret&#39;]);//去换取真正有用的access token$accessToken=$auth-&gt;getAccessToken($_REQUEST[&#39;oauth_verifier&#39;],$_REQUEST[&#39;oauth_token&#39;]);//print_r($accessToken);//存储起来,后面每次请求都要带上这两个值$_SESSION[&#39;token&#39;]=$accessToken[&#39;oauth_token&#39;];$_SESSION[&#39;token_secret&#39;]=$accessToken[&#39;oauth_token_secret&#39;];//接下来你就可以跳转到你的应用页面开始微博之旅了,例如输出一句js,window.location.href=&quot;send.php&quot;//echo &quot;token:&quot;.$_SESSION[&#39;token&#39;];//echo &quot;&lt;br/&gt;token_secret:&quot;.$_SESSION[&#39;token_secret&#39;].&quot;&lt;br/&gt;&quot;;echo &quot;&lt;script&gt;window.location.href=&#39;send.php&#39;&lt;/script&gt;&quot;?&gt;</code></pre><p>5.4 注意最后一句说的是打开一个send.php页面，所以这里还要新建一个send.php文件，在里面打入以下代码</p><pre><code class="php">&lt;?phpsession_start();include (&#39;config.php&#39;);//include (&#39;saetv2.ex.class.php&#39;);include (&#39;saet.ex.class.php&#39;);$auth = new SaeTClient(WB_AKEY,WB_SKEY, $_SESSION[&#39;token&#39;], $_SESSION[&#39;token_secret&#39;]);$mes = $_POST[msg];$auth-&gt;update($mes);// 这句话是关键，其实发新浪微博的方法就这个，非常简单~?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;POST&quot;&gt;要发送的微博：&lt;input type=&quot;text&quot; name=&quot;msg&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;a href=&quot;weibolist.php&quot;&gt;进入你的微博列表页面&lt;/a&gt;&lt;br /&gt; //这个不用写，写了后有更好玩的~&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>把这四个文件打包成一个zip文件，到新浪SAE里面创建一个应用，这时在创建应用的时候就不要选择基于URL安装了，选择下面的“选择文件“，把刚才那压缩的zip文件，点击”安装到以上位置“</li></ul><ul><li><p>刚才config.php代码里面的define( “WB_CALLBACK_URL” , ‘<a href="http://kevinweibo.sinaapp.com/getAccess.php" target="_blank" rel="noopener">http://kevinweibo.sinaapp.com/getAccess.php</a>‘ ); 这里面红字应该知道填写什么了吧？你应用的地址加上getaccess.php</p></li><li><p>好了，大功告成，可以爽一爽了，进入你刚才创建的应用</p></li></ul><p><a href="http://kevinweibo.sinaapp.com/getRequestToken.php" target="_blank" rel="noopener">http://kevinweibo.sinaapp.com/getRequestToken.php</a></p><p>点击上面的受权链接，并将自己的微博账号受权，接着会进入到send.php页面，随便写句话，点击”提交“，看看微博发出去没，哈哈~</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>要玩点更好玩的，可以下载微博SDK，查看里面的API方法，或者在线的查看 <a href="http://open.weibo.com/wiki/API%E6%96%87%E6%A1%A3_V2" target="_blank" rel="noopener">http://open.weibo.com/wiki/API%E6%96%87%E6%A1%A3_V2</a></p><p>我这里创建了个weibolist.php文件，来简单的调用了几个</p><pre><code class="php">&lt;?phpsession_start();include (&#39;config.php&#39;);//include (&#39;saetv2.ex.class.php&#39;);include (&#39;saet.ex.class.php&#39;);$auth = new SaeTClient(WB_AKEY,WB_SKEY, $_SESSION[&#39;token&#39;], $_SESSION[&#39;token_secret&#39;]);$publicmsg=$auth-&gt;followers();//调用followers方法来显示当前用户的粉丝列表 //用foreach方法来遍历数组foreach ($publicmsg as $key=&gt;$value){echo &quot;$key =&gt; $value&quot;.&quot;&lt;br&gt;&quot;;foreach($value as $key1=&gt;$value1){echo &quot;$key1 =&gt; $value1&quot;.&quot;&lt;br&gt;&quot;;}echo &quot;&lt;br&gt;&quot;;}//这里是旧版的SDK的例子$mes = $_POST[msg];$auth-&gt;update($mes);?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;POST&quot;&gt;要发送的微博：&lt;input type=&quot;text&quot; name=&quot;msg&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;br&gt;&lt;h2&gt;第二种种发送新微博&lt;/h2&gt;&lt;form action=&quot;weibolist.php&quot; method=&quot;POST&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;msg&quot; style=&quot;width:300px&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;h2&gt;发送图片微博&lt;/h2&gt;&lt;form action=&quot;weibolist.php&quot; &gt;&lt;input type=&quot;text&quot; name=&quot;msg&quot; style=&quot;width:300px&quot; value=&quot;文字内容&quot; /&gt;&lt;input type=&quot;text&quot; name=&quot;pic&quot; style=&quot;width:300px&quot; value=&quot;图片url&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;?phpif( isset($_REQUEST[&#39;pic&#39;]) ){$rr = $auth -&gt;upload( $_REQUEST[&#39;msg&#39;] , $_REQUEST[&#39;pic&#39;] );echo &quot;&lt;p&gt;发送完成&lt;/p&gt;&quot; ;}?&gt;</code></pre><p>先到这吧，更有意思的东西等待更新的发现~</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>在SUSE中用Pidgin整合QQ与新浪微博</title>
      <link href="/article/227.html"/>
      <url>/article/227.html</url>
      <content type="html"><![CDATA[<p>TX官方出的qq for linux实在是太恶心了，好友不全也就罢了，关键是还总崩溃，忍不了了，一开始我还总是用WEB qq还将就下，可以感觉这个实在是不方便，在网上找了些方法 ， lumqq很久之前就不更新也，不不支持现在的qq登录了，于是找到了传说中的Pidgin，下载了一个最新的2.10.0 软件源，默认的光盘里就有这个软件</p><p>下载安装，其实这个软件可以兼容MSN Gtalk facebook,我还额外的下载了一个新浪微博的插件 pidgin-microblog-sina</p><!--StartFragment--><a href="http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/" target="_blank" rel="noopener">http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/</a>   软件源<br><br>但这个插件表现一般，比官方的air客户端差好多，当时只是好奇<br><br>第一次启动的时候会弹出添加账号窗口，这里选择新浪微博<br><br><a href="/image/2012/01/pidgin1.jpeg"><img src="/image/2012/01/pidgin1.jpeg" alt="" title="pidgin add sina account "></a><br><br>填写好后点击添加会弹出与新浪微博的授权页面，授权后会得到一串数字，填写到弹出的对话框中即可<br><br>添加QQ有点困难<br><br>首先下载libqq,<a id="more"></a><p><a href="http://code.google.com/p/libqq-pidgin/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/libqq-pidgin/downloads/list</a></p><p>下载后用7za 解压，当时我的系统中还没有安装7za，于是用</p><pre>zypper install p7zip</pre><p>命令安装</p><p>接着解压</p><pre>7za x libqq.so_0.71_i386.7z</pre><p>e是解压到当前路径</p><p>x是解压到压缩包命名的目录下</p><p>把解压出来的libqq.so复制到/usr/lib/purple-2 文件夹下</p><p>重启Pidgin，这时在添加账号里就有了QQ选项了</p><p>添加后界面虽说有点简单，但基本的功能都已经包括了，别奢望太多，毕竟不是100多M的QQ……</p><p><a href="/image/2012/01/pidgin2.jpeg"><img src="/image/2012/01/pidgin2.jpeg" alt="" title="the qq UI in pidgin "></a></p>]]></content>
      
      <categories>
          
          <category> Linux相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>美化opensuse中的字体</title>
      <link href="/article/221.html"/>
      <url>/article/221.html</url>
      <content type="html"><![CDATA[<p>原文地址</p><p><a href="http://forums.opensuse.org/ae-ae-chinese/aes-aeoe-e-e-ae-zae-aeoe/c-ae-zae-aeoe/470464-opensuse-c-aeoe-oec-zcs-ae-ae-az-e-c-i-oec-ae-mactype.html" target="_blank" rel="noopener">http://forums.opensuse.org/ae-ae-chinese/aes-aeoe-e-e-ae-zae-aeoe/c-ae-zae-aeoe/470464-opensuse-c-aeoe-oec-zcs-ae-ae-az-e-c-i-oec-ae-mactype.html</a></p><p>openSUSE 目前最完美的中文字型设置，类似 Mactype<br><a id="more"></a><br>1.添加linuxsir中文官方源</p><p><a href="http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/" target="_blank" rel="noopener">http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/</a></p><p>安装里面的freetype2</p><p>安装，然后 Konsole 输入 infctl settyle 「styles」，默认的 style 有 infinality / linux / osx / osx2 / win7 / win98 / winxp 建议大家用 osx。</p><p>这个命令我不知道我使用的对不对，我是这么输入的，infctl settyle osx 结果就是字体变了，还挺好看的</p>]]></content>
      
      <categories>
          
          <category> Linux相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于Audacious中字体乱码的解决办法</title>
      <link href="/article/216.html"/>
      <url>/article/216.html</url>
      <content type="html"><![CDATA[<p>安装完Audatious可以正常播放后，可以播放列表里确是惨不忍睹……</p><p><a href="/image/2012/01/audacious1.jpeg"><img src="/image/2012/01/audacious1.jpeg" alt="" title="audacious1"></a></p><p>原因不说了，因为在windows下使用的不同标准的字体<br> <a id="more"></a><br>更改设置 文件-首选项- playlist</p><p><a href="/image/2012/01/audacious2.jpeg"><img src="/image/2012/01/audacious2.jpeg" alt="" title="audacious2"></a></p><p>在Custom string 上输入 %f</p><p>在上面的Fallback character encodings里输入 GBK</p><p>关闭 - 点击 播放列表- 刷新</p><p>OK 一切正常了～</p>]]></content>
      
      <categories>
          
          <category> Linux相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>opensuse12.1从安装到使用的一些札记</title>
      <link href="/article/210.html"/>
      <url>/article/210.html</url>
      <content type="html"><![CDATA[<p>opensuse也玩了很久了，但我还是觉得自己是一个初学者，写这篇文章主要是想记录一下自己使用中的问题，以后如果再次安装好做一个记录</p><p>本文主要参考网张上的文章</p><p><a href="http://cn.opensuse.org/" target="_blank" rel="noopener">http://cn.opensuse.org</a> 中文wiki</p><p><a href="http://hi.baidu.com/winland0704/home" target="_blank" rel="noopener">http://hi.baidu.com/winland0704/home</a>  winland的百度空间</p><p><a href="http://lug.ustc.edu.cn/sites/opensuse-guide/" target="_blank" rel="noopener">http://lug.ustc.edu.cn/sites/opensuse-guide/</a>   Unofficial guide<br><a id="more"></a><br>一、安装</p><p>如果有条件还是选择光盘安装，如果没有条件或者想搞些新鲜的玩意，选择硬盘安装，我使用的是用Burg4DOS硬盘安装openSUSE</p><p>安装教程请到<a href="http://www.vdisk.cn/down/index/9152371A9887" target="_blank" rel="noopener">http://www.vdisk.cn/down/index/9152371A9887</a> 这里下载，这个教程很简单，也很好用，根着教程操作，但是到了分区这一步要小心，这里面如果出现什么磁盘空间不足之类的提示，在这个界面把 create LVM based proposal选项选中</p><p><a href="/image/2012/01/disk.png"><img src="/image/2012/01/disk.png" alt="" title="分区"></a></p><p>硬盘安装之后有一个遗留问题，就是镜像所在的磁盘不能开机自动挂载上，要挂载的话还要输入一次ROOT密码，这个我找了半天也没有找到方法，但是这样却有一个好处，就是以后在安装这个镜像里的软件时，可以直接安装，我感觉这个可能就是问题所在</p><p>2、安装这后我认为最先要解决的是各种多媒体的codec</p><p>可以用一键安装</p><p><center><a href="http://opensuse-community.org/codecs-kde.ymp" target="_blank" rel="noopener"><img src="http://lug.ustc.edu.cn/sites/opensuse-guide/images/oneclick/codecs.png" alt="ymp"> <span style="font-size: x-large;"> KDE </span></a></center><center><a href="http://opensuse-community.org/codecs-gnome.ymp" target="_blank" rel="noopener"><img src="http://lug.ustc.edu.cn/sites/opensuse-guide/images/oneclick/codecsg.png" alt="ymp"> <span style="font-size: x-large;">GNOME</span></a></center><center></center>我安装的KDE桌面，还是推荐使用KDE桌面</p><p>主要的codec有</p><p>libxine1-codecs（多媒体播放引擎，支持MPEG-4等）</p><p>k3b-codecs（K3b的MP3支持）</p><p>ffmpeg（有名的音视频编解码器，支持众多格式）</p><p>lame（MP3格式支持）</p><p>gstreamer-0_10-plugins-bad gstreamer-0_10-plugins-ugly gstreamer-0_10-ffmpeg（这三个是GStreamer多媒体播放支持） libdvdcss2（如果您不播放DVD可以跳过这条</p><p><span style="color: #ff0000;">注意</span>：在刚刚安装完系统的时候，会有一个系统进程一直在用的软件，这时候你既不能安装软件，也不能做软件源的操作，等会吧， 做了一次更新检查后就好了。 在安装软件的时候，有时候会默认添加很多软件源，而且这些软件源默认也是做自动刷新的，所以注意如果不用的话要取消添加这些源， 即使添加了也要把自动刷新取消，可以定期做一次更新，要不然每次做软件的操作会有很长的等待时间，很烦人。 3.添加一些常用的软件源 parkman: 这个几乎是每一个linux用户必须添加的，很多多媒体的软件等都需要它，unofficial guide上推荐的台湾源我是怎么也添加不上去 所以我就不用那个源了，我用的是 <a href="http://packman.inode.at/suse/12.1/" target="_blank" rel="noopener">http://packman.inode.at/suse/12.1/</a> 这个源 或者你可以找到很多别的好用的packman源， 软件源里一定要有的，OSS开源 non-oss非开源 update更新,我添加了国内的163镜像源， 使用帮助<a href="http://mirrors.163.com/.help/opensuse.html" target="_blank" rel="noopener">http://mirrors.163.com/.help/opensuse.html</a> 还有一些源都是些牛人建立的，也不错，里面有一些国人常用的软件</p><ul><li><a href="http://download.opensuse.org/repositories/home:/hillwood/openSUSE_12.1/" target="_blank" rel="noopener">http://download.opensuse.org/repositories/home:/hillwood/openSUSE_12.1/</a></li><li><a href="http://download.opensuse.org/repositories/home:/swyear/openSUSE_12.1/" target="_blank" rel="noopener">http://download.opensuse.org/repositories/home:/swyear/openSUSE_12.1/</a></li><li><a href="http://download.opensuse.org/repositories/home:/stecue/openSUSE_12.1/" target="_blank" rel="noopener">http://download.opensuse.org/repositories/home:/stecue/openSUSE_12.1/</a></li><li><a href="http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/" target="_blank" rel="noopener">http://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_12.1/</a><br>自己选择一些就可以了，以后你会增加很多的。</li></ul><p>添加完软件源后要做的当然是安装软件了，其实常用的软件在安装opensuse的时候已经自动安装上了，但这里就安装的是自己喜欢 别的软件 如 Audaciou Smplayer 等</p><p>打开 yast 点击安装软件 搜索 MPlayer、SMPlayer、Audacious，AMSN安装，会自动提示安装必要的库</p><p>其他的常用的软件</p><p>Chrome 这个是我必须安装的 <a href="https://www.google.com/chrome?platform=linux" target="_blank" rel="noopener">https://www.google.com/chrome?platform=linux</a></p><p>Skype: <a href="http://skype.tom.com/download/linux/skype-2.2.0.25-suse.i586.rpm" target="_blank" rel="noopener">http://skype.tom.com/download/linux/skype-2.2.0.25-suse.i586.rpm</a></p><p>Fcitx: 这个是我后来才发现的非常好用的输入法，因为我使用的是五笔输入法，在linux上以前一直在ibus下使用万能五笔，但是不 知道12.1的怎么回事，还是按照原来的方法添加了万能五笔后，既没有添加成功，默认安装的输入法也丢失了，无奈之下，上网上搜索了下都说Fcitx这个输入法中的五笔相当好用，于是将系统中原来的ibus和ibus-table remove掉了，安装了Fcitx，这个输入法太惊艳了，我一下子就喜欢上了，爱不释手啊～～</p>]]></content>
      
      <categories>
          
          <category> Linux相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于PHP面向对象的一点网摘(继承性与访问类型)</title>
      <link href="/article/205.html"/>
      <url>/article/205.html</url>
      <content type="html"><![CDATA[<p><strong>类的继承</strong><br>继承作为面向对象的三个重要特性的一个方面，在面向对象的领域有着极其重要的作用，好像没听说哪个面向对象的语言不支持继承。继承是PHP5 面向对象程序设计的重要特性之 一，它是指建立一个新的派生类，从一个或多个先前定义的类中继承数据和函数，而且可以 重新定义或加进新数据和函数，从而建立了类的层次或等级。说的简单点就是，继承性是子类自动共享父类的数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的 时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为 自己的内容，并加入若干新的内容。比如你现在已经有一个“人”这个类了，这个类里面有 两个成员属性“姓名和年龄”以及还有两个成员方法“说话的方法和走路的方法”，如果现在 程序需要一个学生的类，因为学生的也是人，所以学生也有成员属性“姓名和年龄”以及成 员方法“说话的方法和走路的方法”，这个时候你就可以让学生类来继承人这个类，继承之后， 学生类就会把人类里面的所有的属性都继承过来，就不用你再去重新声明一遍这些成员属性 和方法了，因为学生类里面还有所在学校的属性和学习的方法，所以在你做的学生类里面有 继承自人类里面的属性和方法之外在加上学生特有的“所在学校属性”和“学习的方法”, 这样一个学生类就声明完成了，继承我们也可以叫做“扩展”，从上面我们就可以看出，学生 类对人类进行了扩展，在人类里原有两个属性和两个方法的基础上加上一个属性和一个方法 扩展出来一个新的学生类。 通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型 不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基 类，又称为父类以及超类。由已存在的类派生出的新类称为派生类，又称为子类。 在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分 类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重性。采用继承性， 提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重<br>用性。<br>在C++语言中，一个派生类可以从一个基类派生，也可以从多个基类派生。从一个基类派生的继承称为单继承；从多个基类派生的继承称为多继承。<span style="color: #ff0000;">但是在PHP 和Java 语言里面没有多继承，只有单继承，也就是说，一个类只能直接从 一个类中继承数据，这就是我们所说的单继承。 也就是说一个子类只能有一个父类，但一个父类可以有多个子类</span><br>例如：<br>下面是“人”类的抽象 <a id="more"></a><br>代码片段</p><pre><code class="php">class Person{ //定义一个“人”类作为父类//下面是人的成员属性var $name;var $sex;var $age;//定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值function __construct($name, $sex, $age){$this-&gt;name=$name;$this-&gt;sex=$sex;$this-&gt;age=$age;}//这个人可以说话的方法, 说出自己的属性function say() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;&lt;br&gt;&quot;;}}</code></pre><p>下面我们做一个“学生类”，如果不是用继承如下：代码片段</p><p><div></div></p><pre><code class="php">class Student{ //定义一个“人”类做为父类//下面是人的成员属性var $name;var $sex;var $age;var $school; //新添加的学生所在学校的属性//定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值function __construct($name=””, $sex=””, $age=””, $school=””){$this-&gt;name=$name;$this-&gt;sex=$sex;$this-&gt;age=$age;$this-&gt;school=$school;}//这个人可以说话的方法, 说出自己的属性function say() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;&lt;br&gt;&quot;;}//这个学生学习的方法function study() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 我正在”.$this-&gt;school.”学习&lt;br&gt;&quot;;}}//定义一个子类“学生类“使用”extends”关键字来继承”人”类class Student extends Person{var $school; //学生所在学校的属性 只是新添加上去//这个学生学习的方法function study() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 我正在”.$this-&gt;school.”学习&lt;br&gt;&quot;;}}</code></pre><p>通过上面“Student”类的定义，Student 类通过使用“extends”这个关键字把Person 类里的所有成员属性和成员方法都继承过来了，并扩展了一个所在学校成员属性“school”，和一个学习方法“study()”。现在子类“Student”里面和使用这个类实例出来的对象都具有如下的属性和方法：<br>学生类“Student”里面的成员属性有：<br>姓名：name;<br>年龄：age;<br>性别：sex;<br>学校：school;<br>学生类“Student”里面的成员方法有：<br>说话方法：say();<br>学习方法：study();<br>通过上面类继承的使用简化了对象、类的创建工作量，增加了代码的可重性。但是从上面这一个例子上中“可重用性”以及其它的继承性所带来的影响，我们看的还不是特别的明显，你扩展的去想一下，人有无数个岗位，比如上面的学生还有老师、工程师、医生、工人 等，很多很多，如果每个类都定义“人”都共同具有的属性和方法，想一想会有很大的工作 量，这些属性和方法都可以从“Person”人类里面继承过来。</p><p><strong>重载新的方法</strong> (只是在子类里重新定义父类中的函数)<br>在学习PHP 这种语言中你会发现，PHP 中的方法是不能重载的，所谓的方法重载就是定义相同的方法名，通过“参数的个数”不同或“参数的类型”不同,来访问我们的相同方法 名的不同方法。但是因为PHP 是弱类型的语言，所以在方法的参数中本身就可以接收不同类 型的数据，又因为PHP 的方法可以接收不定个数的参数，所以通过传递不同个数的参数调用不相同方法名的不同方法也是不成立的。所以在PHP 里面没有方法重载。不能重载也就是在 你的项目中不能定义相同方法名的方法。另外，因为PHP 没有名子空间的概念，在同一个页 面和被包含的页面中不能定义相同名称的方法，也不能定义和PHP 给我提供的方法重名，当然在同一个类中也不能定义相同名称的方法。我们这里所指的重载新的方法所指的是什么呢？其实我们所说的重载新的方法就是子类覆盖父类的已有的方法，那为什么要这么做呢？父类的方法不是可以继承过来直接用吗？但 有一些情况是我们必须要覆盖的，比如说我们前面提到过的例子里面，“Person”这个人类里 面有一个“说话”的方法，所有继承“Person”类的子类都是可以“说话”的，我们“Student” 类就是“Person”类的子类，所以“Student”的实例就可以“说话”了，但是人类里面“说 话”的方法里面说出的是“Person”类里面的属性，而“Student”类对“Person”类进行了扩 展，又扩展出了几个新的属性，如果使用继承过来的“say()”说话方法的话，只能说出从 “Person”类继承过来的那些属性，那么新扩展的那些属性使用这个继承过来的“say()”的 方法就说不出来了，那有的人就问了，我在“Student”这个子类中再定义一个新的方法用于 说话，说出子类里面所有的属性不就行了吗？一定不要这么做，从抽象的角度来讲，一个“学 生”不能有两种“说话”的方法，就算你定义了两个不同的说话的方法，可以实现你想要的 功能，被继承过来的那个“说话“方法可能没有机会用到了，而且是继承过来的你也删不掉。 这个时候我们就要用到覆盖了。虽然说在PHP 里面不能定义同名的方法，但是在父子关系的两个类中，我们可以在子类 中定义和父类同名的方法，这样就把父类中继承过来的方法覆盖掉了。 代码片段</p><pre><code class="php">&lt;?class Person{ //定义一个“人”类做为父类//下面是人的成员属性var $name;var $sex;var $age;//定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值function __construct($name, $sex, $age){$this-&gt;name=$name;$this-&gt;sex=$sex;$this-&gt;age=$age;}function say() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;&lt;br&gt;&quot;;}}class Student extends Person{var $school;function study() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 我正在”.$this-&gt;school.”学习&lt;br&gt;&quot;;}//这个学性可以说话的方法, 说出自己所有的属性，覆盖了父类的同名方法function say() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;我在&quot;.$this-&gt;school.&quot;上学.&lt;br&gt;&quot;;}}?&gt;</code></pre><p>上面的例子，我们就在“Student”子类里覆盖了继承父类里面的“say()”的方法，通过覆盖我们就实现了对“方法”扩展。 但是，像这样做虽然解决了我们上面说的问题，但是在实际开发中，一个方法不可能就一条代码或是几条代码，比如说“Person”类里面“say()”方法有里面有100 条代码，如果我们想对这个方法覆盖保留原有的功能外加上一点点功能，就要把原有的100 条代码重写 一次，再加上扩展的几条代码，这还算是好的，而有的情况，父类中的方法是看不见原代码 的，这个时候你怎么去重写原有的代码呢？我们也有解决的办法，就是在子类这个方法中可 以调用到父类中被覆盖的方法，也就是把被覆盖的方法原有的功能拿过来再加上自己的一点 功能，可以通过两种方法实现在子类的方法中调用父类被覆盖的方法：一种是使用父类的“类名：：“来调用父类中被覆盖的方法；一种是使用“parent：：”的方试来调用父类中被覆盖的方法；</p><p><div></div></p><pre><code class="php">class Student extends Person{var $school;function study() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 我正在”.$this-&gt;school.”学习&lt;br&gt;&quot;;}//这个学性可以说话的方法, 说出自己所有的属性，覆盖了父类的同名方法function say() {//使用父类的“类名::“来调用父类中被覆盖的方法；// Person::say();//或者使用“parent：：”的方试来调用父类中被覆盖的方法；这种方法没法加上了类的函数parent::say();//加上一点自己的功能echo “我的年龄是：&quot;.$this-&gt;age.&quot;我在&quot;.$this-&gt;school.&quot;上学.&lt;br&gt;&quot;;}}</code></pre><p>现在用两种方式都可以访问到父类中被覆盖的方法，我们选那种方式最好呢？用户可能会发现自己写的代码访问了父类的变量和函数。如果子类非常精炼或者父类非常专业化的时候尤其是这样。不要用代码中父类文字上的名字，应该用特殊的名字parent，它指的就是子类在extends 声明中所指的父类的名字。这样做可以避免在多个地方使用父类的名字。如果继承树在实现的过程中要修改，只要简单地修改类中extends 声明的部分。同样，构造方法在子类中如果没有声明的话，也可以使用父类中的构造方法，如果子类中重新定义了一个构造方法也会覆盖掉父类中的构造方法，如果想使用新的构造方法为所有属性赋值也可以用同样的方式。<br>代码片段</p><p><div></div></p><pre><code class="php">class Student extends Person{var $school; //学生所在学校的属性function __construct($name, $sex, $age, $school){//使用父类中的方法为原有的属性赋值parent::__construct($name, $sex, $age);$this-&gt;school=$school;}//这个学生学习的方法function study() {echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 我正在”.$this-&gt;school.”学习&lt;br&gt;&quot;;}//这个人可以说话的方法, 说出自己的属性function say() {parent::say();//加上一点自己的功能echo “我的年龄是：&quot;.$this-&gt;age.&quot;我在&quot;.$this-&gt;school.&quot;上学.&lt;br&gt;&quot;;</code></pre><p></p><p><div><strong>访问类型</strong><br>类型的访问修饰符允许开发人员对类成员的访问进行限制，这是PHP5 的新特性，但却是OOP 语言的一个好的特性。而且大多数OOP 语言都已支持此特性。PHP5 支持如下3 种访问修饰符public (公有的、默认的)，private (私有的)和protected (受保护的)三种。 public 公有修饰符，类中的成员将没有访问限制，所有的外部成员都可以访问（读和写）这个类成员（包括成员属性和成员方法），在PHP5 之前的所有版本中，PHP 中类的成员都是public 的，而且在PHP5 中如果类的成员没有指定成员访问修饰符，将被视为public。 例：public $name;</div></p><p><div>public function say(){};<br>private 私有修改符，被定义为private 的成员，对于同一个类里的所有成员是可见的，即是没有访问限制；但对于该类的外部代码是不允许改变甚至读操作，对于该类的子类，也不能访问private 修饰的成员。例：private $var1 = ‘A’; //属性<br>private function getValue(){} //函数<br>protected 保护成员修饰符，被修饰为protected 的成员不能被该类的外部代码访问。但是对于该类的子类有访问权限，可以进行属性、方法的读及写操作,该子类的外部代码包括其的子类都不具有访问其属性和方法的权限。<br>例：protected $name;<br>protected function say(){};<br>                    private        protected            public<br>同一个类中             √             √                   √<br>类的子类中             √             √<br>所有的外部成员         √<br>代码片段</div></p><pre><code class="php">&lt;?php/*** Define MyClass*/class MyClass{// Contructors must be publicpublic function __construct() { }// Declare a public methodpublic function MyPublic() { }// Declare a protected methodprotected function MyProtected() { }// Declare a private methodprivate function MyPrivate() { }// This is publicfunction Foo() {$this-&gt;MyPublic();$this-&gt;MyProtected();$this-&gt;MyPrivate();}}$myclass = new MyClass;$myclass-&gt;MyPublic(); //Works$myclass-&gt;MyProtected(); // Fatal Error$myclass-&gt;MyPrivate(); // Fatal Error$myclass-&gt;Foo(); // Public, Protected and Private work/*** Define MyClass2*/class MyClass2 extends MyClass{// This is publicfunction Foo2(){$this-&gt;MyPublic();$this-&gt;MyProtected();$this-&gt;MyPrivate(); // Fatal Error}}$myclass2 = new MyClass2;$myclass2-&gt;MyPublic(); // Works$myclass2-&gt;Foo2(); // Public and Protected work, not Private?&gt;</code></pre><p>另外在子类覆盖父类的方法时也要注意一点，子类中方法的访问权限一定不能低于父类被覆盖方法的访问权限，也就是一定要高于或等于父类方法的访问权限。 例如，如果父类方法的访问权限是protected 那么子类中要覆盖的权限就要是protected<br>和public，如果父类的方法是public 那么子类中要覆盖的方法只能也是public，总之子类中的方法总是要高于或等于父类被覆盖方法的访问权限.</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于PHP面向对象的一点网摘(基本概念与封装性)</title>
      <link href="/article/199.html"/>
      <url>/article/199.html</url>
      <content type="html"><![CDATA[<p>本文大部门摘自网络，作为我学习的一点总结也还不错</p><p><strong>PHP面向对象技术</strong></p><p>本部分一共包括以下一些技术点：<br>1.面向对象的概念<br>2.什么是类，什么是对象，类和对象这间的关系<br>3.什么是面向对象编程呢？<br>4.如何抽象出一个类？<br>5.如何实例化对象？<br>6.如何去使用对象中的成员？<br>7.特殊的引用“$this”的使用<br>8.构造方法与析构方法<br>9.封装性 <a id="more"></a><br>10.<strong>set()、 </strong>get()、 <strong>isset()、 </strong>unset()四个方法的应用<br>11.类的继承<br>12.多态的应用<br>13.重载新的方法<br>14.访问类型<br>15.静态成员的使用<br>16.final关键字的应用<br>17.<strong>toString()方法<br>18.克隆对象<br>19.</strong>call处理调用错误<br>20.自动加载类<br>21.把对象串行化<br>22.抽象方法和抽象类<br>23.php5接口技术</p><p>1.面向对象的概念<br>面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种计算机编程架构，OOP的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成，OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。面向对象一直是软件开发领域内比较热门的话题，首先，面向对象符合人类看待事物的一般规律。其次，采用面向对象方法可以使系统各部分各司其职、各尽所能。为编程人员敞开了一扇大门，使其编程的代码更简洁、更易于维护，并且具有更强的可重用性。有人说PHP不是一个真正的面向对象的语言，这是事实。PHP 是一个混合型语言，你可以使用OOP，也可以使用传统的过程化编程。然而，对于大型项目，你可能需要在PHP 中使用纯的OOP去声明类，而且在你的项目里只用对象和类。这个概念我先不多说了，因为有很多朋友远离面向对象编程的主要原因就是一接触面向对象概念的时候就理解不上去，所以就不想去学下去了。等读者看完整体内容后再去把概念搞明白吧。</p><p>2.什么是类，什么是对象，类和对象这间的关系<br><strong>类</strong>的概念：类是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和服务两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性说明和服务说明两个主要部分。</p><p><strong>对象</strong>的概念：对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。从更抽象的角度来说，对象是问题域或实现域中某些事物的一个抽象，它反映该事物在系统中需要保存的信息和发挥的作用；它是一组属性和有权对这些属性进行操作的一组服务的封装体。客观世界是由对象和对象之间的联系组成的。<br>类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。类描述了一组有相同特性（属性）和相同行为（方法）的对象。</p><p>3.什么是面向对象编程呢？<br>就不说他的概念，如果你想建立一个电脑教室，首先要有一个房间，房间里面要有N台电脑，有N张桌子， N把椅子，白板，投影机等等，这些是什么，刚才咱们说了，这就是对象，能看到的一个个的实体，可以说这个电脑教室的单位就是这一个个的实体对象，它们共同组成了这个电脑教室，那么我们是做程序，这和面向对象有什么关系呢？开发一个系统程序和建一个电脑教室类似，你把每个独立的功能模块抽象成类，形成对象，由多个对象组成这个系统，这些对象之间都能够接收信息、处理数据和向其它对象发送信息等等相互作用。就构成了面向对象的程序。</p><p>4.如何抽象出一个类？<br>上面已经介绍过了，面向对象程序的单位就是对象，但对象又是通过类的实例化出来的，所以我们首先要做的就是如何来声明类，做出来一个类很容易，只要掌握基本的程序语法定义规则就可以做的出来，那么难点在那里呢？一个项目要用到多少个类，用多少个对象，在那要定义类，定义一个什么样的类，这个类实例化出多少个对象，类里面有多少个属性，有多少个方法等等,这就需要读者通过在实际的开发中就实际问题分析设计和总结了。<br>类的定义：<br><span style="color: #00ffff;">class</span> 类名{<br>}</p><p>使用一个关键字class和后面加上一个你想要的类名以及加上一对大括号， 这样一个类的结构就定义出来了，只要在里面写代码就可以了，但是里面写什么？ 能写什么？怎样写才是一个完整的类呢？上面讲过来，使用类是为了让它实例出对象来给我们用，这就要知道你想要的是什么样的对象了，像上面我们讲的一个装机配置单上写什么，你装出来的机子就有什么。比如说，一个人就<br>是一个对象，你怎么把一个你看好的人推荐给你们领导呢？当然是越详细越好了：<br>首先，你会介绍这个人姓名、性别、年龄、身高、体重、电话、家庭住址等等。<br>然后，你要介绍这个人能做什么，可以开车，会说英语，可以使用电脑等等。<br>只要你介绍多一点，别人对这个人就多一点了解，这就是我们对一个人的描述， 现在我们总结<br>一下，所有的对象我们用类去描述都是类似的，从上面人的描述可以看到， 做出一个类来，从定义的角度分两部分，第一是从静态上描述，第二是从动态上描述，静态上的描述就是我们所说的</p><p>属性，像上面我们看到的，人的姓名、性别、年龄、身高、体重、电话、家庭住址等等。动态上也就是人的这个对象的功能，比如这个人可以开车，会说英语，可以使用电脑等等，抽象成程序时，我们把动态的写成函数或者说是方法，函数和方法是一样的。所以，所有类都是从属性和方法这两方面去写，属性又叫做这个类的成员属性，方法叫做这个类的成员方法。<br>class 人{<br>成员属性：姓名、性别、年龄、身高、体重、电话、家庭住址<br>成员方法：可以开车， 会说英语， 可以使用电脑<br>}<br>属性：<br>通过在类定义中使用关键字” <span style="color: #ff0000;">var</span> “（<span style="color: #ff0000;">如果没有别的关键词修饰，则用var来修饰</span>）来声明变量，即创建了类的属性,虽然在声明成员属性的时候可以给定初始值， 但是在声明类的时候给成员属性初使值是没有必要的，比如说要是把人的姓名赋上“张三”,那么用这个类实例出几十个人，这几十个人都叫张三了，所以没有必要， 我们在实例出对象后给成员属性初始值就可以了。<br>如：　var $somevar;<br>方法(成员函数)：<br>通过在类定义中声明函数，即创建了类的方法。<br>如：　function somefun(参数列表)<br>{      … …     }</p><pre class="brush:php"><?phpclass Person{//下面是人的成员属性var $name;     //人的名子var $sex;      //人的性别var $age;      //人的年龄//下面是人的成员方法function say() //这个人可以说话的方法{echo "这个人在说话";}function run() //这个人可以走路的方法{echo "这个人在走路";}}?></pre><p>上面就是一个类的声明，从属性和方法上声明出来的一个类，但是成员属性最好在声明的时候不要给初始的值，因为我们做的人这个类是一个描述信息，将来用它实例化对象，比如实例化出来10个人对象，那么这10个人， 每一个人的名子，性别， 年龄都是不一样的，所以最好不要在这个地方给成员属性赋初值，而是对每个对象分别赋值的。用同样的办法可以做出你想要的类了， 只要你能用属性和方法能描述出来的实体都可以定义成类，去实例化对象。为了加强你对类的理解，我们再做一个类，做一个形状的类，形状的范围广了点， 我们就做个矩形吧，先分析一下，想一想从两方面分析，矩形的属性都有什么？矩形的功能都有什么？<br>class 矩形<br>{<br>//矩形的属性<br>矩形的长；<br>矩形的宽；</p><p>//矩形的方法<br>矩形的周长；<br>矩形的面积；<br>}</p><pre class="brush:php"><?phpclass Rect{var $kuan;var $gao;function zhouChang(){计算矩形的周长；}function mianJi(){计算矩形的面积；}}?></pre><p>如果用这个类来创建出多个矩形对象，每个矩形对象都有自己的长和宽， 都可以求出自己的周长和面积了。</p><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a><strong>面向对象的三大特性</strong></h3><p><strong><span style="font-size: medium;"><a name="_Toc173034049"></a>一、封装性</span></strong></p><div>    封装性是面向对象编程中的三大特性之一，封装性就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义:1.把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位（即对象）。2.信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界〔或者说形成一道屏障〕，只保留有限的对外接口使之与外部发生联系。</div><br><div>    封装的原则在软件上的反映是：要求使对象以外的部分不能随意存取对象的内部数据（属性），从而有效的避免了外部错误对它的”交叉感染”，使软件错误能够局部化，大大减少查错和排错的难度。</div><br><div>       用个实例来说明吧，假如某个人的对象中有年龄和工资等属性，像这样个人隐私的属性是不想让其它人随意就能获得到的，如果你不使用封装，那么别人想知道就能得到，但是如果你封装上之后别人就没有办法获得封装的属性，除非你自己把它说出去，否则别人没有办法得到。再比如说，个人电脑都有一个密码，不想让其它人随意的登陆，在你的电脑里面拷贝和粘贴。还有就是像人这个对象，身高和年龄的属性，只能是自己来增涨，不可以让别人随意的赋值等等。</div><br><div>使用<span style="color: #ff0000;">private</span>这个关键字来对属性和方法进行封装：</div><br><div>原来的成员:</div><br><div>var $name;                  //声明人的姓名</div><br><div>var $sex;                      //声明人的性别</div><br><div>var $age;                      //声明人的年龄</div><br><div>function run(){…….}</div><br><div>改成封装的形式：</div><br><div>private $name;                            //把人的姓名使用private关键字进行封装</div><br><div>private $sex;                                //把人的性别使用private关键字进行封装</div><br><div>private $age;                                //把人的年龄使用private关键字进行封装</div><br><div>private function run(){……}             //把人的走路方法使用private关键字进行封装</div><br><div>注意：只要是成员属性前面有其它的关键字就要去掉原有的关键字“var”。</div><br><div>通过private就可以把人的成员（成员属性和成员方法）封装上了。封装上的成员就不能被类外面直接访问了，只有对象内部自己可以访问；下面的代码会产生错误：</div><br><div><br><div align="left"><br><pre class="brush:php">class Person<br> {<br> //下面是人的成员属性<br> private $name; //人的名子，被private封装上了<br> private $sex; //人的性别, 被private封装上了<br> private $age; //人的年龄, 被private封装上了<br> //这个人可以说话的方法<br> function say()<br> {<br> echo “我的名子叫：”.$this-&gt;name.” 性别：”.$this-&gt;sex.” 我的年龄是：”.$this-&gt;age.”<br>“;<br> }<br> //这个人可以走路的方法, 被private封装上了<br> private function run()<br> {<br> echo “这个人在走路”;<br> }<br> }<br> //实例化一个人的实例对象<br> $p1=new Person();<br> //试图去给私有的属性赋值， 结果会发生错误<br> $p1-&gt;name=”张三”;<br> $p1-&gt;sex=”男”;<br> $p1-&gt;age=20;<br> //试图去打印私有的属性， 结果会发生错误<br> echo $p1-&gt;name.”<br>”;<br> echo $p1-&gt;sex.”<br>”;<br> echo $p1-&gt;age.”<br>”<br> //试图去打印私有的成员方法， 结果会发生错误<br> $p1-&gt;run();<br> ?&gt;</pre><br><br><br></div><br><div>输出结果为：</div><br><div><strong>Fatal error</strong>: Cannot access private property Person::$name</div><br><div><strong>Fatal error</strong>: Cannot access private property Person::$sex</div><br><div><strong>Fatal error</strong>: Cannot access private property Person::$age</div><br><div><strong>Fatal error</strong>: Cannot access private property Person::$name</div><br><div><strong>Fatal error</strong>: Call to private method Person::run() from context ‘’</div><br><div>从上面的实例可以看到，私有的成员是不能被外部访问的，因为私有成员只能在本对象内部自己访问，比如，$p1这个对象自己想把他的私有属性说出去，在say()这个方法里面访问了私有属性，这样是可以。（没有加任何访问控制，默认的是public的，任何地方都可以访问）</div><br><div align="left">//这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法</div><br><div align="left"><br><pre class="brush:php">function say()<br>{<br> echo “我的名子叫：”.$this-&gt;name.” 性别：”.$this-&gt;sex.” 我的年龄是：”.$this-&gt;age.”<br>“;<br> //在这里也可以访问私有方法<br> //$this-&gt;run();<br> }</pre><br><br><br></div><br><div>因为成员方法say()是公有的，所以我们在类的外部调用say()方法是可以的，改变上面的代码；</div><br><div align="left"><br><pre class="brush:php">class Person<br> {<br> //下面是人的成员属性<br> private $name;       //人的名子，被private封装上了<br> private $sex;        //人的性别, 被private封装上了<br> private $age;        //人的年龄, 被private封装上了<br> //定义一个构造方法参数为私有的属性姓名$name、性别$sex和年龄$age进行赋值<br> function <strong>construct($name, $sex, $age) //<span style="color: #ff0000;">此处如果不给予初始值，则实例化对象时new Person() 里要赋值，否则会有警告</span><br> {<br> //通过构造方法传进来的$name给私有成员属性$this-&gt;name赋初使值<br> $this-&gt;name=$name;<br> //通过构造方法传进来的$sex给私有成员属性$this-&gt;sex赋初使值<br> $this-&gt;sex=$sex;<br> //通过构造方法传进来的$age给私有成员属性$this-&gt;age赋初使值<br> $this-&gt;age=$age;<br> }<br> //这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法<br> function say()<br> {<br>     echo “我的名子叫：”.$this-&gt;name.” 性别：”.$this-&gt;sex.” 我的年龄是：”.$this-&gt;age.”<br>“;<br> }<br> }<br> //通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄<br> $p1=new Person(“张三”，”男”, 20);<br> $p2=new Person(“李四”，”女”, 30);<br> $p3=new Person(“王五”，”男”, 40);<br> //下面访问$p1对象中的说话方法<br> $p1-&gt;say();<br> //下面访问$p2对象中的说话方法<br> $p2-&gt;say();<br> //下面访问$p3对象中的说话方法<br> $p3-&gt;say();</strong></pre><br><br><br>输出结果为：<br>我的名子叫：张三性别：男我的年龄是：20<br>我的名子叫：李四性别：女我的年龄是：30<br>我的名子叫：王五性别：男我的年龄是：40<br>因为构造方法是默认的公有方法（构造方法不要设置成私有的），所以在类的外面可以访问到，这样就可以使用构造方法创建对象，另外构造方法也是类里面的函数，所以可以用构造方法给私有的属性赋初值。Say()的方法是默认公有的，所以在外面也可以访问的到，说出他自己的私有属性。<br>从上面的例子中我们可以看到，私有的成员只能在类的内部使用，不能被类外部直接来存取，但是在类的内部是有权限访问的，所以有时候我们需要在类的外面给私有属性赋值和读取出来，也就是给类的外部提供一些可以存取的接口，上例中构造方法就是一种赋值的形式，但是构造方法只是在创建对象的时候赋值，如果我们已经有一个存在的对象了，想对这个存在的对象赋值，这个时候，如果你还使用构造方法传值的形式传值，那么就创建了一个新的对象，并不是这个已存在的对象了。所以我们要对私有的属性做一些可以被外部存取的接口，目的就是可以在对象存在的情况下，改变和存取属性的值，但要注意，只有需要让外部改变的属性才这样做，不想让外面访问的属性是不做这样的接口的，这样就能达到封装的目的，所有的功能都是对象自己来完成，给外面提供尽量少的操作。如果给类外部提供接口，可以为私有属性在类外部提供设置方法和获取方法，来操作私有属性.例如：<br><pre class="brush:php"> private $age; //私有的属性年龄<br> function setAge($age)       //为外部提供一个公有设置年龄的方法<br> {<br>     if($age<0 ¦¦="" $age="">130)     //在给属性赋值的时候，为了避免非法值设置给属性<br>     return;<br>     $this-&gt;age=$age;<br> }<br> function getAge()           //为外部提供一个公有获取年龄的方法<br> {<br>     return($this-&gt;age);<br> }</0></pre><br><br><br></div><br><div>       上面的方法是为一个成员属性设置和获取值，当然你也可以为每个属性用同样的方法对其进行赋值和取值的操作，完成在类外部的存取工作。</div><br><div>**<span style="font-size: medium;"><a name="_Toc173034050"></a><span style="color: #1f3a87;">set() <strong>get() </strong>isset() <strong>unset()</strong></span>四个方法的应用</span>**</div><br><div>一般来说，总是把类的属性定义为private，这更符合现实的逻辑。但是，对属性的读取和赋值操作是非常频繁的，因此在PHP5中，预定义了两个函数“get()”和“<strong>set()”来获取和赋值其属性,以及检查属性的“</strong>isset()”和删除属性的方法“<strong>unset()”。</strong></div><br><div><br><br>上一节中，我们为每个属性做了设置和获取的方法，在PHP5中给我们提供了专门为属性设置值和获取值的方法，“set()”和“<strong>get()”这两个方法，这两个方法不是默认存在的，而是我们手工添加到类里面去的，像构造方法(</strong>construct())一样, 类里面添加了才会存在，可以按下面的方式来添加这两个方法，当然也可以按个人的风格来添加：<br><div align="left"><br><pre class="brush:php">//<strong>get()方法用来获取私有属性<br> private function </strong>get($property_name)<br> {<br>      if(isset($this-&gt;$property_name))<br> {<br>     return($this-&gt;$property_name);<br> }else<br> {<br>     return(NULL);<br> }<br> }<br> //<strong>set()方法用来设置私有属性<br> private function </strong>set($property_name, $value)<br> {<br>     $this-&gt;$property_name = $value;<br> }</pre><br><br><br></div><br><div><strong>get()方法：这个方法用来获取私有成员属性值的,有一个参数，参数传入你要获取的成员属性的名称，返回获取的属性值，这个方法不用我们手工的去调用，因为我们也可以把这个方法做成私有的方法，是在直接获取私有属性的时候对象自动调用的。因为私有属性已经被封装上了，是不能直接获取值的（比如：“echo $p1-&gt;name”这样直接获取是错误的），但是如果你在类里面加上了这个方法，在使用“echo $p1-&gt;name”这样的语句直接获取值的时候就会自动调用</strong>get($property_name)方法，将属性name传给参数$property_name，通过这个方法的内部执行，返回我们传入的私有属性的值。如果成员属性不封装成私有的，对象本身就不会去自动调用这个方法。</div><br><div><strong>set()方法：这个方法用来为私有成员属性设置值的，有两个参数，第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。这个方法同样不用我们手工去调用，它也可以做成私有的，是在直接设置私有属性值的时候自动调用的，同样属性私有的已经被封装上了，如果没有</strong>set()这个方法，是不允许的，比如：$this-&gt;name=‘zhangsan’, 这样会出错，但是如果你在类里面加上了<strong>set($property_name, $value)这个方法，在直接给私有属性赋值的时候，就会自动调用它，把属性比如name传给$property_name, 把要赋的值“zhangsan”传给$value，通过这个方法的执行，达到赋值的目的。如果成员属性不封装成私有的，对象本身就不会去自动调用这个方法。为了不传入非法的值，还可以在这个方法给做一下判断。代码如下：</strong></div><br><div align="left"><br><pre class="brush:php">&lt;?php<br> class Person<br> {<br> //下面是人的成员属性， 都是封装的私有成员<br> private $name;        //人的名子<br> private $sex;         //人的性别<br> private $age;         //人的年龄<br> //get()方法用来获取私有属性<br> private function <strong>get($property_name)<br> {<br>     echo “在直接获取私有属性值的时候，自动调用了这个</strong>get()方法<br>“;<br> if(isset($this-&gt;$property_name))<br> {<br>     return($this-&gt;$property_name);<br> }<br> else<br> {<br>     return(NULL);<br> }<br> }<br> //<strong>set()方法用来设置私有属性<br> private function </strong>set($property_name, $value)<br> {<br>     echo “在直接设置私有属性值的时候，自动调用了这个<strong>set()方法为私有属性赋值<br>“;<br>     $this-&gt;$property_name = $value;<br> }<br> }<br> $p1=new Person();<br> //直接为私有属性赋值的操作， 会自动调用</strong>set()方法进行赋值<br> $p1-&gt;name=”张三”;<br> $p1-&gt;sex=”男”;<br> $p1-&gt;age=20;<br> //直接获取私有属性的值， 会自动调用<strong>get()方法，返回成员属性的值<br> echo “姓名：”.$p1-&gt;name.”<br>“;<br> echo “性别：”.$p1-&gt;sex.”<br>“;<br> echo “年龄：”.$p1-&gt;age.”<br>“;<br> ?&gt;</strong></pre><br><br><br></div><br><div>程序执行结果：</div><br><div>在直接设置私有属性值的时候，自动调用了这个set()方法为私有属性赋值<br>在直接设置私有属性值的时候，自动调用了这个<strong>set()方法为私有属性赋值<br>在直接设置私有属性值的时候，自动调用了这个</strong>set()方法为私有属性赋值<br>在直接获取私有属性值的时候，自动调用了这个<strong>get()方法<br>姓名：张三<br>在直接获取私有属性值的时候，自动调用了这个</strong>get()方法<br>性别：男<br>在直接获取私有属性值的时候，自动调用了这个<strong>get()方法<br>年龄：20</strong></div><br><div>以上代码如果不加上get()和<strong>set()方法，程序就会出错，因为不能在类的外部操作私有成员，而上面的代码是通过自动调用</strong>get()和<strong>set()方法来帮助我们直接存取封装的私有成员的。</strong></div><br><div>isset() 方法：在看这个方法之前我们看一下“isset()”函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。那么如果在一个对象外面使用“isset()”这个函数去测定对象里面的成员是否被设定可不可以用它呢？分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用“isset()”函数来测定私有成员属性是否被设定了呢？可以，你只要在类里面加上一个“<strong>isset()”方法就可以了，当在类外部使用”isset()”函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的“</strong>isset()”方法了帮我们完成这样的操作，“<strong>isset()”方法也可以做成私有的。你可以在类里面加上下面这样的代码就可以了：</strong></div><br><div align="left"><br><pre class="brush:php">private function isset($nm)<br> {<br>     echo “当在类外部使用isset()函数测定私有成员$nm时，自动调用<br>“;<br>     return isset($this-&gt;$nm);<br> }</pre><br><br><br></div><br><div><strong>unset()方法：看这个方法之前呢，我们也先来看一下“unset()”这个函数，“unset()”这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。那么如果在一个对象外部去删除对象内部的成员属性用“unset()”函数可不可以呢，也是分两种情况，如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性，如果对象的成员属性是私有的，我使用这个函数就没有权限去删除，但同样如果你在一个对象里面加上“</strong>unset()”这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了“<strong>unset()”这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，自动调用“</strong>unset()”函数来帮</div><br><div>我们删除对象内部的私有成员属性，这个方法也可以在类的内部定义成私有的。在对象里面加上下面的代码就可以了：</div><br><div align="left"><br><pre class="brush:php">private function <strong>unset($nm)<br> {<br>     echo “当在类外部使用unset()函数来删除私有成员时自动调用的<br>“;<br>     unset($this-&gt;$nm);<br> }</strong></pre><br><br><br></div><br><div>我们来看一个完整的实例：</div><br><div align="left"><br><pre class="brush:php">&lt;?php<br> class Person<br> {<br> //下面是人的成员属性<br> private $name;      //人的名子<br> private $sex;       //人的性别<br> private $age;       //人的年龄<br> //get()方法用来获取私有属性<br> private function <strong>get($property_name)<br> {<br>     if(isset($this-&gt;$property_name))<br> {<br>     return($this-&gt;$property_name);<br> }else {<br>     return(NULL);<br> }<br> }<br> //</strong>set()方法用来设置私有属性<br> private function <strong>set($property_name, $value)<br> {<br>    $this-&gt;$property_name = $value; //这里的$this-&gt;$property_name 中$property_name 中要有$的，没有的话将赋不了值<br> }<br> //</strong>isset()方法<br> private function <strong>isset($nm)<br> {<br>     echo “isset()函数测定私有成员时，自动调用<br>“;<br>     return isset($this-&gt;$nm);<br> }<br> //</strong>unset()方法<br> private function <strong>unset($nm)<br> {<br>     echo “当在类外部使用unset()函数来删除私有成员时自动调用的<br>“;<br>     unset($this-&gt;$nm);<br> }<br> }<br> $p1=new Person();<br> $p1-&gt;name=”this is a person name”;<br> //在使用isset()函数测定私有成员时，自动调用</strong>isset()方法帮我们完成，返回结果为true<br> echo var_dump(isset($p1-&gt;name)).”<br>“;<br> echo $p1-&gt;name.”<br>“;<br> //在使用unset()函数删除私有成员时，自动调用<strong>unset()方法帮我们完成，删除name私有属性<br> unset($p1-&gt;name);<br> //已经被删除了， 所这行不会有输出<br> echo $p1-&gt;name;<br> ?&gt;</strong></pre><br><br><br></div><br><div>输出结果为：</div><br><div>isset()函数测定私有成员时，自动调用<br>bool(true)<br>this is a person name<br>当在类外部使用unset()函数来删除私有成员时自动调用的</div><br><div>set()、<strong>get()、</strong>isset()、__unset() 这四个方法都是我们添加到对象里面的，在需要时自动调用的，来完成在对象外部对对象内部私有属性的操作</div><br></div><br></div>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>说说大学里的打工赚钱</title>
      <link href="/article/131.html"/>
      <url>/article/131.html</url>
      <content type="html"><![CDATA[<p>今天在收拾屋子的时候发现了多年前办的一张农业银行的信用卡，虽然那张卡我始终没有激活，但是却让我开始想起大学里的关于打工挣钱的话题。那张卡是我当时一个不认识的同学打了份零工，就是替银行办理信用卡，办理一张有多少钱给他，我是在我一个同学要求下，不得已而办的，因为我知道不激活那张卡也没有用，自己也没有什么损失。可是没有想到这个农业银行要是从不舍弃放弃，给我发个快四年的短信…… 直到我换了手机号……  endless……</p><p>于是我就在想一个问题，我这不是为了一个我从来不认识的人而给自己造成这么多年的麻烦吗？</p><p><a id="more"></a>上了大学，似乎很多人都有一种长大了的感觉，觉得再花父母的钱多多少少有种罪恶感，于是有的同学可始想着方法去赚钱，于是有的人选择了倒卖东西，有人当家教，有的人选择了成立社团，有的人学了点技术，开始以技术来服务别人来赚钱， 有的人开起了自己的淘宝店，或者开了自己的网站，总之各种吧。</p><p>但是在我看来其实他们还是没有找到自己究竟想要一个什么样的大学，自己究竟想要什么，如果真的只是想赚钱，那么上大学真是亏了，学业没有什么成就，钱真的赚不了多少。如果想积累下自己的社会经验，体验下挣钱的不容易，那么还可以理解。</p><p>但是像那种办卡的业务，说实在的，赚的钱真的不是什么好钱，首先，你利用的是你的朋友关系，那么作为朋友，无论自己有无需要，在面子上总是要给的，既然你开口了，对于我来说也不是多大点事，办也就办了，无所谓，但是你有没有想过，通过你的这份打工，你除了得到了钱你还得到了什么？你不会体验到赚钱是件很困难的事情，因为你有朋友，你的人脉也不会有多大扩展，甚至还会因为这张卡而影响你在你朋友圈中的地位，换句话说，以后别人找你做一件你不喜欢的事情，那么你有什么理由拒绝别人？更何况还有很多你都没有见过面的人因为你而受到银行无休止的短信骚扰，这么人你怎么处理？而你手拿着轻而易举得来的钱你又用在了什么地方？吃喝？还是继续做更大的生意？</p><p>我在大学里也打过工，赚的钱加起来也不足1000，但其实我自己也不想做，很多时候也是出于朋友上的关系，一份是在高校资讯会的时候兜售一个高考的复习资料，当时做的时候学校管，还要躲着保卫处的人，感觉自己在做什么见不得人的事，状态非常不好。另一份是向大一新生推销英语报纸，这个工作似乎是各大报纸商每年都要做的，因为也只有大一小孩才会订，但其实当时做这份推销工作的同时我也是想在向大一新生推销我的网站，只是顺便，虽然感觉这次推销效果比高考那个好一点，但还是会觉得有一种违反校规的感觉，因为还是要躲着宿管大妈。</p><p>两次经历给我最大的收获就是让我知道我真的不适合做销售……</p><p>因为我不能克服自己的心理障碍，而且投入的时间也最后的所得不能达到我的预期。</p><p>我觉得大学里如果想要赚钱，还是想有个自己的规划吧，或者说有个更明确的目的，叫君子爱财，取之有道，如果这些问题还没有想清楚，那么继续想，实在想不出来就去好好学习，不想好好学习就去谈恋爱，没有恋爱去谈那么就多交朋友，如果朋友也不想交，那么就多学点技能，如果技能也不想学，那么就健身，踢球，打篮球，运动也不想干那么就去当志愿者，或者在社会上当义工，大学里有很多事情可以去做，而赚钱的话你以后会发现你虽然得到了点金钱，但却错过了更多美好的大学时光。</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>说说微博与RSS</title>
      <link href="/article/129.html"/>
      <url>/article/129.html</url>
      <content type="html"><![CDATA[<p><a href="/image/2011/11/sinarss.jpg"><img src="/image/2011/11/sinarss.jpg" alt="" title="sinarss"></a></p><p>已经把人人网注销了一段时间了，因为在微博出现之后，我觉得人人网的信息量太少了，而且翻来覆去就那点东西，不是爱就是情，不是星座就是愤青，信息更新太慢了，而且我惭惭觉得SNS在影响着人们正常的沟通方式，看上去在网上大家聊的挺欢，但在现实生活中我们却很少和对方打声招呼。</p><p>微博出现以后其实强大的信息量很吸引我，到目前为止我关注了397人，基本上可以分为朋友，互联网信息，企业高管，名星，普通网友，每当我刷新的时候总会有很多信息出现，起初我还是因为微博上好玩的图片多而喜欢上微博，但后来当我快习惯了微博后，开始搜索一些与文化，生活，购物等的微博来关注，可以说微博是我主要获得信息的渠道，以前我总会用一个例子来说明，给你一分钟，你可以阅读多少条微博？但如果在SNS你可以阅读多少篇日志？或者说是多少条无病呻吟的状态？在微博的世界里，你不必关注有多少人回复你，而在SNS里，你却很在乎有多少朋友在关心你，在回复你，因为微博是一个信息获取的渠道，你在乎的是我在这段时间里又获得了多少信息。<br><a id="more"></a><br>于是我最近在想一个问题，微博的定位到底是自媒体还是社交网络？我现在觉得微博社交的成分要少一些，更多的是一个媒体的发布渠道，可能也因人而义吧，如果就从个人来讲，我开微博，加的关注中大部门都是我的朋友，那么平时我在发微博的时候有很多时候是@我的朋友的，那么对于其他的陌生人来说，你发布的信息对他来说意义不是很大，那么这类人是主要将微博用来社交，但微博作为社交网络的工具来说劣势大于优势，首先信息的交互不是即时的，你在微博上，很有可能你@的人不在，@他或者私信他很长时间他才回复，很有可能你会选择发个短信或者打个电话，或者看他QQ在线就QQ联系了，其次范围很小，只能是以微博主为中心，他的朋友建立的关系网，就是这么一个小的范围，因为你的社交信息对于其它人来说是无用信息。作为自媒体，现在有很多网站企业都有自己的认证微博，一来用于发布自己商品相关的信息，二来转播一些其它有意思的微博来充实自己的信息，如果一个购物网站如团800一直在发布团购的商品，那么作为他的听众，也是会觉得很烦的，所以团800基本上很少发布关于商品的信息，更多的是生活常识，有意思的图片或者励志的微博，这点很符合听众的心思。</p><p>关于这点，其实可以说是微博的另一个劣势，以前某段时间我对汽车有兴趣，然后我以汽车为关键词搜索相应的人并且是认证的，结果出来的大多某些汽车俱乐部的人，当我对他们加了关注后，发现他们平时说的东西很少和车相关，更多的是到哪玩，去哪吃，或者就是一般的对话，感觉和普通人没有什么区别，后来我也就惭惭的取消了对他们的关注，而更多的是关注一些企业微博，也就是新浪微博里加蓝色认证的微博主，因为他们看上去会更专注一些。</p><p>但什么东西也不是完美的，微博信息量大的优势，但有时也是劣势，因为有时有些信息我会看不到，这时我开始接触RSS，其实这个东西以前就接触过，但当时没有发现他的好处，用的阅读器也不怎么样–foxmail，但这也不完全怪foxmail，因为当时我在用它的时候还没有微博也SNS，而且很多默认的订阅很多，一会就会有好几千的新文章，有点看的目不暇接……</p><p>最近开始用google reader，使用其最大的原因是它可能很方便的将信息分享到SNS与微博上，当我看到篇有价值的文章后，可能通过send to功能快速的发到我和微博中，让更多的人看到，当然如果用RSS订阅大型门户网站中的新闻绝对不是一个明智的选择，如果那样的话就会陷入微博信息量大而杂的困境中，RSS适用于订阅些你平时很少访问但偶尔又会关注一下，或者说是某些领域中比较权威的网站，比如我的订阅中有互联网科技，时尚创意，娱乐，豆瓣文化，还有一些小众网站，虽然不是很有名，但是其中的信息还有挺不错的。</p><p>由于Google reader在国内访问有时会出问题，所以如果你会翻墙的话尽量翻墙访问，不会的话也没有关系，国内也有相应的网站提供RSS订阅服务，做的比较好的有鲜果，腾讯等，但个人感觉都没有Google好，qq reader其界面比Google强好多，更人性化，感觉是在休闲中阅读一本杂志，但它的分享功能太狭小了，只是腾讯里的那点产品，不过它可能直接转载到个人的QQ空间还是不错的，鲜果弄的也不错，但鸡肋也是分享功能，没法自定义分享，或者通过别的方式也可以，但是很麻烦。</p><p>当微博与RSS结合后可以说是互相弥补对方劣势的组合，在这个信息量巨大的时代下，能够快速准确的找到自己想要的信息可以说是很关键的。</p>]]></content>
      
      <categories>
          
          <category> IT关注 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>是否还能保持一种学习的态度</title>
      <link href="/article/124.html"/>
      <url>/article/124.html</url>
      <content type="html"><![CDATA[<p>记得很小的时候，听大人们说到了他们的年龄就没有学习的心思了</p><p>现在也开始明白了</p><p>那天突然很羡慕那些还在校园里的同学，因为你们还有寒暑假，因为你们能够在校园里学习自己喜欢的知识</p><p>想我在学校里的时候 也不是爱学习本专业的知识，经常和教务处的老师打交道</p><p>但还好的是我不玩游戏，我把时间放在了计算机上<br><a id="more"></a><br>但现在意识到，自己并不是计算机专业的，很多知识体系不完整，逻辑思考能力不是那么严谨</p><p>想学一些东西比较吃力，再加上工作一段时间了，开始为新的问题而愁，工作，工资，人际，柴米油盐……</p><p>发现能够静下心来学习一种技能很是困难，有时加班，回来很累，什么也看不下去</p><p>其实可能就是一种坚持的问题吧，或者还没有一种踏实的心</p><p>眼前的迷惑很多，同学聚会聊天的话题已经惭惭的从游戏变成了工作，婚姻</p><p>回家的时候老妈也开始问我是否有对象的问题，而我总会以我哥还没有呢我着什么急啊来回应</p><p>学习，对于现在的我来说已经变成了一个越来越远的词汇</p><p>或许改变的只是一种学习的方式与内容吧，谁不是在学习呢，但我总觉得我在大学里就没有打下一个好的基础，真的毕业了，想的是一边工作一边学习，可是现实真的不一样，工作后要处理更多问题，在学校里，看人不爽了，我可以去骂他，打他，而在工作中，必须要换一种方式，或者更多的接受</p><p>现在我必须每个月看两本书，必须在这方面投入相应的精力，如果实在没有时间，我宁可不上网了，发现现在经常在网上其实也一直在做些无聊的事情，本来很无聊，还要和别人着无聊，时间很快的就过去了</p><p>上次我让一个朋友帮我从学校借两本书，当时我开玩笑地说，这个不是书，而是金钱！</p><p>可不是吗，我一直相信，光靠一个好嘴巴是不能立于世的，而必须要有一技在身，即使用好的嘴巴使自己过的不错，但扪心自问，我的心是否空虚？生活是否充实？</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用猫抓老鼠的实例理解java中面向对象的编程与类和对象以及方法的概念</title>
      <link href="/article/121.html"/>
      <url>/article/121.html</url>
      <content type="html"><![CDATA[<p>今天看到马士兵讲的关于面向对象编程的思路，用了一个猫抓老鼠的例子，我觉得这个例子非常形象，于是写在这里，方便学习理解和以后查看</p><a id="more"></a><p>class cat{   //声明一个类–“猫”</p><p>int furcolor; // 定义猫的一个属性（成员变量）“毛的颜色”</p><p>float heght; // 定义猫的一个属性“身高”</p><p>float weight;// 定义猫的一个属性“体重”<span class="Apple-tab-span" style="white-space:pre"> </span></p><p>static void catchmouse(mouse m){ //声明一个方法—-“抓老鼠”</p><p>//how to catch a mouse //方法里面的关于怎么抓老鼠</p><p>//m.scream();</p><p>}</p><p>public static void main(String[] args){// 主函数</p><p>cat C = new cat(); //构造一个猫这个类里的一个新“对象”—-“C”</p><p>mouse M = new mouse();// 构造老鼠里面的一个新“对象”—–“M”</p><p>C.catchmouse(M);// 猫的一个方法“抓老鼠”（具体到抓M那只老鼠）<span class="Apple-tab-span" style="white-space:pre"> </span></p><p>}</p><p>}</p><p>class mouse{ //定义老鼠这个类</p><p>void scream(){ //定义老鼠这个类的一个方法scream</p><p>System.out.println(“mouse”);</p><p>}<span class="Apple-tab-span" style="white-space:pre"> </span></p><p>}</p><p>此程序形象的说明了面向对象中的各种概念，类，对象，方法等</p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大学就这么过了（4）</title>
      <link href="/article/105.html"/>
      <url>/article/105.html</url>
      <content type="html"><![CDATA[<p>在第一周的某个晚上，又传来了陌生人的敲门声</p><p>你们好，我们是材料学院科协的，我们现在在招新，我是主席王东辰”</p><p>科协？这个是做什么的？”</p><p>我们这个组织是在学院管理下，从事一些实验工作，在我们这里你可以提前进入实验室，见到学科的带头负责人，如果做的好的话对你们有很大帮助的”</p><p>我心想这个不错啊，进入大学了就是想要锻炼一下自己的各种能力的，加入个组织也不错哦！</p><p>于是我就报名了，可谁又曾想到，我的真正大学生活由此开始了，以至于以后发生的各种各种，我现在一直认为，加入科协，是我第一个转折点，这个转折点并不是我在科协里学到了什么，办成了什么事情，而是我认识了一个人，他叫姜晓希！</p><p>他和我一样，加入了科协和我分一个部门，那次好像是为全学院的新生做一个讲座，主讲我们实验室的构成，我们学院的分支可以简称为“三室三所”，那天来了很多长老级别的人物，可是当时我们都不知道他们有多么牛逼。</p><p>这个暂时不提了，总之讲的东西当时听不懂，现在也听不懂！<a id="more"></a></p><p>之后我们的部长说请客，说实话，以前我还没有怎么去过餐厅吃饭，这次应该是第一次吧！我们到的是学校的第一餐厅，据说现在改名叫天天餐厅了！</p><p>至于点餐，我很愁，看着菜单上的图片都很漂亮，也不知道哪个好，随便点了个东西，之后就有了喝酒这个环节，我在高的时候喝过一点点，高考结束后，和同学一起吃饭也喝过一些，但是真的是一点点，自己还不喜欢酒的味道！</p><p>那次我们喝的是啤酒，我以前最多就喝过两瓶，这次我也不知道能喝多少，喝多了后会是什么样子的，总之我不会让自己晕晕的，可是一瓶下去后，我虽说还很清醒，但是却有点晕了</p><p>但是姜晓希一开始却怎么也不肯喝酒，一直说自己不会喝，但是一瓶啤酒下了肚子后自己却死活也不放第二瓶酒了，而且他的笑让我们不知道他是真的喝多了还是装的，不过我现在觉得他是真的，因为之后的举动证明了他是真的不清醒了，可能是他酒量真的不行，一瓶啤酒就醉了……</p><p>我将他抬回到宿舍后，心里很是害怕，也不知道他还行不行，他一直在闹，而且谁也劝不了，让他躺床上睡觉他不听，一直在笑，笑的让人害怕！最后他拿着脸盆说要去洗澡，我们都担心他会进了女浴室……</p><p>我其实也不行了，头晕的不行了，只是我没有表现出来而已，而且大家都在关注姜晓希，即使我有点异常也不会关注的……</p><p>在这之后，姜晓希喝酒的样子似乎成为了我们的笑话，没有别的意思，只是现在回想起来觉得挺逗的！</p><p>而为什么说姜晓希的出现是我大学生活的转折呢，我们在经过这次喝酒后，感情似乎有了些加深，以后我们也有过很多的喜与怒！但是经过这次事件后，忘记是元旦还是中秋了，由材料、人文、生命三个学院共同举办一场迎新晚会，每个学院要出个节目……</p><p>而大多数的人是没有什么才华的，唱歌跳舞已经不是简单的歌颂社会主义了，这种事情最令学生会头痛了，上面下了指令，学生会必须出几个节目，其实这也从另一方面说明大学生个性的东西太少了，多年的教育让一个本来才华横溢的孩子变成了一个书呆子，只会读死书！</p><p>我当时也是学生会的成员，说来惭愧，居然还是学习部的，其实更惭愧的是后来大二的时候居然还当上了学习部的部长，这个以后再说明吧，这其实是我一个笑柄！</p><p>我们宿舍里还有一个同学就是头发花白的，他叫于凡，由于长的比较胖，所以日后我们都叫他小胖儿。</p><p>由于姜晓希同学那次喝酒事件，弄的我们全班都当笑话，我和于凡又都是喜欢相声的人，所以我们决定说段相声，其实就是演一遍当年侯宝林说的《醉酒》，想以此来说笑下姜晓希同学。</p><p>他为了这段相声还特意将这个相声的原文写了一遍让我背捧哏的，他说逗哏的，但是当时我觉得说相声这种东西即兴发挥就可以了，没有必要都按照原文的说下来。</p><p>初审我们演的很糟糕，但是最后竟然录用了……</p><p>那天上台表演的时候我到是不怎么紧张，反正我是捧哏的，只是简单的应和下就行了，主要还是看逗哏的</p><p>那天表演的时候他有段还是忘词了，我做为一个捧哏的，为了打圆场就拿主持人姜晓希开了涮……</p><p>虽然效果一般吧，可是在我们下台后有一个人拦住了我们，这个人的出现是我大学里的又一个转折！</p><p>此人名叫朱淑君，听起来像个女生的名字，可是他是一个男的，而且很帅很黑！他也是大一的新生，广告学院的。</p><p>他说“打扰一下，请问你们也是大一的吗？”</p><p>我说“是啊”</p><p>你好，我也是大一的，我们现在正在准备成立一个相声社，我看你们表演的不错，有没有兴趣加入我们社团啊？”</p><p>说过加入社团，这似乎是每一个大一新生在他没有进入大学的时候别人经常给他说的，在大学里要加入几个社团，并努力找到机会成为里面的骨干，锻炼一下自己的组织能力。现在想来这些都是扯谈的东西，要想锻炼你做什么都是一种锻炼，只要你认真的去想去思考去总结，没有必要刻意的做一些事情，就像四年以后的我在面试之前都要接受一些所谓的面试经，这些在我看来纯粹是装B的东西，自己是什么样的人没有必要去隐藏，做事情不能太急功近利！顺其自然才是正道！</p><p>其实在开学的2、3周左右学校社团统一做了招新，这次盛宴似乎是每个新生来到大学后参加的第一个火热的活动，我们学校里的社团各类还挺多的，不过当时的大一新生似乎对吃喝玩乐比较关注，记得当时动漫社的cosplay和ID时尚舞社的劲舞都非常吸引人，而众多的社团中英语协会实力是最大的，因为他们背后有个很有实力的公司在支持，后来才知道，做社团的几乎都有一个叫“外联部”的部门，专门在外面找赞助，如果活动做的好，成员间还能有笔灰色收入，虽然我不喜欢这种行为，但是我认为比起串宿舍卖些小东西，做社团无论是投入还是收获，都要比它强，而做社团的目的已经不是单纯的兴趣爱好相投想一起做些事情了，而掺和了更多的商业，总觉得已不再是那样纯粹了，不过也难怪，在中国这样的伪社会主义中，拜金主义充斥着人们的头脑，当今社会没有钱没有势力好像做什么事情都会很难！而一句“我爸是李刚”却能抵消掉一个平民的“贱命”！</p><p>说远了，回到社团的招新来，我当初很有激情了加入了英语协会，宏文学社，当时我也是个文艺青年，喜欢看些文化的东西，可是后来发现我被这些名字欺骗了！</p><p>现在有个“相声社”的社团要成立，其实最开始的想法是不想参与了，我是个嫌麻烦的人！我问朱淑君，我们加入后能做什么？他说你们来说相声吧！</p><p>我心想，就我们这样的还说相声呢？呵呵，你可真是没有见过会说相声的吧……</p><p>我只是简单的应付着，最后留下了联系方式，心里反应我也不想去，随便吧！于凡也留了他的联系方式！</p><p>可能由于于凡是逗哏的吧，社长先是联系他的，他们怎么联系经的我不大清楚，反正于凡回到宿舍后就和我说，社长是一个坐轮椅的同学，他还说他们社团里有还有一个美女！</p><p>我一听美女，本来不想参加的，顿时来的精神，问于凡，你看到了吗？</p><p>他说没有啊，反正我对美女不感兴趣，我才不参加这个社团呢！</p><p>没过一会，社长就给我打来电话，说想和我聊聊，我说好啊</p><p>于是我到了他的宿舍，刚进去后见到了这个传说中的社长，心中顿时起了敬佩之情，他由于先天原因不得不坐在轮椅上生活，生活起居很不方便，在常人眼里，他应该是一个悲观的人，可是正是这个悲观的人，却正在做一件传播快乐的事情，他见我来了后马上召集的隔壁宿舍的两个同学，一个叫马金，一个叫郑小龙，那天我们基本上除了一开始聊些社团的事情，其余的时间都在扯谈聊闲天，天南地北的砍几个人的关系马上就亲近了。</p><p>我问他们，咱们社团现在有多少人啊？</p><p>社长王一（这个名字非常简单，好记，我们以后经常拿他这个名字开玩笑，问他的八弟叫什么？呵呵）说目前还没有成立，主要的成员有7个</p><p>我其实是关心那个美女是谁，喜欢相声的女生似乎不多，但是又不好意思明说，我问他，听说还有个女生？</p><p>王一说“嗯，这你都知道啊？消息够灵通的！”</p><p>呵呵</p><p>嗯，她确实是个大美女啊”，我现在一直不明白他当初为什么不说后半句，“其实她有男朋友”</p><p>难道说是想用色诱之术？呵呵</p><p>然而我和他们说，“我是社管委的成员”</p><p>其实当初加入社管委（社团管理委员会）也算是个巧合，社管委是在学校团委领导下组建的管理学校里社团活动的官方组织，社团在召新后必须将所得的会费上交到这个组织，以后活动的时候必须得到社管团的批准后才能得到资金。</p><p>我到现在仍然觉得我们大学里社团得不到很好的发展主要原因是由于这个组织的出现，学校一方面鼓励社团活动，但一方面又在限制社团的活动，官方的口气都是说为了学生的生命财产安全，或许也有这方面原因吧，但是我觉得有这么个组织存在，本身就限制了社团的发展，而在社管委工作的人，由于手中有了那么点小权力，似乎不显摆一下难以向他人证明自己的存在，而社管委的人是一年一换的，之前受过压迫的，在其持政后便更会是变本加利的获取这种心里上的虚荣！一个恶性循环开始了！一个小的官僚主义就开始形成了！这也是为这些以后工作在政府中或者行政单位的同学提供一个很好的实习机会！</p><p>我加入这个组织是由陈坛介绍的，我没有走一般的应聘流程，当初进入这个组织目的很单纯，多认识点人。</p><p>因为陈坛在里面表现的不错，已经做了个不错的位置，我也就相应的得到了一个不错的位置！算是个走后门的人吧，呵呵</p><p>当我和王一说到我是社管委的人时，我感觉出来他们已经不想再让我当什么演员了，其实马金也是里面的成员，只是其个性太突出了，一直只是个小部员。</p><p>我经过那天的聊天后，决定不为了别的，只为王一（一哥）也全力帮助相声社！</p>]]></content>
      
      <categories>
          
          <category> 我的大学 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大学就这么过了（3）</title>
      <link href="/article/104.html"/>
      <url>/article/104.html</url>
      <content type="html"><![CDATA[<p>上文说到我正迷茫于为什么而学习这个问题上，由于找不到很好的理由，在上大学之前也曾经为自己设定过很多的目标，很多的想法，大学要这样过，那样走，可是总是有心插花花不成！</p><p>应该是在我还没有正式上课的某个晚上，突然有人来敲门，我们也很客气的说“请进”</p><p>来的人我们并不认识，他是一个形态略胖的一个矮个子男生，带着一个眼镜，手中拿着很多东西，到我们屋来后也很客气的和我们说</p><p>“你们好，我是大二电控学院的崔澜波，你们是新大一吧？”</p><p>“嗯”，我们说是的</p><p>“你们知道现在在大学里最重要的是什么么？”—-“英语！！！！”</p><p>“哦”<br><a id="more"></a><br>“我给你们推荐一本报纸吧，《英语周报》，里面有最新的文章，最热的影评，现在订购还赠送一本词典”</p><p>我们当时心想这位好心的师哥还不错呢， 当时我问他们，你们要吗？</p><p>“要不就来一份吧，一年的”</p><p>“一份够看吗？咱们五个人呢？”</p><p>崔澜波说“那就订两份呗，谁想看都行”</p><p>由于高中的时候我们班是人手一份英语报纸，我忘了叫什么了，总之当时是当做练习册来做的，上面的很多的题，都是专门针对高考而出的，心想英语确实很重要啊，如果一个人别的本事都没有，光有一个很好的英语水平那也足以让他有一份好的工作！</p><p>于是我们一个宿舍5个人就订了两份报纸！他承诺每期都送到宿舍。</p><p>那个英语四级词典好像是随着第一份报纸送到宿舍而送到的，当时我还根本不知道这个小东西的价值有多少？也不知道什么所谓的商业行为，觉得自己订一份报纸认真看看，对于自己的英语肯定有帮助！</p><p>现在毕业后，有一天我回去找我一个大四的朋友，当我走到他宿舍的时候，我下意识的敲了下门，没有人理我，再敲了一下，传来一句不耐烦的声音，“门又没锁，你不会自己进来啊？”</p><p>当我进去的时候，我问他“那个XXX在宿舍吗？”</p><p>他看到我后不好意思的说“他不在”</p><p>现在想想，可能在大一的时候经常被这种敲门的声音而烦恼，起初我们还是热情的接受，甚至去买他们的东西，后来我们变的不热情，再后来我们变得不耐烦，再后来我们就直接说“不要，走吧”，敲门这个动作在我们大学里似乎只有在两种情况下才发生，一种是对方宿舍锁着门，我们想进来，于是我们敲门，第二种就是推销商品，发传单！而如果是同班或者同系的同学到别的宿舍串门，是根本不要敲门这个多余动作的！所以到了大二以后，一般对于敲门都很反感！这也就难怪那个同学对我没有好气的说话了！</p><p>而现在大学里销售的东西真是一点新意都没有，我曾经见过卖耳机的，贴画的，各种小商品，现在想想看你们真的没有发掘学生他们真正想要的是什么？学生这块消费市场与其真正的消费能力有多少？</p><p>在学校里无聊的生活暂且告一段落，终于该上新了，心中还挺期待的，哦，我忘了，在上课之前的某一天里，全学校的新生在操场上举行了盛大的迎新活动，我们全体在操场上按照班级院系站的很整齐，估计这是四年里站的最齐的一次了！</p><p>总之就是那一套中国特色的演讲，而且有幸看到了老校长左铁镛院士，他上台的时候居然还有人来搀着，这让我更加佩服这位老学者，而那个名义上的校长“范伯元”我四年里也未曾见过其庐山真面目，但是我从百度图片中搜索过他！</p><p>最后有一个环节是放飞心愿气球，我忘记我当时写了什么了，总之很飘渺，以至于我现在根本想不起来是什么了！</p><p>不过还好，领导们在似乎感觉到了我们很累的样子，于是这个盛大的迎新会议并没有持续很长时间，结束后我们在张忻老师的带领下到了材料楼的某个教室，开了个班级小会，我们宿舍的同学还挺积极，坐到了第一排，说起来这个会议我们也都是很期待的，因为这个是第一次全班同学在开会，我也想看看别的同学都是什么样子的！</p><p>我们有31个人，其中有9个女生，上大学之前就听说过理工科的女生如何如何，那天真是百闻不如一见！当时我有了一种怀念高中生活的感觉了！</p><p>其实我觉得女生可能也是这么想的吧，我怎么来到了侏罗纪了？</p><p>也不知道是为什么，大学里男生似乎对于男女关系看得很敏感，是不是觉得自己终于可以名目言顺的谈恋爱了？压抑了很久的感情终于要爆发了！</p><p>其实男生嘴里谈论最多的女生要么她很好看，要么她太难看了！对于这两种女生男生口中谈论的大多是“啊，XXX，你和她很配啊！”而这两种唯一不同的就是对于好看的女生他说她和别的男生好的的时候其实他是伪心的，说难看女生的时候其实他是真心的！</p><p>现在回想起来，当时自己真是太肤浅了，没想到以后的时光里会和她们发生那么多的事情！如果以貌取人的话那么我将错失多么美好的东西！</p><p>回到刚刚说过的准备去上课，第一节好像是高数，早上我起的很早，来到第四食堂吃饭，当时是7点半，呵呵，看来和我一样积极的人还不在少数，排了很长的队才买到吃的！</p><p>来到教室本来想早到占个好位置的，可是最后居然只能在后几排找个座位！看来大家在开学的时候都很积极嘛！</p><p>8点铃声响起，老师上来讲课，他先做了个自我介绍，他叫胡京兴，后来得知也是数理学院有名的老师！其他的我记不清了，但是有一句话我记得比较清楚，他供应商“你们现在还可以很早的来到教室，以后就会有很多同学拿着早点到教室或者就不来了”</p><p>我心想这怎么可能？</p><p>事实证明我真是太天真了！</p><p>讲什么不记得了，总之第一节课讲的和高中差不多，基本的微分东西，不听也罢，我还辛勤的记了很多笔记，就差把老师的板书抄不遍了！</p><p>上课是一方面，其实在第一节课还有更有趣的事情，就是观察姑娘。哈哈</p><p>和我们一起上课的还有数理学院的某个系，这不知道是不是人的一种普遍心理呢？总觉得别人的东西比自己的好呢？怎么人家学院的女生都那么漂亮呢？</p><p>其实后来和数理学院的同学聊天的时候他们也特别羡慕我们材料学院的男生！</p><p>看来这种心理是真的！</p><p>接下来有很多课，记不清楚了！总之我们第一周都很积极！</p>]]></content>
      
      <categories>
          
          <category> 我的大学 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大学就这么过了（2）</title>
      <link href="/article/103.html"/>
      <url>/article/103.html</url>
      <content type="html"><![CDATA[<p>书接上文，上文写到我老爸去了我姑家，以后的事情我就不知道了</p><p>我一个人在学校里随便溜达，突然想起我的一个高中同学上行已经先到学校报道了，他叫张路，是和我在高中时候三个人一个宿舍的好兄弟，还有另外一个兄弟叫邓爱光，当时我们三个人一个大宿舍，回想起来真是爽啊，我们平时也是无话不说，还想起高考前的那个晚上，我们聊了很长时间的天，也不知道几点睡觉的，当时我们聊自己心中的大学，自己要在大学里怎么怎么样，不过现在看来好像都没有按照自己所设想的那样，爱光同学还号称自己要在20岁时破处，不过好像现在还是个处男，呵呵！</p><p>张路说他在5号楼，于是我就去打听哪里是5号楼，结果来到了一个非常幽静的地方，当时我也不知道是哪里，可是看到楼牌号上明明写着5号楼，但是这里根本没有新生入学的气氛，我小心翼翼地走到大厅，看到一个阿姨，我就问，这里是5号楼吗？她说是，我说这里有新本科生吗？她很是诧异的看着我，这里是研究生宿舍！没有本科生！</p><p>晕死！！！</p><p>我又给张路打电话，问他是哪呢，他说他在1号楼5层……</p><p>唉<a id="more"></a></p><p>我这个迷失方向的人于是就是学校里乱走，终于看到有一个像有新生气象的楼了，我于是大踏步的走了进去！</p><p>可是迎面来面的是很多漂亮的女生，当然也不是很多了，但是像我这种刚刚进入大学校园，在我的脑海里女生还都是衣着校服的样子，突然有这么多衣着个性着实也让我感叹了一把，原来大学里女生自己打扮起来也都挺好看的，可是走着走着我的步伐就有些放缓，我有点不好意思走进去了，心想“我不会走错宿舍了吧？难道这里是女生宿舍？”心里是这么想的，眼睛就不是这么想的，有些不好意思了，突然一个“衣衫褴褛”的女生从楼上走了下来，身边还有很多和她一样的女生，这让我更加不好意思，我定下步子，只站在了宿舍大厅里，看到有很多的家长在帮孩子拿行李，这里也有男生，所以我不敢确定这个楼到底是男生还是女生，于是我就问那个宿管阿姨这楼是1号楼吗？她恶狠狠的说，这里是2号楼，1号楼在对面！而且这里是女生楼！！！</p><p>噢，当时有点羞，一下子跑了出来！现在回想起来，这次无知的闯入却是我4年大学生活里仅有的2次到女生楼里！第二次也是最后一次却是我4年以后的毕业时帮人收拾行李！</p><p>走出去后，我来到了1号楼，到了五层，找到了张路，呵呵，他还是老样子，瘦瘦的，他在和宿舍里的一个四川同学聊天，记得好像在聊06年四川的大旱，同时还有一个我另外一个高中同学，徐大江，呵呵，高中的时候这个孩子就一直很搞笑，上课时候特别积极，学习特别勤奋，所以他是我们高中班里考到北京工业大学里分最高的，而我是分最底的！不过一想想都无所谓了，现在又在一个起跑线上了！</p><p>我们虽说在假期里一起聚过会，可是现在在一起了却不知道要聊些什么，我问张路是学什么专业的，他说是通信工程，我心想不错啊，我是学习材料科学与工程的，这个名字对于我来说却是个不知所云的东西，后来我才知道，我是被调剂到这个专业的，这个学院在就只有这么一个专业，三个班90多个人，而且是全学校里分数最低的，但是后来我又得知，这个学院实力是相当牛逼的，前任校长就是这个学院的，叫左铁镛，还是中科院的院士，学校能够建设两个奥运场馆也靠这个人的帮助！不过06年却看不到什么奥运场馆，虽说录取通知书上印着它的样子！</p><p>聊天中得知徐大江被认命为他们班的班长！唉，入学分数高就是强啊，想想我们班的班长叫王宇清，曾经是清华附中的高材生，现在也沦为和我们一样了…… 唉，一想想心中也为这个不得志的人而感到遗憾，不过还有一个更遗憾的同学，就是我们班学号为1的同学，她叫尹吉吉，分数足足比我高了100多分，曾经是北京四中的高材生，也就是和我们这些凡夫俗子一个班了！</p><p>我忘了我吃的第一顿饭是和谁一起吃的了，不过我清楚的记得是在第三食堂吃的，当时不知道，感觉第三食堂还不错，宫爆里有这么多肉，但是这就和我那次误进入女生宿舍楼一样，可能是我大学四年里仅有的几个去三食吃饭！</p><p>第一天晚上我清楚的记得我们宿舍里就只有四个人，我们也不知道从哪里聊开了天，也不知道从哪里说到了分数，一提到分数似乎浙江的那个同学特别兴奋，他叫郑辰，这个人在我的大学四年生活里有过太多的喜与怒！湖南的那个同学叫陈坛，这个同学后来成为了我的好兄弟，也是个影响我人生观与价值观我兄弟，还有一个同学叫王云峤，我当时一看到他穿着那身黄背心就想起了白天那个由于档案袋坏了而在老师面前解释的同学，可是我没敢确定，不知道是不是他，于是就这样聊着天，我得知，原来北工大在外地的录取分数是那样的高啊，甚至比北理工都要高，心想你们都被骗了……</p><p>那天晚上我提议咱们在校园里走走吧，临出门的时候我还拿上了白天有人发给我学校地图……</p><p>也不知从哪里走的，总之走了很远，我还是一直没有转过方向来，中途经过了后来才知道的三教，当时觉得这个楼可真新啊！能够在这里学习真是幸福！</p><p>回来后又随便聊了会天，忘了几点了，睡了！我这个人有个毛病，换个地方很不容易睡着觉，那天也照样，很久才入睡……</p><p>第二天我早早的就醒了，我居然起来去操场锻炼身体了！好像是6点多，现在回想起来真是佩服我自己。</p><p>早上的空气很好，操场上也有很多人在锻炼身体！</p><p>回到宿舍后发现宿舍里多了一个人？他在整理自己的床铺，我这才明白，他昨天没有来宿舍住，原来我们宿舍有5个人</p><p>我向他笑了笑，说“刚来啊”</p><p>他说“嗯，刚来”</p><p>我也不知道为什么没有问他叫什么名字，看到他满脑子的白头发心想就有点不舒服的感觉。</p><p>吃了早点，据说今天要开什么迎新会，于是我们就等待这个时间，到了知新园进去后发现里面还真气派，地方很大，那天主持会议的据说都是我们学院里响当当的人物，后来有的人还给我上过课。不过这里面有一个人给我印象最深，他叫“聂祚仁”，他是我们学院现在任的院长，给我印象深刻的是他的严谨的态度，他明明知道我们都不知道这个学院里有谁在负责什么项目，可是在说的时候有一点含糊就问身边的人“是不是那谁谁谁啊？”，感觉这可能是长期严谨的态度养成的习惯吧！</p><p>总之他们在台上说了很多话，我也不知道说什么，就是给我的感觉材料学院很牛逼，你们不要看你们入学的分数可能比那些热门专业如计算机，机械的低，但是只要努力，以后有很大的发展！</p><p>我当时还是个热爱学习的学生，可能大多数都和我一样吧，还想在大学里好好学习一吧，可是现在想想，努力学习又是为了什么呢？初中的时候是为了考上个好高中，我办到了，高中的时候努力学习是为了考个好大学，这个我不知道算不算办到了，可是在大学里好好学习又是为了什么呢？考上研究生？我当时还不知道什么叫考研，似乎本科毕业就可以了！研究生对于我是一个很模糊的概念，根本不知道它是啥样子，不过当时想的就是要好好学习，在不知道自己怎么走的时候先好好学习，没有目的的学习！像那些老师院士一样，有着渊博的知识！</p>]]></content>
      
      <categories>
          
          <category> 我的大学 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大学就这么过了（1）</title>
      <link href="/article/102.html"/>
      <url>/article/102.html</url>
      <content type="html"><![CDATA[<p>今天是2010年12月23日，距离我工作已经有很长时间了，目前我从事的一份生产性行业，最近工作是在车间查看炉子，工作很轻松，于是有了很多胡思乱想的时间，最近我一直在思考一个问题，我现在一直在回想我的大学有多少个转折点？我是怎样走到我现在的路的？我是怎么认识那么多朋友的？于是由此所引导，回想起我大学这四年的时光，真的有很多值得回忆，值得思考，认识很多朋友，经历很多事情，足以让我回味一生。</p><p> 我也不知道从哪里说起，还是从我上学来报道那天说吧。</p><p> 那天是我老爸陪我一起来报道的，我们从家里在坐公交来到这个学校，那天我是从学校西门进来的，第一眼看到让我有点失望，呵呵，其实我一直在想，如果那天我是从学校南门进来的，可能会让我对这个学校第一印象会好些，不过后来我听说有人是从学校北门进来的，这样一想我还是比较庆幸，北门是一个连车都不来的门！</p><p> 其实到现在我还是对于北京工业大学里面转着向，一直认为西门是南门，也许我天生的方向感就不是很强，做在车里左转右转就不知道哪是哪了！</p><p> 我和老爸拿着大包小包在学校里拿着转单走来走去，我担心我老爸跟着我转来转去累，于是我对他说您先在这歇会吧，我先自己去办里各种证件吧，老爸说好，注意身上的钱。我清楚的记得我在找我的班级时候，足足排了有半个多小时的队，中途还遇到了我一个高中同学，他叫卢国轩，我们以前都是运河中学的，他在8班，我在9班，平时见面的时候只是打个招呼，没想到现在竟然成了一个学院的同学了，我问他是哪个宿舍的，他说他在4号楼203，我一看我在4号楼225，唉，怎么离这么远啊？</p><p> 我还清楚的记得，<a id="more"></a>我在和所谓的班主任见面的时候，旁边有一个穿黄色背心的男生，一个身材高大，带着眼镜，他的档案袋坏了，有一些开口，他还一直在解释“这个不是我弄的，我没有看里的东西”，我心里想这个同学可真是的，这么重要的东西怎么说弄坏就弄坏呢！也太不注意了！</p><p> 在和班主任做了简单的交流后，我看到班主任的名字叫“张忻”，我对于第二个字不大确定叫什么， 所以只叫了他张老师，之后我去交了学杂费与住宿费，领了一张饭卡，内含100元的饭费，再基本上把所有的钱交过之后我回去找我老爸，在新图北广场上看到了他，他坐在地上，行李就放在旁边，我当时看到心里就有点酸酸的，让我老爸在这么热的天气下等了我这么长的时间，也找个阴凉的地方，不过我找到我老爸的时候，看到他脸上还是洋溢的幸福的表情，当时我心里就想要好好学习，让老爸的光荣感一直延续下去！</p><p> 可是后来我让他失望了！这个是以后的事情了。</p><p> 在托着行李来到4号楼225的时候，宿舍里已经有一个同学到了，看来我还是来的比较早的，他在他爸妈（其实后来知道不是他妈妈）帮助下在弄被了，他选了一个离窗户的下铺，其实我还是比较喜欢下铺的，我就选了靠门的下铺，老爸和他们聊天时候知道他是来自湖南的，呵呵，这时突然从门外跑进来一个同学，他们问他是哪里人，他说是“浙江”的，在此之前，我还没有怎么接触到外地生，心想，呵呵，这下要和他们一起生活4年，心里在还真是有点打鼓，我看了一下，这个宿舍里有6张床，也就是说还有3个人没有来！</p><p> 之后我就去了楼下办理什么住宿证了，这个比较恶心，说让我交几照片，可是我的照片之前已经交的差不多了，手上没有了，他们让我现在马上去照，我就打听这哪有照相的地方，他们这里所谓的志愿者给我说来说去，有如轻车熟路，靠，我一个新来的，怎么知道啊？于是我走出门后接着打听，最后好像是一个志愿者带着我到学校里的一个照相馆，靠，这里人还真多，情况和我差不多，都是照片没有带够，后来才知道，这个宿舍照片那天不交也可以，以后再交也行！呵呵！</p><p> 回来后看到老爸已经把我的被子弄好了，还给我买了两把小锁，弄的差不多了，老爸说要走了，我说您知道怎么回去吗？他说知道，放心吧。那天他去了我姑家，估计应该是高兴吧！</p><p> (该上班了，回来接着写)</p>]]></content>
      
      <categories>
          
          <category> 我的大学 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Twitter常用术语和名词解析</title>
      <link href="/article/83.html"/>
      <url>/article/83.html</url>
      <content type="html"><![CDATA[<p>网上看到的一个关于Twitter的基础的东西，我想很多人都知道Twitter，但并不是很会用~ 不会的来看看吧~</p><p>如果你是早期的twitter用户并一直使用 ，那对twitter的相关术语和名词肯定是比较熟悉的。而如果是新手用户，对一堆的twitter术语尤其是各种涎生的twitter合成词会找不着北。</p><p>常用的twitter术语</p><p>1、@reply</p><p>表示你想对其他 Twitter 用户发表公开的信息，例如回复别人或者提及别人。在使用的时候需要把 reply 换成某个 Twitter 用户名。顺便说一句，Reply 也是一个 Twitter 用户名，不过它不发表任何信息，也不 Follower 任何人，但是居然有 400 多个 Followers!<br><a id="more"></a><br>2、DM</p><p>DM 的全称是 Direct Message(s)，是指给某个 Twitter 朋友发私信。所谓的朋友，就是你 Follow 我，我也 Follow 你的那种；所谓的私信，就是除了我和你，其他的人都看不到的私信&mdash;&mdash;不过我认为 Twitter 的管理员能够看到。如果你要给某人发私信，可以使用以下格式：</p><p>DM(不分大小写)+空格+Twitter 用户名+空格+私信内容，例如：</p><p>3、RT </p><p>ReTweet 的缩写，也有人用 ReTweeting 的，只是前者是动词，后者是动名词，指把别人的 Tweets 重新发到 Twitter 上。例如：</p><p>RT @caozenghui 微型博客Twitter周五宣布，已成功获得3500万美元投资，这笔资金将主要用于产品开发。&mdash;-好消息，希望twitter借此能避免资金压力，继续做大。</p><p>不过，也有人使用 ReTw 的，例如：</p><p>hexybaby: ReTw @dingyong: 网店卖“草泥马”玩偶 每只售价50元(组图) <a href="http://twurl.nl/ac66eq" target="_blank" rel="noopener">http://twurl.nl/ac66eq</a> #放办公桌上，同事问：什么玩偶啊？好可爱啊！答：草泥马。</p><p>当然，如果您使用 TweetDeck 之类的桌面软件，那么 RT 别人的 Tweets 就会更加方便。</p><p>4、Hashtag</p><p>Hashtag 就和 Flickr 上的标签一样，如果你就某个标签发表信息，那么订阅这个标签的人就会看到你的信息。举例说明：</p><p>webleon: #Blog 企业Blog的价值何在？: Forrester最近的一份数据报告显示，只有16%的在线消费者信任企业Blog（企业博客）。这难免让人产生了疑惑：企业开设Blog究竟有多大价值？这份报告的题目就叫做：Ti.. <a href="http://tinyurl.com/5hw9zu" target="_blank" rel="noopener">http://tinyurl.com/5hw9zu</a></p><p>上面这个 Tweet 中，Blog 就是一个 Hashtag，但是，只有在Blog前面加上#的时候，上面的这句话才会出现在 Hashtags.com 网站，也才可以被订阅 Blog 这个 hashtag 的朋友看见。</p><p>Hashtag.com 目前经常宕机，出现503错误，并且无法识别中文的 Tag，例如，#Blog 可以被收录，但是 #博客就不行了。</p><p>twitter千奇百怪的合成名词</p><p>要把下面这些名词和它们的意义都记住，恐怕需要先去学倒背圆周率之类的记忆方法。</p><p>twacklist</p><p>由 Twitter + blacklist 组成，指 Twitter 上的黑名单。</p><p>twacklog</p><p>由 Twitter + Backlog 合成，指待处理的 tweets。</p><p>twammer</p><p>由 Twitter + spammer 组成，指 Twitter 上的垃圾制造者。</p><p>twandle</p><p>由 Twitter + handle 组成，指 Twitter 用户名。</p><p>twat</p><p>由 Twitter + acct 组成，意思同 Twammer，也是指 Twitter 上的垃圾制造者。</p><p>twait</p><p>由 Twitter + Wait 组成，指计划在未来某个时间发送的 twitter 信息。</p><p>twaitter</p><p>指按时发表 Twitter 信息的人。</p><p>twarmy</p><p>由 Twitter + Army 组成，指 Twitter 上的大军。</p><p>twavatar</p><p>由 Twitter + Avatar 组成，指 Twitter 用户的头像。</p><p>twawkward</p><p>由 Twitter + awkward 组成，指在 Twitter 上感到尴尬。</p><p>tweaten</p><p>由 Twitter + Eaten 组成，指某个 Tweet 被 Twitter 或者某客户端应用程序吃掉了，有和谐的意思吧。</p><p>twedia</p><p>由 Twitter + Media 组成，指 Twitter 上的媒体，例如 @nytimes、@bbcnews、等等。</p><p>tweeotches</p><p>由 Twitter + biotches 组成，指 Twitter 上的狗娘养。</p><p>tweeps</p><p>由 Twitter + peeps 组成，指 Twitter 上的朋友。</p><p>tweetheart</p><p>由 Twitter + Sweetheart 合成，直译为 Twitter 情人。</p><p>tweetspeak</p><p>由 Tweet + Speak 组成，指强迫性发表不超过140个字的 Twitter 信息。</p><p>tweetup</p><p>由 Twitter + meetup 组成，指 Twitter 用户之间的聚会。</p><p>tweme</p><p>由 Twitter + Meme 组成，指 Twitter 上的 Meme( 文化的基本单位&mdash;&mdash;有点玄）。</p><p>tweople/tweeple</p><p>由 Twitter + people 组成，指 Twitter 用户。</p><p>twequilibrium</p><p>指你的 Following 数量刚好等于 Followers 数量。</p><p>twerd</p><p>由 twitter + nerd 组成，指 Twitter 上的专家。</p><p>twerminology</p><p>由 Twitter + terminology 组成，指对 Twitter 术语的研究。</p><p>twerp</p><p>指在 Twitter 上表现不好的用户。</p><p>Twestival</p><p>由 Twitter + Festival 组成，指 Twitter 节，也叫推特节，日期为每年2月12号，活动的筹款全部用于慈善活动。</p><p>Twesting</p><p>由 Twitter + Test 组成，指在 Twitter 上做测试。</p><p>Twitterers</p><p>由 Twitter 用户组成的群体。</p><p>twetin</p><p>由 Twitter + cretin 组成，指白痴的 Twitter 用户.</p><p>twewbie</p><p>由 Twitter + Newbie 组成，指一个牛逼的 Twitter 用户。</p><p>twhater</p><p>认为 Twitter 是愚蠢的人。</p><p>twiend</p><p>由 Twitter + friend 合成，即互相 Follow 的 Twitter 用户（推友）。</p><p>twiller</p><p>由 Twitter + Thriller 组成，指令人毛骨悚然的 Twitter 信息。</p><p>twinsight</p><p>由 Twitter + Insight 组成，指通过 Twitter 认识的新观点，也指两个人在同一时间发表同样的 Tweets。</p><p>twinterview</p><p>由 Twitter + Interview 组成，指通过 Twitter 展开或者促进面试。</p><p>twintro</p><p>由 Twitter + Introduce 组成，指通过 Twitter 介绍两个人相互认识。</p><p>twiplomacy</p><p>由 Twitter + diplomacy 组成，指把 Twitter 作为一种公共交际工具。</p><p>twirt</p><p>由 Twitter + Flirt 组成，指通过 Twitter 公然调情或者公然调情者。</p><p>twissues</p><p>由 Twitter + Issues 组成，指 Twitter 应用存在的问题。</p><p>twater</p><p>由 twitter + hater 组成，指憎恨 Twitter 的人。</p><p>twistory</p><p>由 Twitter + history 组成，有两种意思： 一是指某 Twitter 用户的 Tweets 和 @ 的历史；而是指在 Twitter 上发生的重大事件或者里程碑。</p><p>twitaddict</p><p>100% 的 Twitter 瘾君子，通常一个小时不玩 Twitter 就受不了。</p><p>twitaddict 同时也是一个 Twitter 用户。</p><p>twittarr</p><p>涉及海盗的 Twitter 信息。</p><p>twitcrush</p><p>由 Twitter + Crush 组成，指宣称自己暗恋某个 Twitter 用户。你可以通过 twitcrush.com 宣称自己暗恋了谁。</p><p>twitter squatter</p><p>明显，这不是合成词而是一个词组，指持有某个 Twitter 用户名并想获得好处的人。比如，brianclark 可以看作是一个 twitter squatter，因为其明显是抢注了著名博客兼推客 Copyblogger 作者的名字，不过这种行为是合法合理的，因为其并没有说自己就是 Copyblogger 的作者。</p><p>twitebate</p><p>由 Twitter + Debate 组成，指 Twitter 上的辩论，通常指政治辩论。</p><p>twiterature</p><p>由 Twitter + Literature 组成，指 twitter 上的文学著作。</p><p>twitery</p><p>由 Twitter + poetry 组成，指 Twitter 上的诗歌。twitery.wordpress.com 是一个以发表 twitery 为主的博客。</p><p>twitfluencer</p><p>由 Twitter + Influencer 组成，指有影响力的 Twitter 用户。</p><p>twitterati</p><p>由 Twitter + literati 组成，指 Twitter 上的文人，这个词在 Twitter 上常见。</p><p>twittercane</p><p>由 Twitter + hurricane 组成，就是 Tweet 旋风。</p><p>twitterdipity</p><p>指突然发现或者发送一些对自己或其他 Twitter 用户有用的链接或其他信息。</p><p>twitterfam</p><p>对 follower 的亲切称呼。</p><p>twitterholic</p><p>指沉迷于 Twitter 的用户，也指 twitterholic.com 网站（提供 Twitter 排名服务）。</p><p>twitterluia</p><p>由 Twitter + halleluia 组成，用来描述当奇迹发生时，Twitter 用户看见并发表到 Twitter 上。</p><p>twittermentia</p><p>记不住最后在 Twitter 上发表的信息。</p><p>twitterminology</p><p>由 Twitter + terminology 组成，指 Twitter 术语，意思同 twitterspeak。</p><p>twitterpreneur</p><p>由 Twitter + enterpreneur 组成，指 Twitter 企业家, 包括玩 Twitter 的企业家和企业是建立在 Twitter 基础上的企业家。</p><p>twitterpuff</p><p>由 Twitter + Puff 组成，表示在 Twitter 上自夸的人。</p><p>twitterrhea</p><p>大声令人讨厌混乱的 Twitter 信息。</p><p>twittiquette</p><p>由 Twitter + Ettiquette 组成，指 Twitter 上不成文的相关规则。</p><p>twittersation</p><p>由 Twitter + Conversation组成，指在Twitter 上的交流。</p><p>twitterscuse</p><p>由 Twitter + Excuse 组成，指 Twitter 不能正常运作的借口。</p><p>twitterspeak</p><p>由 Twitter + Speak ?成，指专门用于 Twitter 的语言。</p><p>twitterverse</p><p>Twitter 空间，类似于博客空间（blogosphere）</p><p>twitty</p><p>同 witty，是“诙谐的”意思。</p><p>twollower</p><p>由 Twitter + Follower 组成，指那些 Follower 你的 Twitter 用户。</p><p>twonanism</p><p>指在 Twitter 上自我夸奖。</p><p>tw00b</p><p>一个牛逼的 Twitter 用户。</p><p>twoosh</p><p>指刚好 140 个字的 Tweet。</p><p>twoutage</p><p>Twitter 某种功能的失败。</p><p>twunch</p><p>由 Lunch + Twitter 合成，意为推友之间自由的午餐聚会。</p><p>twunch 同时也是有一个 Twitter 用户，并且拥有一个 twunch.be（荷兰语），推友们可以通过 @twunch 进行公开约会。</p><p>twunken</p><p>酒后玩</p><p>Twitter 或者沉醉于玩 Twitter。</p><p>twurze</p><p>由 Twitter + The Wurzels 合成，通常指牛逼的 Twitter 用户，意思同 tw00b 和 Twewbie。</p><p>twypo</p><p>由 Twitter + Typo 合成，指 Twitter 上的错别字。twypos.com 是一个专门收集 twypo 的网站。</p><p>tweehab</p><p>由 Twitter + Rehab 合成，指离开 Twitter 做一个恢复性的休息。</p><p>twerrorism</p><p>由 Twitter + Terrorism 合成，指 Twitter 黑客行动。</p><p>twincidence</p><p>两个不相关的 Twitter 用户讲述同一件事。</p><p>twoff</p><p>长期不在 Twitter 上。</p><p>twescapade</p><p>各抒己见的线下聚会。</p><p>twingup</p><p>由 twitter + wings+ meetup 组成，指有计划的线下吃鸡翅聚会</p>]]></content>
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>小鸭子</title>
      <link href="/article/850.html"/>
      <url>/article/850.html</url>
      <content type="html"><![CDATA[<p>今天读一本书，读着读着读到了一个关于小鸭子的故事</p><p>于是我联想到了很多我小时候的事情……</p><p>小时候家里养过100多只鸭子，从它们刚出壳没几天身上只有一点点绒毛的时候，到最近养的肥肥大大的<br><a id="more"></a><br>它们来的时候我一是很开心的，天天去看它们，小时也会抓起来一只玩</p><p>但它们一点点的长大，而我却一点都看不出来……</p><p>有天，我带着它们放，这一群啊…… 像一片乌云，但它们遇到了一个水坑，就像找到了自己的天堂，所有的鸭子都撒起了欢~ 有的小鸭子还潜入水中~ 玩的好开心啊……</p><p>这时我也想起了那时的我，一个脏兮兮的小孩儿，赶着那么多小鸭子，自己也乐在其中~</p><p>对于现在的我，什么才是我的小鸭子呢？</p>]]></content>
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/README.html"/>
      <url>/README.html</url>
      <content type="html"><![CDATA[<h1 id="blogsource"><a href="#blogsource" class="headerlink" title="blogsource"></a>blogsource</h1><p>my blog source</p><p>There is my blog source dir for sync and there is no use for other</p>]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>天行健，君子以自强不息；地势坤，君子以厚德载物</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
